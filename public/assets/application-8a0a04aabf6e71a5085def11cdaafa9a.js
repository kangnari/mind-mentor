/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */

(function( window, undefined ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
var
	// The deferred used on DOM ready
	readyList,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// Support: IE<10
	// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
	core_strundefined = typeof undefined,

	// Use the correct document accordingly with window argument (sandbox)
	location = window.location,
	document = window.document,
	docElem = document.documentElement,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// [[Class]] -> type pairs
	class2type = {},

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.10.2",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	// Used for splitting on whitespace
	core_rnotwhite = /\S+/g,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// The ready event handler
	completed = function( event ) {

		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	// Clean-up method for dom ready events
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( jQuery.support.ownLast ) {
			for ( key in obj ) {
				return core_hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations.
	// Note: this method belongs to the css module but it's needed here for the support module.
	// If support gets modularized, this method should be moved back to the css module.
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
/*!
 * Sizzle CSS Selector Engine v1.10.2
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03
 */
(function( window, undefined ) {

var i,
	support,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	hasDuplicate = false,
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rsibling = new RegExp( whitespace + "*[+~]" ),
	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent.attachEvent && parent !== parent.top ) {
		parent.attachEvent( "onbeforeunload", function() {
			setDocument();
		});
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Support: Opera 10-12/IE8
			// ^= $= *= and empty values
			// Should not select anything
			// Support: Windows 8 Native Apps
			// The type attribute is restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "t", "" );

			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );

		if ( compare ) {
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		}

		// Not directly comparable, sort on existence of method
		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val === undefined ?
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null :
		val;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	// A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector )
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return (val = elem.getAttributeNode( name )) && val.specified ?
				val.value :
				elem[ name ] === true ? name.toLowerCase() : null;
		}
	});
}

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function( support ) {

	var all, a, input, select, fragment, opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Finish early in limited (non-browser) environments
	all = div.getElementsByTagName("*") || [];
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !a || !a.style || !all.length ) {
		return support;
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName("tbody").length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName("link").length;

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Will be defined later
	support.inlineBlockNeedsLayout = false;
	support.shrinkWrapBlocks = false;
	support.pixelPosition = false;
	support.deleteExpando = true;
	support.noCloneEvent = true;
	support.reliableMarginRight = true;
	support.boxSizingReliable = true;

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: IE<9
	// Iteration over object's inherited properties before its own.
	for ( i in jQuery( support ) ) {
		break;
	}
	support.ownLast = i !== "0";

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Support: IE8
		// Check if empty table cells still have offsetWidth/Height
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior.
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";

		// Workaround failing boxSizing test due to offsetWidth returning wrong value
		// with some non-1 values of body zoom, ticket #13543
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			support.boxSizing = div.offsetWidth === 4;
		});

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	all = select = fragment = opt = a = input = null;

	return support;
})({});

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt /* Internal Use Only */ ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"applet": true,
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		// Do not set data on non-element because it will not be cleared (#8335).
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			data = null,
			i = 0,
			elem = this[0];

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook,
	rclass = /[\t\r\n\f]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					elem.className = jQuery.trim( cur );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					elem.className = value ? jQuery.trim( cur ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// Use proper attribute retrieval(#6932, #12072)
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

	jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var fn = jQuery.expr.attrHandle[ name ],
				ret = isXML ?
					undefined :
					/* jshint eqeqeq: false */
					(jQuery.expr.attrHandle[ name ] = undefined) !=
						getter( elem, name, isXML ) ?

						name.toLowerCase() :
						null;
			jQuery.expr.attrHandle[ name ] = fn;
			return ret;
		} :
		function( elem, name, isXML ) {
			return isXML ?
				undefined :
				elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};
	jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =
		// Some attributes are constructed with empty-string values when not defined
		function( elem, name, isXML ) {
			var ret;
			return isXML ?
				undefined :
				(ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
		};
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ret.specified ?
				ret.value :
				undefined;
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}


// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !jQuery.support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !jQuery.support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
var isSimple = /^.[^:#\[\.,]*$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},

	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					cur = ret.push( cur );
					break;
				}
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var
			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment
			args = jQuery.map( this, function( elem ) {
				return [ elem.nextSibling, elem.parentNode ];
			}),
			i = 0;

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			var next = args[ i++ ],
				parent = args[ i++ ];

			if ( parent ) {
				// Don't use the snapshot next if it has moved (#13810)
				if ( next && next.parentNode !== parent ) {
					next = this.nextSibling;
				}
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		// Allow new content to include elements from the context set
		}, true );

		// Force removal if there was no new content (e.g., from empty arguments)
		return i ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback, allowIntersection ) {

		// Flatten any nested arrays
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback, allowIntersection );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery._evalUrl( node.src );
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	},

	_evalUrl: function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	}
});
jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	// isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {
			// Use the already-created iframe if possible
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// Work around by temporarily setting element display to inline-block
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});
var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		// Abort all pending requests
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
if ( typeof module === "object" && module && typeof module.exports === "object" ) {
	// Expose jQuery as module.exports in loaders that implement the Node
	// module pattern (including browserify). Do not create the global, since
	// the user will be storing it themselves locally, and globals are frowned
	// upon in the Node module world.
	module.exports = jQuery;
} else {
	// Otherwise expose jQuery to the global object as usual
	window.jQuery = window.$ = jQuery;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	if ( typeof define === "function" && define.amd ) {
		define( "jquery", [], function () { return jQuery; } );
	}
}

})( window );
(function($, undefined) {

/**
 * Unobtrusive scripting adapter for jQuery
 * https://github.com/rails/jquery-ujs
 *
 * Requires jQuery 1.7.0 or later.
 *
 * Released under the MIT license
 *
 */

  // Cut down on the number of issues from people inadvertently including jquery_ujs twice
  // by detecting and raising an error when it happens.
  if ( $.rails !== undefined ) {
    $.error('jquery-ujs has already been loaded!');
  }

  // Shorthand to make it a little easier to call public rails functions from within rails.js
  var rails;
  var $document = $(document);

  $.rails = rails = {
    // Link elements bound by jquery-ujs
    linkClickSelector: 'a[data-confirm], a[data-method], a[data-remote], a[data-disable-with]',

    // Button elements boud jquery-ujs
    buttonClickSelector: 'button[data-remote]',

    // Select elements bound by jquery-ujs
    inputChangeSelector: 'select[data-remote], input[data-remote], textarea[data-remote]',

    // Form elements bound by jquery-ujs
    formSubmitSelector: 'form',

    // Form input elements bound by jquery-ujs
    formInputClickSelector: 'form input[type=submit], form input[type=image], form button[type=submit], form button:not([type])',

    // Form input elements disabled during form submission
    disableSelector: 'input[data-disable-with], button[data-disable-with], textarea[data-disable-with]',

    // Form input elements re-enabled after form submission
    enableSelector: 'input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled',

    // Form required input elements
    requiredInputSelector: 'input[name][required]:not([disabled]),textarea[name][required]:not([disabled])',

    // Form file input elements
    fileInputSelector: 'input[type=file]',

    // Link onClick disable selector with possible reenable after remote submission
    linkDisableSelector: 'a[data-disable-with]',

    // Make sure that every Ajax request sends the CSRF token
    CSRFProtection: function(xhr) {
      var token = $('meta[name="csrf-token"]').attr('content');
      if (token) xhr.setRequestHeader('X-CSRF-Token', token);
    },

    // Triggers an event on an element and returns false if the event result is false
    fire: function(obj, name, data) {
      var event = $.Event(name);
      obj.trigger(event, data);
      return event.result !== false;
    },

    // Default confirm dialog, may be overridden with custom confirm dialog in $.rails.confirm
    confirm: function(message) {
      return confirm(message);
    },

    // Default ajax function, may be overridden with custom function in $.rails.ajax
    ajax: function(options) {
      return $.ajax(options);
    },

    // Default way to get an element's href. May be overridden at $.rails.href.
    href: function(element) {
      return element.attr('href');
    },

    // Submits "remote" forms and links with ajax
    handleRemote: function(element) {
      var method, url, data, elCrossDomain, crossDomain, withCredentials, dataType, options;

      if (rails.fire(element, 'ajax:before')) {
        elCrossDomain = element.data('cross-domain');
        crossDomain = elCrossDomain === undefined ? null : elCrossDomain;
        withCredentials = element.data('with-credentials') || null;
        dataType = element.data('type') || ($.ajaxSettings && $.ajaxSettings.dataType);

        if (element.is('form')) {
          method = element.attr('method');
          url = element.attr('action');
          data = element.serializeArray();
          // memoized value from clicked submit button
          var button = element.data('ujs:submit-button');
          if (button) {
            data.push(button);
            element.data('ujs:submit-button', null);
          }
        } else if (element.is(rails.inputChangeSelector)) {
          method = element.data('method');
          url = element.data('url');
          data = element.serialize();
          if (element.data('params')) data = data + "&" + element.data('params');
        } else if (element.is(rails.buttonClickSelector)) {
          method = element.data('method') || 'get';
          url = element.data('url');
          data = element.serialize();
          if (element.data('params')) data = data + "&" + element.data('params');
        } else {
          method = element.data('method');
          url = rails.href(element);
          data = element.data('params') || null;
        }

        options = {
          type: method || 'GET', data: data, dataType: dataType,
          // stopping the "ajax:beforeSend" event will cancel the ajax request
          beforeSend: function(xhr, settings) {
            if (settings.dataType === undefined) {
              xhr.setRequestHeader('accept', '*/*;q=0.5, ' + settings.accepts.script);
            }
            return rails.fire(element, 'ajax:beforeSend', [xhr, settings]);
          },
          success: function(data, status, xhr) {
            element.trigger('ajax:success', [data, status, xhr]);
          },
          complete: function(xhr, status) {
            element.trigger('ajax:complete', [xhr, status]);
          },
          error: function(xhr, status, error) {
            element.trigger('ajax:error', [xhr, status, error]);
          },
          crossDomain: crossDomain
        };

        // There is no withCredentials for IE6-8 when
        // "Enable native XMLHTTP support" is disabled
        if (withCredentials) {
          options.xhrFields = {
            withCredentials: withCredentials
          };
        }

        // Only pass url to `ajax` options if not blank
        if (url) { options.url = url; }

        var jqxhr = rails.ajax(options);
        element.trigger('ajax:send', jqxhr);
        return jqxhr;
      } else {
        return false;
      }
    },

    // Handles "data-method" on links such as:
    // <a href="/users/5" data-method="delete" rel="nofollow" data-confirm="Are you sure?">Delete</a>
    handleMethod: function(link) {
      var href = rails.href(link),
        method = link.data('method'),
        target = link.attr('target'),
        csrf_token = $('meta[name=csrf-token]').attr('content'),
        csrf_param = $('meta[name=csrf-param]').attr('content'),
        form = $('<form method="post" action="' + href + '"></form>'),
        metadata_input = '<input name="_method" value="' + method + '" type="hidden" />';

      if (csrf_param !== undefined && csrf_token !== undefined) {
        metadata_input += '<input name="' + csrf_param + '" value="' + csrf_token + '" type="hidden" />';
      }

      if (target) { form.attr('target', target); }

      form.hide().append(metadata_input).appendTo('body');
      form.submit();
    },

    /* Disables form elements:
      - Caches element value in 'ujs:enable-with' data store
      - Replaces element text with value of 'data-disable-with' attribute
      - Sets disabled property to true
    */
    disableFormElements: function(form) {
      form.find(rails.disableSelector).each(function() {
        var element = $(this), method = element.is('button') ? 'html' : 'val';
        element.data('ujs:enable-with', element[method]());
        element[method](element.data('disable-with'));
        element.prop('disabled', true);
      });
    },

    /* Re-enables disabled form elements:
      - Replaces element text with cached value from 'ujs:enable-with' data store (created in `disableFormElements`)
      - Sets disabled property to false
    */
    enableFormElements: function(form) {
      form.find(rails.enableSelector).each(function() {
        var element = $(this), method = element.is('button') ? 'html' : 'val';
        if (element.data('ujs:enable-with')) element[method](element.data('ujs:enable-with'));
        element.prop('disabled', false);
      });
    },

   /* For 'data-confirm' attribute:
      - Fires `confirm` event
      - Shows the confirmation dialog
      - Fires the `confirm:complete` event

      Returns `true` if no function stops the chain and user chose yes; `false` otherwise.
      Attaching a handler to the element's `confirm` event that returns a `falsy` value cancels the confirmation dialog.
      Attaching a handler to the element's `confirm:complete` event that returns a `falsy` value makes this function
      return false. The `confirm:complete` event is fired whether or not the user answered true or false to the dialog.
   */
    allowAction: function(element) {
      var message = element.data('confirm'),
          answer = false, callback;
      if (!message) { return true; }

      if (rails.fire(element, 'confirm')) {
        answer = rails.confirm(message);
        callback = rails.fire(element, 'confirm:complete', [answer]);
      }
      return answer && callback;
    },

    // Helper function which checks for blank inputs in a form that match the specified CSS selector
    blankInputs: function(form, specifiedSelector, nonBlank) {
      var inputs = $(), input, valueToCheck,
          selector = specifiedSelector || 'input,textarea',
          allInputs = form.find(selector);

      allInputs.each(function() {
        input = $(this);
        valueToCheck = input.is('input[type=checkbox],input[type=radio]') ? input.is(':checked') : input.val();
        // If nonBlank and valueToCheck are both truthy, or nonBlank and valueToCheck are both falsey
        if (!valueToCheck === !nonBlank) {

          // Don't count unchecked required radio if other radio with same name is checked
          if (input.is('input[type=radio]') && allInputs.filter('input[type=radio]:checked[name="' + input.attr('name') + '"]').length) {
            return true; // Skip to next input
          }

          inputs = inputs.add(input);
        }
      });
      return inputs.length ? inputs : false;
    },

    // Helper function which checks for non-blank inputs in a form that match the specified CSS selector
    nonBlankInputs: function(form, specifiedSelector) {
      return rails.blankInputs(form, specifiedSelector, true); // true specifies nonBlank
    },

    // Helper function, needed to provide consistent behavior in IE
    stopEverything: function(e) {
      $(e.target).trigger('ujs:everythingStopped');
      e.stopImmediatePropagation();
      return false;
    },

    //  replace element's html with the 'data-disable-with' after storing original html
    //  and prevent clicking on it
    disableElement: function(element) {
      element.data('ujs:enable-with', element.html()); // store enabled state
      element.html(element.data('disable-with')); // set to disabled state
      element.bind('click.railsDisable', function(e) { // prevent further clicking
        return rails.stopEverything(e);
      });
    },

    // restore element to its original state which was disabled by 'disableElement' above
    enableElement: function(element) {
      if (element.data('ujs:enable-with') !== undefined) {
        element.html(element.data('ujs:enable-with')); // set to old enabled state
        element.removeData('ujs:enable-with'); // clean up cache
      }
      element.unbind('click.railsDisable'); // enable element
    }

  };

  if (rails.fire($document, 'rails:attachBindings')) {

    $.ajaxPrefilter(function(options, originalOptions, xhr){ if ( !options.crossDomain ) { rails.CSRFProtection(xhr); }});

    $document.delegate(rails.linkDisableSelector, 'ajax:complete', function() {
        rails.enableElement($(this));
    });

    $document.delegate(rails.linkClickSelector, 'click.rails', function(e) {
      var link = $(this), method = link.data('method'), data = link.data('params');
      if (!rails.allowAction(link)) return rails.stopEverything(e);

      if (link.is(rails.linkDisableSelector)) rails.disableElement(link);

      if (link.data('remote') !== undefined) {
        if ( (e.metaKey || e.ctrlKey) && (!method || method === 'GET') && !data ) { return true; }

        var handleRemote = rails.handleRemote(link);
        // response from rails.handleRemote() will either be false or a deferred object promise.
        if (handleRemote === false) {
          rails.enableElement(link);
        } else {
          handleRemote.error( function() { rails.enableElement(link); } );
        }
        return false;

      } else if (link.data('method')) {
        rails.handleMethod(link);
        return false;
      }
    });

    $document.delegate(rails.buttonClickSelector, 'click.rails', function(e) {
      var button = $(this);
      if (!rails.allowAction(button)) return rails.stopEverything(e);

      rails.handleRemote(button);
      return false;
    });

    $document.delegate(rails.inputChangeSelector, 'change.rails', function(e) {
      var link = $(this);
      if (!rails.allowAction(link)) return rails.stopEverything(e);

      rails.handleRemote(link);
      return false;
    });

    $document.delegate(rails.formSubmitSelector, 'submit.rails', function(e) {
      var form = $(this),
        remote = form.data('remote') !== undefined,
        blankRequiredInputs = rails.blankInputs(form, rails.requiredInputSelector),
        nonBlankFileInputs = rails.nonBlankInputs(form, rails.fileInputSelector);

      if (!rails.allowAction(form)) return rails.stopEverything(e);

      // skip other logic when required values are missing or file upload is present
      if (blankRequiredInputs && form.attr("novalidate") == undefined && rails.fire(form, 'ajax:aborted:required', [blankRequiredInputs])) {
        return rails.stopEverything(e);
      }

      if (remote) {
        if (nonBlankFileInputs) {
          // slight timeout so that the submit button gets properly serialized
          // (make it easy for event handler to serialize form without disabled values)
          setTimeout(function(){ rails.disableFormElements(form); }, 13);
          var aborted = rails.fire(form, 'ajax:aborted:file', [nonBlankFileInputs]);

          // re-enable form elements if event bindings return false (canceling normal form submission)
          if (!aborted) { setTimeout(function(){ rails.enableFormElements(form); }, 13); }

          return aborted;
        }

        rails.handleRemote(form);
        return false;

      } else {
        // slight timeout so that the submit button gets properly serialized
        setTimeout(function(){ rails.disableFormElements(form); }, 13);
      }
    });

    $document.delegate(rails.formInputClickSelector, 'click.rails', function(event) {
      var button = $(this);

      if (!rails.allowAction(button)) return rails.stopEverything(event);

      // register the pressed submit button
      var name = button.attr('name'),
        data = name ? {name:name, value:button.val()} : null;

      button.closest('form').data('ujs:submit-button', data);
    });

    $document.delegate(rails.formSubmitSelector, 'ajax:beforeSend.rails', function(event) {
      if (this == event.target) rails.disableFormElements($(this));
    });

    $document.delegate(rails.formSubmitSelector, 'ajax:complete.rails', function(event) {
      if (this == event.target) rails.enableFormElements($(this));
    });

    $(function(){
      // making sure that all forms have actual up-to-date token(cached forms contain old one)
      var csrf_token = $('meta[name=csrf-token]').attr('content');
      var csrf_param = $('meta[name=csrf-param]').attr('content');
      $('form input[name="' + csrf_param + '"]').val(csrf_token);
    });
  }

})( jQuery );
(function() {
  var CSRFToken, anchoredLink, assetsChanged, browserCompatibleDocumentParser, browserIsntBuggy, browserSupportsPushState, cacheCurrentPage, changePage, constrainPageCacheTo, createDocument, crossOriginLink, currentState, executeScriptTags, extractLink, extractTitleAndBody, extractTrackAssets, fetchHistory, fetchReplacement, handleClick, ignoreClick, initializeTurbolinks, initialized, installClickHandlerLast, intersection, invalidContent, loadedAssets, noTurbolink, nonHtmlLink, nonStandardClick, pageCache, recallScrollPosition, referer, reflectNewUrl, reflectRedirectedUrl, rememberCurrentState, rememberCurrentUrl, rememberInitialPage, removeHash, removeNoscriptTags, requestMethod, requestMethodIsSafe, resetScrollPosition, targetLink, triggerEvent, visit, xhr, _ref,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  initialized = false;

  currentState = null;

  referer = document.location.href;

  loadedAssets = null;

  pageCache = {};

  createDocument = null;

  requestMethod = ((_ref = document.cookie.match(/request_method=(\w+)/)) != null ? _ref[1].toUpperCase() : void 0) || '';

  xhr = null;

  visit = function(url) {
    if (browserSupportsPushState && browserIsntBuggy) {
      cacheCurrentPage();
      reflectNewUrl(url);
      return fetchReplacement(url);
    } else {
      return document.location.href = url;
    }
  };

  fetchReplacement = function(url) {
    var safeUrl,
      _this = this;
    triggerEvent('page:fetch');
    safeUrl = removeHash(url);
    if (xhr != null) {
      xhr.abort();
    }
    xhr = new XMLHttpRequest;
    xhr.open('GET', safeUrl, true);
    xhr.setRequestHeader('Accept', 'text/html, application/xhtml+xml, application/xml');
    xhr.setRequestHeader('X-XHR-Referer', referer);
    xhr.onload = function() {
      var doc;
      triggerEvent('page:receive');
      if (invalidContent(xhr) || assetsChanged((doc = createDocument(xhr.responseText)))) {
        return document.location.reload();
      } else {
        changePage.apply(null, extractTitleAndBody(doc));
        reflectRedirectedUrl(xhr);
        if (document.location.hash) {
          document.location.href = document.location.href;
        } else {
          resetScrollPosition();
        }
        return triggerEvent('page:load');
      }
    };
    xhr.onloadend = function() {
      return xhr = null;
    };
    xhr.onabort = function() {
      return rememberCurrentUrl();
    };
    xhr.onerror = function() {
      return document.location.href = url;
    };
    return xhr.send();
  };

  fetchHistory = function(state) {
    var page;
    cacheCurrentPage();
    if (page = pageCache[state.position]) {
      if (xhr != null) {
        xhr.abort();
      }
      changePage(page.title, page.body);
      recallScrollPosition(page);
      return triggerEvent('page:restore');
    } else {
      return fetchReplacement(document.location.href);
    }
  };

  cacheCurrentPage = function() {
    rememberInitialPage();
    pageCache[currentState.position] = {
      url: document.location.href,
      body: document.body,
      title: document.title,
      positionY: window.pageYOffset,
      positionX: window.pageXOffset
    };
    return constrainPageCacheTo(10);
  };

  constrainPageCacheTo = function(limit) {
    var key, value;
    for (key in pageCache) {
      if (!__hasProp.call(pageCache, key)) continue;
      value = pageCache[key];
      if (key <= currentState.position - limit) {
        pageCache[key] = null;
      }
    }
  };

  changePage = function(title, body, csrfToken, runScripts) {
    document.title = title;
    document.documentElement.replaceChild(body, document.body);
    if (csrfToken != null) {
      CSRFToken.update(csrfToken);
    }
    removeNoscriptTags();
    if (runScripts) {
      executeScriptTags();
    }
    currentState = window.history.state;
    return triggerEvent('page:change');
  };

  executeScriptTags = function() {
    var attr, copy, nextSibling, parentNode, script, scripts, _i, _j, _len, _len1, _ref1, _ref2;
    scripts = Array.prototype.slice.call(document.body.getElementsByTagName('script'));
    for (_i = 0, _len = scripts.length; _i < _len; _i++) {
      script = scripts[_i];
      if (!((_ref1 = script.type) === '' || _ref1 === 'text/javascript')) {
        continue;
      }
      copy = document.createElement('script');
      _ref2 = script.attributes;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        attr = _ref2[_j];
        copy.setAttribute(attr.name, attr.value);
      }
      copy.appendChild(document.createTextNode(script.innerHTML));
      parentNode = script.parentNode, nextSibling = script.nextSibling;
      parentNode.removeChild(script);
      parentNode.insertBefore(copy, nextSibling);
    }
  };

  removeNoscriptTags = function() {
    var noscript, noscriptTags, _i, _len;
    noscriptTags = Array.prototype.slice.call(document.body.getElementsByTagName('noscript'));
    for (_i = 0, _len = noscriptTags.length; _i < _len; _i++) {
      noscript = noscriptTags[_i];
      noscript.parentNode.removeChild(noscript);
    }
  };

  reflectNewUrl = function(url) {
    if (url !== document.location.href) {
      referer = document.location.href;
      return window.history.pushState({
        turbolinks: true,
        position: currentState.position + 1
      }, '', url);
    }
  };

  reflectRedirectedUrl = function(xhr) {
    var location;
    if ((location = xhr.getResponseHeader('X-XHR-Current-Location')) && location !== document.location.pathname + document.location.search) {
      return window.history.replaceState(currentState, '', location + document.location.hash);
    }
  };

  rememberCurrentUrl = function() {
    return window.history.replaceState({
      turbolinks: true,
      position: Date.now()
    }, '', document.location.href);
  };

  rememberCurrentState = function() {
    return currentState = window.history.state;
  };

  rememberInitialPage = function() {
    if (!initialized) {
      rememberCurrentUrl();
      rememberCurrentState();
      createDocument = browserCompatibleDocumentParser();
      return initialized = true;
    }
  };

  recallScrollPosition = function(page) {
    return window.scrollTo(page.positionX, page.positionY);
  };

  resetScrollPosition = function() {
    return window.scrollTo(0, 0);
  };

  removeHash = function(url) {
    var link;
    link = url;
    if (url.href == null) {
      link = document.createElement('A');
      link.href = url;
    }
    return link.href.replace(link.hash, '');
  };

  triggerEvent = function(name) {
    var event;
    event = document.createEvent('Events');
    event.initEvent(name, true, true);
    return document.dispatchEvent(event);
  };

  invalidContent = function(xhr) {
    return !xhr.getResponseHeader('Content-Type').match(/^(?:text\/html|application\/xhtml\+xml|application\/xml)(?:;|$)/);
  };

  extractTrackAssets = function(doc) {
    var node, _i, _len, _ref1, _results;
    _ref1 = doc.head.childNodes;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      if ((typeof node.getAttribute === "function" ? node.getAttribute('data-turbolinks-track') : void 0) != null) {
        _results.push(node.src || node.href);
      }
    }
    return _results;
  };

  assetsChanged = function(doc) {
    var fetchedAssets;
    loadedAssets || (loadedAssets = extractTrackAssets(document));
    fetchedAssets = extractTrackAssets(doc);
    return fetchedAssets.length !== loadedAssets.length || intersection(fetchedAssets, loadedAssets).length !== loadedAssets.length;
  };

  intersection = function(a, b) {
    var value, _i, _len, _ref1, _results;
    if (a.length > b.length) {
      _ref1 = [b, a], a = _ref1[0], b = _ref1[1];
    }
    _results = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      value = a[_i];
      if (__indexOf.call(b, value) >= 0) {
        _results.push(value);
      }
    }
    return _results;
  };

  extractTitleAndBody = function(doc) {
    var title;
    title = doc.querySelector('title');
    return [title != null ? title.textContent : void 0, doc.body, CSRFToken.get(doc).token, 'runScripts'];
  };

  CSRFToken = {
    get: function(doc) {
      var tag;
      if (doc == null) {
        doc = document;
      }
      return {
        node: tag = doc.querySelector('meta[name="csrf-token"]'),
        token: tag != null ? typeof tag.getAttribute === "function" ? tag.getAttribute('content') : void 0 : void 0
      };
    },
    update: function(latest) {
      var current;
      current = this.get();
      if ((current.token != null) && (latest != null) && current.token !== latest) {
        return current.node.setAttribute('content', latest);
      }
    }
  };

  browserCompatibleDocumentParser = function() {
    var createDocumentUsingDOM, createDocumentUsingParser, createDocumentUsingWrite, e, testDoc, _ref1;
    createDocumentUsingParser = function(html) {
      return (new DOMParser).parseFromString(html, 'text/html');
    };
    createDocumentUsingDOM = function(html) {
      var doc;
      doc = document.implementation.createHTMLDocument('');
      doc.documentElement.innerHTML = html;
      return doc;
    };
    createDocumentUsingWrite = function(html) {
      var doc;
      doc = document.implementation.createHTMLDocument('');
      doc.open('replace');
      doc.write(html);
      doc.close();
      return doc;
    };
    try {
      if (window.DOMParser) {
        testDoc = createDocumentUsingParser('<html><body><p>test');
        return createDocumentUsingParser;
      }
    } catch (_error) {
      e = _error;
      testDoc = createDocumentUsingDOM('<html><body><p>test');
      return createDocumentUsingDOM;
    } finally {
      if ((testDoc != null ? (_ref1 = testDoc.body) != null ? _ref1.childNodes.length : void 0 : void 0) !== 1) {
        return createDocumentUsingWrite;
      }
    }
  };

  installClickHandlerLast = function(event) {
    if (!event.defaultPrevented) {
      document.removeEventListener('click', handleClick, false);
      return document.addEventListener('click', handleClick, false);
    }
  };

  handleClick = function(event) {
    var link;
    if (!event.defaultPrevented) {
      link = extractLink(event);
      if (link.nodeName === 'A' && !ignoreClick(event, link)) {
        visit(link.href);
        return event.preventDefault();
      }
    }
  };

  extractLink = function(event) {
    var link;
    link = event.target;
    while (!(!link.parentNode || link.nodeName === 'A')) {
      link = link.parentNode;
    }
    return link;
  };

  crossOriginLink = function(link) {
    return location.protocol !== link.protocol || location.host !== link.host;
  };

  anchoredLink = function(link) {
    return ((link.hash && removeHash(link)) === removeHash(location)) || (link.href === location.href + '#');
  };

  nonHtmlLink = function(link) {
    var url;
    url = removeHash(link);
    return url.match(/\.[a-z]+(\?.*)?$/g) && !url.match(/\.html?(\?.*)?$/g);
  };

  noTurbolink = function(link) {
    var ignore;
    while (!(ignore || link === document)) {
      ignore = link.getAttribute('data-no-turbolink') != null;
      link = link.parentNode;
    }
    return ignore;
  };

  targetLink = function(link) {
    return link.target.length !== 0;
  };

  nonStandardClick = function(event) {
    return event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
  };

  ignoreClick = function(event, link) {
    return crossOriginLink(link) || anchoredLink(link) || nonHtmlLink(link) || noTurbolink(link) || targetLink(link) || nonStandardClick(event);
  };

  initializeTurbolinks = function() {
    document.addEventListener('click', installClickHandlerLast, true);
    return window.addEventListener('popstate', function(event) {
      var _ref1;
      if ((_ref1 = event.state) != null ? _ref1.turbolinks : void 0) {
        return fetchHistory(event.state);
      }
    }, false);
  };

  browserSupportsPushState = window.history && window.history.pushState && window.history.replaceState && window.history.state !== void 0;

  browserIsntBuggy = !navigator.userAgent.match(/CriOS\//);

  requestMethodIsSafe = requestMethod === 'GET' || requestMethod === '';

  if (browserSupportsPushState && browserIsntBuggy && requestMethodIsSafe) {
    initializeTurbolinks();
  }

  this.Turbolinks = {
    visit: visit
  };

}).call(this);
/*! 
* DevExpress ChartJS
* Version: 13.1.7
* Build date: Sep 17, 2013
*
* Copyright (c) 2012 - 2013 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: http://chartjs.devexpress.com/EULA
*/


"use strict";

if (!window.DevExpress) {
    /*! Module core, file devexpress.js */
    (function($, global, undefined) {
        (function checkjQueryVersion(version) {
            version = version.split(".");
            if (version[0] < 1 || version[0] === 1 && version[1] < 8)
                throw Error("Your version of jQuery is too old. Please upgrade jQuery to 1.8.0 or later.");
        })($.fn.jquery);
        var Class = function() {
                var wrapOverridden = function(baseProto, methodName, method) {
                        return function() {
                                var prevCallBase = this.callBase;
                                this.callBase = baseProto[methodName];
                                try {
                                    return method.apply(this, arguments)
                                }
                                finally {
                                    this.callBase = prevCallBase
                                }
                            }
                    };
                var clonePrototype = function(obj) {
                        var func = function(){};
                        func.prototype = obj.prototype;
                        return new func
                    };
                var classImpl = function(){};
                var redefine = function(members) {
                        var self = this;
                        if (!members)
                            return self;
                        var memberNames = $.map(members, function(_, k) {
                                return k
                            });
                        $.each(["toString", "toLocaleString", "valueOf"], function() {
                            if (members[this])
                                memberNames.push(this)
                        });
                        $.each(memberNames, function() {
                            var overridden = $.isFunction(self.prototype[this]) && $.isFunction(members[this]);
                            self.prototype[this] = overridden ? wrapOverridden(self.parent.prototype, this, members[this]) : members[this]
                        });
                        return self
                    };
                var include = function() {
                        var classObj = this;
                        $.each(arguments, function() {
                            if (this.ctor)
                                classObj._includedCtors.push(this.ctor);
                            for (var name in this) {
                                if (name === "ctor")
                                    continue;
                                if (name in classObj.prototype)
                                    throw Error("Member name collision: " + name);
                                classObj.prototype[name] = this[name]
                            }
                        });
                        return classObj
                    };
                var subclassOf = function(parentClass) {
                        if (this.parent === parentClass)
                            return true;
                        if (!this.parent || !this.parent.subclassOf)
                            return false;
                        return this.parent.subclassOf(parentClass)
                    };
                classImpl.inherit = function(members) {
                    var inheritor = function() {
                            if (!this || this.constructor !== inheritor)
                                throw Error("A class must be instantiated using the 'new' keyword");
                            var instance = this,
                                ctor = instance.ctor;
                            if (ctor)
                                ctor.apply(instance, arguments);
                            $.each(instance.constructor._includedCtors, function() {
                                this.call(instance)
                            })
                        };
                    inheritor.prototype = clonePrototype(this);
                    inheritor.inherit = this.inherit;
                    inheritor.redefine = redefine;
                    inheritor.include = include;
                    inheritor.subclassOf = subclassOf;
                    inheritor.parent = this;
                    inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
                    inheritor.prototype.constructor = inheritor;
                    inheritor.redefine(members);
                    return inheritor
                };
                return classImpl
            }();
        var enqueue = function() {
                var tasks = [],
                    busy = false;
                var exec = function() {
                        while (tasks.length) {
                            var task = tasks.shift(),
                                result = task();
                            if (result === undefined)
                                continue;
                            if (result.then) {
                                busy = true;
                                $.when(result).always(exec);
                                return
                            }
                            throw Error();
                        }
                        busy = false
                    };
                return function(task) {
                        tasks.push(task);
                        if (!busy)
                            exec()
                    }
            }();
        var parseUrl = function() {
                var a = document.createElement("a"),
                    props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
                var normalizePath = function(value) {
                        if (value.charAt(0) !== "/")
                            value = "/" + value;
                        return value
                    };
                return function(url) {
                        a.href = url;
                        var result = {};
                        $.each(props, function() {
                            result[this] = a[this]
                        });
                        result.pathname = normalizePath(result.pathname);
                        return result
                    }
            }();
        global.DevExpress = global.DevExpress || {};
        var enqueueAsync = function(task) {
                var deferred = $.Deferred();
                setTimeout(function() {
                    deferred.resolve(task())
                }, 60);
                return deferred
            };
        var backButtonCallback = function() {
                var callbacks = [];
                return {
                        add: function(callback) {
                            callbacks.push(callback)
                        },
                        remove: function(callback) {
                            var indexOfCallback = $.inArray(callback, callbacks);
                            if (indexOfCallback !== -1)
                                callbacks.splice(indexOfCallback, 1)
                        },
                        fire: function() {
                            var callback = callbacks.pop(),
                                result = !!callback;
                            if (result)
                                callback();
                            return result
                        }
                    }
            }();
        var overlayTargetContainer = function() {
                var defaultTargetContainer = null;
                return function(targetContainer) {
                        if (arguments.length)
                            defaultTargetContainer = targetContainer;
                        return defaultTargetContainer
                    }
            }();
        $.extend(global.DevExpress, {
            abstract: function() {
                throw Error("Not implemented");
            },
            Class: Class,
            enqueue: enqueue,
            enqueueAsync: enqueueAsync,
            parseUrl: parseUrl,
            backButtonCallback: backButtonCallback,
            overlayTargetContainer: overlayTargetContainer
        })
    })(jQuery, this);
    /*! Module core, file inflector.js */
    (function($, DX, undefined) {
        var _normalize = function(text) {
                if (text === undefined || text === null)
                    return "";
                return String(text)
            };
        var _ucfirst = function(text) {
                return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
            };
        var _chop = function(text) {
                return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
            };
        var dasherize = function(text) {
                return $.map(_chop(text), function(p) {
                        return p.toLowerCase()
                    }).join("-")
            };
        var underscore = function(text) {
                return dasherize(text).replace(/-/g, "_")
            };
        var camelize = function(text, upperFirst) {
                return $.map(_chop(text), function(p, i) {
                        p = p.toLowerCase();
                        if (upperFirst || i > 0)
                            p = _ucfirst(p);
                        return p
                    }).join("")
            };
        var humanize = function(text) {
                return _ucfirst(dasherize(text).replace(/-/g, " "))
            };
        var titleize = function(text) {
                return $.map(_chop(text), function(p) {
                        return _ucfirst(p.toLowerCase())
                    }).join(" ")
            };
        DX.inflector = {
            dasherize: dasherize,
            camelize: camelize,
            humanize: humanize,
            titleize: titleize,
            underscore: underscore
        }
    })(jQuery, DevExpress);
    /*! Module core, file support.js */
    (function($, DX, window) {
        var cssPrefixes = ["", "Webkit", "Moz", "O", "ms"],
            styles = document.createElement("dx").style;
        var transitionEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd',
                msTransition: 'MsTransitionEnd',
                transition: 'transitionend'
            };
        var styleProp = function(prop) {
                prop = DX.inflector.camelize(prop, true);
                for (var i = 0, cssPrefixesCount = cssPrefixes.length; i < cssPrefixesCount; i++) {
                    var specific = cssPrefixes[i] + prop;
                    if (specific in styles)
                        return specific
                }
            };
        var supportProp = function(prop) {
                return !!styleProp(prop)
            };
        DX.support = {
            touch: "ontouchstart" in window,
            transform3d: supportProp("perspective"),
            transition: supportProp("transition"),
            transitionEndEventName: transitionEndEventNames[styleProp("transition")],
            animation: supportProp("animation"),
            winJS: "WinJS" in window,
            styleProp: styleProp,
            supportProp: supportProp
        }
    })(jQuery, DevExpress, this);
    /*! Module core, file browser.js */
    (function($, DX, global, undefined) {
        var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
            operaRegExp = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            ieRegExp = /(msie) ([\w.]+)/,
            mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))?/;
        var ua = navigator.userAgent.toLowerCase();
        var browser = function() {
                var result = {},
                    matches = webkitRegExp.exec(ua) || operaRegExp.exec(ua) || ieRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [],
                    browserName = matches[1],
                    browserVersion = matches[2];
                if (browserName) {
                    result[browserName] = true;
                    result.version = browserVersion
                }
                return result
            }();
        DX.browser = browser
    })(jQuery, DevExpress, this);
    /*! Module core, file position.js */
    (function($, DX, undefined) {
        var horzRe = /left|right/,
            vertRe = /top|bottom/,
            collisionRe = /fit|flip/;
        var splitPair = function(raw) {
                switch (typeof raw) {
                    case"string":
                        return raw.split(/\s+/, 2);
                    case"object":
                        return [raw.x || raw.h, raw.y || raw.v];
                    case"number":
                        return [raw];
                    default:
                        return raw
                }
            };
        var normalizeAlign = function(raw) {
                var result = {
                        h: "center",
                        v: "center"
                    };
                var pair = splitPair(raw);
                if (pair)
                    $.each(pair, function() {
                        var w = String(this).toLowerCase();
                        if (horzRe.test(w))
                            result.h = w;
                        else if (vertRe.test(w))
                            result.v = w
                    });
                return result
            };
        var normalizeOffset = function(raw) {
                var pair = splitPair(raw),
                    h = parseInt(pair && pair[0], 10),
                    v = parseInt(pair && pair[1], 10);
                if (!isFinite(h))
                    h = 0;
                if (!isFinite(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        var normalizeCollision = function(raw) {
                var pair = splitPair(raw),
                    h = String(pair && pair[0]).toLowerCase(),
                    v = String(pair && pair[1]).toLowerCase();
                if (!collisionRe.test(h))
                    h = "none";
                if (!collisionRe.test(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        var getAlignFactor = function(align) {
                switch (align) {
                    case"center":
                        return 0.5;
                    case"right":
                    case"bottom":
                        return 1;
                    default:
                        return 0
                }
            };
        var inverseAlign = function(align) {
                switch (align) {
                    case"left":
                        return "right";
                    case"right":
                        return "left";
                    case"top":
                        return "bottom";
                    case"bottom":
                        return "top";
                    default:
                        return align
                }
            };
        var initMyLocation = function(data) {
                data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
            };
        var decolliders = {
                fit: function(data, bounds) {
                    if (data.myLocation > bounds.max)
                        data.myLocation = bounds.max;
                    if (data.myLocation < bounds.min)
                        data.myLocation = bounds.min
                },
                flip: function(data, bounds) {
                    if (data.myAlign === "center" && data.atAlign === "center")
                        return;
                    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                        var inverseData = $.extend({}, data, {
                                myAlign: inverseAlign(data.myAlign),
                                atAlign: inverseAlign(data.atAlign),
                                offset: -data.offset
                            });
                        initMyLocation(inverseData);
                        if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || inverseData.myLocation > data.myLocation)
                            data.myLocation = inverseData.myLocation
                    }
                }
            };
        var scrollbarWidth;
        var position = function(what, options) {
                var $what = $(what);
                if (!options)
                    return $what.offset();
                var my = normalizeAlign(options.my),
                    at = normalizeAlign(options.at),
                    of = options.of || window,
                    offset = normalizeOffset(options.offset),
                    collision = normalizeCollision(options.collision);
                var h = {
                        mySize: $what.outerWidth(),
                        myAlign: my.h,
                        atAlign: at.h,
                        offset: offset.h,
                        collision: collision.h
                    };
                var v = {
                        mySize: $what.outerHeight(),
                        myAlign: my.v,
                        atAlign: at.v,
                        offset: offset.v,
                        collision: collision.v
                    };
                if (of.preventDefault) {
                    h.atLocation = of.pageX;
                    v.atLocation = of.pageY;
                    h.atSize = 0;
                    v.atSize = 0
                }
                else {
                    of = $(of);
                    if ($.isWindow(of[0])) {
                        h.atLocation = of.scrollLeft();
                        v.atLocation = of.scrollTop();
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else if (of[0].nodeType === 9) {
                        h.atLocation = 0;
                        v.atLocation = 0;
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else {
                        var o = of.offset();
                        h.atLocation = o.left;
                        v.atLocation = o.top;
                        h.atSize = of.outerWidth();
                        v.atSize = of.outerHeight()
                    }
                }
                initMyLocation(h);
                initMyLocation(v);
                var bounds = function() {
                        var win = $(window),
                            left = win.scrollLeft(),
                            top = win.scrollTop();
                        if (scrollbarWidth === undefined)
                            scrollbarWidth = calculateScrollbarWidth();
                        var hScrollbar = document.width > document.documentElement.clientWidth,
                            vScrollbar = document.height > document.documentElement.clientHeight,
                            hZoomLevel = DX.support.touch ? document.documentElement.clientWidth / (vScrollbar ? window.innerWidth - scrollbarWidth : window.innerWidth) : 1,
                            vZoomLevel = DX.support.touch ? document.documentElement.clientHeight / (hScrollbar ? window.innerHeight - scrollbarWidth : window.innerHeight) : 1;
                        return {
                                h: {
                                    min: left,
                                    max: left + win.width() / hZoomLevel - h.mySize
                                },
                                v: {
                                    min: top,
                                    max: top + win.height() / vZoomLevel - v.mySize
                                }
                            }
                    }();
                if (decolliders[h.collision])
                    decolliders[h.collision](h, bounds.h);
                if (decolliders[v.collision])
                    decolliders[v.collision](v, bounds.v);
                $what.offset({
                    left: Math.round(h.myLocation),
                    top: Math.round(v.myLocation)
                })
            };
        DX.position = position;
        var calculateScrollbarWidth = function() {
                var $scrollDiv = $("<div>").css({
                        width: 100,
                        height: 100,
                        overflow: "scroll",
                        position: "absolute",
                        top: -9999
                    }).appendTo($("body")),
                    result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
                $scrollDiv.remove();
                return result
            }
    })(jQuery, DevExpress);
    /*! Module core, file action.js */
    (function($, DX, undefined) {
        var actionExecutors = {};
        var registerExecutor = function(name, executor) {
                if ($.isPlainObject(name)) {
                    $.each(name, registerExecutor);
                    return
                }
                actionExecutors[name] = executor
            };
        var unregisterExecutor = function(name) {
                var args = $.makeArray(arguments);
                $.each(args, function() {
                    delete actionExecutors[this]
                })
            };
        registerExecutor({
            func: {execute: function(e) {
                    if ($.isFunction(e.action)) {
                        e.result = e.action.apply(e.context, e.args);
                        e.handled = true
                    }
                }},
            url: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) !== "#")
                        document.location = e.action
                }},
            hash: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) === "#")
                        document.location.hash = e.action
                }}
        });
        var Action = DX.Class.inherit({
                ctor: function(action, config) {
                    config = config || {};
                    this._action = action || $.noop;
                    this._context = config.context || window;
                    this._beforeExecute = config.beforeExecute || $.noop;
                    this._afterExecute = config.afterExecute || $.noop;
                    this._component = config.component;
                    this._allowedForGesture = !!config.allowedForGesture
                },
                execute: function() {
                    var e = {
                            action: this._action,
                            args: Array.prototype.slice.call(arguments),
                            context: this._context,
                            component: this._component,
                            canceled: false,
                            handled: false,
                            allowedForGesture: this._allowedForGesture
                        };
                    if (!this._validateAction(e))
                        return;
                    this._beforeExecute.call(this._context, e);
                    if (e.canceled)
                        return;
                    var result = this._executeAction(e);
                    this._afterExecute.call(this._context, e);
                    return result
                },
                _validateAction: function(e) {
                    $.each(actionExecutors, function(index, executor) {
                        if (executor.validate)
                            executor.validate(e);
                        if (e.canceled)
                            return false
                    });
                    return !e.canceled
                },
                _executeAction: function(e) {
                    var result;
                    $.each(actionExecutors, function(index, executor) {
                        if (executor.execute)
                            executor.execute(e);
                        if (e.handled) {
                            result = e.result;
                            return false
                        }
                    });
                    return result
                }
            });
        $.extend(DX, {
            registerActionExecutor: registerExecutor,
            unregisterActionExecutor: unregisterExecutor,
            Action: Action
        });
        DX.__internals = {actionExecutors: actionExecutors}
    })(jQuery, DevExpress);
    /*! Module core, file utils.js */
    (function($, DX, undefined) {
        var PI = Math.PI,
            LN10 = Math.LN10;
        var cos = Math.cos,
            sin = Math.sin,
            abs = Math.abs,
            log = Math.log,
            floor = Math.floor,
            ceil = Math.ceil,
            max = Math.max,
            min = Math.min,
            isNaN = window.isNaN,
            Number = window.Number,
            NaN = window.NaN;
        var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
        var isDefined = function(object) {
                return object !== null && object !== undefined
            };
        var isString = function(object) {
                return $.type(object) === 'string'
            };
        var isNumber = function(object) {
                return $.isNumeric(object)
            };
        var isObject = function(object) {
                return $.type(object) === 'object'
            };
        var isArray = function(object) {
                return $.type(object) === 'array'
            };
        var isDate = function(object) {
                return $.type(object) === 'date'
            };
        var isFunction = function(object) {
                return $.type(object) === 'function'
            };
        var toMilliseconds = function(value) {
                switch (value) {
                    case'millisecond':
                        return 1;
                    case'second':
                        return toMilliseconds('millisecond') * 1000;
                    case'minute':
                        return toMilliseconds('second') * 60;
                    case'hour':
                        return toMilliseconds('minute') * 60;
                    case'day':
                        return toMilliseconds('hour') * 24;
                    case'week':
                        return toMilliseconds('day') * 7;
                    case'month':
                        return toMilliseconds('day') * 30;
                    case'quarter':
                        return toMilliseconds('month') * 3;
                    case'year':
                        return toMilliseconds('day') * 365;
                    default:
                        return 0
                }
            };
        var convertDateUnitToMilliseconds = function(dateUnit, count) {
                return toMilliseconds(dateUnit) * count
            };
        var convertMillisecondsToDateUnits = function(value) {
                var i,
                    dateUnitCount,
                    dateUnitInterval,
                    dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'],
                    result = {};
                for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                    dateUnitInterval = dateUnitIntervals[i];
                    dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                    if (dateUnitCount > 0) {
                        result[dateUnitInterval + 's'] = dateUnitCount;
                        value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                    }
                }
                return result
            };
        var convertDateTickIntervalToMilliseconds = function(tickInterval) {
                var milliseconds = 0;
                if (isObject(tickInterval))
                    $.each(tickInterval, function(key, value) {
                        milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                    });
                if (isString(tickInterval))
                    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
                return milliseconds
            };
        var getDatesDifferences = function(date1, date2) {
                var differences,
                    counter = 0;
                differences = {
                    year: date1.getFullYear() !== date2.getFullYear(),
                    month: date1.getMonth() !== date2.getMonth(),
                    day: date1.getDate() !== date2.getDate(),
                    hour: date1.getHours() !== date2.getHours(),
                    minute: date1.getMinutes() !== date2.getMinutes(),
                    second: date1.getSeconds() !== date2.getSeconds()
                };
                $.each(differences, function(key, value) {
                    if (value)
                        counter++
                });
                differences.count = counter;
                return differences
            };
        var getFraction = function(value) {
                var valueString,
                    indexPoint;
                if (isNumber(value)) {
                    valueString = value.toFixed(20);
                    indexPoint = valueString.indexOf('.');
                    return valueString.substr(indexPoint + 1, valueString.length - indexPoint + 1)
                }
                return ''
            };
        var getSignificantDigitPosition = function(value) {
                var fraction = getFraction(value),
                    i;
                if (fraction)
                    for (i = 0; i < fraction.length; i++)
                        if (fraction.charAt(i) !== '0')
                            return i + 1;
                return 0
            };
        var addSubValues = function(value1, value2, isSub) {
                return value1 + (isSub ? -1 : 1) * value2
            };
        var isExponential = function(value) {
                return isNumber(value) && value.toString().indexOf('e') !== -1
            };
        var addInterval = function(value, interval, isNegative) {
                var result = null,
                    intervalObject;
                if (isDate(value)) {
                    intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
                    result = new Date(value.getTime());
                    if (intervalObject.years)
                        result.setFullYear(addSubValues(result.getFullYear(), intervalObject.years, isNegative));
                    if (intervalObject.quarters)
                        result.setMonth(addSubValues(result.getMonth(), 3 * intervalObject.quarters, isNegative));
                    if (intervalObject.months)
                        result.setMonth(addSubValues(result.getMonth(), intervalObject.months, isNegative));
                    if (intervalObject.weeks)
                        result.setDate(addSubValues(result.getDate(), 7 * intervalObject.weeks, isNegative));
                    if (intervalObject.days)
                        result.setDate(addSubValues(result.getDate(), intervalObject.days, isNegative));
                    if (intervalObject.hours)
                        result.setHours(addSubValues(result.getHours(), intervalObject.hours, isNegative));
                    if (intervalObject.minutes)
                        result.setMinutes(addSubValues(result.getMinutes(), intervalObject.minutes, isNegative));
                    if (intervalObject.seconds)
                        result.setSeconds(addSubValues(result.getSeconds(), intervalObject.seconds, isNegative));
                    if (intervalObject.milliseconds)
                        result.setMilliseconds(addSubValues(value.getMilliseconds(), intervalObject.milliseconds, isNegative))
                }
                else
                    result = addSubValues(value, interval, isNegative);
                return result
            };
        var getDateUnitInterval = function(tickInterval) {
                var maxInterval = -1,
                    i;
                if (isString(tickInterval))
                    return tickInterval;
                if (isObject(tickInterval)) {
                    $.each(tickInterval, function(key, value) {
                        for (i = 0; i < dateUnitIntervals.length; i++)
                            if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i)
                                maxInterval = i
                    });
                    return dateUnitIntervals[maxInterval]
                }
                return ''
            };
        var correctDateWithUnitBeginning = function(date, dateInterval) {
                var dayMonth,
                    firstQuarterMonth,
                    dateUnitInterval = getDateUnitInterval(dateInterval);
                switch (dateUnitInterval) {
                    case'second':
                        date.setMilliseconds(0);
                        break;
                    case'minute':
                        date.setSeconds(0, 0);
                        break;
                    case'hour':
                        date.setMinutes(0, 0, 0);
                        break;
                    case'year':
                        date.setMonth(0);
                    case'month':
                        date.setDate(1);
                    case'day':
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'week':
                        dayMonth = date.getDate();
                        if (date.getDay() !== 0)
                            dayMonth += 7 - date.getDay();
                        date.setDate(dayMonth);
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'quarter':
                        firstQuarterMonth = DX.formatHelper.getFirstQuarterMonth(date.getMonth());
                        if (date.getMonth() !== firstQuarterMonth)
                            date.setMonth(firstQuarterMonth);
                        date.setDate(1);
                        date.setHours(0, 0, 0, 0);
                        break
                }
            };
        var roundValue = function(value, precision) {
                if (isNumber(value))
                    if (isExponential(value))
                        return Number(value.toExponential(precision));
                    else
                        return Number(value.toFixed(precision))
            };
        var getPrecision = function(value) {
                var stringFraction,
                    stringValue = value.toString(),
                    pointIndex = stringValue.indexOf('.');
                if (pointIndex !== -1) {
                    stringFraction = stringValue.substring(pointIndex + 1);
                    return stringFraction.length
                }
                return 0
            };
        var applyPrecisionByMinDelta = function(min, delta, value) {
                var minPrecision = getPrecision(min),
                    deltaPrecision = getPrecision(delta);
                return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
            };
        var adjustValue = function(value) {
                var fraction = getFraction(value),
                    nextValue,
                    i;
                if (fraction)
                    for (i = 1; i <= fraction.length; i++) {
                        nextValue = roundValue(value, i);
                        if (nextValue !== 0 && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1])
                            return nextValue
                    }
                return value
            };
        var getDateIntervalByString = function(intervalString) {
                var result = {};
                switch (intervalString) {
                    case'year':
                        result.years = 1;
                        break;
                    case'month':
                        result.months = 1;
                        break;
                    case'quarter':
                        result.months = 3;
                        break;
                    case'week':
                        result.days = 7;
                        break;
                    case'day':
                        result.days = 1;
                        break;
                    case'hour':
                        result.hours = 1;
                        break;
                    case'minute':
                        result.minutes = 1;
                        break;
                    case'second':
                        result.seconds = 1;
                        break;
                    case'millisecond':
                        result.milliseconds = 1;
                        break
                }
                return result
            };
        var normalizeAngle = function(angle) {
                return (angle % 360 + 360) % 360
            };
        var convertAngleToRendererSpace = function(angle) {
                return 90 - angle
            };
        var degreesToRadians = function(value) {
                return PI * value / 180
            };
        var getCosAndSin = function(angle) {
                var angleInRadians = degreesToRadians(angle);
                return {
                        cos: cos(angleInRadians),
                        sin: sin(angleInRadians)
                    }
            };
        var DECIMAL_ORDER_THRESHOLD = 1E-14;
        var getDecimalOrder = function(number) {
                var n = abs(number),
                    cn;
                if (!isNaN(n)) {
                    if (n > 0) {
                        n = log(n) / LN10;
                        cn = ceil(n);
                        return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                    }
                    return 0
                }
                return NaN
            };
        var getAppropriateFormat = function(start, end, count) {
                var order = max(getDecimalOrder(start), getDecimalOrder(end)),
                    precision = -getDecimalOrder(abs(end - start) / count),
                    format;
                if (!isNaN(order) && !isNaN(precision)) {
                    if (abs(order) <= 4) {
                        format = 'fixedPoint';
                        precision < 0 && (precision = 0);
                        precision > 4 && (precision = 4)
                    }
                    else {
                        format = 'exponential';
                        precision += order - 1;
                        precision > 3 && (precision = 3)
                    }
                    return {
                            format: format,
                            precision: precision
                        }
                }
                return null
            };
        var createResizeHandler = function(callback) {
                var $window = $(window),
                    timeout;
                var debug_callback = arguments[1];
                var handler = function() {
                        var width = $window.width(),
                            height = $window.height();
                        clearTimeout(timeout);
                        timeout = setTimeout(function() {
                            $window.width() === width && $window.height() === height && callback();
                            debug_callback && debug_callback()
                        }, 100)
                    };
                handler.stop = function() {
                    clearTimeout(timeout);
                    return this
                };
                return handler
            };
        var logger = function() {
                var info = function() {
                        if (window.console && arguments[0])
                            console.info(arguments[0])
                    };
                var warn = function() {
                        if (window.console && arguments[0])
                            console.warn(arguments[0])
                    };
                var error = function() {
                        if (window.console && arguments[0])
                            console.error(arguments[0])
                    };
                return {
                        info: info,
                        warn: warn,
                        error: error
                    }
            }();
        var debug = function() {
                function assert(condition, message) {
                    if (!condition)
                        throw new Error(message);
                }
                function assertParam(parameter, message) {
                    assert(parameter !== null && parameter !== undefined, message)
                }
                return {
                        assert: assert,
                        assertParam: assertParam
                    }
            }();
        var windowResizeCallbacks = function() {
                var prevSize,
                    callbacks = $.Callbacks(),
                    jqWindow = $(window);
                var formatSize = function() {
                        return [jqWindow.width(), jqWindow.height()].join()
                    };
                var handleResize = function() {
                        var now = formatSize();
                        if (now === prevSize)
                            return;
                        prevSize = now;
                        callbacks.fire()
                    };
                jqWindow.on("resize", handleResize);
                prevSize = formatSize();
                return callbacks
            }();
        var createMarkupFromString = function(str) {
                var tempElement = $("<div />");
                if (window.WinJS)
                    WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
                else
                    tempElement.append(str);
                return tempElement.contents()
            };
        var numClipRect = 1;
        var numPattern = 1;
        var getNextClipId = function() {
                return 'DevExpress_' + numClipRect++
            };
        var getNextPatternId = function() {
                return 'DevExpressPattern_' + numPattern++
            };
        var extendFromDataAttributes = function(target, $el, overrideExistingValues) {
                target = target || {};
                var source = {};
                var prefix = "data-dx-";
                var attributes = $el.get(0).attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var name = attributes[i].name;
                    if (name.indexOf(prefix) === 0) {
                        var propertyName = DX.inflector.camelize(name.substr(prefix.length));
                        source[propertyName] = attributes[i].value
                    }
                }
                return extendFromObject(target, source, overrideExistingValues)
            };
        var extendFromObject = function(target, source, overrideExistingValues) {
                target = target || {};
                for (var prop in source)
                    if (source.hasOwnProperty(prop)) {
                        var value = source[prop];
                        if (!(prop in target) || overrideExistingValues)
                            target[prop] = value
                    }
                return target
            };
        var subscribeEventToDocument = function(event, handler, data) {
                var currentWindow = window;
                $(document).on(event, data, handler)
            };
        var unsubscribeEventFromDocument = function(event) {
                var currentWindow = window;
                $(document).off(event)
            };
        function Clone(){}
        var clone = function(obj) {
                Clone.prototype = obj;
                return new Clone
            };
        var executeAsync = function(action, context) {
                var deferred = $.Deferred(),
                    normalizedContext = context || this;
                setTimeout(function() {
                    var result = action.call(normalizedContext);
                    if (result && result.done && $.isFunction(result.done))
                        result.done(function() {
                            deferred.resolveWith(normalizedContext)
                        });
                    else
                        deferred.resolveWith(normalizedContext)
                }, 0);
                return deferred.promise()
            };
        DX.utils = {
            dateUnitIntervals: dateUnitIntervals,
            isDefined: isDefined,
            isString: isString,
            isNumber: isNumber,
            isObject: isObject,
            isArray: isArray,
            isDate: isDate,
            isFunction: isFunction,
            normalizeAngle: normalizeAngle,
            convertAngleToRendererSpace: convertAngleToRendererSpace,
            degreesToRadians: degreesToRadians,
            getCosAndSin: getCosAndSin,
            getDecimalOrder: getDecimalOrder,
            getAppropriateFormat: getAppropriateFormat,
            getFraction: getFraction,
            adjustValue: adjustValue,
            convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
            convertDateTickIntervalToMilliseconds: convertDateTickIntervalToMilliseconds,
            convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
            getDateUnitInterval: getDateUnitInterval,
            getDatesDifferences: getDatesDifferences,
            correctDateWithUnitBeginning: correctDateWithUnitBeginning,
            roundValue: roundValue,
            isExponential: isExponential,
            applyPrecisionByMinDelta: applyPrecisionByMinDelta,
            getSignificantDigitPosition: getSignificantDigitPosition,
            addInterval: addInterval,
            getDateIntervalByString: getDateIntervalByString,
            logger: logger,
            debug: debug,
            createResizeHandler: createResizeHandler,
            windowResizeCallbacks: windowResizeCallbacks,
            createMarkupFromString: createMarkupFromString,
            getNextClipId: getNextClipId,
            getNextPatternId: getNextPatternId,
            extendFromDataAttributes: extendFromDataAttributes,
            extendFromObject: extendFromObject,
            subscribeEventToDocument: subscribeEventToDocument,
            unsubscribeEventFromDocument: unsubscribeEventFromDocument,
            clone: clone,
            executeAsync: executeAsync
        }
    })(jQuery, DevExpress);
    /*! Module core, file translator.js */
    (function($, DX, undefined) {
        var support = DX.support,
            TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
            TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
        var locate = function($element) {
                var result,
                    position;
                if (support.transform3d) {
                    var translate = getTranslate($element);
                    result = {
                        left: translate.x,
                        top: translate.y
                    }
                }
                else {
                    position = $element.position();
                    result = {
                        left: position.left,
                        top: position.top
                    }
                }
                return result
            };
        var move = function($element, position) {
                if (!support.transform3d) {
                    $element.css(position);
                    return
                }
                var translate = getTranslate($element),
                    left = position.left,
                    top = position.top;
                if (left !== undefined)
                    translate.x = left;
                if (top !== undefined)
                    translate.y = top;
                $element.css("transform", getTranslateCss(translate))
            };
        var getTranslate = function($element) {
                var transformValue = $element.css("transform"),
                    matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
                    is3D = matrix && matrix[1];
                if (matrix) {
                    matrix = matrix[2].split(",");
                    if (is3D === "3d")
                        matrix = matrix.slice(12, 15);
                    else {
                        matrix.push(0);
                        matrix = matrix.slice(4, 7)
                    }
                }
                else
                    matrix = [0, 0, 0];
                return {
                        x: parseFloat(matrix[0]),
                        y: parseFloat(matrix[1]),
                        z: parseFloat(matrix[2])
                    }
            };
        var parseTranslate = function(translateString) {
                var result = translateString.match(TRANSLATE_REGEX);
                if (!result || !result[1])
                    return;
                result = result[1].split(",");
                result = {
                    x: parseFloat(result[0]),
                    y: parseFloat(result[1]),
                    z: parseFloat(result[2])
                };
                return result
            };
        var getTranslateCss = function(translate) {
                return "translate3d(" + (translate.x || 0) + "px, " + (translate.y || 0) + "px, " + (translate.z || 0) + "px)"
            };
        DX.translator = {
            move: move,
            locate: locate,
            parseTranslate: parseTranslate,
            getTranslate: getTranslate,
            getTranslateCss: getTranslateCss
        }
    })(jQuery, DevExpress);
    /*! Module core, file devices.js */
    (function($, DX, undefined) {
        var knownUATable = {
                iPhone: "iPhone",
                iPhone5: "iPhone 5",
                iPad: "iPad",
                iPadMini: "iPad Mini",
                androidPhone: "Android Mobile",
                androidTablet: "Android",
                win8: "MSAppHost",
                win8Phone: "Windows Phone 8",
                msSurface: "MSIE ARM Tablet PC",
                desktop: "desktop"
            },
            deviceDefault = {
                phone: false,
                tablet: false,
                android: false,
                ios: false,
                win8: false
            },
            desktopDevice = $.extend(deviceDefault, {platform: "desktop"});
        var fromUA = function(ua) {
                var ipad = /ipad/i.test(ua),
                    iphone = /iphone|ipod/i.test(ua),
                    android = /android|silk-accelerated/i.test(ua),
                    win8Phone = /windows phone 8|wpdesktop/i.test(ua),
                    msSurface = /msie(.*)arm(.*)tablet\spc/i.test(ua),
                    win8 = /msapphost/i.test(ua) || win8Phone || msSurface;
                if (!ipad && !iphone && !android && !win8 && !win8Phone && !msSurface)
                    return $.extend({}, desktopDevice);
                var phone = iphone || android && /mobile/i.test(ua) || win8Phone,
                    tablet = !phone && !win8 && !win8Phone,
                    name = android ? "android" : win8 ? "win8" : "ios";
                return {
                        phone: phone,
                        tablet: tablet,
                        android: android,
                        ios: ipad || iphone,
                        win8: name === "win8",
                        platform: name
                    }
            };
        var getDevice = function(deviceName) {
                var ua;
                if (deviceName) {
                    ua = knownUATable[deviceName];
                    if (!ua)
                        throw Error("Unknown device");
                }
                else
                    ua = navigator.userAgent;
                return fromUA(ua)
            };
        var androidVersion = function(userAgent) {
                userAgent = userAgent || window.navigator.userAgent;
                var matches = /Android (\d\.\d(?:\.\d)?)/.exec(userAgent);
                if (matches && matches.length === 2)
                    return $.map(matches[1].split("."), function(versionPart) {
                            return parseInt(versionPart, 10)
                        });
                return []
            };
        function iosVersion(userAgent) {
            userAgent = userAgent || window.navigator.userAgent;
            if (/iP(hone|od|ad)/.test(userAgent)) {
                var v = userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
                return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)]
            }
        }
        var device;
        var getDeviceNameFromSessionStorage = function() {
                return window.sessionStorage && (sessionStorage.getItem("dx-force-device") || sessionStorage.getItem("dx-simulator-device"))
            };
        var getDeviceNameFromWindowScope = function() {
                var result = undefined;
                if (window.top["dx-force-device"])
                    result = window.top["dx-force-device"];
                return result
            };
        var current = function(deviceOrName) {
                if (deviceOrName)
                    if ($.isPlainObject(deviceOrName))
                        device = $.extend(deviceDefault, deviceOrName);
                    else
                        device = getDevice(deviceOrName);
                else {
                    if (!device) {
                        var deviceName = undefined;
                        try {
                            deviceName = getDeviceNameFromWindowScope()
                        }
                        catch(e) {
                            deviceName = getDeviceNameFromSessionStorage()
                        }
                        finally {
                            if (!deviceName)
                                deviceName = getDeviceNameFromSessionStorage()
                        }
                        device = getDevice(deviceName)
                    }
                    return device
                }
            };
        DX.devices = {
            androidVersion: androidVersion,
            iosVersion: iosVersion,
            current: current,
            fromUA: function() {
                return fromUA(navigator.userAgent)
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file fx.js */
    (function($, DX, undefined) {
        var translator = DX.translator,
            support = DX.support,
            transitionEndEventName = support.transitionEndEventName + ".dxFX";
        var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
            SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY = "dxSimulatedTransitionTimeoutKey",
            ANIM_DATA_KEY = "dxAnimData",
            TRANSFORM_PROP = "transform",
            FRAME_ANIMATION_STEP_TIME = 1000 / 60;
        var TransitionAnimationStrategy = {
                animate: function($element, config) {
                    var deferred = $.Deferred(),
                        transitionEndFired = $.Deferred(),
                        simulatedTransitionEndFired = $.Deferred();
                    $element.one(transitionEndEventName, function() {
                        transitionEndFired.reject()
                    });
                    $element.data(SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY, setTimeout(function() {
                        simulatedTransitionEndFired.reject()
                    }, config.duration + config.delay));
                    $.when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
                        this._cleanup($element);
                        deferred.resolveWith($element, [config, $element])
                    }, this));
                    translator.getTranslate($element);
                    $element.css({
                        transitionProperty: "all",
                        transitionDelay: config.delay + "ms",
                        transitionDuration: config.duration + "ms",
                        transitionTimingFunction: config.easing
                    });
                    setProps($element, config.to);
                    if (!config.duration)
                        $element.trigger(transitionEndEventName);
                    return deferred.promise()
                },
                _cleanup: function($element) {
                    $element.css("transition", "none").off(transitionEndEventName);
                    var simulatedEndEventTimer = $element.data(SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY);
                    clearTimeout(simulatedEndEventTimer);
                    $element.removeData(SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY)
                },
                stop: function($element, jumpToEnd) {
                    var config = $element.data(ANIM_DATA_KEY);
                    if (!config)
                        return;
                    if (jumpToEnd)
                        $element.trigger(transitionEndEventName);
                    else {
                        $.each(config.to, function(key) {
                            $element.css(key, $element.css(key))
                        });
                        this._cleanup($element)
                    }
                }
            };
        var requestAnimationFrame = function() {
                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
                        window.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
                    }
            }();
        var FrameAnimationStrategy = {
                animate: function($element, config) {
                    var deferred = $.Deferred(),
                        animationData = $element.data(ANIM_DATA_KEY),
                        self = this;
                    if (!animationData)
                        return deferred.reject().promise();
                    $.each(config.to, function(prop) {
                        if (config.from[prop] === undefined)
                            config.from[prop] = self._normalizeValue($element.css(prop))
                    });
                    if (config.to[TRANSFORM_PROP]) {
                        config.from[TRANSFORM_PROP] = self._parseTransform(config.from[TRANSFORM_PROP]);
                        config.to[TRANSFORM_PROP] = self._parseTransform(config.to[TRANSFORM_PROP])
                    }
                    animationData.frameAnimation = {
                        to: config.to,
                        from: config.from,
                        currentValue: config.from,
                        easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
                        duration: config.duration,
                        startTime: (new Date).valueOf(),
                        finish: function() {
                            this.currentValue = this.to;
                            this.draw();
                            deferred.resolve()
                        },
                        draw: function() {
                            var currentValue = $.extend({}, this.currentValue);
                            if (currentValue[TRANSFORM_PROP])
                                currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                    if (prop === "translate")
                                        return translator.getTranslateCss(value);
                                    else if (prop === "scale")
                                        return "scale(" + value + ")";
                                    else if (prop.substr(0, prop.length - 1) === "rotate")
                                        return prop + "(" + value + "deg)"
                                }).join(" ");
                            $element.css(currentValue)
                        }
                    };
                    if (config.delay) {
                        animationData.frameAnimation.startTime += config.delay;
                        animationData.frameAnimation.delayTimeout = setTimeout(function() {
                            self._animationStep($element)
                        }, config.delay)
                    }
                    else
                        self._animationStep($element);
                    return deferred.promise()
                },
                _parseTransform: function(transformString) {
                    var result = {};
                    $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
                        var translateData = translator.parseTranslate(part),
                            scaleData = part.match(/scale\((.+?)\)/),
                            rotateData = part.match(/(rotate.)\((.+)deg\)/);
                        if (translateData)
                            result.translate = translateData;
                        if (scaleData && scaleData[1])
                            result.scale = parseFloat(scaleData[1]);
                        if (rotateData && rotateData[1])
                            result[rotateData[1]] = parseFloat(rotateData[2])
                    });
                    return result
                },
                stop: function($element, jumpToEnd) {
                    var animationData = $element.data(ANIM_DATA_KEY),
                        frameAnimation = animationData && animationData.frameAnimation;
                    if (!frameAnimation)
                        return;
                    clearTimeout(frameAnimation.delayTimeout);
                    if (jumpToEnd)
                        frameAnimation.finish()
                },
                _animationStep: function($element) {
                    var animationData = $element.data(ANIM_DATA_KEY),
                        frameAnimation = animationData && animationData.frameAnimation;
                    if (!frameAnimation)
                        return;
                    var now = (new Date).valueOf();
                    if (now >= frameAnimation.startTime + frameAnimation.duration) {
                        frameAnimation.finish();
                        return
                    }
                    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                    frameAnimation.draw();
                    requestAnimationFrame($.proxy(function() {
                        this._animationStep($element)
                    }, this))
                },
                _calcStepValue: function(frameAnimation, currentDuration) {
                    var calcValueRecursively = function(from, to) {
                            var result = $.isArray(to) ? [] : {};
                            var calcEasedValue = function(propName) {
                                    var x = currentDuration / frameAnimation.duration,
                                        t = currentDuration,
                                        b = 1 * from[propName],
                                        c = to[propName] - from[propName],
                                        d = frameAnimation.duration;
                                    return $.easing[frameAnimation.easing](x, t, b, c, d)
                                };
                            $.each(to, function(propName, endPropValue) {
                                if (typeof endPropValue === "string" && parseFloat(endPropValue, 10) === false)
                                    return true;
                                result[propName] = typeof endPropValue === "object" ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                            });
                            return result
                        };
                    return calcValueRecursively(frameAnimation.from, frameAnimation.to)
                },
                _normalizeValue: function(value) {
                    var numericValue = parseFloat(value, 10);
                    if (numericValue === false)
                        return value;
                    return numericValue
                }
            };
        var animationStrategies = {
                transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
                frame: FrameAnimationStrategy
            };
        var getAnimationStrategy = function(config) {
                return animationStrategies[config && config.strategy || "transition"]
            };
        var TransitionTimingFuncMap = {
                linear: "cubic-bezier(0, 0, 1, 1)",
                ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
                "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
                "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
                "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
            };
        var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
                cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
                var bezCoeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
                if (!bezCoeffs)
                    return "linear";
                bezCoeffs = bezCoeffs.slice(1, 5);
                $.each(bezCoeffs, function(index, value) {
                    bezCoeffs[index] = parseFloat(value)
                });
                var easingName = "cubicbezier_" + bezCoeffs.join("_").replace(/\./g, "p");
                if (!$.isFunction($.easing[easingName])) {
                    var polynomBezier = function(x1, y1, x2, y2) {
                            var Cx = 3 * x1,
                                Bx = 3 * (x2 - x1) - Cx,
                                Ax = 1 - Cx - Bx,
                                Cy = 3 * y1,
                                By = 3 * (y2 - y1) - Cy,
                                Ay = 1 - Cy - By;
                            var bezierX = function(t) {
                                    return t * (Cx + t * (Bx + t * Ax))
                                };
                            var bezierY = function(t) {
                                    return t * (Cy + t * (By + t * Ay))
                                };
                            var findXfor = function(t) {
                                    var x = t,
                                        i = 0,
                                        z;
                                    while (i < 14) {
                                        z = bezierX(x) - t;
                                        if (Math.abs(z) < 1e-3)
                                            break;
                                        x = x - z / derivativeX(x);
                                        i++
                                    }
                                    return x
                                };
                            var derivativeX = function(t) {
                                    return Cx + t * (2 * Bx + t * 3 * Ax)
                                };
                            return function(t) {
                                    return bezierY(findXfor(t))
                                }
                        };
                    $.easing[easingName] = function(x, t, b, c, d) {
                        return c * polynomBezier(bezCoeffs[0], bezCoeffs[1], bezCoeffs[2], bezCoeffs[3])(t / d) + b
                    }
                }
                return easingName
            };
        var baseConfigValidator = function(config, animationType) {
                $.each(["from", "to"], function() {
                    if (!$.isPlainObject(config[this]))
                        throw Error("Animation with the '" + animationType + "' type requires '" + this + "' configuration as an plain object.");
                })
            };
        var CustomAnimationConfigurator = {setup: function($element, config){}};
        var SlideAnimationConfigurator = {
                validateConfig: function(config) {
                    baseConfigValidator(config, "slide")
                },
                setup: function($element, config) {
                    var animStrategy = getAnimationStrategy(config);
                    if (!support.transform3d || animStrategy !== TransitionAnimationStrategy && animStrategy !== FrameAnimationStrategy)
                        return;
                    this._setupConfig($element, config.from);
                    this._setupConfig($element, config.to)
                },
                _setupConfig: function($element, config) {
                    var translate = translator.getTranslate($element),
                        left = config.left,
                        top = config.top;
                    if (left !== undefined) {
                        translate.x = left;
                        delete config.left
                    }
                    if (top !== undefined) {
                        translate.y = top;
                        delete config.top
                    }
                    config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
                }
            };
        var FadeAnimationConfigurator = {setup: function($element, config) {
                    var from = config.from,
                        fromOpacity = $.isPlainObject(from) ? $element.css("opacity") : String(from),
                        toOpacity = String(config.to);
                    config.from = {opacity: fromOpacity};
                    config.to = {opacity: toOpacity}
                }};
        var PopAnimationConfigurator = {
                validateConfig: function(config) {
                    baseConfigValidator(config, "pop")
                },
                setup: function($element, config) {
                    if (!support.transform3d)
                        return;
                    var from = config.from,
                        to = config.to,
                        fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
                        toOpacicy = "opacity" in to ? to.opacity : 1,
                        fromScale = "scale" in from ? from.scale : 0,
                        toScale = "scale" in to ? to.scale : 1;
                    config.from = {opacity: fromOpacity};
                    config.from[TRANSFORM_PROP] = this._getCssTransform(fromScale);
                    config.to = {opacity: toOpacicy};
                    config.to[TRANSFORM_PROP] = this._getCssTransform(toScale)
                },
                _getCssTransform: function(scale) {
                    return "scale(" + scale + ")"
                }
            };
        var animationConfigurators = {
                custom: CustomAnimationConfigurator,
                slide: SlideAnimationConfigurator,
                fade: FadeAnimationConfigurator,
                pop: PopAnimationConfigurator
            };
        var getAnimationConfigurator = function(type) {
                var result = animationConfigurators[type];
                if (!result)
                    throw Error("Unknown animation type \"" + type + "\"");
                return result
            };
        var defaultConfig = {
                type: "custom",
                from: {},
                to: {},
                duration: 400,
                complete: $.noop,
                easing: "ease",
                delay: 0
            };
        var animate = function(element, config) {
                config = $.extend(true, {}, defaultConfig, config);
                var $element = $(element),
                    configurator = getAnimationConfigurator(config.type);
                if ($.isFunction(configurator.validateConfig))
                    configurator.validateConfig(config);
                configurator.setup($element, config);
                stop($element);
                setProps($element, config.from);
                return executeAnimation($element, config).done(config.complete)
            };
        var setProps = function($element, props) {
                $.each(props, function(key, value) {
                    $element.css(key, value)
                })
            };
        var executeAnimation = function($element, config) {
                var deferred = $.Deferred();
                $element.data(ANIM_DATA_KEY, config);
                if (DX.fx.off)
                    config.duration = 0;
                getAnimationStrategy(config).animate($element, config).done(function() {
                    $element.removeData(ANIM_DATA_KEY);
                    deferred.resolveWith(this, [$element, config])
                });
                return deferred.promise()
            };
        var animating = function($element) {
                return !!$element.data(ANIM_DATA_KEY)
            };
        var stop = function(element, jumpToEnd) {
                var $element = $(element);
                getAnimationStrategy($element.data(ANIM_DATA_KEY)).stop($element, jumpToEnd);
                $element.removeData(ANIM_DATA_KEY)
            };
        DX.fx = {
            off: false,
            animationTypes: animationConfigurators,
            animate: animate,
            animating: animating,
            stop: stop
        };
        DX.fx.__internals = {convertTransitionTimingFuncToJQueryEasing: convertTransitionTimingFuncToJQueryEasing}
    })(jQuery, DevExpress);
    /*! Module core, file endpointSelector.js */
    (function($, DX, undefined) {
        var location = window.location,
            DXPROXY_HOST = "dxproxy.devexpress.com:8000",
            WIN_JS = location.protocol === "ms-appx:",
            IS_DXPROXY = location.host === DXPROXY_HOST,
            IS_LOCAL = isLocalHostName(location.hostname);
        function isLocalHostName(url) {
            return /^(localhost$|127\.)/i.test(url)
        }
        var extractProxyAppId = function() {
                return location.pathname.split("/")[1]
            };
        var formatProxyUrl = function(localUrl) {
                var urlData = DX.parseUrl(localUrl);
                if (!isLocalHostName(urlData.hostname))
                    return localUrl;
                return "http://" + DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port + urlData.pathname + urlData.search
            };
        var EndpointSelector = DX.EndpointSelector = function(config) {
                this.config = config
            };
        EndpointSelector.prototype = {urlFor: function(key) {
                var bag = this.config[key];
                if (!bag)
                    throw Error("Unknown endpoint key");
                if (IS_DXPROXY)
                    return formatProxyUrl(bag.local);
                if (bag.production)
                    if (WIN_JS && !Debug.debuggerEnabled || !WIN_JS && !IS_LOCAL)
                        return bag.production;
                return bag.local
            }}
    })(jQuery, DevExpress);
    /*! Module core, file formatHelper.js */
    (function($, DX, undefined) {
        var utils = DX.utils;
        DX.NumericFormat = {
            currency: 'C',
            fixedpoint: 'N',
            exponential: '',
            percent: 'P',
            decimal: 'D'
        };
        DX.LargeNumberFormatPostfixes = {
            1: 'K',
            2: 'M',
            3: 'B',
            4: 'T'
        };
        var MAX_LARGE_NUMBER_POWER = 4,
            DECIMAL_BASE = 10;
        DX.LargeNumberFormatPowers = {
            largenumber: 'auto',
            thousands: 1,
            millions: 2,
            billions: 3,
            trillions: 4
        };
        DX.DateTimeFormat = {
            longdate: 'D',
            longtime: 'T',
            monthandday: 'M',
            monthandyear: 'Y',
            quarterandyear: 'qq',
            shortdate: 'd',
            shorttime: 't',
            millisecond: 'fff',
            second: 'T',
            minute: 't',
            hour: 't',
            day: 'dd',
            week: 'dd',
            month: 'MMMM',
            quarter: 'qq',
            year: 'yyyy',
            longdatelongtime: 'D',
            shortdateshorttime: 'd'
        };
        DX.formatHelper = {
            romanDigits: ['I', 'II', 'III', 'IV'],
            _addFormatSeparator: function(format1, format2) {
                var separator = ' ';
                if (format2)
                    return format1 + separator + format2;
                return format1
            },
            _getDateTimeFormatPattern: function(dateTimeFormat) {
                return Globalize.findClosestCulture().calendar.patterns[DX.DateTimeFormat[dateTimeFormat.toLowerCase()]]
            },
            _isDateFormatContains: function(format) {
                var result = false;
                $.each(DX.DateTimeFormat, function(key, value) {
                    result = key === format.toLowerCase();
                    return !result
                });
                return result
            },
            getQuarter: function(month) {
                return Math.floor(month / 3)
            },
            getQuarterString: function(date, format) {
                var resultQuarter = '',
                    quarter = this.getQuarter(date.getMonth());
                switch (format) {
                    case'q':
                        resultQuarter = this.romanDigits[quarter];
                        break;
                    case'qq':
                        resultQuarter = 'Q' + this.romanDigits[quarter];
                        break;
                    case'Q':
                        resultQuarter = (quarter + 1).toString();
                        break;
                    case'QQ':
                        resultQuarter = 'Q' + (quarter + 1).toString();
                        break
                }
                return resultQuarter
            },
            getFirstQuarterMonth: function(month) {
                return this.getQuarter(month) * 3
            },
            _formatCustomString: function(value, format) {
                var regExp = /qq|q|QQ|Q/g,
                    quarterFormat,
                    result = '',
                    index = 0;
                while (index < format.length) {
                    quarterFormat = regExp.exec(format);
                    if (!quarterFormat || quarterFormat.index > index)
                        result += Globalize.format(value, format.substring(index, quarterFormat ? quarterFormat.index : format.length));
                    if (quarterFormat) {
                        result += this.getQuarterString(value, quarterFormat[0]);
                        index = quarterFormat.index + quarterFormat[0].length
                    }
                    else
                        index = format.length
                }
                return result
            },
            _parseNumberFormatString: function(format) {
                var formatList,
                    formatObject = {};
                if (!format || typeof format !== 'string')
                    return;
                formatList = format.toLowerCase().split(' ');
                $.each(formatList, function(index, value) {
                    if (value in DX.NumericFormat)
                        formatObject.formatType = value;
                    else if (value in DX.LargeNumberFormatPowers)
                        formatObject.power = DX.LargeNumberFormatPowers[value]
                });
                if (formatObject.power && !formatObject.formatType)
                    formatObject.formatType = 'fixedpoint';
                if (formatObject.formatType)
                    return formatObject
            },
            _calculateNumberPower: function(value, base, minPower, maxPower) {
                var number = Math.abs(value);
                var power = 0;
                if (number > 1)
                    while (number && number >= base && (maxPower === undefined || power < maxPower)) {
                        power++;
                        number = number / base
                    }
                else if (number > 0 && number < 1)
                    while (number < 1 && (minPower === undefined || power > minPower)) {
                        power--;
                        number = number * base
                    }
                return power
            },
            _getNumberByPower: function(number, power, base) {
                var result = number;
                while (power > 0) {
                    result = result / base;
                    power--
                }
                while (power < 0) {
                    result = result * base;
                    power++
                }
                return result
            },
            _formatNumber: function(value, formatObject, precision) {
                var powerPostfix;
                if (formatObject.power === 'auto')
                    formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
                if (formatObject.power)
                    value = this._getNumberByPower(value, formatObject.power, 1000);
                powerPostfix = DX.LargeNumberFormatPostfixes[formatObject.power] || '';
                return this._formatNumberCore(value, formatObject.formatType, precision) + powerPostfix
            },
            _formatNumberExponential: function(value, precision) {
                var power = this._calculateNumberPower(value, DECIMAL_BASE),
                    number = this._getNumberByPower(value, power, DECIMAL_BASE),
                    powString;
                precision = precision === undefined ? 1 : precision;
                if (number.toFixed(precision || 0) >= DECIMAL_BASE) {
                    power++;
                    number = number / DECIMAL_BASE
                }
                powString = (power >= 0 ? '+' : '') + power.toString();
                return this._formatNumberCore(number, 'fixedpoint', precision) + 'E' + powString
            },
            _formatNumberCore: function(value, format, precision) {
                if (format === 'exponential')
                    return this._formatNumberExponential(value, precision);
                else
                    return Globalize.format(value, DX.NumericFormat[format] + (utils.isNumber(precision) ? precision : 0))
            },
            _formatDate: function(date, format, formatString) {
                var resultFormat = DX.DateTimeFormat[format.toLowerCase()];
                format = format.toLowerCase();
                if (format === 'quarterandyear')
                    resultFormat = this.getQuarterString(date, resultFormat) + ' yyyy';
                if (format === 'quarter')
                    return this.getQuarterString(date, resultFormat);
                if (format === 'longdatelongtime')
                    return this._formatDate(date, 'longdate') + ' ' + this._formatDate(date, 'longtime');
                if (format === 'shortdateshorttime')
                    return this._formatDate(date, 'shortDate') + ' ' + this._formatDate(date, 'shortTime');
                return Globalize.format(date, resultFormat)
            },
            format: function(value, format, precision) {
                if (format && format.format)
                    if (format.dateType)
                        return this._formatDateEx(value, format);
                    else if (utils.isNumber(value) && isFinite(value))
                        return this._formatNumberEx(value, format);
                return this._format(value, format, precision)
            },
            _format: function(value, format, precision) {
                var numberFormatObject;
                if (!utils.isString(format) || format === '' || !utils.isNumber(value) && !utils.isDate(value))
                    return utils.isDefined(value) ? value.toString() : '';
                numberFormatObject = this._parseNumberFormatString(format);
                if (utils.isNumber(value) && numberFormatObject)
                    return this._formatNumber(value, numberFormatObject, precision);
                if (utils.isDate(value) && this._isDateFormatContains(format))
                    return this._formatDate(value, format);
                if (!numberFormatObject && !this._isDateFormatContains(format))
                    return this._formatCustomString(value, format)
            },
            _formatNumberEx: function(value, formatInfo) {
                var self = this,
                    numericFormatType = DX.NumericFormat[formatInfo.format.toLowerCase()],
                    numberFormat = Globalize.culture().numberFormat,
                    currencyFormat = formatInfo.currencyCulture && Globalize.cultures[formatInfo.currencyCulture] ? Globalize.cultures[formatInfo.currencyCulture].numberFormat.currency : numberFormat.currency,
                    percentFormat = numberFormat.percent,
                    formatSettings = self._getUnitFormatSettings(value, formatInfo),
                    unit = formatSettings.unit,
                    precision = formatSettings.precision,
                    showTrailingZeros = formatSettings.showTrailingZeros,
                    includeGroupSeparator = formatSettings.includeGroupSeparator,
                    groupSymbol = numberFormat[","],
                    floatingSymbol = numberFormat["."],
                    number,
                    isNegative,
                    pattern,
                    currentFormat,
                    regexParts = /n|\$|-|%/g,
                    result = "";
                value = self._applyUnitToValue(value, unit);
                number = Math.abs(value);
                isNegative = value < 0;
                switch (numericFormatType) {
                    case"D":
                        pattern = "n";
                        number = Math[isNegative ? "ceil" : "floor"](number);
                        if (precision > 0) {
                            var str = "" + number;
                            for (var i = str.length; i < precision; i += 1)
                                str = "0" + str;
                            number = str
                        }
                        if (isNegative)
                            number = "-" + number;
                        break;
                    case"N":
                        currentFormat = numberFormat;
                    case"C":
                        currentFormat = currentFormat || currencyFormat;
                    case"P":
                        currentFormat = currentFormat || percentFormat;
                        pattern = isNegative ? currentFormat.pattern[0] : currentFormat.pattern[1] || "n";
                        number = Globalize.format(number * (numericFormatType === "P" ? 100 : 1), "N" + precision);
                        if (!showTrailingZeros)
                            number = self._excludeTrailingZeros(number, floatingSymbol);
                        if (!includeGroupSeparator)
                            number = number.replace(new RegExp('\\' + groupSymbol, 'g'), '');
                        break;
                    default:
                        throw"Illegal numeric format: '" + numericFormatType + "'";
                }
                for (; ; ) {
                    var lastIndex = regexParts.lastIndex,
                        matches = regexParts.exec(pattern);
                    result += pattern.slice(lastIndex, matches ? matches.index : pattern.length);
                    if (matches)
                        switch (matches[0]) {
                            case"-":
                                if (/[1-9]/.test(number))
                                    result += numberFormat["-"];
                                break;
                            case"$":
                                result += currencyFormat.symbol;
                                break;
                            case"%":
                                result += percentFormat.symbol;
                                break;
                            case"n":
                                result += number + unit;
                                break
                        }
                    else
                        break
                }
                return (formatInfo.plus && value > 0 ? "+" : '') + result
            },
            _excludeTrailingZeros: function(strValue, floatingSymbol) {
                var floatingIndex = strValue.indexOf(floatingSymbol),
                    stopIndex,
                    i;
                if (floatingIndex < 0)
                    return strValue;
                stopIndex = strValue.length;
                for (i = stopIndex - 1; i >= floatingIndex && (strValue[i] === '0' || i === floatingIndex); i--)
                    stopIndex--;
                return strValue.substring(0, stopIndex)
            },
            _getUnitFormatSettings: function(value, formatInfo) {
                var unit = formatInfo.unit || '',
                    precision = formatInfo.precision || 0,
                    includeGroupSeparator = formatInfo.includeGroupSeparator || false,
                    showTrailingZeros = formatInfo.showTrailingZeros === undefined ? true : formatInfo.showTrailingZeros,
                    significantDigits = formatInfo.significantDigits || 1,
                    absValue;
                if (unit.toLowerCase() === 'auto') {
                    showTrailingZeros = false;
                    absValue = Math.abs(value);
                    if (significantDigits < 1)
                        significantDigits = 1;
                    if (absValue >= 1000000000) {
                        unit = 'B';
                        absValue /= 1000000000
                    }
                    else if (absValue >= 1000000) {
                        unit = 'M';
                        absValue /= 1000000
                    }
                    else if (absValue >= 1000) {
                        unit = 'K';
                        absValue /= 1000
                    }
                    else
                        unit = '';
                    if (absValue == 0)
                        precision = 0;
                    else if (absValue < 1) {
                        precision = significantDigits;
                        var smallValue = Math.pow(10, -significantDigits);
                        while (absValue < smallValue) {
                            smallValue /= 10;
                            precision++
                        }
                    }
                    else if (absValue >= 100)
                        precision = significantDigits - 3;
                    else if (absValue >= 10)
                        precision = significantDigits - 2;
                    else
                        precision = significantDigits - 1
                }
                if (precision < 0)
                    precision = 0;
                return {
                        unit: unit,
                        precision: precision,
                        showTrailingZeros: showTrailingZeros,
                        includeGroupSeparator: includeGroupSeparator
                    }
            },
            _applyUnitToValue: function(value, unit) {
                if (unit == 'B')
                    return value.toFixed(1) / 1000000000;
                if (unit == 'M')
                    return value / 1000000;
                if (unit == 'K')
                    return value / 1000;
                return value
            },
            _formatDateEx: function(value, formatInfo) {
                var self = this,
                    quarterPrefix = 'Q',
                    format = formatInfo.format,
                    dateType = formatInfo.dateType,
                    calendar = Globalize.culture().calendars.standard,
                    time = undefined,
                    index,
                    dateStr;
                format = format.toLowerCase();
                if (dateType !== 'num' || format === 'dayofweek')
                    switch (format) {
                        case'monthyear':
                            return self._formatDate(value, 'monthandyear');
                        case'quarteryear':
                            return self.getQuarterString(value, 'QQ') + ' ' + value.getFullYear();
                        case'daymonthyear':
                            return self._formatDate(value, dateType + 'Date');
                        case'datehour':
                            time = new Date(value.getTime());
                            time.setMinutes(0);
                            dateStr = dateType === 'timeOnly' ? '' : self._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? self._formatDate(time, 'shorttime') : dateStr + ' ' + self._formatDate(time, 'shorttime');
                        case'datehourminute':
                            dateStr = dateType === 'timeOnly' ? '' : self._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? self._formatDate(value, 'shorttime') : dateStr + ' ' + self._formatDate(value, 'shorttime');
                        case'datehourminutesecond':
                            dateStr = dateType === 'timeOnly' ? '' : self._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? self._formatDate(value, 'longtime') : dateStr + ' ' + self._formatDate(value, 'longtime');
                        case'year':
                            dateStr = value.toString();
                            return dateType === 'abbr' ? dateStr.slice(2, 4) : dateStr;
                        case'quarter':
                            return quarterPrefix + value.toString();
                        case'month':
                            index = value - 1;
                            return dateType === 'abbr' ? calendar.months.namesAbbr[index] : calendar.months.names[index];
                        case'hour':
                            if (dateType === 'long') {
                                time = new Date;
                                time.setHours(value);
                                time.setMinutes(0);
                                return self._formatDate(time, 'shorttime')
                            }
                            else
                                return value.toString();
                        case'dayofweek':
                            index = $.inArray(value, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']);
                            if (dateType !== 'num')
                                return dateType === 'abbr' ? calendar.days.namesAbbr[index] : calendar.days.names[index];
                            else
                                return ((index - calendar.firstDay + 1 + 7) % 8).toString();
                        default:
                            return value.toString()
                    }
                else
                    return value.toString()
            },
            getTimeFormat: function(showSecond) {
                if (showSecond)
                    return this._getDateTimeFormatPattern('longtime');
                return this._getDateTimeFormatPattern('shorttime')
            },
            getDateFormatByDifferences: function(dateDifferences) {
                var resultFormat = '';
                if (dateDifferences.millisecond)
                    resultFormat = DX.DateTimeFormat.millisecond;
                if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second)
                    resultFormat = this._addFormatSeparator(this.getTimeFormat(dateDifferences.second), resultFormat);
                if (dateDifferences.year && dateDifferences.month && dateDifferences.day)
                    return this._addFormatSeparator(this._getDateTimeFormatPattern('shortdate'), resultFormat);
                if (dateDifferences.year && dateDifferences.month)
                    return DX.DateTimeFormat['monthandyear'];
                if (dateDifferences.year)
                    return DX.DateTimeFormat['year'];
                if (dateDifferences.month && dateDifferences.day)
                    return this._addFormatSeparator(this._getDateTimeFormatPattern('monthandday'), resultFormat);
                if (dateDifferences.month)
                    return DX.DateTimeFormat['month'];
                if (dateDifferences.day)
                    return this._addFormatSeparator('dddd, dd', resultFormat);
                return resultFormat
            },
            getDateFormatByTicks: function(ticks) {
                var resultFormat,
                    maxDif,
                    currentDif,
                    i,
                    dateUnitInterval;
                if (ticks.length > 1) {
                    maxDif = utils.getDatesDifferences(ticks[0], ticks[1]);
                    for (i = 1; i < ticks.length - 1; i++) {
                        currentDif = utils.getDatesDifferences(ticks[i], ticks[i + 1]);
                        if (maxDif.count < currentDif.count)
                            maxDif = currentDif
                    }
                }
                else
                    maxDif = {
                        year: true,
                        month: true,
                        day: true,
                        hour: ticks[0].getHours() > 0,
                        minute: ticks[0].getMinutes() > 0,
                        second: ticks[0].getSeconds() > 0
                    };
                resultFormat = this.getDateFormatByDifferences(maxDif);
                return resultFormat
            },
            getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
                var resultFormat,
                    dateDifferences,
                    dateUnitInterval,
                    dateDifferencesConverter = {
                        quarter: 'month',
                        week: 'day'
                    },
                    correctDateDifferences = function(dateDifferences, tickInterval, value) {
                        switch (tickInterval) {
                            case'year':
                                dateDifferences.month = value;
                            case'quarter':
                            case'month':
                                dateDifferences.day = value;
                            case'week':
                            case'day':
                                dateDifferences.hour = value;
                            case'hour':
                                dateDifferences.minute = value;
                            case'minute':
                                dateDifferences.second = value;
                            case'second':
                                dateDifferences.millisecond = value
                        }
                    },
                    correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                        if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                            if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                                differences.millisecond = true;
                                differences.second = false
                            }
                        }
                        else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                            if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                                differences.second = true;
                                differences.minute = false
                            }
                        }
                        else if (!maxDate.getMinutes() && maxDate.getHours()) {
                            if (maxDate.getHours() - minDate.getHours() === 1) {
                                differences.minute = true;
                                differences.hour = false
                            }
                        }
                        else if (!maxDate.getHours() && maxDate.getDate() > 1) {
                            if (maxDate.getDate() - minDate.getDate() === 1) {
                                differences.hour = true;
                                differences.day = false
                            }
                        }
                        else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
                            if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                differences.day = true;
                                differences.month = false
                            }
                        }
                        else if (!maxDate.getMonth() && maxDate.getFullYear())
                            if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                differences.month = true;
                                differences.year = false
                            }
                    };
                tickInterval = utils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
                dateDifferences = utils.getDatesDifferences(startValue, endValue);
                if (startValue !== endValue)
                    correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
                dateUnitInterval = utils.getDateUnitInterval(dateDifferences);
                correctDateDifferences(dateDifferences, dateUnitInterval, true);
                dateUnitInterval = utils.getDateUnitInterval(tickInterval || 'second');
                correctDateDifferences(dateDifferences, dateUnitInterval, false);
                dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
                resultFormat = this.getDateFormatByDifferences(dateDifferences);
                return resultFormat
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file color.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        DX.Color = Class.inherit(function() {
            var ctor = function(baseColor) {
                    this.baseColor = baseColor;
                    this.decode()
                };
            var standardColorNames = {
                    aliceblue: 'f0f8ff',
                    antiquewhite: 'faebd7',
                    aqua: '00ffff',
                    aquamarine: '7fffd4',
                    azure: 'f0ffff',
                    beige: 'f5f5dc',
                    bisque: 'ffe4c4',
                    black: '000000',
                    blanchedalmond: 'ffebcd',
                    blue: '0000ff',
                    blueviolet: '8a2be2',
                    brown: 'a52a2a',
                    burlywood: 'deb887',
                    cadetblue: '5f9ea0',
                    chartreuse: '7fff00',
                    chocolate: 'd2691e',
                    coral: 'ff7f50',
                    cornflowerblue: '6495ed',
                    cornsilk: 'fff8dc',
                    crimson: 'dc143c',
                    cyan: '00ffff',
                    darkblue: '00008b',
                    darkcyan: '008b8b',
                    darkgoldenrod: 'b8860b',
                    darkgray: 'a9a9a9',
                    darkgreen: '006400',
                    darkkhaki: 'bdb76b',
                    darkmagenta: '8b008b',
                    darkolivegreen: '556b2f',
                    darkorange: 'ff8c00',
                    darkorchid: '9932cc',
                    darkred: '8b0000',
                    darksalmon: 'e9967a',
                    darkseagreen: '8fbc8f',
                    darkslateblue: '483d8b',
                    darkslategray: '2f4f4f',
                    darkturquoise: '00ced1',
                    darkviolet: '9400d3',
                    deeppink: 'ff1493',
                    deepskyblue: '00bfff',
                    dimgray: '696969',
                    dodgerblue: '1e90ff',
                    feldspar: 'd19275',
                    firebrick: 'b22222',
                    floralwhite: 'fffaf0',
                    forestgreen: '228b22',
                    fuchsia: 'ff00ff',
                    gainsboro: 'dcdcdc',
                    ghostwhite: 'f8f8ff',
                    gold: 'ffd700',
                    goldenrod: 'daa520',
                    gray: '808080',
                    green: '008000',
                    greenyellow: 'adff2f',
                    honeydew: 'f0fff0',
                    hotpink: 'ff69b4',
                    indianred: 'cd5c5c',
                    indigo: '4b0082',
                    ivory: 'fffff0',
                    khaki: 'f0e68c',
                    lavender: 'e6e6fa',
                    lavenderblush: 'fff0f5',
                    lawngreen: '7cfc00',
                    lemonchiffon: 'fffacd',
                    lightblue: 'add8e6',
                    lightcoral: 'f08080',
                    lightcyan: 'e0ffff',
                    lightgoldenrodyellow: 'fafad2',
                    lightgrey: 'd3d3d3',
                    lightgreen: '90ee90',
                    lightpink: 'ffb6c1',
                    lightsalmon: 'ffa07a',
                    lightseagreen: '20b2aa',
                    lightskyblue: '87cefa',
                    lightslateblue: '8470ff',
                    lightslategray: '778899',
                    lightsteelblue: 'b0c4de',
                    lightyellow: 'ffffe0',
                    lime: '00ff00',
                    limegreen: '32cd32',
                    linen: 'faf0e6',
                    magenta: 'ff00ff',
                    maroon: '800000',
                    mediumaquamarine: '66cdaa',
                    mediumblue: '0000cd',
                    mediumorchid: 'ba55d3',
                    mediumpurple: '9370d8',
                    mediumseagreen: '3cb371',
                    mediumslateblue: '7b68ee',
                    mediumspringgreen: '00fa9a',
                    mediumturquoise: '48d1cc',
                    mediumvioletred: 'c71585',
                    midnightblue: '191970',
                    mintcream: 'f5fffa',
                    mistyrose: 'ffe4e1',
                    moccasin: 'ffe4b5',
                    navajowhite: 'ffdead',
                    navy: '000080',
                    oldlace: 'fdf5e6',
                    olive: '808000',
                    olivedrab: '6b8e23',
                    orange: 'ffa500',
                    orangered: 'ff4500',
                    orchid: 'da70d6',
                    palegoldenrod: 'eee8aa',
                    palegreen: '98fb98',
                    paleturquoise: 'afeeee',
                    palevioletred: 'd87093',
                    papayawhip: 'ffefd5',
                    peachpuff: 'ffdab9',
                    peru: 'cd853f',
                    pink: 'ffc0cb',
                    plum: 'dda0dd',
                    powderblue: 'b0e0e6',
                    purple: '800080',
                    red: 'ff0000',
                    rosybrown: 'bc8f8f',
                    royalblue: '4169e1',
                    saddlebrown: '8b4513',
                    salmon: 'fa8072',
                    sandybrown: 'f4a460',
                    seagreen: '2e8b57',
                    seashell: 'fff5ee',
                    sienna: 'a0522d',
                    silver: 'c0c0c0',
                    skyblue: '87ceeb',
                    slateblue: '6a5acd',
                    slategray: '708090',
                    snow: 'fffafa',
                    springgreen: '00ff7f',
                    steelblue: '4682b4',
                    tan: 'd2b48c',
                    teal: '008080',
                    thistle: 'd8bfd8',
                    tomato: 'ff6347',
                    turquoise: '40e0d0',
                    violet: 'ee82ee',
                    violetred: 'd02090',
                    wheat: 'f5deb3',
                    white: 'ffffff',
                    whitesmoke: 'f5f5f5',
                    yellow: 'ffff00',
                    yellowgreen: '9acd32'
                };
            var standardColorTypes = [{
                        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                        process: function(colorString) {
                            return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
                        }
                    }, {
                        re: /^(\w{2})(\w{2})(\w{2})$/,
                        process: function(colorString) {
                            return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
                        }
                    }, {
                        re: /^(\w{1})(\w{1})(\w{1})$/,
                        process: function(colorString) {
                            return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
                        }
                    }];
            var decode = function() {
                    var baseColor = this.baseColor;
                    if (baseColor.charAt(0) === '#')
                        baseColor = baseColor.substr(1, 6);
                    baseColor = baseColor.toLowerCase();
                    baseColor = baseColor.replace(/ /g, '');
                    for (var standardColor in standardColorNames)
                        if (standardColorNames.hasOwnProperty(standardColor))
                            if (baseColor === standardColor)
                                baseColor = standardColorNames[standardColor];
                    for (var i = 0; i < standardColorTypes.length; i++) {
                        var re = standardColorTypes[i].re;
                        var colorString = re.exec(baseColor);
                        if (colorString) {
                            var colorRgb = standardColorTypes[i].process(colorString);
                            this.r = colorRgb[0];
                            this.g = colorRgb[1];
                            this.b = colorRgb[2];
                            this.ok = true;
                            break
                        }
                    }
                    this.r = normalize(this.r);
                    this.g = normalize(this.g);
                    this.b = normalize(this.b)
                };
            var normalize = function(colorComponent) {
                    return colorComponent < 0 || isNaN(colorComponent) ? 0 : colorComponent > 255 ? 255 : colorComponent
                };
            var digitToHex = function(n) {
                    var st = n.toString(16);
                    if (st.length === 1)
                        return '0' + st;
                    return st
                };
            var toHexFromRgb = function(r, g, b) {
                    return '#' + digitToHex(r) + digitToHex(g) + digitToHex(b)
                };
            var toHex = function() {
                    return toHexFromRgb(this.r, this.g, this.b)
                };
            var highlight = function(step) {
                    step = step || 10;
                    return toHexFromRgb(normalize(this.r + step), normalize(this.g + step), normalize(this.b + step))
                };
            var darken = function(step) {
                    step = step || 10;
                    return toHexFromRgb(normalize(this.r - step), normalize(this.g - step), normalize(this.b - step))
                };
            return {
                    ctor: ctor,
                    highlight: highlight,
                    darken: darken,
                    decode: decode,
                    toHex: toHex
                }
        }())
    })(jQuery, DevExpress);
    /*! Module core, file data.js */
    (function($, DX, undefined) {
        var HAS_KO = !!window.ko;
        var bracketsToDots = function(expr) {
                return expr.replace(/\[/g, ".").replace(/\]/g, "")
            };
        var unwrapObservable = function(value) {
                if (HAS_KO)
                    return ko.utils.unwrapObservable(value);
                return value
            };
        var isObservable = function(value) {
                return HAS_KO && ko.isObservable(value)
            };
        var assign = function(obj, propName, value) {
                var propValue = obj[propName];
                if (isObservable(propValue))
                    propValue(value);
                else
                    obj[propName] = value
            };
        var compileGetter = function(expr) {
                if (arguments.length > 1)
                    expr = $.makeArray(arguments);
                if (!expr || expr === "this")
                    return function(obj) {
                            return obj
                        };
                if ($.isFunction(expr))
                    return expr;
                if ($.isArray(expr))
                    return combineGetters(expr);
                expr = bracketsToDots(expr);
                var path = expr.split(".");
                return function(obj, options) {
                        options = options || {};
                        var current = unwrapObservable(obj);
                        $.each(path, function() {
                            if (!current)
                                return false;
                            var next = unwrapObservable(current[this]);
                            if ($.isFunction(next) && !options.functionsAsIs)
                                next = next.call(current);
                            current = next
                        });
                        return current
                    }
            };
        var combineGetters = function(getters) {
                var compiledGetters = {};
                $.each(getters, function() {
                    compiledGetters[this] = compileGetter(this)
                });
                return function(obj) {
                        var result = {};
                        $.each(compiledGetters, function(name) {
                            var value = this(obj),
                                current,
                                path,
                                last,
                                i;
                            if (value === undefined)
                                return;
                            current = result;
                            path = name.split(".");
                            last = path.length - 1;
                            for (i = 0; i < last; i++)
                                current = current[path[i]] = {};
                            current[path[i]] = value
                        });
                        return result
                    }
            };
        var compileSetter = function(expr) {
                if (!expr || expr === "this")
                    throw Error("Cannot assign to self");
                expr = bracketsToDots(expr);
                var pos = expr.lastIndexOf("."),
                    targetGetter = compileGetter(expr.substr(0, pos)),
                    targetExpr = expr.substr(1 + pos);
                return function(obj, value, options) {
                        options = options || {};
                        var target = targetGetter(obj, {functionsAsIs: options.functionsAsIs}),
                            prevTargetValue = target[targetExpr];
                        if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isObservable(prevTargetValue))
                            target[targetExpr](value);
                        else {
                            prevTargetValue = unwrapObservable(prevTargetValue);
                            if (options.merge && $.isPlainObject(value) && (prevTargetValue === undefined || $.isPlainObject(prevTargetValue))) {
                                if (!prevTargetValue)
                                    assign(target, targetExpr, {});
                                $.extend(true, unwrapObservable(target[targetExpr]), value)
                            }
                            else
                                assign(target, targetExpr, value)
                        }
                    }
            };
        var normalizeBinaryCriterion = function(crit) {
                return [crit[0], crit.length < 3 ? "=" : crit[1].toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
            };
        var normalizeSortingInfo = function(info) {
                if (!$.isArray(info))
                    info = [info];
                return $.map(info, function(i) {
                        return {
                                selector: $.isFunction(i) || typeof i === "string" ? i : i.field || i.selector,
                                desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === "d")
                            }
                    })
            };
        var Guid = DX.Class.inherit({
                ctor: function(value) {
                    if (value)
                        value = String(value);
                    this._value = this._normalize(value || this._generate())
                },
                _normalize: function(value) {
                    value = value.replace(/[^a-f0-9]/ig, "").toLowerCase();
                    while (value.length < 32)
                        value += "0";
                    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20)].join("-")
                },
                _generate: function() {
                    var value = "";
                    for (var i = 0; i < 32; i++)
                        value += Math.round(Math.random() * 16).toString(16);
                    return value
                },
                toString: function() {
                    return this._value
                },
                valueOf: function() {
                    return this._value
                },
                toJSON: function() {
                    return this._value
                }
            });
        var toComparable = function(value, caseSensitive) {
                if (value instanceof Date)
                    return value.getTime();
                if (value instanceof Guid)
                    return value.valueOf();
                if (!caseSensitive && typeof value === "string")
                    return value.toLowerCase();
                return value
            };
        var keysEqual = function(keyExpr, key1, key2) {
                if ($.isArray(keyExpr)) {
                    var names = $.map(key1, function(v, k) {
                            return k
                        }),
                        name;
                    for (var i = 0; i < names.length; i++) {
                        name = names[i];
                        if (toComparable(key1[name], true) != toComparable(key2[name], true))
                            return false
                    }
                    return true
                }
                return toComparable(key1, true) == toComparable(key2, true)
            };
        var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var base64_encode = function(input) {
                if (!$.isArray(input))
                    input = stringToByteArray(String(input));
                var result = "";
                for (var i = 0; i < input.length; i += 3) {
                    var octet1 = input[i],
                        octet2 = input[i + 1],
                        octet3 = input[i + 2];
                    result += $.map([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], function(item) {
                        return BASE64_CHARS.charAt(item)
                    }).join("")
                }
                return result
            };
        var stringToByteArray = function(str) {
                var bytes = [],
                    code,
                    i;
                for (i = 0; i < str.length; i++) {
                    code = str.charCodeAt(i);
                    if (code < 128)
                        bytes.push(code);
                    else if (code < 2048)
                        bytes.push(192 + (code >> 6), 128 + (code & 63));
                    else if (code < 65536)
                        bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
                    else if (code < 2097152)
                        bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63))
                }
                return bytes
            };
        var errorMessageFromXhr = function() {
                var textStatusMessages = {
                        timeout: "Network connection timeout",
                        error: "Unspecified network error",
                        parsererror: "Unexpected server response"
                    };
                var textStatusDetails = {
                        timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                        error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                        parsererror: "the remote host did not respond with valid JSON data"
                    };
                var explainTextStatus = function(textStatus) {
                        var result = textStatusMessages[textStatus];
                        if (!result)
                            return textStatus;
                        result += " (" + textStatusDetails[textStatus] + ")";
                        return result
                    };
                return function(xhr, textStatus) {
                        if (xhr.status < 400)
                            return explainTextStatus(textStatus);
                        return xhr.statusText
                    }
            }();
        var data = DX.data = {
                utils: {
                    compileGetter: compileGetter,
                    compileSetter: compileSetter,
                    normalizeBinaryCriterion: normalizeBinaryCriterion,
                    normalizeSortingInfo: normalizeSortingInfo,
                    toComparable: toComparable,
                    keysEqual: keysEqual,
                    errorMessageFromXhr: errorMessageFromXhr
                },
                Guid: Guid,
                base64_encode: base64_encode,
                queryImpl: {},
                queryAdapters: {},
                query: function() {
                    var impl = $.isArray(arguments[0]) ? "array" : "remote";
                    return data.queryImpl[impl].apply(this, arguments)
                },
                errorHandler: null,
                _handleError: function(error) {
                    if (window.console)
                        console.warn("[DevExpress.data]: " + error);
                    if (data.errorHandler)
                        data.errorHandler(error)
                }
            }
    })(jQuery, DevExpress);
    /*! Module core, file data.query.array.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            data = DX.data,
            queryImpl = data.queryImpl,
            compileGetter = data.utils.compileGetter,
            toComparable = data.utils.toComparable;
        var Iterator = Class.inherit({
                toArray: function() {
                    var result = [];
                    this.reset();
                    while (this.next())
                        result.push(this.current());
                    return result
                },
                countable: function() {
                    return false
                }
            });
        var ArrayIterator = Iterator.inherit({
                ctor: function(array) {
                    this.array = array;
                    this.index = -1
                },
                next: function() {
                    if (this.index + 1 < this.array.length) {
                        this.index++;
                        return true
                    }
                    return false
                },
                current: function() {
                    return this.array[this.index]
                },
                reset: function() {
                    this.index = -1
                },
                toArray: function() {
                    return this.array.slice(0)
                },
                countable: function() {
                    return true
                },
                count: function() {
                    return this.array.length
                }
            });
        var WrappedIterator = Iterator.inherit({
                ctor: function(iter) {
                    this.iter = iter
                },
                next: function() {
                    return this.iter.next()
                },
                current: function() {
                    return this.iter.current()
                },
                reset: function() {
                    return this.iter.reset()
                }
            });
        var SortIterator = Iterator.inherit({
                ctor: function(iter, getter, desc) {
                    this.iter = iter;
                    this.rules = [{
                            getter: getter,
                            desc: desc
                        }]
                },
                thenBy: function(getter, desc) {
                    var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
                    if (!this.sortedIter)
                        result.rules = this.rules.concat(result.rules);
                    return result
                },
                next: function() {
                    this._ensureSorted();
                    return this.sortedIter.next()
                },
                current: function() {
                    this._ensureSorted();
                    return this.sortedIter.current()
                },
                reset: function() {
                    delete this.sortedIter
                },
                countable: function() {
                    return this.sortedIter || this.iter.countable()
                },
                count: function() {
                    if (this.sortedIter)
                        return this.sortedIter.count();
                    return this.iter.count()
                },
                _ensureSorted: function() {
                    if (this.sortedIter)
                        return;
                    $.each(this.rules, function() {
                        this.getter = compileGetter(this.getter)
                    });
                    this.sortedIter = new ArrayIterator(this.iter.toArray().sort($.proxy(this._compare, this)))
                },
                _compare: function(x, y) {
                    if (x === y)
                        return 0;
                    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                        var rule = this.rules[i],
                            xValue = toComparable(rule.getter(x)),
                            yValue = toComparable(rule.getter(y)),
                            factor = rule.desc ? -1 : 1;
                        if (xValue < yValue)
                            return -factor;
                        if (xValue > yValue)
                            return factor;
                        if (xValue !== yValue)
                            return !xValue ? -factor : factor
                    }
                    return 0
                }
            });
        var compileCriteria = function() {
                var compileGroup = function(crit) {
                        var operands = [],
                            bag = ["return function(d) { return "],
                            index = 0,
                            pushAnd = false;
                        $.each(crit, function() {
                            if ($.isArray(this) || $.isFunction(this)) {
                                if (pushAnd)
                                    bag.push(" && ");
                                operands.push(compileCriteria(this));
                                bag.push("op[", index, "](d)");
                                index++;
                                pushAnd = true
                            }
                            else {
                                bag.push(/and|&/i.test(this) ? " && " : " || ");
                                pushAnd = false
                            }
                        });
                        bag.push(" }");
                        return new Function("op", bag.join(""))(operands)
                    };
                var toString = function(value) {
                        return DX.utils.isDefined(value) ? value.toString() : ''
                    };
                var compileBinary = function(crit) {
                        crit = data.utils.normalizeBinaryCriterion(crit);
                        var getter = compileGetter(crit[0]),
                            op = crit[1],
                            value = crit[2];
                        value = toComparable(value);
                        switch (op.toLowerCase()) {
                            case"=":
                                return function(obj) {
                                        return toComparable(getter(obj)) == value
                                    };
                            case"<>":
                                return function(obj) {
                                        return toComparable(getter(obj)) != value
                                    };
                            case">":
                                return function(obj) {
                                        return toComparable(getter(obj)) > value
                                    };
                            case"<":
                                return function(obj) {
                                        return toComparable(getter(obj)) < value
                                    };
                            case">=":
                                return function(obj) {
                                        return toComparable(getter(obj)) >= value
                                    };
                            case"<=":
                                return function(obj) {
                                        return toComparable(getter(obj)) <= value
                                    };
                            case"startswith":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === 0
                                    };
                            case"endswith":
                                return function(obj) {
                                        var getterValue = toComparable(toString(getter(obj)));
                                        return getterValue.lastIndexOf(value) === getterValue.length - toString(value).length
                                    };
                            case"contains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) > -1
                                    };
                            case"notcontains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === -1
                                    }
                        }
                    };
                return function(crit) {
                        if ($.isFunction(crit))
                            return crit;
                        if ($.isArray(crit[0]))
                            return compileGroup(crit);
                        return compileBinary(crit)
                    }
            }();
        var FilterIterator = WrappedIterator.inherit({
                ctor: function(iter, criteria) {
                    this.callBase(iter);
                    this.criteria = compileCriteria(criteria)
                },
                next: function() {
                    while (this.iter.next())
                        if (this.criteria(this.current()))
                            return true;
                    return false
                }
            });
        var GroupIterator = Iterator.inherit({
                ctor: function(iter, getter) {
                    this.iter = iter;
                    this.getter = getter
                },
                next: function() {
                    this._ensureGrouped();
                    return this.groupedIter.next()
                },
                current: function() {
                    this._ensureGrouped();
                    return this.groupedIter.current()
                },
                reset: function() {
                    delete this.groupedIter
                },
                countable: function() {
                    return !!this.groupedIter
                },
                count: function() {
                    return this.groupedIter.count()
                },
                _ensureGrouped: function() {
                    if (this.groupedIter)
                        return;
                    var hash = {},
                        keys = [],
                        iter = this.iter,
                        getter = compileGetter(this.getter);
                    iter.reset();
                    while (iter.next()) {
                        var current = iter.current(),
                            key = getter(current);
                        if (key in hash)
                            hash[key].push(current);
                        else {
                            hash[key] = [current];
                            keys.push(key)
                        }
                    }
                    this.groupedIter = new ArrayIterator($.map(keys, function(key) {
                        return {
                                key: key,
                                items: hash[key]
                            }
                    }))
                }
            });
        var SelectIterator = WrappedIterator.inherit({
                ctor: function(iter, getter) {
                    this.callBase(iter);
                    this.getter = compileGetter(getter)
                },
                current: function() {
                    return this.getter(this.callBase())
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return this.iter.count()
                }
            });
        var SliceIterator = WrappedIterator.inherit({
                ctor: function(iter, skip, take) {
                    this.callBase(iter);
                    this.skip = Math.max(0, skip);
                    this.take = Math.max(0, take);
                    this.pos = 0
                },
                next: function() {
                    if (this.pos >= this.skip + this.take)
                        return false;
                    while (this.pos < this.skip && this.iter.next())
                        this.pos++;
                    this.pos++;
                    return this.iter.next()
                },
                reset: function() {
                    this.callBase();
                    this.pos = 0
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return Math.min(this.iter.count() - this.skip, this.take)
                }
            });
        queryImpl.array = function(iter, queryOptions) {
            queryOptions = queryOptions || {};
            if (!(iter instanceof Iterator))
                iter = new ArrayIterator(iter);
            var handleError = function(error) {
                    var handler = queryOptions.errorHandler;
                    if (handler)
                        handler(error);
                    data._handleError(error)
                };
            var aggregate = function(seed, step, finalize) {
                    var d = $.Deferred().fail(handleError);
                    try {
                        iter.reset();
                        if (arguments.length < 2) {
                            step = arguments[0];
                            seed = iter.next() ? iter.current() : undefined
                        }
                        var accumulator = seed;
                        while (iter.next())
                            accumulator = step(accumulator, iter.current());
                        d.resolve(finalize ? finalize(accumulator) : accumulator)
                    }
                    catch(x) {
                        d.reject(x)
                    }
                    return d.promise()
                };
            var select = function(getter) {
                    if (!$.isFunction(getter) && !$.isArray(getter))
                        getter = $.makeArray(arguments);
                    return chainQuery(new SelectIterator(iter, getter))
                };
            var selectProp = function(name) {
                    return select(compileGetter(name))
                };
            var chainQuery = function(iter) {
                    return queryImpl.array(iter, queryOptions)
                };
            return {
                    toArray: function() {
                        return iter.toArray()
                    },
                    enumerate: function() {
                        var d = $.Deferred().fail(handleError);
                        try {
                            d.resolve(iter.toArray())
                        }
                        catch(x) {
                            d.reject(x)
                        }
                        return d.promise()
                    },
                    sortBy: function(getter, desc) {
                        return chainQuery(new SortIterator(iter, getter, desc))
                    },
                    thenBy: function(getter, desc) {
                        if (iter instanceof SortIterator)
                            return chainQuery(iter.thenBy(getter, desc));
                        throw Error();
                    },
                    filter: function(criteria) {
                        if (!$.isArray(criteria))
                            criteria = $.makeArray(arguments);
                        return chainQuery(new FilterIterator(iter, criteria))
                    },
                    slice: function(skip, take) {
                        if (take === undefined)
                            take = Number.MAX_VALUE;
                        return chainQuery(new SliceIterator(iter, skip, take))
                    },
                    select: select,
                    groupBy: function(getter, desc) {
                        return chainQuery(new GroupIterator(iter, getter, desc))
                    },
                    aggregate: aggregate,
                    count: function() {
                        if (iter.countable()) {
                            var d = $.Deferred().fail(handleError);
                            try {
                                d.resolve(iter.count())
                            }
                            catch(x) {
                                d.reject(x)
                            }
                            return d.promise()
                        }
                        return aggregate(0, function(count) {
                                return 1 + count
                            })
                    },
                    sum: function(getter) {
                        if (getter)
                            return selectProp(getter).sum();
                        return aggregate(0, function(sum, item) {
                                return sum + item
                            })
                    },
                    min: function(getter) {
                        if (getter)
                            return selectProp(getter).min();
                        return aggregate(function(min, item) {
                                return item < min ? item : min
                            })
                    },
                    max: function(getter) {
                        if (getter)
                            return selectProp(getter).max();
                        return aggregate(function(max, item) {
                                return item > max ? item : max
                            })
                    },
                    avg: function(getter) {
                        if (getter)
                            return selectProp(getter).avg();
                        var count = 0;
                        return aggregate(0, function(sum, item) {
                                count++;
                                return sum + item
                            }, function(sum) {
                                return count ? sum / count : undefined
                            })
                    }
                }
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.query.remote.js */
    (function($, DX, undefined) {
        var data = DX.data,
            queryImpl = data.queryImpl;
        queryImpl.remote = function(url, queryOptions, tasks) {
            tasks = tasks || [];
            queryOptions = queryOptions || {};
            var createTask = function(name, args) {
                    return {
                            name: name,
                            args: args
                        }
                };
            var exec = function(executorTask) {
                    var d = $.Deferred(),
                        adapterFactory,
                        adapter,
                        taskQueue,
                        currentTask;
                    var rejectWithNotify = function(error) {
                            var handler = queryOptions.errorHandler;
                            if (handler)
                                handler(error);
                            data._handleError(error);
                            d.reject(error)
                        };
                    try {
                        adapterFactory = queryOptions.adapter || "odata";
                        if (!$.isFunction(adapterFactory))
                            adapterFactory = data.queryAdapters[adapterFactory];
                        adapter = adapterFactory(queryOptions);
                        taskQueue = [].concat(tasks).concat(executorTask);
                        while (taskQueue.length) {
                            currentTask = taskQueue[0];
                            if (String(currentTask.name) !== "enumerate")
                                if (!adapter[currentTask.name] || adapter[currentTask.name].apply(adapter, currentTask.args) === false)
                                    break;
                            taskQueue.shift()
                        }
                        adapter.exec(url).done(function(result) {
                            if (!taskQueue.length)
                                d.resolve(result);
                            else {
                                var clientChain = queryImpl.array(result, {errorHandler: queryOptions.errorHandler});
                                $.each(taskQueue, function() {
                                    clientChain = clientChain[this.name].apply(clientChain, this.args)
                                });
                                clientChain.done($.proxy(d.resolve, d)).fail($.proxy(d.reject, d))
                            }
                        }).fail(rejectWithNotify)
                    }
                    catch(x) {
                        rejectWithNotify(x)
                    }
                    return d.promise()
                };
            var query = {};
            $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
                var name = this;
                query[name] = function() {
                    return queryImpl.remote(url, queryOptions, tasks.concat(createTask(name, arguments)))
                }
            });
            $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
                var name = this;
                query[name] = function() {
                    return exec.call(this, createTask(name, arguments))
                }
            });
            return query
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.odata.js */
    (function($, DX, undefined) {
        var data = DX.data,
            Guid = data.Guid;
        var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";
        var ajaxOptionsForRequest = function(request, requestOptions) {
                request = $.extend({
                    method: "get",
                    url: "",
                    params: {},
                    payload: null,
                    headers: {}
                }, request);
                requestOptions = requestOptions || {};
                var beforeSend = requestOptions.beforeSend;
                if (beforeSend)
                    beforeSend(request);
                var method = (request.method || "get").toLowerCase(),
                    isGet = method === "get",
                    useJsonp = isGet && requestOptions.jsonp,
                    params = $.extend({}, request.params),
                    ajaxData = isGet ? params : JSON.stringify(request.payload),
                    qs = !isGet && $.param(params),
                    url = request.url,
                    contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
                if (qs)
                    url += (url.indexOf("?") > -1 ? "&" : "?") + qs;
                if (useJsonp)
                    ajaxData["$format"] = "json";
                return {
                        url: url,
                        data: ajaxData,
                        dataType: useJsonp ? "jsonp" : "json",
                        jsonp: useJsonp && "$callback",
                        type: method,
                        timeout: 30000,
                        headers: request.headers,
                        contentType: contentType,
                        accepts: {json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()},
                        xhrFields: {withCredentials: requestOptions.withCredentials}
                    }
            };
        var sendRequest = function(request, requestOptions) {
                var d = $.Deferred();
                $.ajax(ajaxOptionsForRequest(request, requestOptions)).always(function(obj, textStatus) {
                    var tuplet = interpretVerboseJsonFormat(obj, textStatus),
                        error = tuplet.error,
                        data = tuplet.data,
                        nextUrl = tuplet.nextUrl;
                    if (error)
                        d.reject(error);
                    else if (requestOptions.countOnly)
                        d.resolve(tuplet.count);
                    else if (nextUrl)
                        sendRequest({url: nextUrl}, requestOptions).fail($.proxy(d.reject, d)).done(function(nextData) {
                            d.resolve(data.concat(nextData))
                        });
                    else
                        d.resolve(data)
                });
                return d.promise()
            };
        var formatDotNetError = function(errorObj) {
                var message,
                    currentError = errorObj;
                if ("message" in errorObj)
                    if (errorObj.message.value)
                        message = errorObj.message.value;
                    else
                        message = errorObj.message;
                while (currentError = currentError.innererror || currentError.internalexception) {
                    message = currentError.message;
                    if (currentError.internalexception && message.indexOf("inner exception") === -1)
                        break
                }
                return message
            };
        var errorFromResponse = function(obj, textStatus) {
                if (textStatus === "nocontent")
                    return null;
                var httpStatus = 200,
                    message = "Unknown error",
                    innerError,
                    response = obj;
                if (textStatus !== "success") {
                    httpStatus = obj.status;
                    message = data.utils.errorMessageFromXhr(obj, textStatus);
                    try {
                        response = $.parseJSON(obj.responseText)
                    }
                    catch(x) {}
                }
                var errorObj = response && response.error;
                if (errorObj) {
                    message = formatDotNetError(errorObj) || message;
                    if (httpStatus === 200)
                        httpStatus = 500;
                    if (response.error.code)
                        httpStatus = Number(response.error.code);
                    return $.extend(Error(message), {
                            httpStatus: httpStatus,
                            errorDetails: errorObj
                        })
                }
                else if (httpStatus !== 200)
                    return $.extend(Error(message), {httpStatus: httpStatus})
            };
        var interpretVerboseJsonFormat = function(obj, textStatus) {
                var error = errorFromResponse(obj, textStatus);
                if (error)
                    return {error: error};
                if (!$.isPlainObject(obj))
                    return {data: obj};
                var data = obj.d;
                if (!data)
                    return {error: Error("Malformed or unsupported JSON response received")};
                data = data.results || data;
                recognizeDates(data);
                return {
                        data: data,
                        nextUrl: obj.d.__next,
                        count: obj.d.__count
                    }
            };
        var EdmLiteral = DX.Class.inherit({
                ctor: function(value) {
                    this._value = value
                },
                valueOf: function() {
                    return this._value
                }
            });
        var serializeDate = function() {
                var pad = function(part) {
                        part = String(part);
                        if (part.length < 2)
                            part = "0" + part;
                        return part
                    };
                return function(date) {
                        var result = ["datetime'", date.getUTCFullYear(), "-", pad(date.getUTCMonth() + 1), "-", pad(date.getUTCDate())];
                        if (date.getUTCHours() || date.getUTCMinutes() || date.getUTCSeconds() || date.getUTCMilliseconds()) {
                            result.push("T", pad(date.getUTCHours()), ":", pad(date.getUTCMinutes()), ":", pad(date.getUTCSeconds()));
                            if (date.getUTCMilliseconds())
                                result.push(".", date.getUTCMilliseconds())
                        }
                        result.push("'");
                        return result.join("")
                    }
            }();
        var serializePropName = function(propName) {
                if (propName instanceof EdmLiteral)
                    return propName.valueOf();
                return propName.replace(/\./g, "/")
            };
        var serializeValue = function(value) {
                if (value instanceof Date)
                    return serializeDate(value);
                if (value instanceof Guid)
                    return "guid'" + value + "'";
                if (value instanceof EdmLiteral)
                    return value.valueOf();
                if (typeof value === "string")
                    return "'" + value.replace(/'/g, "''") + "'";
                return String(value)
            };
        var serializeKey = function(key) {
                if ($.isPlainObject(key)) {
                    var parts = [];
                    $.each(key, function(k, v) {
                        parts.push(serializePropName(k) + "=" + serializeValue(v))
                    });
                    return parts.join()
                }
                return serializeValue(key)
            };
        var recognizeDates = function(list) {
                $.each(list, function(i, val) {
                    if (val !== null && typeof val === "object")
                        recognizeDates(val);
                    else if (typeof val === "string") {
                        var matches = val.match(/^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/);
                        if (matches)
                            list[i] = new Date(Number(matches[1]) + matches[2] * 60000)
                    }
                })
            };
        var keyConverters = {
                String: function(value) {
                    return value + ""
                },
                Int32: function(value) {
                    return ~~value
                },
                Int64: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "L")
                },
                Guid: function(value) {
                    if (value instanceof Guid)
                        return value;
                    return new Guid(value)
                }
            };
        var compileCriteria = function() {
                var createBinaryOperationFormatter = function(op) {
                        return function(prop, val, bag) {
                                bag.push(prop, " ", op, " ", val)
                            }
                    };
                var createStringFuncFormatter = function(op, reverse) {
                        return function(prop, val, bag) {
                                if (reverse)
                                    bag.push(op, "(", val, ",", prop, ")");
                                else
                                    bag.push(op, "(", prop, ",", val, ")")
                            }
                    };
                var formatters = {
                        "=": createBinaryOperationFormatter("eq"),
                        "<>": createBinaryOperationFormatter("ne"),
                        ">": createBinaryOperationFormatter("gt"),
                        ">=": createBinaryOperationFormatter("ge"),
                        "<": createBinaryOperationFormatter("lt"),
                        "<=": createBinaryOperationFormatter("le"),
                        startswith: createStringFuncFormatter("startswith"),
                        endswith: createStringFuncFormatter("endswith"),
                        contains: createStringFuncFormatter("substringof", true),
                        notcontains: createStringFuncFormatter("not substringof", true)
                    };
                var compileBinary = function(criteria, bag) {
                        criteria = data.utils.normalizeBinaryCriterion(criteria);
                        formatters[criteria[1]](serializePropName(criteria[0]), serializeValue(criteria[2]), bag)
                    };
                var compileGroup = function(criteria, bag) {
                        var pushAnd = false;
                        $.each(criteria, function() {
                            if ($.isArray(this)) {
                                if (pushAnd)
                                    bag.push(" and ");
                                bag.push("(");
                                compileCore(this, bag);
                                bag.push(")");
                                pushAnd = true
                            }
                            else {
                                bag.push(/and|&/i.test(this) ? " and " : " or ");
                                pushAnd = false
                            }
                        })
                    };
                var compileCore = function(criteria, bag) {
                        if ($.isArray(criteria[0]))
                            compileGroup(criteria, bag);
                        else
                            compileBinary(criteria, bag)
                    };
                return function(criteria) {
                        var bag = [];
                        compileCore(criteria, bag);
                        return bag.join("")
                    }
            }();
        var createODataQueryAdapter = function(queryOptions) {
                var sorting = [],
                    criteria = [],
                    select,
                    skip,
                    take,
                    countQuery;
                var hasSlice = function() {
                        return skip || take !== undefined
                    };
                var sortCore = function(getter, desc, reset) {
                        if (hasSlice() || typeof getter !== "string")
                            return false;
                        if (reset)
                            sorting = [];
                        var rule = serializePropName(getter);
                        if (desc)
                            rule += " desc";
                        sorting.push(rule)
                    };
                var generateExpand = function() {
                        var hash = {};
                        if (queryOptions.expand)
                            $.each($.makeArray(queryOptions.expand), function() {
                                hash[serializePropName(this)] = 1
                            });
                        if (select)
                            $.each(select, function() {
                                var path = this.split(".");
                                if (path.length < 2)
                                    return;
                                path.pop();
                                hash[serializePropName(path.join("."))] = 1
                            });
                        return $.map(hash, function(k, v) {
                                return v
                            }).join() || undefined
                    };
                var requestData = function() {
                        var result = {};
                        if (!countQuery) {
                            if (sorting.length)
                                result["$orderby"] = sorting.join(",");
                            if (skip)
                                result["$skip"] = skip;
                            if (take !== undefined)
                                result["$top"] = take;
                            if (select)
                                result["$select"] = serializePropName(select.join());
                            result["$expand"] = generateExpand()
                        }
                        if (criteria.length)
                            result["$filter"] = compileCriteria(criteria.length < 2 ? criteria[0] : criteria);
                        if (countQuery) {
                            result["$inlinecount"] = "allpages";
                            result["$top"] = 0
                        }
                        return result
                    };
                return {
                        exec: function(url) {
                            return sendRequest({
                                    url: url,
                                    params: $.extend(requestData(), queryOptions && queryOptions.params)
                                }, {
                                    beforeSend: queryOptions.beforeSend,
                                    jsonp: queryOptions.jsonp,
                                    withCredentials: queryOptions.withCredentials,
                                    countOnly: countQuery
                                })
                        },
                        sortBy: function(getter, desc) {
                            return sortCore(getter, desc, true)
                        },
                        thenBy: function(getter, desc) {
                            return sortCore(getter, desc, false)
                        },
                        slice: function(skipCount, takeCount) {
                            if (hasSlice())
                                return false;
                            skip = skipCount;
                            take = takeCount
                        },
                        filter: function(criterion) {
                            if (hasSlice() || $.isFunction(criterion))
                                return false;
                            if (!$.isArray(criterion))
                                criterion = $.makeArray(arguments);
                            if (criteria.length)
                                criteria.push("and");
                            criteria.push(criterion)
                        },
                        select: function(expr) {
                            if (select || $.isFunction(expr))
                                return false;
                            if (!$.isArray(expr))
                                expr = $.makeArray(arguments);
                            select = expr
                        },
                        count: function() {
                            countQuery = true
                        }
                    }
            };
        $.extend(true, data, {
            EdmLiteral: EdmLiteral,
            utils: {odata: {
                    sendRequest: sendRequest,
                    serializePropName: serializePropName,
                    serializeValue: serializeValue,
                    serializeKey: serializeKey,
                    keyConverters: keyConverters
                }},
            queryAdapters: {odata: createODataQueryAdapter}
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.abstract.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            abstract = DX.abstract,
            data = DX.data,
            normalizeSortingInfo = data.utils.normalizeSortingInfo;
        var STORE_CALLBACK_NAMES = ["loading", "loaded", "modifying", "modified", "inserting", "inserted", "updating", "updated", "removing", "removed"];
        var multiLevelGroup = function(query, groupInfo) {
                query = query.groupBy(groupInfo[0].selector);
                if (groupInfo.length > 1)
                    query = query.select(function(g) {
                        return $.extend({}, g, {items: multiLevelGroup(data.query(g.items), groupInfo.slice(1)).toArray()})
                    });
                return query
            };
        data.Store = Class.inherit({
            ctor: function(options) {
                var self = this;
                options = options || {};
                $.each(STORE_CALLBACK_NAMES, function() {
                    var callbacks = self[this] = $.Callbacks();
                    if (this in options)
                        callbacks.add(options[this])
                });
                this._key = options.key;
                this._keyGetter = data.utils.compileGetter(this._key);
                this._errorHandler = options.errorHandler
            },
            customLoadOptions: function() {
                return null
            },
            key: function() {
                return this._key
            },
            keyOf: function(obj) {
                return this._keyGetter(obj)
            },
            _requireKey: function() {
                if (!this._key)
                    throw Error("Key expression is required for this operation");
            },
            load: function(options) {
                var self = this;
                options = options || {};
                this.loading.fire(options);
                return this._loadImpl(options).done(function(result) {
                        self.loaded.fire(result)
                    })
            },
            _loadImpl: function(options) {
                var filter = options.filter,
                    sort = options.sort,
                    select = options.select,
                    group = options.group,
                    skip = options.skip,
                    take = options.take,
                    q = this.createQuery(options);
                if (filter)
                    q = q.filter(filter);
                if (group)
                    group = normalizeSortingInfo(group);
                if (sort) {
                    sort = normalizeSortingInfo(sort);
                    if (group)
                        sort = group.concat(sort);
                    $.each(sort, function(index) {
                        q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
                    })
                }
                if (group)
                    q = multiLevelGroup(q, group);
                if (take || skip)
                    q = q.slice(skip || 0, take);
                if (select)
                    q = q.select(select);
                return q.enumerate()
            },
            createQuery: abstract,
            byKey: function(key, extraOptions) {
                return this._addFailHandlers(this._byKeyImpl(key, extraOptions))
            },
            _byKeyImpl: abstract,
            insert: function(values) {
                var self = this;
                self.modifying.fire();
                self.inserting.fire(values);
                return self._addFailHandlers(self._insertImpl(values).done(function(callbackValues, callbackKey) {
                        self.inserted.fire(callbackValues, callbackKey);
                        self.modified.fire()
                    }))
            },
            _insertImpl: abstract,
            update: function(key, values) {
                var self = this;
                self.modifying.fire();
                self.updating.fire(key, values);
                return self._addFailHandlers(self._updateImpl(key, values).done(function(callbackKey, callbackValues) {
                        self.updated.fire(callbackKey, callbackValues);
                        self.modified.fire()
                    }))
            },
            _updateImpl: abstract,
            remove: function(key) {
                var self = this;
                self.modifying.fire();
                self.removing.fire(key);
                return self._addFailHandlers(self._removeImpl(key).done(function(callbackKey) {
                        self.removed.fire(callbackKey);
                        self.modified.fire()
                    }))
            },
            _removeImpl: abstract,
            _addFailHandlers: function(deferred) {
                return deferred.fail(this._errorHandler, data._handleError)
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.array.js */
    (function($, DX, undefined) {
        var data = DX.data,
            Guid = data.Guid;
        var trivialPromise = function(_) {
                var d = $.Deferred();
                return d.resolve.apply(d, arguments).promise()
            };
        var rejectedPromise = function(_) {
                var d = $.Deferred();
                return d.reject.apply(d, arguments).promise()
            };
        data.ArrayStore = data.Store.inherit({
            ctor: function(options) {
                if ($.isArray(options))
                    options = {data: options};
                else
                    options = options || {};
                this.callBase(options);
                this._array = options.data || []
            },
            createQuery: function() {
                return data.query(this._array, {errorHandler: this._errorHandler})
            },
            _byKeyImpl: function(key) {
                return trivialPromise(this._array[this._indexByKey(key)])
            },
            _insertImpl: function(values) {
                var keyExpr = this.key(),
                    keyValue,
                    obj = {};
                $.extend(obj, values);
                if (keyExpr) {
                    keyValue = this.keyOf(obj);
                    if (keyValue === undefined || typeof keyValue === "object" && $.isEmptyObject(keyValue)) {
                        if ($.isArray(keyExpr))
                            throw Error("Compound keys cannot be auto-generated");
                        keyValue = obj[keyExpr] = String(new Guid)
                    }
                    else if (this._array[this._indexByKey(keyValue)] !== undefined)
                        return rejectedPromise(Error("Attempt to insert an item with the duplicate key"))
                }
                else
                    keyValue = obj;
                this._array.push(obj);
                return trivialPromise(values, keyValue)
            },
            _updateImpl: function(key, values) {
                var target;
                if (this.key()) {
                    var index = this._indexByKey(key);
                    if (index < 0)
                        return rejectedPromise(Error("Data item not found"));
                    target = this._array[index]
                }
                else
                    target = key;
                $.extend(true, target, values);
                return trivialPromise(key, values)
            },
            _removeImpl: function(key) {
                var index = this._indexByKey(key);
                if (index > -1)
                    this._array.splice(index, 1);
                return trivialPromise(key)
            },
            _indexByKey: function(key) {
                for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++)
                    if (data.utils.keysEqual(this.key(), this._keyGetter(this._array[i]), key))
                        return i;
                return -1
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.local.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            abstract = DX.abstract,
            data = DX.data;
        var LocalStoreBackend = Class.inherit({
                ctor: function(store, storeOptions) {
                    this._store = store;
                    this._dirty = false;
                    var immediate = this._immediate = storeOptions.immediate;
                    var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
                    if (!immediate) {
                        var saveProxy = $.proxy(this.save, this);
                        setInterval(saveProxy, flushInterval);
                        $(window).on("beforeunload", saveProxy);
                        if (window.cordova)
                            document.addEventListener("pause", saveProxy, false)
                    }
                },
                notifyChanged: function() {
                    this._dirty = true;
                    if (this._immediate)
                        this.save()
                },
                load: function() {
                    this._store._array = this._loadImpl();
                    this._dirty = false
                },
                save: function() {
                    if (!this._dirty)
                        return;
                    this._saveImpl(this._store._array);
                    this._dirty = false
                },
                _loadImpl: abstract,
                _saveImpl: abstract
            });
        var DomLocalStoreBackend = LocalStoreBackend.inherit({
                ctor: function(store, storeOptions) {
                    this.callBase(store, storeOptions);
                    var name = storeOptions.name;
                    if (!name)
                        throw Error("Name is required");
                    this._key = "dx-data-localStore-" + name
                },
                _loadImpl: function() {
                    var raw = localStorage.getItem(this._key);
                    if (raw)
                        return JSON.parse(raw);
                    return []
                },
                _saveImpl: function(array) {
                    if (!array.length)
                        localStorage.removeItem(this._key);
                    else
                        localStorage.setItem(this._key, JSON.stringify(array))
                }
            });
        var localStoreBackends = {dom: DomLocalStoreBackend};
        data.LocalStore = data.ArrayStore.inherit({
            ctor: function(options) {
                if (typeof options === "string")
                    options = {name: options};
                else
                    options = options || {};
                this.callBase(options);
                this._backend = new localStoreBackends[options.backend || "dom"](this, options);
                this._backend.load()
            },
            clear: function() {
                this._array = [];
                this._backend.notifyChanged()
            },
            _insertImpl: function(values) {
                var b = this._backend;
                return this.callBase(values).done($.proxy(b.notifyChanged, b))
            },
            _updateImpl: function(key, values) {
                var b = this._backend;
                return this.callBase(key, values).done($.proxy(b.notifyChanged, b))
            },
            _removeImpl: function(key) {
                var b = this._backend;
                return this.callBase(key).done($.proxy(b.notifyChanged, b))
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.odata.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            data = DX.data,
            odataUtils = data.utils.odata;
        var escapeServiceOperationParams = function(params) {
                if (!params)
                    return params;
                var result = {};
                $.each(params, function(k, v) {
                    result[k] = odataUtils.serializeValue(v)
                });
                return result
            };
        var convertSimpleKey = function(keyType, keyValue) {
                var converter = odataUtils.keyConverters[keyType];
                if (!converter)
                    throw Error("Unknown key type: " + keyType);
                return converter(keyValue)
            };
        var SharedMethods = {
                _extractServiceOptions: function(options) {
                    options = options || {};
                    this._url = String(options.url).replace(/\/+$/, "");
                    this._beforeSend = options.beforeSend;
                    this._jsonp = options.jsonp;
                    this._withCredentials = options.withCredentials
                },
                _sendRequest: function(url, method, params, payload) {
                    return odataUtils.sendRequest({
                            url: url,
                            method: method,
                            params: params || {},
                            payload: payload
                        }, {
                            beforeSend: this._beforeSend,
                            jsonp: this._jsonp,
                            withCredentials: this._withCredentials
                        })
                }
            };
        var ODataStore = data.Store.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this._extractServiceOptions(options);
                    this._name = options.name;
                    this._keyType = options.keyType
                },
                customLoadOptions: function() {
                    return ["expand", "customQueryParams"]
                },
                _byKeyImpl: function(key, extraOptions) {
                    var params = {};
                    if (extraOptions)
                        if (extraOptions.expand)
                            params["$expand"] = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join();
                    return this._sendRequest(this._byKeyUrl(key), "GET", params)
                },
                createQuery: function(loadOptions) {
                    loadOptions = loadOptions || {};
                    return data.query(this._url, {
                            beforeSend: this._beforeSend,
                            errorHandler: this._errorHandler,
                            jsonp: this._jsonp,
                            withCredentials: this._withCredentials,
                            params: escapeServiceOperationParams(loadOptions.customQueryParams),
                            expand: loadOptions.expand
                        })
                },
                _insertImpl: function(values) {
                    this._requireKey();
                    var self = this,
                        d = $.Deferred();
                    $.when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
                        d.resolve(values, self._keyGetter(serverResponse))
                    }).fail($.proxy(d.reject, d));
                    return d.promise()
                },
                _updateImpl: function(key, values) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "MERGE", null, values)).done(function() {
                        d.resolve(key, values)
                    }).fail($.proxy(d.reject, d));
                    return d.promise()
                },
                _removeImpl: function(key) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                        d.resolve(key)
                    }).fail($.proxy(d.reject, d));
                    return d.promise()
                },
                _byKeyUrl: function(key) {
                    var keyType = this._keyType;
                    if ($.isPlainObject(keyType))
                        $.each(keyType, function(subKeyName, subKeyType) {
                            key[subKeyName] = convertSimpleKey(subKeyType, key[subKeyName])
                        });
                    else if (keyType)
                        key = convertSimpleKey(keyType, key);
                    return this._url + "(" + encodeURIComponent(odataUtils.serializeKey(key)) + ")"
                }
            }).include(SharedMethods);
        var ODataContext = Class.inherit({
                ctor: function(options) {
                    var self = this;
                    self._extractServiceOptions(options);
                    self._errorHandler = options.errorHandler;
                    $.each(options.entities || [], function(entityAlias, entityOptions) {
                        self[entityAlias] = new ODataStore($.extend({}, options, {url: self._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)}, entityOptions))
                    })
                },
                get: function(operationName, params) {
                    return this.invoke(operationName, params, "GET")
                },
                invoke: function(operationName, params, httpMethod) {
                    httpMethod = httpMethod || "POST";
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._url + "/" + encodeURIComponent(operationName), httpMethod, escapeServiceOperationParams(params))).done(function(r) {
                        if (r && operationName in r)
                            r = r[operationName];
                        d.resolve(r)
                    }).fail([this._errorHandler, data._handleError, $.proxy(d.reject, d)]);
                    return d.promise()
                },
                objectLink: function(entityAlias, key) {
                    var store = this[entityAlias];
                    if (!store)
                        throw Error("Unknown entity name or alias: " + entityAlias);
                    return {__metadata: {uri: store._byKeyUrl(key)}}
                }
            }).include(SharedMethods);
        $.extend(data, {
            ODataStore: ODataStore,
            ODataContext: ODataContext
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.rest.js */
    (function($, DX, undefined) {
        var data = DX.data;
        function createAjaxFailureHandler(deferred) {
            return function(xhr, textStatus) {
                    if (!xhr || !xhr.getResponseHeader)
                        deferred.reject.apply(deferred, arguments);
                    else
                        deferred.reject(Error(data.utils.errorMessageFromXhr(xhr, textStatus)))
                }
        }
        function operationCustomizerPropName(operationName) {
            return "_customize" + DX.inflector.camelize(operationName, true)
        }
        function pathPropName(operationName) {
            return "_" + operationName + "Path"
        }
        data.RestStore = data.Store.inherit({
            ctor: function(options) {
                var self = this;
                self.callBase(options);
                options = options || {};
                self._url = String(options.url).replace(/\/+$/, "");
                self._jsonp = options.jsonp;
                self._withCredentials = options.withCredentials;
                $.each(["Load", "Insert", "Update", "Remove", "ByKey", "Operation"], function() {
                    var value = options["customize" + this];
                    if (value)
                        self[operationCustomizerPropName(this)] = value
                });
                $.each(["load", "insert", "update", "remove", "byKey"], function() {
                    var value = options[this + "Path"];
                    if (value)
                        self[pathPropName(this)] = value
                })
            },
            _loadImpl: function(options) {
                var d = $.Deferred(),
                    ajaxOptions = {
                        url: this._formatUrlNoKey("load"),
                        type: "GET"
                    };
                $.when(this._createAjax(ajaxOptions, "load", options)).done($.proxy(d.resolve, d)).fail(createAjaxFailureHandler(d));
                return this._addFailHandlers(d.promise())
            },
            createQuery: function() {
                throw Error("Not supported");
            },
            _insertImpl: function(values) {
                var d = $.Deferred(),
                    self = this,
                    ajaxOptions = {
                        url: this._formatUrlNoKey("insert"),
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(values)
                    };
                $.when(this._createAjax(ajaxOptions, "insert")).done(function(serverResponse) {
                    d.resolve(values, self.key() && self._keyGetter(serverResponse))
                }).fail(createAjaxFailureHandler(d));
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var d = $.Deferred(),
                    ajaxOptions = {
                        url: this._formatUrlWithKey("update", key),
                        type: "PUT",
                        contentType: "application/json",
                        data: JSON.stringify(values)
                    };
                $.when(this._createAjax(ajaxOptions, "update")).done(function() {
                    d.resolve(key, values)
                }).fail(createAjaxFailureHandler(d));
                return d.promise()
            },
            _removeImpl: function(key) {
                var d = $.Deferred(),
                    ajaxOptions = {
                        url: this._formatUrlWithKey("remove", key),
                        type: "DELETE"
                    };
                $.when(this._createAjax(ajaxOptions, "remove")).done(function() {
                    d.resolve(key)
                }).fail(createAjaxFailureHandler(d));
                return d.promise()
            },
            _byKeyImpl: function(key) {
                var d = $.Deferred(),
                    ajaxOptions = {
                        url: this._formatUrlWithKey("byKey", key),
                        type: "GET"
                    };
                $.when(this._createAjax(ajaxOptions, "byKey")).done(function(data) {
                    d.resolve(data)
                }).fail(createAjaxFailureHandler(d));
                return d.promise()
            },
            _createAjax: function(ajaxOptions, operationName, extra) {
                var customizationFunc,
                    customizationResult;
                function isDeferred(obj) {
                    return "done" in obj && "fail" in obj
                }
                if (this._jsonp && ajaxOptions.type === "GET")
                    ajaxOptions.dataType = "jsonp";
                else
                    $.extend(true, ajaxOptions, {xhrFields: {withCredentials: this._withCredentials}});
                customizationFunc = this[operationCustomizerPropName("operation")];
                if (customizationFunc) {
                    customizationResult = customizationFunc(ajaxOptions, operationName, extra);
                    if (customizationResult) {
                        if (isDeferred(customizationResult))
                            return customizationResult;
                        ajaxOptions = customizationResult
                    }
                }
                customizationFunc = this[operationCustomizerPropName(operationName)];
                if (customizationFunc) {
                    customizationResult = customizationFunc(ajaxOptions, extra);
                    if (customizationResult) {
                        if (isDeferred(customizationResult))
                            return customizationResult;
                        ajaxOptions = customizationResult
                    }
                }
                return $.ajax(ajaxOptions)
            },
            _formatUrlNoKey: function(operationName) {
                var url = this._url,
                    path = this[pathPropName(operationName)];
                if (!path)
                    return url;
                if ($.isFunction(path))
                    return path(url);
                return url + "/" + path
            },
            _formatUrlWithKey: function(operationName, key) {
                var url = this._url,
                    path = this[pathPropName(operationName)];
                if (!path)
                    return url + "/" + encodeURIComponent(key);
                if ($.isFunction(path))
                    return path(url, key);
                return url + "/" + path + "/" + encodeURIComponent(key)
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.simple.js */
    (function($, DX, undefined) {
        var data = DX.data;
        function operationCustomizerPropName(operationName) {
            return "_customize" + DX.inflector.camelize(operationName, true)
        }
        function pathPropName(operationName) {
            return "_" + operationName + "Path"
        }
        data.SimpleStore = data.Store.inherit({
            ctor: function(options) {
                var self = this;
                self.callBase(options);
                options = options || {};
                self.changed = options.changed;
                self.userLoadCallback = options.load;
                self.userLookupCallback = options.lookup
            },
            _loadImpl: function(loadOptions) {
                if (!this.userLoadCallback)
                    throw new Error('Load callback was not defined');
                var loadOptions2 = {refresh: loadOptions.refresh};
                loadOptions2.searchString = loadOptions.searchString;
                var result = this.userLoadCallback(loadOptions2);
                if (!result)
                    result = (new $.Deferred).resolve([]);
                if ($.isArray(result))
                    result = (new $.Deferred).resolve(result);
                return result
            },
            lookup: function(key, lookupExpression, lookupGetter) {
                if (!this.userLookupCallback)
                    throw new Error('Lookup callback was not defined');
                var result = this.userLookupCallback(key, lookupExpression, lookupGetter);
                if ($.isArray(result))
                    result = result[0];
                if (!result)
                    result = (new $.Deferred).resolve([]);
                if (!result.done)
                    result = (new $.Deferred).resolve(result);
                return result
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.dataSource.js */
    (function($, DX, undefined) {
        var data = DX.data,
            Class = DX.Class;
        var LOCAL_KEY_PROP = "__key__";
        var emptyPromise = $.Deferred().resolve([]).promise();
        var DataSource = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    var store = options.store;
                    if ($.isArray(store))
                        store = new data.ArrayStore(store);
                    this._store = store;
                    this._storeLoadOptions = this._extractLoadOptions(options);
                    this._mapFunc = options.map;
                    this._postProcessFunc = options.postProcess;
                    this._pageIndex = 0;
                    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
                    this._items = [];
                    this._updateMode = options.updateMode || "item";
                    this._isLoaded = false;
                    this._preferSync = options._preferSync;
                    this._paginate = options.paginate;
                    if (this._paginate === undefined)
                        this._paginate = !this._isGrouped();
                    this._isLastPage = !this._paginate;
                    this.changed = $.Callbacks();
                    this.loadError = $.Callbacks();
                    store.updated.add(this._storeUpdatedHandler = $.proxy(this._handleStoreUpdated, this));
                    store.inserted.add(this._storeInsertedHandler = $.proxy(this._handleStoreInserted, this));
                    store.removed.add(this._storeRemovedHandler = $.proxy(this._handleStoreRemoved, this));
                    this._customizeFilters = $.Callbacks()
                },
                dispose: function() {
                    this.changed.empty();
                    this.loadError.empty();
                    this._store.updated.remove(this._storeUpdatedHandler);
                    delete this._storeUpdatedHandler;
                    this._store.inserted.remove(this._storeInsertedHandler);
                    delete this._storeInsertedHandler;
                    this._store.removed.remove(this._storeRemovedHandler);
                    delete this._storeRemovedHandler;
                    delete this._store;
                    this._disposed = true
                },
                _extractLoadOptions: function(options) {
                    var result = {},
                        names = ["sort", "filter", "select", "group"],
                        customNames = this._store.customLoadOptions();
                    if (customNames)
                        names = names.concat(customNames);
                    $.each(names, function() {
                        result[this] = options[this]
                    });
                    return result
                },
                loadOptions: function() {
                    return this._storeLoadOptions
                },
                _accessStoreLoadOption: function(name, value) {
                    var options = this._storeLoadOptions;
                    if (arguments.length < 2)
                        return options[name];
                    options[name] = value;
                    this.reload()
                },
                filter: function(expr) {
                    if (!arguments.length)
                        return this._accessStoreLoadOption("filter");
                    if (expr && !$.isArray(expr))
                        expr = $.makeArray(arguments);
                    this._accessStoreLoadOption("filter", expr)
                },
                clearFilter: function() {
                    this.filter(null)
                },
                sortBy: function(expr) {
                    if (arguments.length > 1)
                        expr = {
                            selector: arguments[0],
                            desc: arguments[1]
                        };
                    this._accessStoreLoadOption("sort", expr)
                },
                clearSort: function() {
                    this.sortBy(null)
                },
                store: function() {
                    return this._store
                },
                key: function() {
                    return this._store && this._store.key()
                },
                _isGrouped: function() {
                    return !!this._storeLoadOptions.group
                },
                _assignPageIndex: function(value) {
                    if (this._pageIndex === value)
                        return;
                    this._pageIndex = value;
                    this.load()
                },
                reload: function(options) {
                    this._pageIndex = 0;
                    this._isLastPage = !this._paginate;
                    return this._loadCore(options)
                },
                load: function(options) {
                    return this._loadCore(options)
                },
                isLoaded: function() {
                    return this._isLoaded
                },
                lookup: function(options) {
                    var d = new $.Deferred,
                        self = this,
                        key = options.key;
                    options.lookupExpression = options.lookupExpression || self.key();
                    if (this._store.lookup)
                        this._store.lookup(key).done(function(item) {
                            if (self._disposed)
                                return;
                            var transformed = self._transformLoadedData(item);
                            d.resolve(transformed[0])
                        });
                    else if (options.lookupExpression && options.lookupExpression === self.key())
                        this._loadSingleByKey(key).done(function(item) {
                            d.resolve(item)
                        });
                    else {
                        var newDataSource = self._store.toDataSource();
                        newDataSource.load({
                            searchString: key,
                            searchMethod: "=",
                            searchField: options.lookupExpression,
                            silent: true
                        }).done(function() {
                            if (self._disposed)
                                return;
                            var items = newDataSource.items();
                            var transformed = self._transformLoadedData(items);
                            d.resolve(transformed[0])
                        }).always(function() {
                            newDataSource.dispose()
                        })
                    }
                    return d
                },
                nextPage: function(append) {
                    append = append === undefined ? true : append;
                    if (this._isLastPage)
                        return emptyPromise;
                    this._pageIndex++;
                    var options = {append: append};
                    $.extend(options, this._searchCondition);
                    return this._loadCore(options)
                },
                _loadCore: function(options) {
                    options = options || {};
                    var self = this,
                        d = $.Deferred(),
                        errorCallback = self.loadError,
                        loadOptions = $.extend(true, {}, self._storeLoadOptions),
                        localFilter;
                    if (!this.userDataSource && (options.searchField || loadOptions.searchFilter)) {
                        if (loadOptions.filter && !$.isArray(loadOptions.filter[0]))
                            loadOptions.filter = [loadOptions.filter];
                        loadOptions.filter = loadOptions.filter || [];
                        if (options.searchField)
                            localFilter = [options.searchField, options.searchMethod || "contains", options.searchString];
                        else
                            localFilter = loadOptions.searchFilter;
                        loadOptions.filter.push(localFilter);
                        self._storeLoadOptions.searchFilter = localFilter
                    }
                    if (this._paginate)
                        if (self._pageSize)
                            $.extend(loadOptions, {
                                skip: self._pageIndex * self._pageSize,
                                take: self._pageSize
                            });
                    $.extend(loadOptions, {
                        refresh: !self._paginate || self._pageIndex === 0,
                        searchString: options.searchString
                    });
                    var loadTask = function() {
                            if (self._disposed)
                                return undefined;
                            return $.when(self._store.load(loadOptions)).done(function(data) {
                                    var processData = function() {
                                            if (self._disposed)
                                                return;
                                            var items = self._items;
                                            data = self._transformLoadedData(data);
                                            if (!options.append)
                                                items.splice(0, items.length);
                                            items.push.apply(items, data);
                                            if (!data.length || !self._paginate || self._pageSize && data.length < self._pageSize)
                                                self._isLastPage = true;
                                            self._isLoaded = true;
                                            if (!options.silent)
                                                self.changed.fire();
                                            d.resolve(data)
                                        };
                                    if (self._preferSync)
                                        processData();
                                    else
                                        DX.utils.executeAsync(processData)
                                }).fail($.proxy(d.reject, d))
                        };
                    if (DataSourceLoadLock.locked())
                        DataSourceLoadLock.addTask(loadTask);
                    else
                        loadTask();
                    return d.promise().fail($.proxy(errorCallback.fire, errorCallback))
                },
                _loadSingleByKey: function(key) {
                    var self = this,
                        d = $.Deferred();
                    if (!self._disposed)
                        $.when(self._store.byKey(key)).done(function(item) {
                            if (self._disposed)
                                return;
                            var transformed = self._transformLoadedData(item);
                            d.resolve(transformed[0])
                        });
                    return d.promise()
                },
                _transformLoadedData: function(data) {
                    var self = this,
                        result;
                    result = $.map($.makeArray(data), function(item, index) {
                        var keyValue = self._store.keyOf(item),
                            transformed;
                        if (self._mapFunc)
                            transformed = self._mapFunc(item, index);
                        else if (typeof item === "object")
                            transformed = $.extend({}, item);
                        else
                            transformed = item;
                        if (typeof item === "object")
                            transformed[LOCAL_KEY_PROP] = keyValue;
                        return transformed
                    });
                    if (self._postProcessFunc)
                        result = self._postProcessFunc(result);
                    return result
                },
                _localIndexByKey: function(key) {
                    var items = this._items,
                        len = items.length,
                        keyExpr = this._store.key(),
                        itemKey;
                    for (var i = 0; i < len; i++) {
                        itemKey = items[i][LOCAL_KEY_PROP];
                        if (data.utils.keysEqual(keyExpr, itemKey, key))
                            return i
                    }
                    return -1
                },
                _handleStoreUpdated: function(key) {
                    var self = this;
                    switch (self._updateMode) {
                        case"full":
                            this.reload();
                            break;
                        case"item":
                            if (self._isGrouped())
                                return;
                            var localIndex = this._localIndexByKey(key);
                            if (localIndex < 0)
                                return;
                            self._loadSingleByKey(key).done(function(item) {
                                self._items.splice(localIndex, 1, item);
                                self.changed.fire()
                            });
                            break
                    }
                },
                _handleStoreInserted: function(_, key) {
                    var self = this;
                    switch (self._updateMode) {
                        case"full":
                            self.reload();
                            break;
                        case"item":
                            if (self._isGrouped())
                                return;
                            self._loadSingleByKey(key).done(function(item) {
                                self._items.push(item);
                                self.changed.fire()
                            });
                            break
                    }
                },
                _handleStoreRemoved: function(key) {
                    var self = this;
                    switch (self._updateMode) {
                        case"full":
                            self.reload();
                            break;
                        case"item":
                            if (self._isGrouped())
                                return;
                            var localIndex = this._localIndexByKey(key);
                            if (localIndex < 0)
                                return;
                            self._items.splice(localIndex, 1);
                            self.changed.fire();
                            break
                    }
                }
            });
        var SimpleDataSource = DataSource.inherit({
                items: function() {
                    return this._items
                },
                pageIndex: function(value) {
                    if (value === undefined)
                        return this._pageIndex;
                    this._assignPageIndex(value)
                },
                isLastPage: function() {
                    return this._isLastPage
                }
            });
        var KoDataSource = DataSource.inherit({
                ctor: function(store, options) {
                    this.callBase(store, options);
                    var pinger = ko.observable();
                    this.changed.add(function() {
                        pinger.notifySubscribers()
                    });
                    this.items = ko.computed(function() {
                        pinger();
                        return this._items
                    }, this);
                    this.pageIndex = ko.computed({
                        read: function() {
                            pinger();
                            return this._pageIndex
                        },
                        write: function(value) {
                            this._assignPageIndex(value)
                        }
                    }, this);
                    this.isLastPage = ko.computed(function() {
                        pinger();
                        return this._isLastPage
                    }, this)
                },
                dispose: function() {
                    this.callBase();
                    this.items.dispose();
                    this.pageIndex.dispose();
                    this.isLastPage.dispose()
                }
            });
        data.Store.redefine({toDataSource: function(options, impl) {
                var dataSource;
                options = $.extend({store: this}, options);
                if ($.isFunction(impl))
                    dataSource = new impl(options);
                else
                    switch (impl) {
                        case"simple":
                            dataSource = new SimpleDataSource(options);
                            break;
                        default:
                            dataSource = new KoDataSource(options)
                    }
                if (dataSource && this.changed && $.isFunction(this.changed.add))
                    this.changed.add(function() {
                        dataSource.reload()
                    });
                if (options.userDataSource)
                    dataSource.userDataSource = options.userDataSource;
                return dataSource
            }});
        var createDataSource = function(dataSourceOptions) {
                var defaultDataSourceType = window.ko ? KoDataSource : SimpleDataSource;
                return new DX.data.SimpleStore(dataSourceOptions).toDataSource({
                        pageSize: null,
                        userDataSource: true
                    }, defaultDataSourceType)
            };
        var DataSourceLoadLock = new function() {
                var delayedLoadTasks = [],
                    lockCount = 0;
                var obtain = function() {
                        lockCount++
                    };
                var release = function() {
                        lockCount--;
                        if (lockCount < 1) {
                            $.each(delayedLoadTasks, function() {
                                DX.enqueue(this)
                            });
                            delayedLoadTasks = []
                        }
                    };
                return {
                        obtain: obtain,
                        release: release,
                        locked: function() {
                            return lockCount > 0
                        },
                        addTask: function(task) {
                            delayedLoadTasks.push(task)
                        }
                    }
            };
        $.extend(true, data, {
            DataSource: DataSource,
            KoDataSource: KoDataSource,
            SimpleDataSource: SimpleDataSource,
            createDataSource: createDataSource,
            utils: {DataSourceLoadLock: DataSourceLoadLock}
        })
    })(jQuery, DevExpress);
    /*! Module core, file social.js */
    DevExpress.social = {};
    /*! Module core, file facebook.js */
    (function($, DX, undefined) {
        var social = DX.social;
        var location = window.location,
            navigator = window.navigator,
            encodeURIComponent = window.encodeURIComponent,
            decodeURIComponent = window.decodeURIComponent,
            iosStandaloneMode = navigator.standalone,
            cordovaMode = false;
        if (window.cordova)
            $(document).on("deviceready", function() {
                cordovaMode = true
            });
        var ACCESS_TOKEN_KEY = "dx-facebook-access-token",
            IOS_STANDALONE_STEP1_KEY = "dx-facebook-step1",
            IOS_STANDALONE_STEP2_KEY = "dx-facebook-step2";
        var accessToken = null,
            expires = null,
            connectionChanged = $.Callbacks();
        var pendingLoginRedirectUrl;
        var isConnected = function() {
                return !!accessToken
            };
        var getAccessTokenObject = function() {
                return {
                        accessToken: accessToken,
                        expiresIn: accessToken ? expires : 0
                    }
            };
        var FB = social.Facebook = {
                loginRedirectUrl: "FacebookLoginCallback.html",
                connectionChanged: connectionChanged,
                isConnected: isConnected,
                getAccessTokenObject: getAccessTokenObject,
                jsonp: false
            };
        var login = function(appId, options) {
                options = options || {};
                if (cordovaMode)
                    pendingLoginRedirectUrl = "https://www.facebook.com/connect/login_success.html";
                else
                    pendingLoginRedirectUrl = formatLoginRedirectUrl();
                var scope = (options.permissions || []).join(),
                    url = "https://www.facebook.com/dialog/oauth?display=popup&client_id=" + appId + "&redirect_uri=" + encodeURIComponent(pendingLoginRedirectUrl) + "&scope=" + encodeURIComponent(scope) + "&response_type=token";
                if (iosStandaloneMode)
                    putData(IOS_STANDALONE_STEP1_KEY, location.href);
                if (cordovaMode)
                    startLogin_cordova(url);
                else
                    startLogin_browser(url)
            };
        var formatLoginRedirectUrl = function() {
                var pathSegments = location.pathname.split(/\//g);
                pathSegments.pop();
                pathSegments.push(FB.loginRedirectUrl);
                return location.protocol + "//" + location.host + pathSegments.join("/")
            };
        var startLogin_browser = function(loginUrl) {
                var width = 512,
                    height = 320,
                    left = (screen.width - width) / 2,
                    top = (screen.height - height) / 2;
                window.open(loginUrl, null, "width=" + width + ",height=" + height + ",toolbar=0,scrollbars=0,status=0,resizable=0,menuBar=0,left=" + left + ",top=" + top)
            };
        var startLogin_cordova = function(loginUrl) {
                var ref = window.open(loginUrl, "_blank");
                ref.addEventListener('exit', function(event) {
                    pendingLoginRedirectUrl = null
                });
                ref.addEventListener('loadstop', function(event) {
                    var url = unescape(event.url);
                    if (url.indexOf(pendingLoginRedirectUrl) === 0) {
                        ref.close();
                        _processLoginRedirectUrl(url)
                    }
                })
            };
        var handleLoginRedirect = function() {
                var opener = window.opener;
                if (iosStandaloneMode) {
                    putData(IOS_STANDALONE_STEP2_KEY, location.href);
                    location.href = getData(IOS_STANDALONE_STEP1_KEY)
                }
                else if (opener && opener.DevExpress) {
                    opener.DevExpress.social.Facebook._processLoginRedirectUrl(location.href);
                    window.close()
                }
            };
        var _processLoginRedirectUrl = function(url) {
                var params = parseUrlFragment(url);
                expires = params.expires_in;
                changeToken(params.access_token);
                pendingLoginRedirectUrl = null
            };
        var parseUrlFragment = function(url) {
                var hash = url.split("#")[1];
                if (!hash)
                    return {};
                var pairs = hash.split(/&/g),
                    result = {};
                $.each(pairs, function(i) {
                    var splitPair = this.split("=");
                    result[splitPair[0]] = decodeURIComponent(splitPair[1])
                });
                return result
            };
        var logout = function() {
                changeToken(null)
            };
        var changeToken = function(value) {
                if (value === accessToken)
                    return;
                accessToken = value;
                putData(ACCESS_TOKEN_KEY, value);
                connectionChanged.fire(!!value)
            };
        var api = function(resource, method, params) {
                if (!isConnected())
                    throw Error("Not connected");
                if (typeof method !== "string") {
                    params = method;
                    method = undefined
                }
                method = (method || "get").toLowerCase();
                var d = $.Deferred();
                var args = arguments;
                $.ajax({
                    url: "https://graph.facebook.com/" + resource,
                    type: method,
                    data: $.extend({access_token: accessToken}, params),
                    dataType: FB.jsonp && method === "get" ? "jsonp" : "json"
                }).done(function(response) {
                    response = response || simulateErrorResponse();
                    if (response.error)
                        d.reject(response.error);
                    else
                        d.resolve(response)
                }).fail(function(xhr) {
                    var response;
                    try {
                        response = $.parseJSON(xhr.responseText);
                        var tries = args[3] || 0;
                        if (tries++ < 3 && response.error.code == 190 && response.error.error_subcode == 466) {
                            setTimeout(function() {
                                api(resource, method, params, tries).done(function(result) {
                                    d.resolve(result)
                                }).fail(function(error) {
                                    d.reject(error)
                                })
                            }, 500);
                            return
                        }
                    }
                    catch(x) {
                        response = simulateErrorResponse()
                    }
                    d.reject(response.error)
                });
                return d.promise()
            };
        var simulateErrorResponse = function() {
                return {error: {message: "Unknown error"}}
            };
        var ensureStorageBackend = function() {
                if (!hasStorageBackend())
                    throw Error("HTML5 sessionStorage or jQuery.cookie plugin is required");
            };
        var hasStorageBackend = function() {
                return !!($.cookie || window.sessionStorage)
            };
        var putData = function(key, data) {
                ensureStorageBackend();
                data = JSON.stringify(data);
                if (window.sessionStorage)
                    if (data === null)
                        sess.removeItem(key);
                    else
                        sessionStorage.setItem(key, data);
                else
                    $.cookie(key, data)
            };
        var getData = function(key) {
                ensureStorageBackend();
                try {
                    return JSON.parse(window.sessionStorage ? sessionStorage.getItem(key) : $.cookie(key))
                }
                catch(x) {
                    return null
                }
            };
        if (hasStorageBackend())
            accessToken = getData(ACCESS_TOKEN_KEY);
        if (iosStandaloneMode) {
            var url = getData(IOS_STANDALONE_STEP2_KEY);
            if (url) {
                _processLoginRedirectUrl(url);
                putData(IOS_STANDALONE_STEP1_KEY, null);
                putData(IOS_STANDALONE_STEP2_KEY, null)
            }
        }
        $.extend(FB, {
            login: login,
            logout: logout,
            handleLoginRedirect: handleLoginRedirect,
            _processLoginRedirectUrl: _processLoginRedirectUrl,
            api: api
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.js */
    (function($, DX, undefined) {
        var ui = DX.ui = {};
        var initViewport = function(options) {
                options = $.extend({}, options);
                var inFrame = top != self;
                var device = DX.devices.fromUA();
                var allowZoom = options.allowZoom,
                    allowPan = options.allowPan;
                var metaSelector = "meta[name=viewport]";
                if (!$(metaSelector).length)
                    $("<meta />").attr("name", "viewport").appendTo("head");
                var metaVerbs = ["width=device-width"],
                    msTouchVerbs = [];
                if (allowZoom)
                    msTouchVerbs.push("pinch-zoom");
                else
                    metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0");
                if (allowPan)
                    msTouchVerbs.push("pan-x", "pan-y");
                if (!allowPan && !allowZoom)
                    $("html, body").css("overflow", "hidden");
                else
                    $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar");
                $(metaSelector).attr("content", metaVerbs.join());
                $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
                if (DX.support.touch)
                    $(document).on("touchmove", function(e) {
                        var count = e.originalEvent.touches.length,
                            zoomDisabled = !allowZoom && count > 1,
                            panDisabled = !allowPan && count === 1 && !e.originalEvent.isScrollingEvent;
                        if (zoomDisabled || panDisabled)
                            e.preventDefault()
                    });
                if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
                    $(document.head).append($("<style/>").text("@-ms-viewport{ width:auto!important; user-zoom: fixed; max-zoom: 1; min-zoom: 1; }"));
                    $(window).bind("load resize", function(e) {
                        var TOP_BAR_W = 44,
                            TOP_BAR_H = 21,
                            ADDRESS_BAR_H = 72;
                        var isStandalone = 'Notify' in window.external;
                        var barWidth = isStandalone ? TOP_BAR_W : 0,
                            barHeight = isStandalone ? TOP_BAR_H : ADDRESS_BAR_H;
                        var actualHeight = $(window).width() < $(window).height() ? Math.round(screen.availHeight * (document.body.clientWidth / screen.availWidth)) - barHeight : Math.round(screen.availWidth * (document.body.clientHeight / screen.availHeight)) - barWidth;
                        document.body.style.setProperty("min-height", actualHeight + "px", "important")
                    })
                }
                var hideAddressBar = function() {
                        var ADDRESS_BAR_HEIGHT = 60,
                            isIphone = device.phone,
                            isSafari = !navigator.standalone && /safari/i.test(navigator.userAgent);
                        var doHide = function() {
                                window.scrollTo(0, 1)
                            };
                        var isInput = function($who) {
                                return $who.is(":input")
                            };
                        return function(e) {
                                var height,
                                    $target = $(e.target),
                                    $active = $(document.activeElement),
                                    isTouch = e.type === "touchstart";
                                if (isTouch) {
                                    if (isInput($target))
                                        return;
                                    if (isInput($active))
                                        $active.blur()
                                }
                                else if (isInput($active))
                                    return;
                                if (isIphone && isSafari) {
                                    height = $(window).height() + ADDRESS_BAR_HEIGHT;
                                    if ($(document.body).height() !== height)
                                        $(document.body).height(height)
                                }
                                doHide()
                            }
                    }();
                if (!inFrame && device.ios && DX.devices.iosVersion()[0] < 7) {
                    $(window).on("load resize touchstart", hideAddressBar);
                    $(function() {
                        $(document.body).on("focusout", function() {
                            var fix_Q477825 = window.pageYOffset
                        })
                    })
                }
            };
        var TemplateProvider = DX.Class.inherit({
                getTemplateClass: function(widget) {
                    return Template
                },
                supportDefaultTemplate: function(widget) {
                    return false
                },
                getDefaultTemplate: function(widget) {
                    return null
                }
            });
        var Template = DX.Class.inherit({
                ctor: function(element) {
                    this._template = this._element = $(element)
                },
                render: function(container) {
                    container.append(this._template);
                    return this._template
                },
                dispose: $.noop
            });
        DX.registerActionExecutor({
            designMode: {validate: function(e) {
                    if (DX.designMode && !(e.context instanceof ui.dxScrollable) && !(e.context instanceof ui.dxScrollView))
                        e.canceled = true
                }},
            gesture: {validate: function(e) {
                    var args = e.args,
                        context = e.context,
                        component = args.length && args[0].component,
                        recentGestureOwner = ui.gestureUtils.recentGestureOwner();
                    if (ui.gestureUtils.hasRecent() && !e.allowedForGesture && !($.isFunction(context) && recentGestureOwner instanceof context) && recentGestureOwner !== context && recentGestureOwner !== component)
                        e.canceled = true
                }},
            disabled: {validate: function(e) {
                    if (!e.args.length)
                        return;
                    var element = e.args[0].itemElement || e.args[0].element;
                    if (element && element.is(".dx-state-disabled, .dx-state-disabled *"))
                        e.canceled = true
                }}
        });
        $.extend(ui, {
            TemplateProvider: TemplateProvider,
            Template: Template,
            initViewport: initViewport
        });
        ui.__internals = {Template: Template}
    })(jQuery, DevExpress);
    /*! Module core, file ui.dialog.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var DEFAULT_BUTTON = {
                text: "Ok",
                clickAction: function() {
                    return true
                }
            };
        var DX_DIALOG_CLASSNAME = "dx-dialog",
            DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
            DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
            DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
            DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
            DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
        var dialog = function(options) {
                var self = this,
                    result;
                if (!ui.dxPopup)
                    throw new Error("DevExpress.ui.dxPopup required.");
                var deferred = $.Deferred();
                options = $.extend(ui.optionsByDevice(DX.devices.current(), "dxDialog"), options);
                var $holder = $(".dx-viewport");
                var $element = $("<div/>").addClass(DX_DIALOG_CLASSNAME).appendTo($holder);
                var $message = $("<div/>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
                var $buttons = $("<div/>").addClass(DX_DIALOG_BUTTONS_CLASSNAME);
                var popupInstance = $element.dxPopup({
                        title: options.title || self.title,
                        height: "auto",
                        width: function() {
                            var isPortrait = $(window).height() > $(window).width(),
                                key = (isPortrait ? "p" : "l") + "Width";
                            return options.hasOwnProperty(key) ? options[key] : options["width"]
                        }
                    }).data("dxPopup");
                $.each(options.buttons || [DEFAULT_BUTTON], function() {
                    var button = $("<div/>").addClass(DX_DIALOG_BUTTON_CLASSNAME).appendTo($buttons);
                    var action = new DX.Action(this.clickAction, {context: popupInstance});
                    button.dxButton($.extend(this, {clickAction: function() {
                            result = action.execute(arguments);
                            hide()
                        }}))
                });
                popupInstance._element().addClass(DX_DIALOG_ROOT_CLASSNAME);
                popupInstance.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message).append($buttons);
                function show() {
                    popupInstance.show();
                    return deferred.promise()
                }
                function hide(value) {
                    popupInstance.hide().done(function() {
                        popupInstance._element().remove()
                    });
                    deferred.resolve(result || value)
                }
                return {
                        show: show,
                        hide: hide
                    }
            };
        var alert = function(message, title) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message
                    };
                dialogInstance = ui.dialog.custom(options);
                return dialogInstance.show()
            };
        var confirm = function(message, title) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message,
                        buttons: [{
                                text: "Yes",
                                clickAction: function() {
                                    return true
                                }
                            }, {
                                text: "No",
                                clickAction: function() {
                                    return false
                                }
                            }]
                    };
                dialogInstance = ui.dialog.custom(options);
                return dialogInstance.show()
            };
        var notify = function(message, type, displayTime) {
                var instance,
                    options = $.isPlainObject(message) ? message : {message: message};
                if (!ui.dxToast) {
                    alert(options.message);
                    return
                }
                if (type)
                    options.type = type;
                if (displayTime)
                    options.displayTime = displayTime;
                instance = $("<div/>").appendTo($(".dx-viewport")).dxToast(options).data("dxToast");
                instance.option("hiddenAction", function() {
                    this._element().remove();
                    new DX.Action(options.hiddenAction, {context: this}).execute(arguments)
                });
                instance.show()
            };
        $.extend(ui, {
            notify: notify,
            dialog: {
                custom: dialog,
                alert: alert,
                confirm: confirm
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.knockoutIntegration.js */
    (function($, DX, undefined) {
        var ko = window.ko;
        if (!ko)
            return;
        (function checkKnockoutVersion(version) {
            version = version.split(".");
            if (version[0] < 2 || version[0] == 2 && version[1] < 2)
                throw Error("Your version of KnockoutJS is too old. Please upgrade KnockoutJS to 2.2.0 or later.");
        })(ko.version);
        var ui = DX.ui,
            inflector = DX.inflector,
            DATA_BIND_ATTR = "data-bind",
            ANONYMOUS_BINDING_KEY = "unknown",
            ANONYMOUS_OPTION_NAME_FOR_OPTIONS_BAG = "_";
        var LOCKS_DATA_KEY = "dxKoLocks",
            MODEL_TO_OPTIONS_LOCK_NAME = "M2O",
            OPTIONS_TO_MODEL_LOCK_NAME = "O2M",
            CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
        var defaultBindingProvider = ko.bindingProvider.instance,
            parseObjectLiteral = ko.jsonExpressionRewriting.parseObjectLiteral,
            bindingEvaluatorElement = $("<div></div>");
        var isComponentName = function(name) {
                return name in ui && ui[name].subclassOf && ui[name].subclassOf(ui.Component)
            };
        var stripQuotes = function(text) {
                return text.replace(/^['"]|['"]$/g, "")
            };
        var hideComponentBindings = function(element) {
                element = $(element);
                var bindingExpr = element.attr(DATA_BIND_ATTR);
                if (!bindingExpr)
                    return;
                var parsedBindingExpr = parseObjectLiteral(bindingExpr),
                    newBindingFragments = [],
                    found = false;
                $.each(parsedBindingExpr, function() {
                    var componentName = stripQuotes(this.key),
                        hiddenBindingsAttrName = "data-" + inflector.underscore(componentName);
                    if (isComponentName(componentName) && !element.attr(hiddenBindingsAttrName)) {
                        found = true;
                        element.attr(hiddenBindingsAttrName, this.value);
                        newBindingFragments.push({
                            key: componentName,
                            value: "true"
                        })
                    }
                    else
                        newBindingFragments.push(this)
                });
                if (found)
                    element.attr(DATA_BIND_ATTR, $.map(newBindingFragments, function(i) {
                        return i.key + ": " + i.value
                    }).join(", "))
            };
        var PatchedBindingProvider = {
                _original: defaultBindingProvider,
                nodeHasBindings: function(node) {
                    return defaultBindingProvider.nodeHasBindings(node)
                },
                getBindings: function(node, bindingContext) {
                    hideComponentBindings(node);
                    return defaultBindingProvider.getBindings(node, bindingContext)
                }
            };
        var Locks = function() {
                var info = {};
                var currentCount = function(lockName) {
                        return info[lockName] || 0
                    };
                return {
                        obtain: function(lockName) {
                            info[lockName] = currentCount(lockName) + 1
                        },
                        release: function(lockName) {
                            var count = currentCount(lockName);
                            if (count < 1)
                                throw Error("Not locked");
                            if (count === 1)
                                delete info[lockName];
                            else
                                info[lockName] = count - 1
                        },
                        locked: function(lockName) {
                            return currentCount(lockName) > 0
                        }
                    }
            };
        var registerComponentKoBinding = function(componentName) {
                var parseHiddenBindings = function(element) {
                        var bindingString = $.trim(element.attr("data-" + inflector.underscore(componentName))),
                            result,
                            firstItem;
                        if (bindingString.charAt(0) === "{") {
                            result = parseObjectLiteral(bindingString);
                            firstItem = result[0];
                            if (firstItem && ANONYMOUS_BINDING_KEY in firstItem)
                                result = $.trim(firstItem[ANONYMOUS_BINDING_KEY])
                        }
                        else
                            result = bindingString;
                        if (result === "")
                            result = [];
                        return result
                    };
                ko.bindingHandlers[componentName] = {init: function(domNode) {
                        var element = $(domNode),
                            parsedBindings = parseHiddenBindings(element),
                            ctorOptions = {},
                            optionNameToModelMap = {};
                        var evalModelValue = function(optionName, modelValueExpr) {
                                bindingEvaluatorElement.attr(DATA_BIND_ATTR, optionName + ":" + modelValueExpr);
                                try {
                                    return defaultBindingProvider.getBindings(bindingEvaluatorElement[0], ko.contextFor(domNode))[optionName]
                                }
                                finally {
                                    bindingEvaluatorElement.removeAttr(DATA_BIND_ATTR)
                                }
                            };
                        var applyModelValueToOption = function(optionName, modelValue) {
                                var component = element.data(componentName),
                                    locks = element.data(LOCKS_DATA_KEY),
                                    optionValue = ko.utils.unwrapObservable(modelValue);
                                if (!component) {
                                    ctorOptions[optionName] = optionValue;
                                    if (ko.isWriteableObservable(modelValue))
                                        optionNameToModelMap[optionName] = modelValue
                                }
                                else {
                                    if (locks.locked(OPTIONS_TO_MODEL_LOCK_NAME))
                                        return;
                                    locks.obtain(MODEL_TO_OPTIONS_LOCK_NAME);
                                    try {
                                        component.option(optionName, optionValue)
                                    }
                                    finally {
                                        locks.release(MODEL_TO_OPTIONS_LOCK_NAME)
                                    }
                                }
                            };
                        var handleOptionChanged = function(optionName, optionValue) {
                                if (!(optionName in optionNameToModelMap))
                                    return;
                                var element = this._$element,
                                    locks = element.data(LOCKS_DATA_KEY);
                                if (locks.locked(MODEL_TO_OPTIONS_LOCK_NAME))
                                    return;
                                locks.obtain(OPTIONS_TO_MODEL_LOCK_NAME);
                                try {
                                    optionNameToModelMap[optionName](optionValue)
                                }
                                finally {
                                    locks.release(OPTIONS_TO_MODEL_LOCK_NAME)
                                }
                            };
                        ko.utils.domNodeDisposal.addDisposeCallback(domNode, function() {
                            $.each(element.data("dxComponents") || [], function(index, item) {
                                element.data(item)._dispose()
                            })
                        });
                        if (typeof parsedBindings === "string")
                            ko.computed(function() {
                                var cmp = element.data(componentName);
                                if (cmp)
                                    cmp.beginUpdate();
                                $.each(ko.utils.unwrapObservable(evalModelValue(ANONYMOUS_OPTION_NAME_FOR_OPTIONS_BAG, parsedBindings)), applyModelValueToOption);
                                if (cmp)
                                    cmp.endUpdate()
                            }, null, {disposeWhenNodeIsRemoved: domNode});
                        else
                            $.each(parsedBindings, function() {
                                var optionName = stripQuotes($.trim(this.key)),
                                    modelValueExpr = $.trim(this.value);
                                ko.computed(function() {
                                    var modelValue = evalModelValue(optionName, modelValueExpr);
                                    applyModelValueToOption(optionName, modelValue)
                                }, null, {disposeWhenNodeIsRemoved: domNode})
                            });
                        if (ctorOptions) {
                            element.data(CREATED_WITH_KO_DATA_KEY, true);
                            element[componentName](ctorOptions);
                            ctorOptions = null;
                            element.data(LOCKS_DATA_KEY, new Locks);
                            element.data(componentName).optionChanged.add(handleOptionChanged)
                        }
                        return {controlsDescendantBindings: ui[componentName].subclassOf(ui.Widget)}
                    }}
            };
        ko.bindingProvider.instance = PatchedBindingProvider;
        var KoTemplate = ui.Template.inherit({
                ctor: function(element) {
                    this.callBase.apply(this, arguments);
                    this._template = $("<div />").append(element);
                    this._cleanTemplateElement();
                    this._registerKoTemplate()
                },
                _cleanTemplateElement: function() {
                    this._element.each(function() {
                        ko.cleanNode(this)
                    })
                },
                _registerKoTemplate: function() {
                    var template = this._template.get(0);
                    new ko.templateSources.anonymousTemplate(template)['nodes'](template)
                },
                render: function(container, data) {
                    if (!$(container).closest("body").length)
                        throw Error("Attempt to render into container detached from document");
                    data = data !== undefined ? data : ko.dataFor(container.get(0)) || {};
                    var containerBindingContext = ko.contextFor(container[0]);
                    var bindingContext = containerBindingContext ? containerBindingContext.createChildContext(data) : data;
                    var renderBag = $("<div />").appendTo(container);
                    ko.renderTemplate(this._template.get(0), bindingContext, null, renderBag.get(0));
                    var result = renderBag.contents();
                    container.append(result);
                    renderBag.remove();
                    return result
                },
                dispose: function() {
                    this._cleanTemplateElement();
                    this._element.remove();
                    this._template.remove()
                }
            });
        var KoTemplateProvider = ui.TemplateProvider.inherit({
                getTemplateClass: function(widget) {
                    if (this._createdWithKo(widget))
                        return KoTemplate;
                    return this.callBase(widget)
                },
                supportDefaultTemplate: function(widget) {
                    return this._createdWithKo(widget) ? true : this.callBase(widget)
                },
                getDefaultTemplate: function(widget) {
                    if (this._createdWithKo(widget))
                        return defaultKoTemplate(widget.NAME)
                },
                _createdWithKo: function(widget) {
                    return !!widget._element().data(CREATED_WITH_KO_DATA_KEY)
                }
            });
        ko.bindingHandlers.dxAction = {update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                var $element = $(element);
                var actionSource = ko.utils.unwrapObservable(valueAccessor()),
                    action = new DX.Action(actionSource, {context: element});
                $element.off(".dxActionBinding").on("click.dxActionBinding", function() {
                    action.execute({
                        element: $element,
                        model: viewModel,
                        evaluate: function(expression) {
                            var context = viewModel;
                            if (expression.length > 0 && expression[0] === "$")
                                context = ko.contextFor(element);
                            var getter = DX.data.utils.compileGetter(expression);
                            return getter(context)
                        }
                    })
                })
            }};
        var defaultKoTemplate = function() {
                var cache = {};
                return function(widgetName) {
                        if (!DEFAULT_ITEM_TEMPLATE_GENERATORS[widgetName])
                            widgetName = "base";
                        if (!cache[widgetName]) {
                            var html = DEFAULT_ITEM_TEMPLATE_GENERATORS[widgetName](),
                                markup = DX.utils.createMarkupFromString(html);
                            markup.each(function() {
                                hideComponentBindings($(this))
                            });
                            cache[widgetName] = new KoTemplate(markup)
                        }
                        return cache[widgetName]
                    }
            }();
        var createElementWithBindAttr = function(tagName, bindings, closeTag) {
                closeTag = closeTag === undefined ? true : closeTag;
                var bindAttr = $.map(bindings, function(value, key) {
                        return key + ":" + value
                    }).join(",");
                return "<" + tagName + " data-bind=\"" + bindAttr + "\">" + (closeTag ? "</" + tagName + ">" : "")
            };
        var defaultKoTemplateBasicBindings = {
                visible: "$data.visible === undefined || $data.visible",
                css: "{ 'dx-state-disabled': $data.disabled }"
            };
        var DEFAULT_ITEM_TEMPLATE_GENERATORS = {base: function() {
                    var template = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                        htmlBinding = createElementWithBindAttr("div", {html: "html"}),
                        textBinding = createElementWithBindAttr("div", {text: "text"}),
                        primitiveBinding = createElementWithBindAttr("div", {html: "String($data)"});
                    template.push("<!-- ko if: $data.html -->", htmlBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>");
                    return template.join("")
                }};
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxList = function() {
            var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
                keyBinding = createElementWithBindAttr("div", {html: "key"});
            template = [template.substring(0, template.length - 6), "<!-- ko if: $data.key -->" + keyBinding + "<!-- /ko -->", "</div>"];
            return template.join("")
        };
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxToolbar = function() {
            var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base();
            template = [template.substring(0, template.length - 6), "<!-- ko if: $data.widget -->"];
            $.each(["button", "tabs", "dropDownMenu"], function() {
                var bindingName = DX.inflector.camelize(["dx", "-", this].join("")),
                    bindingObj = {};
                bindingObj[bindingName] = "$data.options";
                template.push("<!-- ko if: $data.widget === '", this, "' -->", createElementWithBindAttr("div", bindingObj), "<!-- /ko -->")
            });
            template.push("<!-- /ko -->");
            return template.join("")
        };
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxGallery = function() {
            var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
                primitiveBinding = createElementWithBindAttr("div", {html: "String($data)"}),
                imgBinding = createElementWithBindAttr("img", {attr: "{ src: String($data) }"}, false);
            template = template.replace(primitiveBinding, imgBinding);
            return template
        };
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxTabs = function() {
            var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
                baseTextBinding = createElementWithBindAttr("div", {text: "text"}),
                iconBinding = createElementWithBindAttr("span", {
                    attr: "{ 'class': 'dx-icon-' + $data.icon }",
                    css: "{ 'dx-icon': true }"
                }),
                iconSrcBinding = createElementWithBindAttr("img", {
                    attr: "{ src: $data.iconSrc }",
                    css: "{ 'dx-icon': true }"
                }, false),
                textBinding = "<!-- ko if: $data.icon -->" + iconBinding + "<!-- /ko -->" + "<!-- ko if: !$data.icon && $data.iconSrc -->" + iconSrcBinding + "<!-- /ko -->" + "<span class=\"dx-tab-text\" data-bind=\"text: $data.text\"></span>";
            template = template.replace("<!-- ko if: !$data.html && $data.text -->", "<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(baseTextBinding, textBinding);
            return template
        };
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxActionSheet = function() {
            return createElementWithBindAttr("div", {dxButton: "{ text: $data.text, clickAction: $data.clickAction, type: $data.type, disabled: !!$data.disabled }"})
        };
        DEFAULT_ITEM_TEMPLATE_GENERATORS.dxNavBar = DEFAULT_ITEM_TEMPLATE_GENERATORS.dxTabs;
        $.extend(ui, {
            registerComponentKoBinding: registerComponentKoBinding,
            TemplateProvider: KoTemplateProvider,
            Template: KoTemplate,
            defaultTemplate: defaultKoTemplate
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.gestureUtils.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.support,
            TOUCH = support.touch,
            UNLOCK_ACTION_TIMEOUT = 400;
        var gestureUtils = function() {
                var unlockActionTimer = null,
                    gestureStartCallbacks = $.Callbacks(),
                    gestureOwner;
                var notifyGestureStart = function(owner) {
                        gestureOwner = owner || this;
                        clearTimeout(unlockActionTimer);
                        unlockActionTimer = null;
                        gestureStartCallbacks.fire()
                    };
                var notifyGestureEnd = function(owner) {
                        if (unlockActionTimer)
                            return;
                        if (owner && gestureOwner !== owner)
                            return;
                        unlockActionTimer = setTimeout(function() {
                            gestureOwner = undefined;
                            unlockActionTimer = null
                        }, UNLOCK_ACTION_TIMEOUT)
                    };
                var forgetRecentGesture = function(owner) {
                        if (owner && gestureOwner !== owner)
                            return;
                        gestureOwner = undefined;
                        clearTimeout(unlockActionTimer);
                        unlockActionTimer = null
                    };
                var recentGestureOwner = function() {
                        return gestureOwner
                    };
                var hasRecentGesture = function() {
                        return !!gestureOwner
                    };
                var android4nativeBrowser = /^4\.0/.test(DX.devices.androidVersion()) && navigator.userAgent.indexOf("Chrome") === -1;
                var preventHangingCursor = function() {
                        if (TOUCH)
                            if (android4nativeBrowser)
                                androidInputBlur();
                            else if (document.activeElement)
                                document.activeElement.blur()
                    };
                var androidInputBlur = function() {
                        var $specInput = $("<input>").addClass("dx-hidden-input").appendTo("body");
                        setTimeout(function() {
                            $specInput.focus();
                            setTimeout(function() {
                                $specInput.hide();
                                $specInput.remove()
                            }, 100)
                        }, 100)
                    };
                var preventNativeElastic = function(e) {
                        if (TOUCH)
                            e.preventDefault()
                    };
                var needSkipEvent = function(e) {
                        return $(e.target).is("input, textarea, select")
                    };
                return {
                        gestureStartCallbacks: gestureStartCallbacks,
                        preventHangingCursor: preventHangingCursor,
                        preventNativeElastic: preventNativeElastic,
                        needSkipEvent: needSkipEvent,
                        notifyStart: notifyGestureStart,
                        notifyEnd: notifyGestureEnd,
                        hasRecent: hasRecentGesture,
                        recentGestureOwner: recentGestureOwner,
                        forget: forgetRecentGesture
                    }
            }();
        gestureUtils.__internals = {
            UNLOCK_ACTION_TIMEOUT: UNLOCK_ACTION_TIMEOUT,
            setUnlockTimeout: function(timeout) {
                UNLOCK_ACTION_TIMEOUT = timeout
            }
        };
        ui.gestureUtils = gestureUtils
    })(jQuery, DevExpress);
    /*! Module core, file ui.dataHelper.js */
    (function($, DX, undefined) {
        var data = DX.data;
        var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
            DATA_SOURCE_CHANGED_METHOD = "_handleDataSourceChanged",
            DATA_SOURCE_LOAD_ERROR_METHOD = "_handleDataSourceLoadError";
        DX.ui.DataHelperMixin = {
            ctor: function() {
                this.disposing.add(function() {
                    this._disposeDataSource()
                })
            },
            _initDataSource: function() {
                var self = this,
                    dataSourceOptions = self.option("dataSource"),
                    dataSource,
                    widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {},
                    dataSourceType = self._dataSourceType ? self._dataSourceType() : data.SimpleDataSource;
                self._disposeDataSource();
                if (!dataSourceOptions)
                    return;
                if ($.isArray(dataSourceOptions))
                    dataSource = new data.ArrayStore(dataSourceOptions).toDataSource(widgetDataSourceOptions, dataSourceType);
                else if ($.isPlainObject(dataSourceOptions))
                    if ('load' in dataSourceOptions)
                        dataSource = data.createDataSource(dataSourceOptions);
                    else {
                        if (!dataSourceOptions.store && !DX.designMode)
                            throw Error("Please specify 'load' function for the dataSource");
                        dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, dataSourceOptions))
                    }
                else if (dataSourceOptions instanceof data.DataSource) {
                    self._sharedDataSource = true;
                    dataSource = dataSourceOptions
                }
                else if (dataSourceOptions instanceof data.Store)
                    dataSource = dataSourceOptions.toDataSource(widgetDataSourceOptions, dataSourceType);
                else
                    throw Error("Invalid dataSource option");
                self._dataSource = dataSource;
                dataSource.changed.add(self._dataSourceChangedHandler = function() {
                    self._dataSourceLoading = false;
                    self[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
                });
                if (DATA_SOURCE_LOAD_ERROR_METHOD in self)
                    dataSource.loadError.add(self._dataSourceLoadErrorHandler = $.proxy(self[DATA_SOURCE_LOAD_ERROR_METHOD], self))
            },
            _loadDataSource: function() {
                var ds = this._dataSource;
                if (!ds)
                    return;
                if (ds.isLoaded())
                    this._dataSourceChangedHandler();
                else {
                    this._dataSourceLoading = true;
                    ds.load()
                }
            },
            _disposeDataSource: function() {
                if (!this._dataSource)
                    return;
                if (!this._sharedDataSource)
                    this._dataSource.dispose();
                else {
                    delete this._sharedDataSource;
                    this._dataSource.changed.remove(this._dataSourceChangedHandler);
                    this._dataSource.loadError.remove(this._dataSourceLoadErrorHandler)
                }
                delete this._dataSource;
                delete this._dataSourceChangedHandler;
                delete this._dataSourceLoadErrorHandler
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.eventHelper.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            gestureUtils = ui.gestureUtils;
        var EventHelper = DX.Class.inherit({
                EVENT_SOURCES_REGEX: {
                    mouse: /^mouse/i,
                    touch: /^touch/i,
                    keyboard: /^key/i
                },
                EVENTS: {
                    click: "click",
                    start: "touchstart mousedown",
                    move: "touchmove mousemove",
                    end: "touchend mouseup",
                    cancel: "touchcancel",
                    wheel: "mousewheel"
                },
                ctor: function(namespace) {
                    this._namespace = namespace
                },
                eventSource: function(e) {
                    var result = "other";
                    $.each(this.EVENT_SOURCES_REGEX, function(key) {
                        if (this.test(e.type)) {
                            result = key;
                            return false
                        }
                    });
                    return result
                },
                isMouseEvent: function(e) {
                    return this.eventSource(e) === "mouse"
                },
                isTouchEvent: function(e) {
                    return this.eventSource(e) === "touch"
                },
                isKeyboardEvent: function() {
                    return this.eventSource(e) === "keyboard"
                },
                eventName: function(type) {
                    var self = this;
                    var events = this.EVENTS[type] || type;
                    events = events.split(/\s+/g);
                    $.each(events, function(index, eventName) {
                        events[index] = eventName + "." + self._namespace
                    });
                    return events.join(" ")
                },
                eventX: function(e) {
                    if (this.isMouseEvent(e))
                        return e.pageX;
                    if (this.isTouchEvent(e))
                        return e.originalEvent.touches[0].pageX
                },
                eventY: function(e) {
                    if (this.isMouseEvent(e))
                        return e.pageY;
                    if (this.isTouchEvent(e))
                        return e.originalEvent.touches[0].pageY
                },
                eventData: function(e) {
                    if (this.isMouseEvent(e))
                        return {
                                x: e.pageX,
                                y: e.pageY,
                                time: e.timeStamp
                            };
                    if (this.isTouchEvent(e)) {
                        var touch = (e.changedTouches || e.originalEvent.changedTouches)[0];
                        return {
                                x: touch.pageX,
                                y: touch.pageY,
                                time: e.timeStamp
                            }
                    }
                },
                eventDelta: function(from, to) {
                    return {
                            x: to.x - from.x,
                            y: to.y - from.y,
                            time: to.time - from.time || 1
                        }
                },
                hasTouches: function(e) {
                    if (this.isMouseEvent(e))
                        return 0;
                    if (this.isTouchEvent(e))
                        return e.originalEvent.touches.length
                },
                needSkipEvent: function(e) {
                    if (this.isMouseEvent(e))
                        return gestureUtils.needSkipEvent(e) || e.which > 1;
                    if (this.isTouchEvent(e))
                        return (e.changedTouches || e.originalEvent.changedTouches).length !== 1
                }
            });
        var MOUSE_EVENT_LOCK_TIMEOUT = 400,
            mouseLocked = false,
            unlockMouseTimer = null;
        DX.registerActionExecutor("ignoreMouseAfterTouch", {validate: function(e) {
                var event = e.args[0];
                if (event && event.jQueryEvent)
                    event = event.jQueryEvent;
                if (!(event instanceof $.Event))
                    return;
                if (EventHelper.prototype.isTouchEvent(event)) {
                    mouseLocked = true;
                    clearTimeout(unlockMouseTimer);
                    unlockMouseTimer = setTimeout(function() {
                        mouseLocked = false
                    }, MOUSE_EVENT_LOCK_TIMEOUT)
                }
                else if (EventHelper.prototype.isMouseEvent(event))
                    if (mouseLocked)
                        e.canceled = true
            }});
        DX.ui.EventHelper = EventHelper
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.js */
    (function($, DX, undefined) {
        var EVENTS_NAME_SPACE = "dxSpecialEvents",
            HOLD_TIMER_DATA_KEY = EVENTS_NAME_SPACE + "HoldTimer";
        var eventHelper = new DX.ui.EventHelper(EVENTS_NAME_SPACE),
            startEventName = eventHelper.eventName("start"),
            endEventName = eventHelper.eventName("end"),
            cancelEventName = eventHelper.eventName("cancel"),
            eventNS = $.event,
            specialNS = eventNS.special;
        var hold = specialNS["dx:hold"] = {
                HOLD_TIMEOUT: 750,
                setup: function(data) {
                    var element = this,
                        $element = $(element);
                    var handleStart = function(e) {
                            if ($element.data(HOLD_TIMER_DATA_KEY))
                                return;
                            $element.data(HOLD_TIMER_DATA_KEY, setTimeout(function() {
                                $element.removeData(HOLD_TIMER_DATA_KEY);
                                eventNS.dispatch.call(element, $.Event("dx:hold", {target: e.target}))
                            }, data && "timeout" in data ? data.timeout : hold.HOLD_TIMEOUT))
                        };
                    var handleEnd = function() {
                            clearTimeout($element.data(HOLD_TIMER_DATA_KEY));
                            $element.removeData(HOLD_TIMER_DATA_KEY)
                        };
                    $element.on(startEventName + ".dxHold", handleStart).on(endEventName + ".dxHold", handleEnd)
                },
                teardown: function() {
                    var $element = $(this);
                    clearTimeout($element.data(HOLD_TIMER_DATA_KEY));
                    $element.removeData(HOLD_TIMER_DATA_KEY).off(".dxHold")
                }
            };
        var MOUSE_EVENT_LOCK_TIMEOUT = 600,
            mouseLocked = false,
            unlockMouseTimer = null;
        var click = specialNS["dx:click"] = {
                TOUCH_BOUNDARY: 10,
                _trackingClick: false,
                _skipNextClick: false,
                _$target: null,
                _startX: 0,
                _startY: 0,
                _touchWasMoved: function(e) {
                    var eventData = eventHelper.eventData(e),
                        boundary = click.TOUCH_BOUNDARY;
                    return Math.abs(eventData.x - click._startX) > boundary || Math.abs(eventData.y - click._startY) > boundary
                },
                _handleStart: function(e) {
                    if (eventHelper.isMouseEvent(e))
                        return;
                    var targetTouches = e.originalEvent.targetTouches,
                        touch = targetTouches[0];
                    if (targetTouches.length > 1)
                        return;
                    click._trackingClick = true;
                    click._$target = $(e.target);
                    click._startX = touch.pageX;
                    click._startY = touch.pageY
                },
                _handleClick: function(e) {
                    if (!click._skipNextClick) {
                        e.type = "dx:click";
                        $(e.currentTarget).trigger(e)
                    }
                    click._skipNextClick = false
                },
                _handleEnd: function(e) {
                    if (eventHelper.isTouchEvent(e)) {
                        mouseLocked = true;
                        clearTimeout(unlockMouseTimer);
                        unlockMouseTimer = setTimeout(function() {
                            mouseLocked = false
                        }, MOUSE_EVENT_LOCK_TIMEOUT)
                    }
                    else if (eventHelper.isMouseEvent(e))
                        if (mouseLocked)
                            click._skipNextClick = true;
                    if (eventHelper.isMouseEvent(e))
                        return;
                    if (click._touchWasMoved(e)) {
                        click._trackingClick = false;
                        click._$target = null
                    }
                    if (!click._trackingClick)
                        return;
                    click._trackingClick = false;
                    click._$target.trigger("dx:click")
                },
                _handleCancel: function() {
                    click._trackingClick = false;
                    click._$target = null
                },
                setup: function() {
                    $(this).on(["click", EVENTS_NAME_SPACE, "dxClick"].join("."), $.proxy(click._handleClick, this)).on(startEventName + ".dxClick", $.proxy(click._handleStart, this)).on(endEventName + ".dxClick", $.proxy(click._handleEnd, this)).on(cancelEventName + ".dxClick", $.proxy(click._handleCancel, this))
                },
                teardown: function() {
                    $(this).off(".dxClick")
                }
            }
    })(jQuery, DevExpress);
    /*! Module core, file ui.component.js */
    (function($, DX, undefined) {
        var COMPONENT_NAMES_DATA_KEY = "dxComponents",
            HAS_KO = !!window.ko,
            ui = DX.ui,
            dataUtils = DX.data.utils,
            DISABLED_STATE_CLASS = "dx-state-disabled";
        var Component = DX.Class.inherit({
                NAME: null,
                _defaultOptions: function() {
                    return {disabled: false}
                },
                ctor: function(element, options) {
                    if (!this.NAME)
                        throw Error("NAME is not specified");
                    this._$element = $(element);
                    this._element().data(this.NAME, this);
                    if (!this._element().data(COMPONENT_NAMES_DATA_KEY))
                        this._element().data(COMPONENT_NAMES_DATA_KEY, []);
                    this._element().data(COMPONENT_NAMES_DATA_KEY).push(this.NAME);
                    this._options = {};
                    this._updateLockCount = 0;
                    this._requireRefresh = false;
                    this._eventHelper = new ui.EventHelper(this.NAME);
                    this.optionChanged = $.Callbacks();
                    this.disposing = $.Callbacks();
                    this.beginUpdate();
                    try {
                        var device = DX.devices.current(),
                            optionsByDevice = ui.optionsByDevice(device, this.NAME) || {},
                            defaultOptions = $.extend(this._defaultOptions(), optionsByDevice);
                        this.option(defaultOptions);
                        this._initOptions(options || {})
                    }
                    finally {
                        this.endUpdate()
                    }
                },
                _initOptions: function(options) {
                    this.option(options)
                },
                _optionValuesEqual: function(name, oldValue, newValue) {
                    oldValue = dataUtils.toComparable(oldValue, true);
                    newValue = dataUtils.toComparable(newValue, true);
                    if (oldValue === null || typeof oldValue !== "object")
                        return oldValue === newValue;
                    return false
                },
                _init: $.noop,
                _render: function() {
                    this._renderDisabledState()
                },
                _clean: $.noop,
                _invalidate: function() {
                    if (!this._updateLockCount)
                        throw Error("Invalidate called outside update transaction");
                    this._requireRefresh = true
                },
                _refresh: function() {
                    this._clean();
                    this._render()
                },
                _dispose: function() {
                    this._clean();
                    this.optionChanged.empty();
                    this.disposing.fireWith(this).empty()
                },
                _renderDisabledState: function() {
                    this._element().toggleClass(DISABLED_STATE_CLASS, this.option("disabled"))
                },
                _createAction: function(actionSource, config) {
                    var self = this;
                    config = $.extend({}, config);
                    var element = config.element || self._element(),
                        model = self._modelByElement(element);
                    config.context = model || self;
                    config.component = self;
                    var action = new DX.Action(actionSource, config);
                    return function(e) {
                            if (!arguments.length)
                                e = {};
                            if (e instanceof $.Event)
                                throw Error("Action must be executed with jQuery.Event like action({ jQueryEvent: event })");
                            if (!$.isPlainObject(e))
                                e = {actionValue: e};
                            return action.execute.call(action, $.extend(e, {
                                    component: self,
                                    element: element,
                                    model: model
                                }))
                        }
                },
                _createActionByOption: function(optionName, config) {
                    if (typeof optionName !== "string")
                        throw Error("Option name type is unexpected");
                    return this._createAction(this.option(optionName), config)
                },
                _modelByElement: function(element) {
                    if (HAS_KO && element.length)
                        return ko.dataFor(element.get(0))
                },
                _optionChanged: function(name, value, prevValue) {
                    if (name === "disabled")
                        this._renderDisabledState();
                    else
                        this._invalidate()
                },
                _element: function() {
                    return this._$element
                },
                instance: function() {
                    return this
                },
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount--;
                    if (!this._updateLockCount)
                        if (!this._initializing && !this._initialized) {
                            this._initializing = true;
                            try {
                                this._init()
                            }
                            finally {
                                this._initializing = false;
                                this._initialized = true
                            }
                            this._render()
                        }
                        else if (this._requireRefresh) {
                            this._requireRefresh = false;
                            this._refresh()
                        }
                },
                option: function(options) {
                    var self = this,
                        name = options,
                        value = arguments[1];
                    if (arguments.length < 2 && $.type(name) !== "object")
                        return dataUtils.compileGetter(name)(self._options, {functionsAsIs: true});
                    if (typeof name === "string") {
                        options = {};
                        options[name] = value
                    }
                    self.beginUpdate();
                    try {
                        $.each(options, function(name, value) {
                            var prevValue = dataUtils.compileGetter(name)(self._options, {functionsAsIs: true}),
                                topLevelName;
                            if (self._optionValuesEqual(name, prevValue, value))
                                return;
                            dataUtils.compileSetter(name)(self._options, value, {
                                functionsAsIs: true,
                                merge: true
                            });
                            topLevelName = name.split(/[.\[]/)[0];
                            if (self._initialized) {
                                self.optionChanged.fireWith(self, [topLevelName, value, prevValue]);
                                self._optionChanged(topLevelName, value, prevValue)
                            }
                        })
                    }
                    finally {
                        self.endUpdate()
                    }
                }
            });
        var registerComponent = function(name, componentClass) {
                ui[name] = componentClass;
                componentClass.prototype.NAME = name;
                $.fn[name] = function(options) {
                    var isMemberInvoke = typeof options === "string",
                        result = this;
                    if (isMemberInvoke) {
                        var memberName = options,
                            memberArgs = $.makeArray(arguments).slice(1);
                        this.each(function() {
                            var instance = $(this).data(name);
                            if (!instance)
                                throw Error("Component " + name + " has not been initialized on this element");
                            var member = instance[memberName],
                                memberValue = member.apply(instance, memberArgs);
                            if (memberValue !== undefined) {
                                result = memberValue;
                                return false
                            }
                        })
                    }
                    else
                        this.each(function() {
                            var instance = $(this).data(name);
                            if (instance)
                                instance.option(options);
                            else
                                new componentClass(this, options)
                        });
                    return result
                };
                if (HAS_KO)
                    ui.registerComponentKoBinding(name)
            };
        var getComponents = function(element) {
                element = $(element);
                var names = element.data(COMPONENT_NAMES_DATA_KEY);
                if (!names)
                    return [];
                return $.map(names, function(name) {
                        return element.data(name)
                    })
            };
        function cleanComponentsAndKoData(element, andSelf) {
            element.each(function() {
                var all = this.getElementsByTagName ? this.getElementsByTagName("*") : [];
                if (andSelf)
                    all = jQuery.merge([this], all);
                for (var i = 0, item; (item = all[i]) != null; i++) {
                    $.each(getComponents(item), function() {
                        this._dispose()
                    });
                    if (HAS_KO)
                        ko.cleanNode(item)
                }
            })
        }
        var originalEmpty = $.fn.empty;
        $.fn.empty = function() {
            cleanComponentsAndKoData(this, false);
            return originalEmpty.apply(this, arguments)
        };
        var originalRemove = $.fn.remove;
        $.fn.remove = function(selector, keepData) {
            if (!keepData) {
                var subject = this;
                if (selector)
                    subject = subject.filter(selector);
                cleanComponentsAndKoData(subject, true)
            }
            return originalRemove.call(this, selector, keepData)
        };
        var originalHtml = $.fn.html;
        $.fn.html = function(value) {
            if (typeof value === "string")
                cleanComponentsAndKoData(this, false);
            return originalHtml.apply(this, arguments)
        };
        var originalParseHtml = $.parseHTML;
        $.parseHTML = function() {
            return originalParseHtml.apply(this, arguments) || []
        };
        $.extend(ui, {
            registerComponent: registerComponent,
            Component: Component
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.widget.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            UI_FEEDBACK = "UIFeedback",
            UI_FEEDBACK_CLASS = "dx-feedback",
            ACTIVE_STATE_CLASS = "dx-state-active",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            FEEDBACK_SHOW_TIMEOUT = 30,
            FEEDBACK_HIDE_TIMEOUT = 400;
        var activeElement,
            eventHelper = new ui.EventHelper(UI_FEEDBACK),
            feedbackLocked = false;
        ui.feedback = {
            lock: function() {
                feedbackLocked = true
            },
            unlock: function() {
                window.setTimeout(function() {
                    feedbackLocked = false
                }, 0)
            }
        };
        ui.Widget = ui.Component.inherit({
            _defaultOptions: function() {
                return $.extend(this.callBase(), {
                        visible: true,
                        activeStateEnabled: true,
                        width: undefined,
                        height: undefined,
                        clickAction: null
                    })
            },
            _init: function() {
                this.callBase();
                this._feedbackShowTimeout = FEEDBACK_SHOW_TIMEOUT
            },
            _render: function() {
                this.callBase();
                this._element().addClass("dx-widget");
                this._toggleVisibility(this.option("visible"));
                this._refreshFeedback();
                this._renderDimensions();
                this._renderClick()
            },
            _dispose: function() {
                this._clearTimers();
                if (activeElement && activeElement.closest(this._element()).length)
                    activeElement = null;
                this._clickAction = null;
                this.callBase()
            },
            _clean: function() {
                this.callBase();
                this._element().empty()
            },
            _clearTimers: function() {
                clearTimeout(this._feedbackHideTimer);
                clearTimeout(this._feedbackShowTimer)
            },
            _toggleVisibility: function(visible) {
                this._element().toggleClass(INVISIBLE_STATE_CLASS, !visible)
            },
            _renderDimensions: function() {
                var width = this.option("width"),
                    height = this.option("height");
                this._element().width(width);
                this._element().height(height)
            },
            _refreshFeedback: function() {
                if (this._feedbackDisabled()) {
                    this._feedbackOff();
                    this._element().removeClass(UI_FEEDBACK_CLASS)
                }
                else
                    this._element().addClass(UI_FEEDBACK_CLASS)
            },
            _renderClick: function() {
                var self = this,
                    eventName = self._eventHelper.eventName("click");
                self._clickAction = self._createActionByOption("clickAction");
                self._element().off(eventName).on(eventName, function(e) {
                    self._clickAction({jQueryEvent: e})
                })
            },
            _feedbackDisabled: function() {
                return !this.option("activeStateEnabled") || this.option("disabled")
            },
            _feedbackOn: function(element, immediate) {
                if (this._feedbackDisabled() || feedbackLocked)
                    return;
                this._clearTimers();
                if (immediate)
                    this._feedbackShow(element);
                else
                    this._feedbackShowTimer = window.setTimeout($.proxy(this._feedbackShow, this, element), this._feedbackShowTimeout);
                this._saveActiveElement()
            },
            _feedbackShow: function(element) {
                var activeStateElement = this._element();
                if (this._activeStateUnit)
                    activeStateElement = $(element).closest(this._activeStateUnit);
                if (!activeStateElement.hasClass(DISABLED_STATE_CLASS))
                    activeStateElement.addClass(ACTIVE_STATE_CLASS)
            },
            _saveActiveElement: function() {
                activeElement = this._element()
            },
            _feedbackOff: function(isGestureStart, immediate) {
                this._clearTimers();
                if (immediate)
                    this._feedbackHide();
                else
                    this._feedbackHideTimer = window.setTimeout($.proxy(this._feedbackHide, this), FEEDBACK_HIDE_TIMEOUT)
            },
            _feedbackHide: function() {
                var activeStateElement = this._element();
                if (this._activeStateUnit)
                    activeStateElement = activeStateElement.find(this._activeStateUnit);
                activeStateElement.removeClass(ACTIVE_STATE_CLASS);
                this._clearActiveElement()
            },
            _clearActiveElement: function() {
                var rootDomElement = this._element().get(0),
                    activeDomElement = activeElement && activeElement.get(0);
                if (activeDomElement && (activeDomElement === rootDomElement || $.contains(rootDomElement, activeDomElement)))
                    activeElement = null
            },
            _optionChanged: function(name, value) {
                switch (name) {
                    case"disabled":
                        this.callBase.apply(this, arguments);
                    case"activeStateEnabled":
                        this._refreshFeedback();
                        break;
                    case"visible":
                        this._toggleVisibility(value);
                        break;
                    case"width":
                    case"height":
                        this._renderDimensions();
                        break;
                    case"clickAction":
                        this._renderClick();
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            }
        });
        var handleStart = function(e, immediate) {
                if (eventHelper.needSkipEvent(e))
                    return;
                if (activeElement)
                    getWidget(activeElement)._feedbackOff(false, true);
                var closestFeedbackElement = $(e.target).closest("." + UI_FEEDBACK_CLASS),
                    widget;
                if (closestFeedbackElement.length) {
                    widget = getWidget(closestFeedbackElement);
                    widget._feedbackOn(e.target, immediate);
                    if (immediate)
                        widget._feedbackOff()
                }
            };
        var handleEnd = function(isGestureStart) {
                if (!activeElement)
                    return;
                getWidget(activeElement)._feedbackOff(isGestureStart)
            };
        var getWidget = function(widgetElement) {
                var result;
                $.each(widgetElement.data("dxComponents"), function(index, componentName) {
                    if (ui[componentName].subclassOf(ui.Widget)) {
                        result = widgetElement.data(componentName);
                        return false
                    }
                });
                return result
            };
        $(function() {
            var startAction = new DX.Action(handleStart);
            $(document).on(eventHelper.eventName("start"), function(e) {
                startAction.execute(e)
            }).on(eventHelper.eventName("end") + " " + eventHelper.eventName("cancel"), function(e) {
                var activeElementClicked = activeElement && $(e.target).closest("." + UI_FEEDBACK_CLASS).get(0) === activeElement.get(0);
                if (!DX.ui.gestureUtils.hasRecent() && activeElementClicked)
                    startAction.execute(e, true);
                handleEnd()
            });
            ui.gestureUtils.gestureStartCallbacks.add(function() {
                handleEnd(true)
            })
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.containerWidget.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            ANONYMOUS_TEMPLATE_NAME = "template";
        var getTemplateOptions = function(element) {
                var options = element.data("options");
                if ($.trim(options).charAt(0) !== "{")
                    options = "{" + options + "}";
                return new Function("return " + options)().dxTemplate
            };
        var ContainerWidget = ui.Widget.inherit({
                _init: function() {
                    this.callBase();
                    this._templateProvider = new ui.TemplateProvider;
                    this._initTemplates()
                },
                _clean: $.noop,
                _initTemplates: function() {
                    var templates = {},
                        templateClass = this._templateProvider.getTemplateClass(this),
                        templateElements = this._element().children("[data-options]");
                    if (templateElements.length)
                        templateElements.each(function(index, element) {
                            element = $(element);
                            var templateOptions = getTemplateOptions(element);
                            if (!templateOptions.name)
                                throw Error("Template name was not specified");
                            templates[templateOptions.name] = new templateClass(element.get(0))
                        });
                    else
                        templates[ANONYMOUS_TEMPLATE_NAME] = new templateClass(this._element().contents());
                    this._templates = templates
                },
                _getTemplate: function(templateName) {
                    var result = this._aquireTemplate.apply(this, arguments);
                    if (!result && this._templateProvider.supportDefaultTemplate(this)) {
                        result = this._templateProvider.getDefaultTemplate(this);
                        if (!result)
                            throw Error("Template \"" + templateName + "\" was not found and no default template specified!");
                    }
                    return result
                },
                _aquireTemplate: function(templateName) {
                    if ($.isFunction(templateName))
                        templateName = templateName.apply(this, $.makeArray(arguments).slice(1));
                    return this._templates[templateName]
                },
                _cleanTemplates: function() {
                    $.each(this._templates, function(templateName, template) {
                        template.dispose()
                    })
                },
                _dispose: function() {
                    this._cleanTemplates();
                    this.callBase()
                }
            });
        ui.ContainerWidget = ContainerWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.template.js */
    /*! Module core, file ui.collectionContainerWidget.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var CollectionContainerWidget = ui.ContainerWidget.inherit({
                _defaultOptions: function() {
                    return $.extend(this.callBase(), {
                            items: [],
                            itemTemplate: "item",
                            itemRender: null,
                            itemClickAction: null,
                            itemRenderedAction: null,
                            noDataText: "No data to display",
                            dataSource: null
                        })
                },
                _init: function() {
                    this.callBase();
                    this._initDataSource();
                    this._loadDataSource()
                },
                _optionChanged: function(name, value, prevValue) {
                    switch (name) {
                        case"dataSource":
                            this._clean();
                            this._initDataSource();
                            this._loadDataSource();
                            return;
                        case"noDataText":
                            this._renderEmptyMessage();
                            return;
                        case"itemRenderedAction":
                            return;
                        default:
                            this.callBase(name, value, prevValue)
                    }
                },
                _clean: function() {
                    this._itemContainer().empty()
                },
                _handleDataSourceChanged: function(items) {
                    this.option("items", items);
                    this._renderEmptyMessage()
                },
                _itemContainer: function() {
                    return this._element()
                },
                _itemClass: DX.abstract,
                _itemSelector: function() {
                    return "." + this._itemClass()
                },
                _itemDataKey: DX.abstract,
                _items: function() {
                    return this._itemContainer().find(this._itemSelector())
                },
                _render: function() {
                    this.callBase();
                    this._attachClickEvent();
                    this._renderItems()
                },
                _renderEmptyMessage: function() {
                    var noDataText = this.option("noDataText"),
                        noDataTextElement = this._element().find(".dx-empty-message"),
                        items = this.option("items"),
                        itemExists = items && items.length;
                    if (!noDataText || itemExists || this._dataSourceLoading)
                        noDataTextElement.remove();
                    else {
                        if (!noDataTextElement.length)
                            noDataTextElement = $("<div />").addClass("dx-empty-message").appendTo(this._itemContainer());
                        noDataTextElement.text(noDataText)
                    }
                },
                _attachClickEvent: function() {
                    var self = this,
                        itemSelector = self._itemSelector();
                    self._itemContainer().off("." + self.NAME, itemSelector).on(self._eventHelper.eventName("click"), itemSelector, $.proxy(self._handleItemClick, self))
                },
                _handleItemClick: function(e) {
                    this._handleItemEvent(e, "itemClickAction")
                },
                _renderItems: function() {
                    var items = this.option("items") || [];
                    if (items.length)
                        $.each(items, $.proxy(this._renderItem, this));
                    else
                        this._renderEmptyMessage()
                },
                _renderItem: function(index, item, container) {
                    container = container || this._itemContainer();
                    var itemRenderer = this.option("itemRender"),
                        itemTemplateName = this.option("itemTemplate"),
                        itemTemplate = this._getTemplate(item.template || itemTemplateName, index, item),
                        itemElement;
                    var renderArgs = {
                            index: index,
                            item: item,
                            container: container
                        };
                    if (itemRenderer)
                        itemElement = this._createItemByRenderer(itemRenderer, renderArgs);
                    else if (itemTemplate)
                        itemElement = this._createItemByTemplate(itemTemplate, renderArgs);
                    else
                        itemElement = this._createItemByRenderer(this._itemRenderDefault, renderArgs);
                    itemElement.addClass(this._itemClass()).data(this._itemDataKey(), item);
                    this._createActionByOption("itemRenderedAction", {
                        element: this._element(),
                        allowedForGesture: true
                    })({
                        itemElement: itemElement,
                        itemData: item
                    });
                    return itemElement
                },
                _createItemByRenderer: function(itemRenderer, renderArgs) {
                    var itemElement = $("<div />").appendTo(renderArgs.container);
                    var rendererResult = itemRenderer.call(this, renderArgs.item, renderArgs.index, itemElement);
                    if (rendererResult && itemElement[0] !== rendererResult[0])
                        itemElement.append(rendererResult);
                    return itemElement
                },
                _createItemByTemplate: function(itemTemplate, renderArgs) {
                    return itemTemplate.render(renderArgs.container, renderArgs.item)
                },
                _itemRenderDefault: function(item, index, itemElement) {
                    if ($.isPlainObject(item)) {
                        if (item.visible !== undefined && !item.visible)
                            itemElement.hide();
                        if (item.disabled)
                            itemElement.addClass("dx-state-disabled");
                        if (item.text)
                            itemElement.text(item.text);
                        if (item.html)
                            itemElement.html(item.html)
                    }
                    else
                        itemElement.html(String(item))
                },
                _handleItemEvent: function(jQueryEvent, handlerOptionName, args) {
                    var itemElement = $(jQueryEvent.target).closest(this._itemSelector());
                    var action = this._createActionByOption(handlerOptionName, {element: this._element()});
                    var actionArgs = $.extend({
                            itemElement: itemElement,
                            itemData: itemElement.data(this._itemDataKey()),
                            jQueryEvent: jQueryEvent
                        }, args);
                    return action(actionArgs)
                }
            }).include(ui.DataHelperMixin);
        ui.CollectionContainerWidget = CollectionContainerWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.optionsByDevice.js */
    (function($, DX, undefined) {
        DX.ui.optionsByDevice = function(device, componentName) {
            if (componentName === "dxScrollView") {
                var scrollViewOptions = {};
                if (navigator.appName === "Microsoft Internet Explorer")
                    scrollViewOptions.animationStrategy = "transition";
                if (device.platform === "desktop") {
                    scrollViewOptions.scrollByContent = false;
                    scrollViewOptions.showScrollbar = false;
                    return scrollViewOptions
                }
                if (device.platform === "win8")
                    scrollViewOptions.animationStrategy = "transition";
                return scrollViewOptions
            }
            if (componentName === "dxScrollable") {
                var scrollableOptions = {};
                if (navigator.appName === "Microsoft Internet Explorer")
                    scrollableOptions.animationStrategy = "transition";
                if (device.platform === "desktop") {
                    scrollableOptions.scrollByContent = false;
                    scrollableOptions.showScrollbar = false;
                    return scrollableOptions
                }
                if (device.platform === "win8")
                    scrollableOptions.animationStrategy = "transition";
                return scrollableOptions
            }
            if (componentName === "dxList")
                if (device.platform === "desktop")
                    return {
                            scrollingEnabled: false,
                            showScrollbar: false,
                            autoPagingEnabled: false,
                            showNextButton: true
                        };
            if (componentName === "dxPopup")
                if (device.platform === "win8" && !device.phone)
                    return {
                            width: "60%",
                            height: "auto"
                        };
            if (componentName === "dxDialog") {
                if (device.platform === "ios")
                    return {width: 276};
                if (device.platform === "win8" && !device.phone)
                    return {width: "60%"};
                if (device.platform === "android")
                    return {
                            lWidth: "60%",
                            pWidth: "80%"
                        }
            }
            if (componentName === "dxLookup") {
                if (device.platform === "android")
                    return {hideCancelButton: false};
                if (device.platform === "win8" && device.phone)
                    return {
                            hideCancelButton: true,
                            fullScreen: true
                        };
                if (device.platform === "ios" && device.phone)
                    return {fullScreen: true}
            }
            if (componentName === "dxLoadIndicator")
                if (navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "MSAppHost/1.0")
                    return {viaImage: true}
        }
    })(jQuery, DevExpress)
}
if (!DevExpress.MOD_VIZ) {
    /*! Module viz, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz = {}
    })(DevExpress);
    /*! Module viz, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.core = {}
    })(DevExpress);
    /*! Module viz, file tickProvider.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            core = DX.viz.core;
        var TICKS_COUNT_LIMIT = 2000;
        core.outOfScreen = {
            x: -1000,
            y: -1000
        };
        core.tickIntervalCalculator = {
            _defaultNumberMultipliers: [1, 2, 3, 5],
            _defaultGridSpacingFactor: 30,
            _getNumericTickInterval: function(deltaCoef, numberMultipliers) {
                var factor,
                    result = 0,
                    newResult,
                    hasResult = false,
                    i;
                if (deltaCoef > 1.0)
                    for (factor = 1; !hasResult; factor *= 10)
                        for (i = 0; i < numberMultipliers.length; i++) {
                            result = numberMultipliers[i] * factor;
                            if (deltaCoef <= result) {
                                hasResult = true;
                                break
                            }
                        }
                else if (deltaCoef > 0) {
                    result = 1;
                    for (factor = 0.1; !hasResult; factor /= 10)
                        for (i = numberMultipliers.length - 1; i >= 0; i--) {
                            newResult = numberMultipliers[i] * factor;
                            if (deltaCoef > newResult) {
                                hasResult = true;
                                break
                            }
                            result = newResult
                        }
                }
                return utils.adjustValue(result)
            },
            _getDatetimeTickInterval: function(deltaCoef, numberMultipliers) {
                var datetimeMultipliers = {
                        millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
                        second: [1, 2, 3, 5, 10, 15, 20, 30],
                        minute: [1, 2, 3, 5, 10, 15, 20, 30],
                        hour: [1, 2, 3, 4, 6, 8, 12],
                        day: [1, 2, 3, 5, 7, 10, 14],
                        month: [1, 2, 3, 6]
                    },
                    result = {},
                    factor,
                    key,
                    specificMultipliers,
                    yearsCount,
                    i;
                if (deltaCoef < 1.0)
                    return {milliseconds: 1};
                for (key in datetimeMultipliers)
                    if (datetimeMultipliers.hasOwnProperty(key)) {
                        specificMultipliers = datetimeMultipliers[key];
                        for (i = 0; i < specificMultipliers.length; i++)
                            if (deltaCoef <= utils.convertDateUnitToMilliseconds(key, specificMultipliers[i])) {
                                result[key + 's'] = specificMultipliers[i];
                                return result
                            }
                    }
                for (factor = 1; ; factor *= 10)
                    for (i = 0; i < numberMultipliers.length; i++) {
                        yearsCount = factor * numberMultipliers[i];
                        if (deltaCoef <= utils.convertDateUnitToMilliseconds('year', yearsCount))
                            return {years: yearsCount}
                    }
                return null
            },
            getTickInterval: function(type, businessDelta, screenDelta, gridSpacingFactor, numberMultipliers) {
                var self = this,
                    gridSpacingFactor = gridSpacingFactor || self._defaultGridSpacingFactor,
                    numberMultipliers = numberMultipliers || self._defaultNumberMultipliers,
                    deltaCoef = screenDelta > 0 ? gridSpacingFactor * businessDelta / screenDelta : 0;
                self._testNumberMultipliers = numberMultipliers;
                switch (type) {
                    case'numeric':
                        return self._getNumericTickInterval(deltaCoef, numberMultipliers);
                    case'dateTime':
                        return self._getDatetimeTickInterval(deltaCoef, numberMultipliers)
                }
                return null
            }
        };
        core.minorTickIntervalCalculator = {
            _defaultNumberMultipliers: [2, 4, 5, 8, 10],
            _defaultGridSpacingFactor: 15,
            _getDatetimeTickInterval: function(businessDelta, deltaCoef, numberMultipliers) {
                var result,
                    i;
                for (i = numberMultipliers.length - 1; i >= 0; i--) {
                    this.testResultNumberMultiplier = numberMultipliers[i];
                    result = Math.floor(businessDelta / numberMultipliers[i]);
                    if (deltaCoef <= result)
                        return utils.convertMillisecondsToDateUnits(result)
                }
                return 0
            },
            _getNumericTickInterval: function(businessDelta, deltaCoef, numberMultipliers) {
                var result,
                    i;
                for (i = numberMultipliers.length - 1; i >= 0; i--) {
                    this.testResultNumberMultiplier = numberMultipliers[i];
                    result = businessDelta / numberMultipliers[i];
                    if (deltaCoef <= result)
                        return utils.adjustValue(result)
                }
                return 0
            },
            getTickInterval: function(type, businessDelta, screenDelta, gridSpacingFactor, numberMultipliers) {
                var self = this,
                    gridSpacingFactor = !utils.isDefined(gridSpacingFactor) ? self._defaultGridSpacingFactor : gridSpacingFactor,
                    numberMultipliers = numberMultipliers || self._defaultNumberMultipliers,
                    deltaCoef = gridSpacingFactor * businessDelta / screenDelta;
                switch (type) {
                    case'numeric':
                        return self._getNumericTickInterval(businessDelta, deltaCoef, numberMultipliers);
                    case'dateTime':
                        return self._getDatetimeTickInterval(businessDelta, deltaCoef, numberMultipliers)
                }
                return 0
            }
        };
        core.tickProvider = {
            _areDisplayValuesValid: function(value1, value2, options) {
                var getText = this._getTextFunc(options),
                    svgElement1 = options.renderer.createText(getText(value1), core.outOfScreen.x + options.translator.translateX(value1), core.outOfScreen.y, options.textOptions).append(),
                    svgElement2 = options.renderer.createText(getText(value2), core.outOfScreen.x + options.translator.translateX(value2), core.outOfScreen.y, options.textOptions).append(),
                    bBox1 = svgElement1.getBBox(),
                    bBox2 = svgElement2.getBBox(),
                    result,
                    inverted = options.translator.businessRange.invertX;
                result = !inverted ? bBox1.x + bBox1.width < bBox2.x : bBox2.x + bBox2.width < bBox1.x;
                svgElement1.remove();
                svgElement2.remove();
                return result
            },
            _removeInvalidDatesWithUnitBegining: function(dates, options) {
                if (dates.length <= 1 || !options.setTicksAtUnitBeginning || !utils.isDate(options.min))
                    return;
                if (!this._areDisplayValuesValid(dates[0], dates[1], options))
                    dates.splice(1, 1)
            },
            _getMaxDisplayValue: function(values, options) {
                var maxDisplayValue = null,
                    getText = this._getTextFunc(options),
                    currentDisplayValue,
                    i;
                if (values.length > 0) {
                    maxDisplayValue = getText(values[0]);
                    for (i = 1; i < values.length; i++) {
                        currentDisplayValue = getText(values[i]);
                        if (maxDisplayValue.length < currentDisplayValue.length)
                            maxDisplayValue = currentDisplayValue
                    }
                }
                return maxDisplayValue
            },
            _getValueSize: function(value, options) {
                if (value === null)
                    return 0;
                var svgElement = options.renderer.createText(value, core.outOfScreen.x, core.outOfScreen.y, options.textOptions).append(),
                    result = options.isHorizontal ? svgElement.getBBox().width : svgElement.getBBox().height;
                svgElement.remove();
                return Math.ceil(result)
            },
            _adjustNumericTickValue: function(value, interval, min) {
                return utils.isExponential(value) ? utils.adjustValue(value) : utils.applyPrecisionByMinDelta(min, interval, value)
            },
            _generateStartTick: function(tickInterval, options) {
                var self = this,
                    milliseconds = 0,
                    boundedRule = options.min - options.max < 0,
                    startTick = options.min,
                    isDate = utils.isDate(options.min),
                    currentTickInterval = isDate ? utils.convertDateTickIntervalToMilliseconds(tickInterval) : tickInterval;
                startTick = Math.floor(options.min / currentTickInterval) * currentTickInterval;
                startTick = isDate ? new Date(startTick) : self._adjustNumericTickValue(startTick, currentTickInterval, options.min);
                while (boundedRule === startTick - options.min < 0 && startTick !== options.min)
                    startTick = self._nextTick(startTick, tickInterval, options);
                return startTick
            },
            _nextTick: function(tick, tickInterval, options) {
                var nextTick = utils.addInterval(tick, tickInterval, options.min > options.max);
                if (utils.isNumber(options.min))
                    nextTick = this._adjustNumericTickValue(nextTick, tickInterval, options.min);
                if (utils.isDate(options.min) && options.setTicksAtUnitBeginning)
                    utils.correctDateWithUnitBeginning(nextTick, tickInterval);
                return nextTick
            },
            _addMinorTicks: function(majorTick1, majorTick2, ticksInfo, options, isReverse) {
                var self = this,
                    i,
                    dataType = utils.isDate(majorTick1) ? 'dateTime' : 'numeric',
                    businessDelta,
                    minorTicks = [],
                    interval = 0,
                    minorTickIntervalsCount = options.minorTickCount + 1,
                    intervalsCount,
                    tickInterval;
                options.min = majorTick1;
                options.max = majorTick2;
                if (!utils.isDefined(options.tickInterval)) {
                    businessDelta = Math.abs(options.max - options.min);
                    if (utils.isDefined(options.minorTickCount)) {
                        if (!ticksInfo.majorTicks.autoArrangementStep || ticksInfo.majorTicks.autoArrangementStep <= 1) {
                            intervalsCount = options.minorTickCount + 1;
                            interval = dataType === 'dateTime' ? utils.convertDateTickIntervalToMilliseconds(ticksInfo.majorTickInterval) : ticksInfo.majorTickInterval;
                            minorTickIntervalsCount = Math.round(businessDelta / interval * intervalsCount) || 1
                        }
                        tickInterval = dataType === 'dateTime' ? utils.convertMillisecondsToDateUnits(businessDelta / minorTickIntervalsCount) : businessDelta / minorTickIntervalsCount;
                        if ($.isNumeric(tickInterval))
                            tickInterval = utils.adjustValue(tickInterval)
                    }
                    else if (utils.isDate(majorTick1))
                        tickInterval = core.minorTickIntervalCalculator.getTickInterval(dataType, businessDelta, businessDelta * options.deltaCoef, options.gridSpacingFactor, options.numberMultipliers)
                }
                options = $.extend(true, {}, options, {tickInterval: tickInterval});
                minorTicks = self.getTicks(options);
                if (isReverse)
                    minorTicks.reverse();
                if (minorTicks.length > 0)
                    if (Math.ceil(Math.abs(majorTick2 - minorTicks[minorTicks.length - 1]) * options.deltaCoef) < 2)
                        minorTicks.pop();
                for (i = 0; i < minorTicks.length; i++) {
                    ticksInfo.minorTicks.push(minorTicks[i]);
                    ticksInfo.fullTicks.push(minorTicks[i])
                }
            },
            _addLeftBoudedTicks: function(ticksInfo, min, minorTicksOptions) {
                if (utils.isDefined(min) && ticksInfo.majorTicks[0].valueOf() !== min.valueOf()) {
                    minorTicksOptions.addMinMax.max = true;
                    this._addMinorTicks(ticksInfo.majorTicks[0], min, ticksInfo, minorTicksOptions, true);
                    minorTicksOptions.addMinMax.max = false;
                    if (minorTicksOptions.showCustomBoundaryTicks) {
                        if (ticksInfo.minorTicks.length > 0 && ticksInfo.minorTicks[0].valueOf() === min.valueOf())
                            ticksInfo.minorTicks.shift(min);
                        ticksInfo.customBoundaryTicks.push(min);
                        ticksInfo.fullTicks.unshift(min)
                    }
                }
            },
            _addRightBoudedTicks: function(ticksInfo, max, minorTicksOptions) {
                var lastMajorTick = ticksInfo.majorTicks[ticksInfo.majorTicks.length - 1];
                ticksInfo.fullTicks.push(lastMajorTick);
                if (utils.isDefined(max) && lastMajorTick.valueOf() !== max.valueOf()) {
                    minorTicksOptions.addMinMax.min = false;
                    minorTicksOptions.addMinMax.max = true;
                    this._addMinorTicks(lastMajorTick, max, ticksInfo, minorTicksOptions);
                    if (minorTicksOptions.showCustomBoundaryTicks) {
                        if (ticksInfo.minorTicks.length > 0 && ticksInfo.minorTicks[ticksInfo.minorTicks.length - 1].valueOf() === max.valueOf())
                            ticksInfo.minorTicks.pop(max);
                        ticksInfo.customBoundaryTicks.push(max);
                        ticksInfo.fullTicks.push(max)
                    }
                }
            },
            _correctBoundedTicks: function(min, max, ticks, addMinMax) {
                addMinMax = $.extend({}, {
                    min: true,
                    max: true
                }, addMinMax);
                if (ticks.length > 0) {
                    if (!addMinMax.min && ticks[0].valueOf() === min.valueOf())
                        ticks.shift();
                    if (!addMinMax.max || ticks[ticks.length - 1].valueOf() !== max.valueOf())
                        ticks.pop()
                }
            },
            _initializeMinorTicksOptions: function(dataType, min, max, screenDelta, ticksInfo, options) {
                var self = this,
                    businessDelta,
                    hasMinorsCount = utils.isDefined(options.minorTickCount);
                $.extend(true, options, {
                    addMinMax: {
                        min: false,
                        max: false
                    },
                    deltaCoef: self._getDeltaCoef(screenDelta, min, max)
                }, options);
                options.numberMultipliers = hasMinorsCount ? [options.minorTickCount + 1] : options.numberMultipliers;
                options.gridSpacingFactor = hasMinorsCount ? 0 : options.gridSpacingFactor;
                if (!hasMinorsCount && ticksInfo.majorTicks.length > 1) {
                    businessDelta = Math.abs(ticksInfo.majorTicks[0] - ticksInfo.majorTicks[1]);
                    if (self.needTickIntervalCalculation(businessDelta, ticksInfo.minorTickInterval, options.incidentOccured)) {
                        ticksInfo.minorTickInterval = core.minorTickIntervalCalculator.getTickInterval(dataType, businessDelta, businessDelta * options.deltaCoef, options.gridSpacingFactor, options.numberMultipliers);
                        if (utils.isNumber(min))
                            options.tickInterval = ticksInfo.minorTickInterval;
                        else
                            options.tickInterval = undefined
                    }
                }
            },
            _getDataType: function(value) {
                return utils.isDate(value) ? 'dateTime' : 'numeric'
            },
            _getDeltaCoef: function(screenDelta, max, min) {
                return screenDelta / Math.abs(max - min)
            },
            _initializeMajorTicksOptions: function(dataType, min, max, screenDelta, ticksInfo, options) {
                var businessDelta;
                $.extend(true, options, {
                    min: min,
                    max: max,
                    screenDelta: screenDelta,
                    isHorizontal: true
                });
                if (utils.isDefined(min) && utils.isDefined(max)) {
                    businessDelta = Math.abs(max - min);
                    if (this.needTickIntervalCalculation(businessDelta, ticksInfo.majorTickInterval, options.incidentOccured)) {
                        options.isStartTickGenerated = true;
                        ticksInfo.majorTickInterval = core.tickIntervalCalculator.getTickInterval(dataType, businessDelta, screenDelta, options.gridSpacingFactor, options.numberMultipliers);
                        options.tickInterval = ticksInfo.majorTickInterval
                    }
                }
            },
            _getTextFunc: function(options) {
                return options.getText || function(value) {
                        return value.toString()
                    }
            },
            needTickIntervalCalculation: function(businessDelta, tickInterval, incidentOccured) {
                var date;
                if (utils.isDefined(tickInterval)) {
                    if (!utils.isNumber(tickInterval)) {
                        date = new Date;
                        tickInterval = utils.addInterval(date, tickInterval) - date;
                        if (!tickInterval)
                            return true
                    }
                    if (utils.isNumber(tickInterval))
                        if (tickInterval > 0 && businessDelta / tickInterval > TICKS_COUNT_LIMIT) {
                            if (incidentOccured)
                                incidentOccured('Tick count is too big. So, the tick interval is specified automatically.')
                        }
                        else
                            return false
                }
                return true
            },
            getAutoArrangementStep: function(ticks, options) {
                var self = this,
                    maxDisplayValue = this._getMaxDisplayValue(ticks, options),
                    maxDisplayValueSize = this._getValueSize(maxDisplayValue, options),
                    requiredValuesCount,
                    addedSpacing = options.isHorizontal ? options.textSpacing : 0;
                if (maxDisplayValueSize > 0) {
                    requiredValuesCount = Math.floor((options.screenDelta + options.textSpacing) / (maxDisplayValueSize + addedSpacing));
                    return Math.ceil((options.ticksCount || ticks.length) / requiredValuesCount)
                }
                return 1
            },
            getAutoArrangementTicks: function(ticks, options, step) {
                var self = this,
                    resultTicks = ticks,
                    step = utils.isNumber(step) ? step : self.getAutoArrangementStep(ticks, options),
                    i;
                if (step > 1) {
                    resultTicks = [];
                    for (i = 0; i < ticks.length; i += step)
                        resultTicks.push(ticks[i])
                }
                self._removeInvalidDatesWithUnitBegining(resultTicks, options);
                resultTicks.autoArrangementStep = step;
                return resultTicks
            },
            getTickIntervals: function(min, max, screenDelta, majorTicksOptions, minorTicksOptions) {
                var self = this,
                    i,
                    businessDelta,
                    dataType = self._getDataType(min),
                    ticksInfo = {
                        majorTickInterval: majorTicksOptions.tickInterval,
                        minorTickInterval: minorTicksOptions.tickInterval,
                        majorTicks: []
                    };
                self._initializeMajorTicksOptions(dataType, min, max, screenDelta, ticksInfo, majorTicksOptions);
                if (utils.isDefined(min) && utils.isDefined(max)) {
                    ticksInfo.majorTicks.push(min);
                    ticksInfo.majorTicks.push(self._nextTick(min, ticksInfo.majorTickInterval, {
                        min: min,
                        max: max,
                        setTicksAtUnitBeginning: majorTicksOptions.setTicksAtUnitBeginning
                    }));
                    businessDelta = Math.abs(ticksInfo.majorTicks[0] - ticksInfo.majorTicks[1]);
                    self._initializeMinorTicksOptions(dataType, min, max, screenDelta, ticksInfo, minorTicksOptions)
                }
                return ticksInfo
            },
            getFullTicks: function(min, max, screenDelta, majorTicksOptions, minorTicksOptions) {
                var self = this,
                    i,
                    dataType = self._getDataType(min),
                    ticksInfo = {
                        customBoundaryTicks: [],
                        fullTicks: [],
                        majorTickInterval: majorTicksOptions.tickInterval,
                        majorTicks: [],
                        minorTickInterval: minorTicksOptions.tickInterval,
                        minorTicks: []
                    };
                self._initializeMajorTicksOptions(dataType, min, max, screenDelta, ticksInfo, majorTicksOptions);
                ticksInfo.majorTicks = self.getTicks(majorTicksOptions);
                if (utils.isDefined(min) && utils.isDefined(max) && ticksInfo.majorTicks.length > 0) {
                    if (ticksInfo.majorTicks.autoArrangementStep && ticksInfo.majorTicks.autoArrangementStep > 1 && !utils.isDefined(minorTicksOptions.tickInterval) && !utils.isDefined(minorTicksOptions.minorTickCount))
                        minorTicksOptions.tickInterval = ticksInfo.minorTickInterval = majorTicksOptions.tickInterval;
                    self._initializeMinorTicksOptions(dataType, min, max, screenDelta, ticksInfo, minorTicksOptions);
                    self._addLeftBoudedTicks(ticksInfo, min, minorTicksOptions);
                    for (i = 0; i < ticksInfo.majorTicks.length - 1; i++) {
                        ticksInfo.fullTicks.push(ticksInfo.majorTicks[i]);
                        self._addMinorTicks(ticksInfo.majorTicks[i], ticksInfo.majorTicks[i + 1], ticksInfo, minorTicksOptions)
                    }
                    self._addRightBoudedTicks(ticksInfo, max, minorTicksOptions)
                }
                return ticksInfo
            },
            getTicks: function(options) {
                var self = this,
                    ticks = [],
                    tick,
                    boundedRule = options.max - options.min > 0,
                    leftBound,
                    rightBound,
                    tickInterval,
                    isStartTickGenerated = options.isStartTickGenerated,
                    businessDelta,
                    useTicksAutoArrangement = options.useTicksAutoArrangement;
                if (!utils.isDefined(options.min) || !utils.isDefined(options.max) || isNaN(options.min) || isNaN(options.max)) {
                    ticks = options.isHorizontal ? ['canvas_position_left', 'canvas_position_center', 'canvas_position_right'] : ['canvas_position_bottom', 'canvas_position_middle', 'canvas_position_top'];
                    useTicksAutoArrangement = false;
                    ticks.hideLabels = true
                }
                else {
                    tickInterval = $.isNumeric(options.min) && $.isNumeric(options.max) && !$.isNumeric(options.tickInterval) ? undefined : options.tickInterval;
                    businessDelta = Math.abs(options.max - options.min);
                    if (this.needTickIntervalCalculation(businessDelta, tickInterval, options.incidentOccured)) {
                        isStartTickGenerated = utils.isDefined(isStartTickGenerated) ? isStartTickGenerated : true;
                        tickInterval = core.tickIntervalCalculator.getTickInterval(utils.isDate(options.min) ? 'dateTime' : 'numeric', Math.abs(options.max - options.min), options.screenDelta, options.gridSpacingFactor, options.numberMultipliers)
                    }
                    self.isTestStartTickGenerated = isStartTickGenerated;
                    self.isTestTickInterval = tickInterval;
                    if (tickInterval.valueOf() !== 0 && options.min.valueOf() !== options.max.valueOf()) {
                        tick = isStartTickGenerated ? self._generateStartTick(tickInterval, options) : options.min;
                        do {
                            ticks.push(tick);
                            tick = self._nextTick(tick, tickInterval, options);
                            if (ticks[ticks.length - 1].valueOf() === tick.valueOf())
                                break;
                            leftBound = tick - options.min > 0;
                            rightBound = options.max - tick > 0
                        } while (boundedRule === leftBound && boundedRule === rightBound);
                        ticks.push(tick);
                        self._correctBoundedTicks(options.min, options.max, ticks, options.addMinMax)
                    }
                }
                if (options.beforeTicksAutoArrangement)
                    options.beforeTicksAutoArrangement(ticks);
                return useTicksAutoArrangement ? self.getAutoArrangementTicks(ticks, options) : ticks
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz, file linearTranslator.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            isNumber = utils.isNumber,
            isDate = utils.isDate,
            isDefined = utils.isDefined,
            round = Math.round;
        DX.viz.core.LinearTranslator = DX.Class.inherit(function() {
            var ctor = function(businessRanges, canvas) {
                    this.canvas = canvas;
                    this.updateBusinessRange(businessRanges)
                };
            var dispose = function() {
                    var _this = this;
                    _this.canvas = null;
                    _this.businessRange.dispose();
                    _this.businessRange = null;
                    _this.categoriesXToPoints = null;
                    _this.categoriesYToPoints = null
                };
            var init = function() {
                    var _this = this,
                        canvas = _this.canvas,
                        range = _this.businessRange,
                        categoriesX = _this.businessRange.categoriesX,
                        categoriesY = _this.businessRange.categoriesY,
                        i,
                        category;
                    _this.width = canvas.width - canvas.left - canvas.right;
                    _this.height = canvas.height - canvas.top - canvas.bottom;
                    if (categoriesX) {
                        _this.categoriesXNumber = categoriesX.length;
                        if (range.stickX)
                            _this.horizontalInterval = _this.width / (_this.categoriesXNumber - 1);
                        else
                            _this.horizontalInterval = _this.width / _this.categoriesXNumber;
                        _this.categoriesXToPoints = makeCategoriesToPoints(categoriesX, _this.businessRange.invertX);
                        _this.translateX = translateCategoryX;
                        _this.getIntervalX = getCategoryIntervalX
                    }
                    else {
                        _this.translateX = translateContinousX;
                        _this.getIntervalX = getContinousIntervalX;
                        if (isNumber(range.minX))
                            _this.untranslateX = untranslateContinousX;
                        else if (isDate(range.minX))
                            _this.untranslateX = untranslateDatetimeX
                    }
                    if (categoriesY) {
                        _this.categoriesYNumber = categoriesY.length;
                        if (range.stickY)
                            _this.verticalInterval = _this.height / (_this.categoriesYNumber - 1);
                        else
                            _this.verticalInterval = _this.height / _this.categoriesYNumber;
                        _this.categoriesYToPoints = makeCategoriesToPoints(categoriesY, _this.businessRange.invertY);
                        _this.translateY = translateCategoryY;
                        _this.getIntervalY = getCategoryIntervalY
                    }
                    else {
                        _this.translateY = translateContinousY;
                        _this.getIntervalY = getContinousIntervalY;
                        if (isNumber(range.minY))
                            _this.untranslateY = untranslateContinousY;
                        else if (isDate(range.minY))
                            _this.untranslateY = untranslateDatetimeY
                    }
                };
            var updateBusinessRange = function(businessRange) {
                    this.businessRange = businessRange;
                    if (businessRange.minVisibleX === undefined)
                        businessRange.minVisibleX = businessRange.minX;
                    if (businessRange.maxVisibleX === undefined)
                        businessRange.maxVisibleX = businessRange.maxX;
                    if (businessRange.minVisibleY === undefined)
                        businessRange.minVisibleY = businessRange.minY;
                    if (businessRange.maxVisibleY === undefined)
                        businessRange.maxVisibleY = businessRange.maxY;
                    this.init()
                };
            var getBusinessRange = function() {
                    return this.businessRange
                };
            var zoomX = function(min, max) {
                    var businessRange = this.businessRange;
                    businessRange.minVisibleX = min;
                    businessRange.maxVisibleX = max;
                    businessRange.applyEqualLimitsMargins();
                    this.init()
                };
            var zoomY = function(min, max) {
                    var businessRange = this.businessRange;
                    businessRange.minVisibleY = min;
                    businessRange.maxVisibleY = max;
                    businessRange.applyEqualLimitsMargins();
                    this.init()
                };
            var translateSpecialCases = function(_this, value, position) {
                    var parsedValue = (value + '').match(/canvas_position_(.*)/),
                        canvas = _this.canvas,
                        range = _this.businessRange;
                    if (parsedValue) {
                        value = parsedValue[1];
                        if (value === 'default') {
                            if (range['minVisible' + position] <= 0 && 0 <= range['maxVisible' + position])
                                return _this['translate' + position](0);
                            if (position === 'X')
                                if (range.invertX)
                                    return canvas.left + _this.width;
                                else
                                    return canvas.left;
                            else if (range.invertY)
                                return canvas.top;
                            else
                                return canvas.top + _this.height
                        }
                        if (position === "X") {
                            if (value === 'left')
                                return canvas.left;
                            if (value === 'center')
                                return canvas.left + _this.width / 2;
                            if (value === 'right')
                                return canvas.left + _this.width
                        }
                        else {
                            if (value === 'bottom')
                                return canvas.top + _this.height;
                            if (value === 'middle')
                                return canvas.top + _this.height / 2;
                            if (value === 'top')
                                return canvas.top
                        }
                    }
                    return null
                };
            var translateContinousX = function(bpX) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas,
                        result;
                    var specialValue = translateSpecialCases(_this, bpX, "X");
                    if (isDefined(specialValue))
                        return specialValue;
                    if (bpX < ranges.minX)
                        return null;
                    if (bpX > ranges.maxX)
                        return null;
                    if (ranges.invertX)
                        result = canvas.left + (1 - (bpX - ranges.minVisibleX) / (ranges.maxVisibleX - ranges.minVisibleX)) * _this.width;
                    else
                        result = canvas.left + (bpX - ranges.minVisibleX) / (ranges.maxVisibleX - ranges.minVisibleX) * _this.width;
                    return round(result)
                };
            var untranslateContinousX = function(posX) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas;
                    if (posX < canvas.left)
                        return null;
                    if (posX > canvas.left + _this.width)
                        return null;
                    if (ranges.invertX)
                        return ranges.minVisibleX + (_this.width - (posX - canvas.left)) * (ranges.maxVisibleX - ranges.minVisibleX) / _this.width;
                    else
                        return ranges.minVisibleX + (posX - canvas.left) * (ranges.maxVisibleX - ranges.minVisibleX) / _this.width
                };
            var untranslateDatetimeX = function(posX) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas;
                    if (posX < canvas.left)
                        return null;
                    if (posX > canvas.left + _this.width)
                        return null;
                    if (ranges.invertX)
                        return new Date(ranges.minVisibleX.valueOf() + (_this.width - (posX - canvas.left)) * (ranges.maxVisibleX - ranges.minVisibleX) / _this.width);
                    else
                        return new Date(ranges.minVisibleX.valueOf() + (posX - canvas.left) * (ranges.maxVisibleX - ranges.minVisibleX) / _this.width)
                };
            var translateContinousY = function(bpY) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas,
                        result;
                    var specialValue = translateSpecialCases(_this, bpY, "Y");
                    if (isDefined(specialValue))
                        return specialValue;
                    if (bpY < ranges.minY)
                        return null;
                    if (bpY > ranges.maxY)
                        return null;
                    if (ranges.invertY)
                        result = canvas.height - canvas.bottom - (1 - (bpY - ranges.minVisibleY) / (ranges.maxVisibleY - ranges.minVisibleY)) * _this.height;
                    else
                        result = canvas.height - canvas.bottom - (bpY - ranges.minVisibleY) / (ranges.maxVisibleY - ranges.minVisibleY) * _this.height;
                    return round(result)
                };
            var untranslateContinousY = function(posY) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas;
                    if (posY < canvas.top)
                        return null;
                    if (posY > canvas.top + _this.height)
                        return null;
                    if (ranges.invertY)
                        return ranges.maxVisibleY - (_this.height - (posY - canvas.top)) * (ranges.maxVisibleY - ranges.minVisibleY) / _this.height;
                    else
                        return ranges.maxVisibleY - (posY - canvas.top) * (ranges.maxVisibleY - ranges.minVisibleY) / _this.height
                };
            var untranslateDatetimeY = function(posY) {
                    var _this = this,
                        ranges = _this.businessRange,
                        canvas = _this.canvas;
                    if (posY < canvas.top)
                        return null;
                    if (posY > canvas.top + _this.height)
                        return null;
                    if (ranges.invertY)
                        return new Date(ranges.maxVisibleY.valueOf() - (_this.height - (posY - canvas.top)) * (ranges.maxVisibleY - ranges.minVisibleY) / _this.height);
                    else
                        return new Date(ranges.maxVisibleY.valueOf() - (posY - canvas.top) * (ranges.maxVisibleY - ranges.minVisibleY) / _this.height)
                };
            var translateCategoryX = function(category) {
                    var _this = this,
                        canvas = _this.canvas,
                        categoryRecord,
                        result = 0;
                    var specialValue = translateSpecialCases(_this, category, "X");
                    if (isDefined(specialValue))
                        return specialValue;
                    categoryRecord = _this.categoriesXToPoints[category];
                    if (!categoryRecord)
                        return 0;
                    if (_this.businessRange.stickX)
                        result = canvas.left + _this.horizontalInterval * categoryRecord.index;
                    else
                        result = canvas.left + _this.horizontalInterval * (categoryRecord.index + 0.5);
                    return round(result)
                };
            var getCategoryIntervalX = function() {
                    return this.horizontalInterval
                };
            var translateCategoryY = function(category) {
                    var _this = this,
                        canvas = _this.canvas,
                        categoryRecord,
                        result = 0;
                    var specialValue = translateSpecialCases(_this, category, "Y");
                    if (isDefined(specialValue))
                        return specialValue;
                    categoryRecord = _this.categoriesYToPoints[category];
                    if (!categoryRecord)
                        return 0;
                    if (_this.businessRange.stickY)
                        result = canvas.top + _this.verticalInterval * categoryRecord.index;
                    else
                        result = canvas.top + _this.verticalInterval * (categoryRecord.index + 0.5);
                    return round(result)
                };
            var getCategoryIntervalY = function() {
                    return this.verticalInterval
                };
            var getContinousIntervalX = function() {
                    var _this = this,
                        result = 0;
                    if (_this.businessRange.intervalX !== undefined)
                        result = _this.width * _this.businessRange.intervalX / (_this.businessRange.maxVisibleX - _this.businessRange.minVisibleX);
                    return round(result)
                };
            var getContinousIntervalY = function() {
                    var _this = this,
                        result = 0;
                    if (_this.businessRange.intervalY !== undefined)
                        result = _this.height * _this.businessRange.intervalY / (_this.businessRange.maxVisibleY - _this.businessRange.minVisibleY);
                    return round(result)
                };
            var getBusinessVisibleArea = function() {
                    var range = this.businessRange,
                        visibleArea = {};
                    visibleArea.minX = range.minVisibleX;
                    visibleArea.maxX = range.maxVisibleX;
                    visibleArea.minY = range.minVisibleY;
                    visibleArea.maxY = range.maxVisibleY;
                    if (range.categoriesX) {
                        visibleArea.categoriesX = range.categoriesX;
                        visibleArea.minCategoryXPos = 0;
                        visibleArea.maxCategoryXPos = visibleArea.minCategoryXPos + visibleArea.categoriesX.length - 1
                    }
                    if (range.categoriesY) {
                        visibleArea.categoriesY = range.categoriesY;
                        visibleArea.minCategoryYPos = 0;
                        visibleArea.maxCategoryYPos = visibleArea.minCategoryYPos + visibleArea.categoriesY.length - 1
                    }
                    return visibleArea
                };
            var getCanvasVisibleArea = function() {
                    var canvas = this.canvas;
                    return {
                            minX: canvas.left,
                            maxX: canvas.width - canvas.right,
                            minY: canvas.top,
                            maxY: canvas.height - canvas.bottom
                        }
                };
            var makeCategoriesToPoints = function(categories, invert) {
                    var categoriesToPoints = {},
                        category,
                        i;
                    if (invert)
                        for (i = categories.length - 1; i >= 0; i--) {
                            category = categories[categories.length - 1 - i];
                            categoriesToPoints[category] = {
                                name: category,
                                index: i
                            }
                        }
                    else
                        for (i = 0; i < categories.length; i++) {
                            category = categories[i];
                            categoriesToPoints[category] = {
                                name: category,
                                index: i
                            }
                        }
                    return categoriesToPoints
                };
            var prototypeObject = {
                    ctor: ctor,
                    dispose: dispose,
                    init: init,
                    getCanvasVisibleArea: getCanvasVisibleArea,
                    getBusinessVisibleArea: getBusinessVisibleArea,
                    updateBusinessRange: updateBusinessRange,
                    getBusinessRange: getBusinessRange,
                    zoomX: zoomX,
                    zoomY: zoomY
                };
            prototypeObject.translateCategoryX = translateCategoryX;
            prototypeObject.translateCategoryY = translateCategoryY;
            prototypeObject.getCategoryIntervalX = getCategoryIntervalX;
            prototypeObject.getCategoryIntervalY = getCategoryIntervalY;
            prototypeObject.translateContinousX = translateContinousX;
            prototypeObject.translateContinousY = translateContinousY;
            prototypeObject.getContinousIntervalX = getContinousIntervalX;
            prototypeObject.getContinousIntervalY = getContinousIntervalY;
            prototypeObject.untranslateContinousX = untranslateContinousX;
            prototypeObject.untranslateContinousY = untranslateContinousY;
            prototypeObject.untranslateDatetimeX = untranslateDatetimeX;
            prototypeObject.untranslateDatetimeY = untranslateDatetimeY;
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file translator1D.js */
    (function(DX, undefined) {
        var NaN = window.NaN,
            Number = window.Number;
        DX.viz.core.Translator1D = DX.Class.inherit({
            ctor: function(domainStart, domainEnd, codomainStart, codomainEnd) {
                DX.utils.debug.assertParam(domainStart, 'domainStart was not passed');
                DX.utils.debug.assertParam(domainEnd, 'domainEnd was not passed');
                DX.utils.debug.assertParam(codomainStart, 'codomainStart was not passed');
                DX.utils.debug.assertParam(codomainEnd, 'codomainEnd was not passed');
                var self = this;
                self._domainStart = Number(domainStart);
                self._domainEnd = Number(domainEnd);
                self._codomainStart = Number(codomainStart);
                self._codomainEnd = Number(codomainEnd);
                self._domainDelta = self._domainEnd - self._domainStart;
                self._codomainDelta = self._codomainEnd - self._codomainStart
            },
            getDomainStart: function() {
                return this._domainStart
            },
            getDomainEnd: function() {
                return this._domainEnd
            },
            getCodomainStart: function() {
                return this._codomainStart
            },
            getCodomainEnd: function() {
                return this._codomainEnd
            },
            getDomainRange: function() {
                return this._domainDelta
            },
            getCodomainRange: function() {
                return this._codomainDelta
            },
            translate: function(value) {
                var self = this,
                    ratio = (value - self._domainStart) / self._domainDelta;
                return 0 <= ratio && ratio <= 1 ? self._codomainStart + ratio * self._codomainDelta : NaN
            },
            adjust: function(value) {
                var self = this,
                    ratio = (value - self._domainStart) / self._domainDelta,
                    result = NaN;
                if (ratio < 0)
                    result = self._domainStart;
                else if (ratio > 1)
                    result = self._domainEnd;
                else if (0 <= ratio && ratio <= 1)
                    result = Number(value);
                return result
            }
        })
    })(DevExpress);
    /*! Module viz, file rectangle.js */
    (function(DX, undefined) {
        var isFinite = window.isFinite;
        DX.viz.core.Rectangle = DX.Class.inherit({
            ctor: function(options) {
                var self = this;
                options = options || {};
                self.left = Number(options.left) || 0;
                self.right = Number(options.right) || 0;
                self.top = Number(options.top) || 0;
                self.bottom = Number(options.bottom) || 0
            },
            width: function() {
                return this.right - this.left
            },
            height: function() {
                return this.bottom - this.top
            },
            horizontalMiddle: function() {
                return (this.left + this.right) / 2
            },
            verticalMiddle: function() {
                return (this.top + this.bottom) / 2
            },
            raw: function() {
                var self = this;
                return {
                        left: self.left,
                        top: self.top,
                        right: self.right,
                        bottom: self.bottom
                    }
            },
            clone: function() {
                return new this.constructor(this.raw())
            },
            move: function(dx, dy) {
                var result = this.clone();
                if (isFinite(dx) && isFinite(dy)) {
                    result.left += Number(dx);
                    result.right += Number(dx);
                    result.top += Number(dy);
                    result.bottom += Number(dy)
                }
                return result
            },
            inflate: function(dx, dy) {
                var result = this.clone();
                if (isFinite(dx) && isFinite(dy)) {
                    result.left -= Number(dx);
                    result.right += Number(dx);
                    result.top -= Number(dy);
                    result.bottom += Number(dy)
                }
                return result
            },
            scale: function(factor) {
                var self = this;
                if (factor > 0)
                    return self.inflate(self.width() * (factor - 1) / 2, self.height() * (factor - 1) / 2);
                return self.clone()
            }
        })
    })(DevExpress);
    /*! Module viz, file themes.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            viz = DX.viz;
        core.findTheme = function(themeName) {
            var themes = viz.themes,
                theme,
                themeId;
            for (themeId = 0; themeId < themes.length; themeId++) {
                theme = themes[themeId];
                if (theme.name === themeName)
                    return theme
            }
        };
        core.registerTheme = function(theme, basedOnThemeName) {
            var baseTheme,
                extendedTheme;
            if (!theme || !theme.name || core.findTheme(theme.name))
                return;
            if (basedOnThemeName) {
                baseTheme = core.findTheme(basedOnThemeName);
                if (baseTheme) {
                    extendedTheme = $.extend(true, {}, baseTheme, theme);
                    viz.themes.push(extendedTheme)
                }
            }
            else
                viz.themes.push(theme)
        }
    })(jQuery, DevExpress);
    /*! Module viz, file palette.js */
    (function($, DX, undefined) {
        var core = DX.viz.core;
        core.palettes = {
            'default': ['#5F8B95', '#BA4D51', '#AF8A53', '#955F71', '#859666', '#7E688C'],
            'Harmony Light': ['#FCB65E', '#679EC5', '#AD79CE', '#A6C567', '#E18E92', '#DDED6E', '#B7ABEA', '#A8E7E3'],
            'Soft Pastel': ['#7CBAB4', '#92C7E2', '#75B5D6', '#B78C9B', '#F2CA84', '#A7CA74']
        };
        core.findPalette = function(paletteName) {
            return core.palettes[paletteName]
        };
        core.registerPalette = function(paletteName, palette) {
            return core.palettes[paletteName] = palette
        };
        function RingBuf(buf) {
            var ind = 0;
            this.next = function() {
                var res = buf[ind++];
                if (ind == buf.length)
                    this.reset();
                return res
            };
            this.reset = function() {
                ind = 0
            }
        }
        core.Palette = DX.Class.inherit({
            ctor: function(palette, stepHighlight) {
                var self = this;
                self.currentColor = 0;
                self.stepHighlight = stepHighlight || 0;
                if ($.isArray(palette))
                    self.originalPalette = palette;
                else {
                    self.originalPalette = core.findPalette(palette);
                    if (!self.originalPalette)
                        self.originalPalette = core.palettes['default']
                }
                self.palette = self.originalPalette.slice(0);
                self.paletteActions = new RingBuf(['highlight', 'highlight', 'darken', 'darken'])
            },
            dispose: function() {
                this.originalPalette = null;
                this.palette = null;
                this.paletteActions = null
            },
            getNextColor: function() {
                var self = this,
                    palette = self.palette,
                    color = palette[self.currentColor],
                    action;
                self.currentColor++;
                if (self.currentColor >= palette.length) {
                    self.currentColor = 0;
                    if (self.stepHighlight) {
                        action = self.paletteActions.next();
                        for (var i = 0; i < palette.length; i++)
                            palette[i] = new DX.Color(palette[i])[action](self.stepHighlight)
                    }
                }
                return color
            },
            reset: function() {
                this.currentColor = 0;
                this.palette = this.originalPalette.slice(0);
                this.paletteActions.reset()
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file baseThemeManager.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            core = viz.core;
        var findThemeOrDefault = function(themeName) {
                return core.findTheme(themeName) || viz.themes[0]
            };
        core.BaseThemeManager = DX.Class.inherit({
            ctor: function(userTheme, themeGroupName) {
                userTheme = userTheme || {};
                var _this = this,
                    themeName = typeof userTheme === 'string' ? userTheme : userTheme.name,
                    theme = findThemeOrDefault(themeName);
                _this.font = $.extend(true, {}, theme.font, userTheme.font || {});
                if (themeGroupName && theme)
                    $.each(themeGroupName.split('.'), function() {
                        theme = theme[this]
                    });
                _this.theme = $.extend(true, {}, theme || {}, typeof userTheme === 'string' ? {} : userTheme)
            },
            dispose: function() {
                this.font = null;
                this.theme = null
            },
            initializeFont: function(fontOptions) {
                $.extend(fontOptions, this.font, $.extend({}, fontOptions))
            },
            applyTheme: function(theme, userOptions) {
                return $.extend(true, {}, theme, userOptions || {})
            },
            getTheme: function() {
                return this.theme
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file textCloud.js */
    (function(DX, undefined) {
        var min = Math.min;
        DX.viz.core.TextCloud = DX.Class.inherit(function() {
            var DEFAULT_OPTIONS = {
                    horMargin: 8,
                    verMargin: 4,
                    tailLength: 10
                };
            var COEFFICIENTS_MAP = {};
            COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
            COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
            COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
            COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
            COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
            COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
            COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
            COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];
            return {
                    setup: function(options) {
                        var self = this,
                            ops = $.extend({}, DEFAULT_OPTIONS, options),
                            x = ops.x,
                            y = ops.y,
                            type = COEFFICIENTS_MAP[ops.type],
                            cloudWidth = ops.textWidth + 2 * ops.horMargin,
                            cloudHeight = ops.textHeight + 2 * ops.verMargin,
                            tailWidth = ops.tailLength,
                            tailHeight = tailWidth,
                            cx = x,
                            cy = y;
                        if (type[0] & 1)
                            tailHeight = min(tailHeight, cloudHeight / 3);
                        else
                            tailWidth = min(tailWidth, cloudWidth / 3);
                        self._points = [x, y, x += type[0] * (cloudWidth + tailWidth), y += type[1] * (cloudHeight + tailHeight), x += type[2] * cloudWidth, y += type[3] * cloudHeight, x += type[4] * cloudWidth, y += type[5] * cloudHeight, x += type[6] * (cloudWidth - tailWidth), y += type[7] * (cloudHeight - tailHeight)];
                        self._cx = cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2;
                        self._cy = cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2;
                        self._cloudWidth = cloudWidth;
                        self._cloudHeight = cloudHeight;
                        self._tailLength = ops.tailLength;
                        return self
                    },
                    points: function() {
                        return this._points.slice(0)
                    },
                    cx: function() {
                        return this._cx
                    },
                    cy: function() {
                        return this._cy
                    },
                    width: function() {
                        return this._cloudWidth
                    },
                    height: function() {
                        return this._cloudHeight
                    },
                    tailLength: function() {
                        return this._tailLength
                    }
                }
        }())
    })(DevExpress);
    /*! Module viz, file parseUtils.js */
    (function($, DX) {
        var viz = DX.viz,
            core = viz.core,
            Class = DX.Class,
            isDefined = DX.utils.isDefined;
        var parseUtils = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._incidentOccured = $.isFunction(options.incidentOccured) ? options.incidentOccured : $.noop
                },
                correctValueType: function(type) {
                    return type === 'numeric' || type === 'datetime' || type === 'string' ? type : ''
                },
                _parsers: {
                    string: function(val) {
                        return isDefined(val) ? '' + val : val
                    },
                    numeric: function(val) {
                        if (!isDefined(val))
                            return val;
                        var parsedVal = Number(val);
                        if (isNaN(parsedVal))
                            parsedVal = undefined;
                        return parsedVal
                    },
                    datetime: function(val) {
                        if (!isDefined(val))
                            return val;
                        var parsedVal,
                            numVal = Number(val);
                        if (!isNaN(numVal))
                            parsedVal = new Date(numVal);
                        else
                            parsedVal = new Date(val);
                        if (isNaN(Number(parsedVal)))
                            parsedVal = undefined;
                        return parsedVal
                    }
                },
                getParser: function(valueType, entity) {
                    var self = this,
                        parser,
                        message = 'valueType is unknown.';
                    if (entity)
                        message = 'The type specified as the valueType property of the ' + entity + ' configuration object is unknown.';
                    valueType = self.correctValueType(valueType);
                    parser = self._parsers[valueType];
                    if (!parser)
                        this._incidentOccured.call(null, message);
                    return parser || $.noop
                }
            });
        core.ParseUtils = parseUtils
    })(jQuery, DevExpress);
    /*! Module viz, file default.js */
    (function($, DX, undefined) {
        DX.viz.themes = DX.viz.themes || [];
        DX.viz.themes.push({
            name: 'default',
            font: {
                color: '#808080',
                opacity: 0.75,
                family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                weight: 400,
                size: 12,
                cursor: 'default'
            },
            chart: {
                containerBackgroundColor: '#FFFFFF',
                defaultPalette: 'default',
                commonSeriesSettings: {
                    border: {
                        visible: false,
                        width: 2
                    },
                    hoverMode: 'excludePoints',
                    selectionMode: 'includePoints',
                    hoverStyle: {
                        hatching: 'none',
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    selectionStyle: {
                        hatching: 'right',
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    point: {
                        visible: true,
                        symbol: 'circle',
                        size: 6,
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverMode: 'onlyPoint',
                        selectionMode: 'onlyPoint',
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 6
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 6
                        }
                    },
                    label: {
                        font: {
                            color: '#FFFFFF',
                            opacity: 1
                        },
                        border: {
                            visible: false,
                            width: 1,
                            color: '#808080',
                            dashStyle: 'solid'
                        },
                        connector: {
                            visible: false,
                            width: 1
                        }
                    },
                    scatter: {},
                    line: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    stackedline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    fullstackedline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    stepline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    area: {point: {visible: false}},
                    stackedarea: {point: {visible: false}},
                    fullstackedarea: {point: {visible: false}},
                    steparea: {
                        border: {
                            visible: true,
                            width: 2
                        },
                        point: {visible: false},
                        hoverStyle: {border: {
                                visible: true,
                                width: 3
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                width: 3
                            }}
                    },
                    spline: {
                        width: 2,
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    splinearea: {point: {visible: false}},
                    bar: {cornerRadius: 0},
                    stackedbar: {cornerRadius: 0},
                    fullstackedbar: {cornerRadius: 0},
                    rangebar: {cornerRadius: 0},
                    rangearea: {point: {visible: false}},
                    rangesplinearea: {point: {visible: false}},
                    pie: {
                        border: {
                            visible: false,
                            width: 2,
                            color: '#FFFFFF'
                        },
                        hoverStyle: {border: {
                                visible: true,
                                width: 3,
                                color: '#FFFFFF'
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                width: 3,
                                color: '#FFFFFF'
                            }}
                    },
                    doughnut: {innerRadius: 0.5},
                    candlestick: {
                        width: 1,
                        innerColor: '#ffffff',
                        reduction: {color: '#FF0000'},
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    },
                    stock: {
                        width: 1,
                        reduction: {color: '#FF0000'},
                        hoverStyle: {width: 3},
                        selectionStyle: {width: 3}
                    }
                },
                legend: {
                    verticalAlignment: 'top',
                    horizontalAlignment: 'right',
                    position: 'outside',
                    font: {color: '#808080'},
                    visible: true,
                    customizeText: undefined,
                    itemTextPosition: undefined,
                    margin: 20,
                    equalColumnWidth: false,
                    markerSize: 12,
                    backgroundColor: undefined,
                    border: {
                        visible: false,
                        width: 1,
                        color: '#808080',
                        cornerRadius: 0,
                        opacity: 0.35,
                        dashStyle: 'solid'
                    },
                    paddingLeftRight: 20,
                    paddingTopBottom: 15,
                    columnCount: 0,
                    rowCount: 0,
                    columnItemSpacing: 20,
                    rowItemSpacing: 8
                },
                tooltip: {
                    enabled: false,
                    font: {
                        family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200,
                        size: 26,
                        color: '#ffffff'
                    },
                    arrowLength: 10,
                    paddingLeftRight: 22,
                    paddingTopBottom: 6,
                    format: '',
                    argumentFormat: '',
                    precision: 0,
                    argumentPrecision: 0,
                    percentPrecision: 0,
                    customizeText: undefined
                },
                title: {font: {
                        family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200,
                        color: '#232323',
                        size: 28,
                        opacity: 1
                    }},
                commonAxisSettings: {
                    discreteAxisDivisionMode: 'betweenLabels',
                    visible: false,
                    color: '#808080',
                    opacity: 0.35,
                    width: 1,
                    multipleAxesSpacing: 5,
                    label: {
                        visible: true,
                        staggered: false,
                        staggeringSpacing: 5,
                        overlappingBehavior: {
                            mode: 'enlargeTickInterval',
                            rotationAngle: 90,
                            staggeringSpacing: 5
                        },
                        precision: 0,
                        format: '',
                        customizeText: undefined,
                        indentFromAxis: 10
                    },
                    grid: {
                        visible: false,
                        color: '#808080',
                        opacity: 0.35,
                        width: 1
                    },
                    tick: {
                        visible: false,
                        color: '#808080',
                        opacity: 0.35
                    },
                    title: {
                        font: {size: 16},
                        margin: 10
                    },
                    stripStyle: {
                        paddingLeftRight: 10,
                        paddingTopBottom: 5
                    }
                },
                horizontalAxis: {
                    isHorizontal: true,
                    position: 'bottom',
                    axisDivisionFactor: 50,
                    label: {alignment: "center"},
                    stripStyle: {label: {
                            horizontalAlignment: 'center',
                            verticalAlignment: 'top'
                        }}
                },
                verticalAxis: {
                    isHorizontal: false,
                    position: 'left',
                    axisDivisionFactor: 30,
                    label: {alignment: "right"},
                    stripStyle: {label: {
                            horizontalAlignment: 'left',
                            verticalAlignment: 'center'
                        }}
                },
                argumentAxisStyle: {},
                valueAxisStyle: {grid: {visible: true}},
                commonPaneSettings: {border: {
                        color: '#808080',
                        opacity: 0.35,
                        width: 1
                    }}
            },
            gauge: {
                area: {
                    radius: 120,
                    fromAngle: 225,
                    toAngle: 315,
                    formatText: undefined
                },
                range: {
                    type: 'multicolor',
                    sizes: {length: 5},
                    colors: ['#00FF00', '#FFFF00', '#FF0000']
                },
                scale: {
                    type: 'TODO',
                    tick: {
                        sizes: {
                            length: 5,
                            width: 2
                        },
                        color: '#BFBFBF'
                    },
                    text: {
                        indent: 10,
                        color: '#7F7F7F',
                        font: {
                            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                            weight: 400,
                            size: 12
                        }
                    }
                },
                needle: {
                    type: 'line',
                    sizes: {width: 3},
                    color: '#BFBFBF'
                },
                marker: {
                    type: 'triangle',
                    sizes: {
                        length: 12,
                        width: 10
                    },
                    color: '#679EC5'
                }
            },
            rangeSelector: {
                containerBackgroundColor: 'white',
                scale: {
                    label: {
                        topIndent: 7,
                        font: {size: 11}
                    },
                    tick: {
                        width: 1,
                        color: 'black',
                        opacity: 0.1
                    },
                    marker: {
                        separatorHeight: 33,
                        topIndent: 10,
                        textLeftIndent: 7,
                        textTopIndent: 11
                    }
                },
                sliderMarker: {
                    padding: 7,
                    pointerSize: 6,
                    color: '#9B9B9B',
                    invalidRangeColor: 'red',
                    font: {
                        color: 'white',
                        size: 11
                    }
                },
                sliderHandles: {
                    width: 1,
                    color: 'black',
                    opacity: 0.1
                },
                shutter: {
                    color: undefined,
                    opacity: 0.75
                },
                background: {color: "#C0BAE1"},
                chart: {
                    containerBackgroundColor: undefined,
                    defaultPalette: 'default',
                    commonSeriesSettings: {
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverStyle: {border: {}},
                        selectionStyle: {border: {}},
                        point: {
                            visible: false,
                            symbol: 'circle',
                            border: {
                                visible: false,
                                width: 1
                            },
                            size: 6,
                            hoverStyle: {border: {}},
                            selectionStyle: {border: {}}
                        },
                        line: {width: 2},
                        stackedline: {width: 2},
                        fullstackedline: {width: 2},
                        area: {},
                        stackedarea: {},
                        fullstackedarea: {},
                        spline: {width: 2},
                        splinearea: {},
                        bar: {cornerRadius: 0},
                        stackedbar: {cornerRadius: 0},
                        fullstackedbar: {cornerRadius: 0},
                        rangebar: {cornerRadius: 0},
                        rangearea: {},
                        rangesplinearea: {},
                        pie: {},
                        candlestick: {
                            width: 1,
                            innerColor: '#ffffff',
                            reduction: {color: '#FF0000'}
                        },
                        stock: {
                            width: 1,
                            reduction: {color: '#FF0000'}
                        }
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.renderers = {}
    })(DevExpress);
    /*! Module viz, file svgRenderer.js */
    (function($, DX) {
        var renderers = DX.viz.renderers,
            utils = DX.utils,
            Class = DX.Class,
            doc = document,
            easingFunctions,
            MAX_PIXEL_COUNT = 10000000000;
        (function() {
            var jStep = $.fx.step,
                fxProto = $.fx.prototype,
                baseCur = fxProto['cur'],
                baseD = jStep['d'],
                baseRotate = jStep['rotate'],
                baseTranslate = jStep['translate'],
                getNextAnimStep;
            getNextAnimStep = function(elem, pos, start, end, unit) {
                var easing = elem.renderer.animOptions.easing;
                return easingFunctions[easing || 'easeOutCubic'](pos, start, end) + (unit == '%' ? '%' : '')
            };
            fxProto['cur'] = function() {
                var fx = this,
                    prop = fx.prop;
                if (fx.elem instanceof BaseSvgElement) {
                    if (prop === 'svgheight' || prop === 'svgwidth')
                        prop = prop.substr(3);
                    return $(fx.elem.element).attr(prop)
                }
                return baseCur.apply(fx, arguments)
            };
            $.each(['x', 'y', 'cx', 'cy', 'r', 'rx', 'ry', 'strokeWidth'], function(i, prop) {
                var propName = DX.inflector.camelize(prop),
                    elem,
                    baseFn = jStep[propName];
                jStep[propName] = function(fx) {
                    var elem = fx.elem,
                        animProp;
                    if (!(elem instanceof BaseSvgElement)) {
                        baseFn ? baseFn.apply(this, arguments) : 0;
                        return
                    }
                    animProp = {sharpEdges: false};
                    animProp[fx.prop] = getNextAnimStep(elem, fx.pos, fx.start, fx.end, fx.unit);
                    elem.applySettings(animProp)
                }
            });
            $.each(['width', 'height'], function(i, prop) {
                var propName = 'svg' + prop,
                    elem;
                jStep[propName] = function(fx) {
                    var elem = fx.elem,
                        animProp = fx.prop.substr(3),
                        animParams;
                    animParams = {sharpEdges: false};
                    animParams[animProp] = getNextAnimStep(elem, fx.pos, fx.start || 0, fx.end || 0, fx.unit);
                    elem.applySettings(animParams)
                }
            });
            jStep['d'] = function(fx) {
                var elem = fx.elem,
                    fromSegments,
                    toSegments,
                    diff,
                    slice,
                    end;
                if (!(elem instanceof BaseSvgElement)) {
                    baseD ? baseD.apply(this, arguments) : 0;
                    return
                }
                if (!fx.initialized) {
                    fromSegments = elem.fromSegments || [];
                    toSegments = elem.segments || [];
                    if (fromSegments.length == 0)
                        fromSegments = [].concat(toSegments);
                    diff = toSegments.length - fromSegments.length;
                    if (diff > 0) {
                        slice = [].concat(fromSegments).splice(fromSegments.length - diff, diff);
                        fromSegments = fromSegments.concat(slice)
                    }
                    else if (diff < 0) {
                        slice = [].concat(toSegments).splice(toSegments.length + diff, -diff);
                        toSegments = toSegments.concat(slice)
                    }
                    fx.start = fromSegments;
                    fx.end = toSegments;
                    fx.initialized = true
                }
                end = fx.pos === 1 ? fx.end : $.map(fx.start, function(fromSeg, i) {
                    var toSeg = fx.end[i],
                        seg;
                    seg = $.map(fromSeg, function(fromEl, j) {
                        var toEl;
                        if (!$.isNumeric(fromEl))
                            return fromEl;
                        toEl = toSeg[j];
                        return getNextAnimStep(elem, fx.pos, fromEl, toEl)
                    });
                    return [seg]
                });
                elem.applySettings({d: $.map(end, function(seg, i) {
                        return seg.join(' ')
                    }).join(' ')})
            };
            jStep['rotate'] = function(fx) {
                var elem = fx.elem,
                    params,
                    curTransform,
                    angle;
                if (!(elem instanceof BaseSvgElement)) {
                    baseRotate ? baseRotate.apply(this, arguments) : 0;
                    return
                }
                if (!fx.initialized) {
                    params = fx.end;
                    curTransform = elem.transformation || {};
                    fx.start = curTransform.rotateAngle || 0,
                    fx.end = params.angle || 0,
                    fx.x = params.x || 0,
                    fx.y = params.y || 0;
                    fx.initialized = true
                }
                angle = getNextAnimStep(elem, fx.pos, fx.start, fx.end);
                elem.applySettings({rotate: [angle, fx.x, fx.y]})
            };
            jStep['translate'] = function(fx) {
                var elem = fx.elem,
                    params,
                    curTransform,
                    newX,
                    newY;
                if (!(elem instanceof BaseSvgElement)) {
                    baseTranslate ? baseTranslate.apply(this, arguments) : 0;
                    return
                }
                if (!fx.initialized) {
                    params = fx.end;
                    curTransform = elem.transformation || {};
                    fx.startX = curTransform.translateX || 0,
                    fx.startY = curTransform.translateY || 0,
                    fx.endX = params.x || 0,
                    fx.endY = params.y || 0;
                    fx.initialized = true
                }
                newX = getNextAnimStep(elem, fx.pos, fx.startX, fx.endX);
                newY = getNextAnimStep(elem, fx.pos, fx.startY, fx.endY);
                elem.applySettings({
                    translateX: newX,
                    translateY: newY
                })
            }
        })();
        easingFunctions = {
            easeOutCubic: function(pos, start, end) {
                return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
            },
            linear: function(pos, start, end) {
                return pos === 1 ? end : pos * (end - start) + +start
            }
        };
        var BaseSvgElement = Class.inherit({
                ctor: function baseSvgElementCtor(renderer, name, params) {
                    this.renderer = renderer;
                    this.element = this.createElement(name);
                    this.$element = $(this.element);
                    this.applySettings($.extend({}, this.defaultSettings(), params));
                    this.__passedParams = params
                },
                defaultSettings: $.noop,
                createElement: function(nodeName) {
                    this._nodeName = nodeName;
                    return doc.createElementNS('http://www.w3.org/2000/svg', nodeName)
                },
                dispose: function() {
                    this.off();
                    this.remove();
                    this.renderer = null;
                    this.element = null;
                    this.settings = null;
                    this.$element = null;
                    this.transformation = null;
                    this.__passedParams = null;
                    this.__appliedSettings = null;
                    this.__appliedStyle = null
                },
                append: function(svgElement) {
                    var toElement = svgElement || this.renderer.getRoot();
                    toElement.element.appendChild(this.element);
                    return this
                },
                toBackground: function() {
                    this.element.parentNode && this.element.parentNode.insertBefore(this.element, this.element.parentNode.firstChild);
                    return this
                },
                toForeground: function() {
                    this.element.parentNode && this.element.parentNode.appendChild(this.element);
                    return this
                },
                addClass: function(className) {
                    var classAttribute = this.$element.attr('class'),
                        classNameIndex,
                        classNames;
                    if (className) {
                        if (classAttribute) {
                            classNames = classAttribute.split(' ');
                            classNameIndex = $.inArray(className, classNames);
                            if (classNameIndex === -1)
                                classAttribute += ' ' + className
                        }
                        else
                            classAttribute = className;
                        this.$element.attr('class', classAttribute)
                    }
                    return this.$element
                },
                removeClass: function(className) {
                    var classAttribute = this.$element.attr('class'),
                        classNames,
                        indexDeleteElement,
                        resultClassNames = '',
                        i;
                    if (classAttribute && className) {
                        classNames = classAttribute.split(' ');
                        indexDeleteElement = $.inArray(className, classNames);
                        if (indexDeleteElement !== -1) {
                            for (i = 0; i < classNames.length; i++)
                                if (i !== indexDeleteElement)
                                    resultClassNames += classNames[i] + ' ';
                            this.$element.attr('class', resultClassNames.replace(/ $/, ''))
                        }
                    }
                    return this.$element
                },
                applySettings: function(settings) {
                    var normalized;
                    this.settings = $.extend(this.settings || {}, settings || {});
                    this.adjustSettings();
                    normalized = this._normalizeSettings(this.settings);
                    this.applyStyle(this._style);
                    this._applyAttributes(normalized);
                    return this
                },
                _applyAttributes: function(settings) {
                    this.$element.attr(settings);
                    this.__appliedSettings = settings
                },
                adjustSettings: function(){},
                applyStyle: function(style) {
                    this.$element.css(style || {});
                    this.__appliedStyle = style || {};
                    return this
                },
                trigger: function(event, data) {
                    this.$element.trigger(event, data)
                },
                on: function(events, data, handler) {
                    this.$element.on.apply(this.$element, arguments);
                    return this
                },
                data: function(data) {
                    this.$element.data(data);
                    return this
                },
                removeData: function() {
                    this.$element.removeData();
                    return this
                },
                off: function(events) {
                    this.$element.off(events);
                    return this
                },
                getBBox: function() {
                    var self = this,
                        bBox,
                        element = this.element,
                        transformation = self.transformation,
                        rotateAngle = transformation.rotateAngle || 0,
                        rotateX = transformation.rotateX || 0,
                        rotateY = transformation.rotateY || 0,
                        mabs = Math.abs,
                        mmin = Math.min;
                    function bBox(el) {
                        var ret = {};
                        try {
                            if (!$.isFunction(el.getBBox))
                                throw{};
                            else
                                ret = el.getBBox()
                        }
                        catch(e) {
                            ret = {
                                x: 0,
                                y: 0,
                                width: el.offsetWidth || 0,
                                height: el.offsetHeight || 0
                            }
                        }
                        return ret
                    }
                    bBox = $.extend({}, bBox(element));
                    if (rotateAngle) {
                        var cossin = utils.getCosAndSin(rotateAngle),
                            sin = cossin.sin.toFixed(3),
                            cos = cossin.cos.toFixed(3),
                            ltx = bBox.x - rotateX,
                            lty = bBox.y - rotateY,
                            rtx = bBox.x + bBox.width - rotateX,
                            rty = bBox.y - rotateY,
                            lbx = bBox.x - rotateX,
                            lby = bBox.y + bBox.height - rotateY,
                            rbx = bBox.x + bBox.width - rotateX,
                            rby = bBox.y + bBox.height - rotateY,
                            w,
                            h;
                        w = mabs(bBox.height * sin) + mabs(bBox.width * cos);
                        h = mabs(bBox.height * cos) + mabs(bBox.width * sin);
                        bBox.x = mmin(ltx * cos - lty * sin + rotateX, rtx * cos - rty * sin + rotateX, lbx * cos - lby * sin + rotateX, rbx * cos - rby * sin + rotateX);
                        bBox.y = mmin(ltx * sin + lty * cos + rotateY, rtx * sin + rty * cos + rotateY, lbx * sin + lby * cos + rotateY, rbx * sin + rby * cos + rotateY);
                        bBox.width = w;
                        bBox.height = h
                    }
                    return self._normalizeBBox(bBox)
                },
                _normalizeBBox: function(bBox) {
                    var ceil = Math.ceil,
                        floor = Math.floor,
                        $isNumeric = $.isNumeric,
                        rxl = floor(bBox.x),
                        ryt = floor(bBox.y),
                        rxr = ceil(bBox.width + bBox.x),
                        ryb = ceil(bBox.height + bBox.y),
                        width,
                        height;
                    bBox.x = $isNumeric(rxl) && rxl < MAX_PIXEL_COUNT && rxl > -MAX_PIXEL_COUNT ? rxl : 0;
                    bBox.y = $isNumeric(ryt) && ryt < MAX_PIXEL_COUNT && ryt > -MAX_PIXEL_COUNT ? ryt : 0;
                    width = rxr - rxl;
                    height = ryb - ryt;
                    bBox.width = $isNumeric(width) && width < MAX_PIXEL_COUNT && width > -MAX_PIXEL_COUNT ? width : 0;
                    bBox.height = $isNumeric(height) && height < MAX_PIXEL_COUNT && height > -MAX_PIXEL_COUNT ? height : 0;
                    bBox.isEmpty = !bBox.x && !bBox.y && !bBox.width && !bBox.height;
                    return bBox
                },
                clear: function(selector) {
                    selector ? this.$element.find(selector).remove() : this.$element.empty()
                },
                detach: function() {
                    this.$element.detach()
                },
                animate: function(params, options, complete) {
                    options = options || {};
                    if (this.renderer.animOptions.enabled) {
                        $.each(['height', 'width'], function(_, propName) {
                            if (propName in params) {
                                params['svg' + propName] = params[propName];
                                delete params[propName]
                            }
                        });
                        $(this).stop();
                        if (complete)
                            $.extend(options, {complete: complete});
                        $(this).animate(params, $.extend({duration: this.renderer.animOptions.duration}, options))
                    }
                    else {
                        if (params.translate) {
                            if ('x' in params.translate)
                                params.translateX = params.translate.x;
                            if ('y' in params.translate)
                                params.translateY = params.translate.y;
                            delete params.translate
                        }
                        if (options && options.step) {
                            options.step.call(this, undefined, {pos: 1});
                            options.complete && options.complete.call(this)
                        }
                        else
                            this.applySettings(params)
                    }
                },
                show: function(animate) {
                    if (animate && this.renderer.animOptions.enabled)
                        this.$element.show(this.renderer.animOptions.duration);
                    else
                        this.$element.show()
                },
                hide: function(animate) {
                    if (animate && this.renderer.animOptions.enabled)
                        this.$element.hide(this.renderer.animOptions.duration);
                    else
                        this.$element.hide()
                },
                move: function(x, y, animate, animOptions) {
                    x = x || 0,
                    y = y || 0;
                    animOptions = animOptions || {};
                    if (!animate)
                        this.applySettings({
                            translateX: x,
                            translateY: y
                        });
                    else
                        this.animate({translate: {
                                x: x,
                                y: y
                            }}, animOptions)
                },
                rotate: function(angle, x, y, animate, animOptions) {
                    angle = angle || 0;
                    x = x || 0;
                    y = y || 0;
                    animOptions = animOptions || {};
                    if (!animate)
                        this.applySettings({rotate: [angle, x, y]});
                    else
                        this.animate({rotate: {
                                angle: angle,
                                x: x,
                                y: y
                            }}, animOptions)
                },
                remove: function() {
                    this.$element.remove()
                },
                _normalizeSettings: function(settings) {
                    var key,
                        style,
                        firstChar,
                        styleName,
                        prop,
                        value,
                        normalized = {},
                        fontSetting;
                    for (key in settings) {
                        prop = key,
                        value = settings[prop];
                        if (prop === 'align') {
                            prop = 'text-anchor';
                            value = {
                                left: 'start',
                                center: 'middle',
                                right: 'end'
                            }[value]
                        }
                        else if (prop === 'font') {
                            style = this['_style'] = this['_style'] || {};
                            if (!$.isPlainObject(value))
                                continue;
                            $.each(value, function(fontSetting) {
                                switch (fontSetting) {
                                    case'color':
                                        styleName = 'fill';
                                        break;
                                    case'opacity':
                                        styleName = 'fillOpacity';
                                        break;
                                    case'cursor':
                                        styleName = fontSetting;
                                        break;
                                    default:
                                        firstChar = fontSetting.charAt(0);
                                        styleName = 'font' + fontSetting.replace(firstChar, firstChar.toUpperCase())
                                }
                                style[styleName] = value[fontSetting]
                            });
                            continue
                        }
                        else if (prop === 'dashStyle') {
                            prop = 'stroke-dasharray';
                            value = value.toLowerCase();
                            value = value === 'solid' ? 'none' : value.replace(/longdash/g, '8,3,').replace(/dash/g, '4,3,').replace(/dot/g, '1,3,').replace(/,$/, '').split(',');
                            if (value !== 'none')
                                value = $.map(value, function(p) {
                                    return +p * (settings.strokeWidth || 1)
                                }).join(',')
                        }
                        else if (/^(linecap|linejoin)$/i.test(prop))
                            prop = 'stroke-' + prop;
                        else if (/^(translateX|translateY|rotate|scale)$/i.test(prop)) {
                            this['_' + prop] = value;
                            continue
                        }
                        else if (prop === 'clipId') {
                            prop = 'clip-path';
                            value = 'url(#' + value + ')'
                        }
                        else if (prop === 'style') {
                            this['_style'] = this['_style'] || {};
                            $.extend(true, this['_style'], value);
                            continue
                        }
                        else if (prop === 'text')
                            continue;
                        else if (prop === 'segments')
                            continue;
                        else
                            prop = DX.inflector.dasherize(prop);
                        normalized[prop] = value
                    }
                    return this._applyTransformation(normalized)
                },
                _applyTransformation: function(settings) {
                    this.transformation = {
                        translateX: this._translateX,
                        translateY: this._translateY,
                        rotateAngle: 0,
                        rotateX: 0,
                        rotateY: 0
                    };
                    var tr = this.transformation,
                        rotate = this._rotate,
                        scale = this._scale,
                        transformations = [];
                    if (utils.isDefined(tr.translateX) || utils.isDefined(tr.translateY))
                        transformations.push('translate(' + (tr.translateX || 0) + ',' + (tr.translateY || 0) + ')');
                    if (utils.isDefined(rotate)) {
                        if (utils.isNumber(rotate)) {
                            tr.rotateAngle = rotate;
                            tr.rotateX = settings.x || 0;
                            tr.rotateY = settings.y || 0
                        }
                        else if ($.isArray(rotate)) {
                            tr.rotateAngle = rotate[0] || 0;
                            tr.rotateX = rotate[1] || 0;
                            tr.rotateY = rotate[2] || 0
                        }
                        else if (utils.isObject(rotate)) {
                            tr.rotateAngle = rotate.angle || 0;
                            tr.rotateX = rotate.x || 0;
                            tr.rotateY = rotate.y || 0
                        }
                        transformations.push('rotate(' + tr.rotateAngle + ',' + tr.rotateX + ',' + tr.rotateY + ')')
                    }
                    if (utils.isDefined(scale))
                        transformations.push('scale(' + (scale || 0) + ',' + (scale || 0) + ')');
                    if (transformations.length)
                        settings.transform = transformations.join(' ');
                    return settings
                }
            });
        var RootSvgElement = BaseSvgElement.inherit({
                defaultSettings: function() {
                    return {
                            width: 0,
                            height: 0,
                            style: {'-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)'},
                            xmlns: 'http://www.w3.org/2000/svg',
                            'xmlns:xlink': 'http://www.w3.org/1999/xlink',
                            version: '1.1',
                            stroke: 'none',
                            strokeWidth: 0,
                            fill: 'none'
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'svg', params)
                }
            });
        var RectSvgBaseElement = {
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                },
                adjustSettings: function() {
                    if (!utils.isDefined(this.settings.sharpEdges) || this.settings.sharpEdges) {
                        this.sharpEdges();
                        delete this.settings.sharpEdges
                    }
                },
                prepareSettings: function(settings) {
                    var prevStrokeWidth = this.settings ? Number(this.settings.strokeWidth) || 0 : 0,
                        newStrokeWidth,
                        maxStrokeWidth,
                        strokeWidthChanged = false;
                    if (utils.isDefined(settings.width))
                        this._realWidth = Number(settings.width);
                    if (utils.isDefined(settings.height))
                        this._realHeight = Number(settings.height);
                    if (utils.isDefined(settings.x))
                        this._realX = Number(settings.x);
                    if (utils.isDefined(settings.y))
                        this._realY = Number(settings.y);
                    if (utils.isDefined(settings.strokeWidth))
                        this._realStrokeWidth = Number(settings.strokeWidth);
                    this._realStrokeWidth = this._realStrokeWidth || this.defaultSettings().strokeWidth || 0;
                    maxStrokeWidth = ~~((this._realWidth < this._realHeight ? this._realWidth : this._realHeight) / 2);
                    newStrokeWidth = this._realStrokeWidth < maxStrokeWidth ? this._realStrokeWidth : maxStrokeWidth;
                    if (newStrokeWidth !== prevStrokeWidth) {
                        strokeWidthChanged = true;
                        settings.sharpEdges = true;
                        newStrokeWidth > 0 && (settings.strokeWidth = newStrokeWidth)
                    }
                    (utils.isDefined(settings.x) || strokeWidthChanged) && (settings.x = this._realX + newStrokeWidth / 2);
                    (utils.isDefined(settings.y) || strokeWidthChanged) && (settings.y = this._realY + newStrokeWidth / 2);
                    (utils.isDefined(settings.width) || strokeWidthChanged) && (settings.width = this._realWidth - newStrokeWidth);
                    (utils.isDefined(settings.height) || strokeWidthChanged) && (settings.height = this._realHeight - newStrokeWidth)
                },
                applySettings: function(settings) {
                    var settings = $.extend(true, {}, settings);
                    this.prepareSettings(settings);
                    this.callBase(settings)
                },
                sharpEdges: function() {
                    var strokeWidth = Math.round(this.settings.strokeWidth || 0),
                        correction = strokeWidth % 2 / 2;
                    this.settings.x = Math.floor(this.settings.x - correction || 0) + correction;
                    this.settings.y = Math.floor(this.settings.y - correction || 0) + correction;
                    this.settings.width = Math.floor(this.settings.width || 0);
                    this.settings.height = Math.floor(this.settings.height || 0);
                    this.settings.strokeWidth > 0 && (this.settings.strokeWidth = strokeWidth)
                }
            };
        var ImageSvgElement = BaseSvgElement.inherit(RectSvgBaseElement).inherit({
                ctor: function(renderer, params, href, location) {
                    var locationToPreserveAspectRatioMap = {
                            full: 'none',
                            lefttop: 'xMinYMin',
                            leftcenter: 'xMinYMid',
                            leftbottom: 'xMinYMax',
                            centertop: 'xMidYMin',
                            center: 'xMidYMid',
                            centerbottom: 'xMidYMax',
                            righttop: 'xMaxYMin',
                            rightcenter: 'xMaxYMid',
                            rightbottom: 'xMaxYMax'
                        };
                    this.href = utils.isDefined(href) ? href : '';
                    this.preserveAspectRatio = locationToPreserveAspectRatioMap[(location || '').toLowerCase()];
                    this.preserveAspectRatio = this.preserveAspectRatio || 'none';
                    this.callBase(renderer, 'image', params)
                },
                adjustSettings: function() {
                    this.callBase();
                    this.element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', this.href);
                    if (this.preserveAspectRatio)
                        this.element.setAttribute('preserveAspectRatio', this.preserveAspectRatio)
                }
            });
        var RectSvgElement = BaseSvgElement.inherit(RectSvgBaseElement).inherit({
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            rx: 0,
                            ry: 0
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'rect', params)
                }
            });
        var PathSvgElement = BaseSvgElement.inherit({
                defaultSettings: function() {
                    return {points: {
                                x: 0,
                                y: 0
                            }}
                },
                getNodeName: function() {
                    return 'path'
                },
                getPathAttributeName: function() {
                    return 'd'
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, this.getNodeName(), params)
                },
                dispose: function() {
                    this.segments = null;
                    this.fromSegments = null;
                    this.callBase()
                },
                adjustSettings: function() {
                    this.prepareSegments(this.settings)
                },
                applySettings: function(settings) {
                    var settings = settings || {};
                    if (this.settings && settings.strokeWidth && this.settings.strokeWidth !== settings.strokeWidth)
                        settings.sharpEdges = true;
                    this.callBase(settings)
                },
                prepareSegments: function(params) {
                    if ('points' in params) {
                        var points = params.points,
                            firstElem = points[0],
                            close = this.closePath || params.closePath,
                            segments = [],
                            i;
                        if (utils.isObject(firstElem))
                            segments = $.map(points, function(pt, i) {
                                if (!i)
                                    return [['M', pt.x, pt.y]];
                                return [['L', pt.x, pt.y]]
                            });
                        else if (utils.isNumber(firstElem))
                            for (i = 0; i < points.length; i += 2) {
                                if (!i) {
                                    segments = [['M', points[i] || 0, points[i + 1] || 0]];
                                    continue
                                }
                                segments.push(['L', points[i] || 0, points[i + 1] || 0])
                            }
                        else
                            segments = [['M', 0, 0]];
                        if (close)
                            segments.push(['Z']);
                        this.segments = segments;
                        delete params.points;
                        delete params.closePath;
                        params.sharpEdges = true
                    }
                    if (params.sharpEdges) {
                        this.sharpEdges();
                        this.combinePathParams(params);
                        delete params.sharpEdges
                    }
                },
                customizeSegments: function(segments) {
                    return segments
                },
                combinePathParams: function(params) {
                    var path;
                    this.segments = this.customizeSegments(this.segments);
                    if (this.segments) {
                        path = $.map(this.segments, function(seg, i) {
                            return seg.join(' ')
                        });
                        path = path.join(' ');
                        params[this.getPathAttributeName()] = path
                    }
                },
                animate: function(params, options) {
                    var callBase = this.callBase;
                    if (!('points' in params))
                        return this.callBase(params, options);
                    this.fromSegments = this.segments;
                    this.prepareSegments(params);
                    if (this.renderer.animOptions.enabled)
                        $.extend(params, {d: 1});
                    this.callBase = callBase;
                    this.callBase(params, options)
                },
                sharpEdges: function() {
                    var self = this,
                        segLength = self.segments.length,
                        i = 0,
                        curSeg,
                        nextSeg,
                        curX,
                        curY,
                        nextX,
                        nextY,
                        curXIdx,
                        curYIdx,
                        nextXIdx,
                        nextYIdx,
                        strokeWidth = Math.round(self.settings.strokeWidth || 0),
                        correction = strokeWidth % 2 / 2;
                    for (i; i < segLength - 1; i++) {
                        curSeg = self.segments[i];
                        nextSeg = self.segments[i + 1];
                        if (nextSeg[0] === 'Z' && i)
                            nextSeg = self.segments[0];
                        switch (curSeg[0]) {
                            case'M':
                            case'L':
                                curXIdx = 1;
                                curYIdx = 2;
                                break;
                            case'C':
                                curXIdx = 5;
                                curYIdx = 6;
                                break;
                            case'A':
                                curXIdx = 6;
                                curYIdx = 7;
                                break;
                            case'Z':
                                continue
                        }
                        switch (nextSeg[0]) {
                            case'M':
                            case'L':
                                nextXIdx = 1;
                                nextYIdx = 2;
                                break;
                            case'C':
                                nextXIdx = 5;
                                nextYIdx = 6;
                                break;
                            case'A':
                                nextXIdx = 6;
                                nextYIdx = 7;
                                break;
                            case'Z':
                                continue
                        }
                        curX = Math.floor(curSeg[curXIdx]);
                        curY = Math.floor(curSeg[curYIdx]);
                        nextX = nextSeg[nextXIdx] = Math.floor(nextSeg[nextXIdx]);
                        nextY = nextSeg[nextYIdx] = Math.floor(nextSeg[nextYIdx]);
                        curSeg[curXIdx] = i == 0 ? curX : curSeg[curXIdx];
                        curSeg[curYIdx] = i == 0 ? curY : curSeg[curYIdx];
                        if (curX == nextX) {
                            curSeg[curXIdx] = curX + correction;
                            nextSeg[nextXIdx] = nextX + correction
                        }
                        if (curY == nextY) {
                            curSeg[curYIdx] = curY + correction;
                            nextSeg[nextYIdx] = nextY + correction
                        }
                    }
                }
            });
        var SegmentRectSvgElement = PathSvgElement.inherit(RectSvgBaseElement).inherit({
                defaultSettings: function() {
                    return $.extend(true, {}, this.callBase(), {segments: {
                                top: true,
                                bottom: true,
                                left: true,
                                right: true
                            }})
                },
                prepareSegments: function() {
                    var self = this,
                        settings = self.settings,
                        left = settings.x,
                        right = left + settings.width,
                        top = settings.y,
                        bottom = top + settings.height,
                        segments = [],
                        segmentSequence,
                        visiblyOpt = 0,
                        prevSegmentVisibility = 0;
                    var allSegment = {
                            top: [['M', left, top], ['L', right, top]],
                            right: [['M', right, top], ['L', right, bottom]],
                            bottom: [['M', right, bottom], ['L', left, bottom]],
                            left: [['M', left, bottom], ['L', left, top]]
                        };
                    $.each(allSegment, function(seg, _) {
                        var visibility = !!self.settings.segments[seg];
                        visiblyOpt = visiblyOpt * 2 + ~~visibility
                    });
                    switch (visiblyOpt) {
                        case(13):
                        case(9):
                            segmentSequence = ['left', 'top', 'right', 'bottom'];
                            break;
                        case(11):
                            segmentSequence = ['bottom', 'left', 'top', 'right'];
                            break;
                        default:
                            segmentSequence = ['top', 'right', 'bottom', 'left']
                    }
                    $.each(segmentSequence, function(_, seg) {
                        var segmentVisibility = !!self.settings.segments[seg];
                        if (segmentVisibility)
                            $.each(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
                                segments.push(segment)
                            });
                        prevSegmentVisibility = ~~segmentVisibility
                    });
                    visiblyOpt == 15 && segments.push(['Z']);
                    this.segments = segments.length ? segments : [['M', 0, 0], ['Z']];
                    this.combinePathParams(settings)
                },
                adjustSettings: function() {
                    this.callBase();
                    this.prepareSegments()
                },
                applySettings: function(settings) {
                    var segments = this.settings && this.settings.segments || this.defaultSettings().segments;
                    settings.segments = $.extend(true, {}, segments || {}, settings.segments);
                    this.callBase(settings)
                }
            });
        var AreaSvgElement = PathSvgElement.inherit({
                defaultSettings: function() {
                    return {points: {
                                x: 0,
                                y: 0
                            }}
                },
                ctor: function(renderer, params) {
                    this.closePath = true;
                    this.callBase(renderer, params)
                }
            });
        var BezierSvgElement = PathSvgElement.inherit({
                defaultSettings: function() {
                    return {points: {
                                x: 0,
                                y: 0
                            }}
                },
                prepareSegments: function(params) {
                    if (!('points' in params))
                        return;
                    var points = params.points,
                        firstElem = points[0],
                        close = this.closePath || params.closePath,
                        segments = [],
                        seg = [],
                        i,
                        x,
                        y;
                    var cnt = 0;
                    if (utils.isObject(firstElem)) {
                        for (i = 0; i < points.length; i++) {
                            x = points[i].x;
                            y = points[i].y;
                            if (!i) {
                                segments = [['M', x, y]];
                                continue
                            }
                            if ((i - 1) % 3 == 0) {
                                if (seg.length > 0)
                                    segments.push(seg);
                                seg = ['C', x, y];
                                continue
                            }
                            seg.push(x);
                            seg.push(y)
                        }
                        if (seg.length > 0)
                            segments.push(seg)
                    }
                    else if (utils.isNumber(firstElem)) {
                        for (i = 0; i < points.length; i += 2) {
                            x = points[i];
                            y = points[i + 1];
                            if (!i) {
                                segments = [['M', x, y || 0]];
                                continue
                            }
                            if ((i - 2) % 6 == 0) {
                                if (seg.length > 0)
                                    segments.push(seg);
                                seg = ['C', x, y || 0];
                                continue
                            }
                            seg.push(x);
                            seg.push(y || 0)
                        }
                        if (seg.length > 0)
                            segments.push(seg)
                    }
                    else
                        segments = [['M', 0, 0]];
                    if (close)
                        segments.push(['Z']);
                    this.segments = segments;
                    delete params.points;
                    delete params.closePath;
                    this.combinePathParams(params)
                }
            });
        var BezierAreaSvgElement = BezierSvgElement.inherit({
                defaultSettings: function() {
                    return {points: {
                                x: 0,
                                y: 0
                            }}
                },
                ctor: function(renderer, params) {
                    this.closePath = true;
                    this.callBase(renderer, params)
                }
            });
        var ArcSvgElement = PathSvgElement.inherit({
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0,
                            linejoin: 'round'
                        }
                },
                createArcSegments: function(x, y, innerR, outerR, startAngle, endAngle) {
                    var longFlag = Math.abs(endAngle - startAngle) > Math.PI ? '1' : '0',
                        xOuterStart = x + outerR * Math.cos(startAngle),
                        yOuterStart = y - outerR * Math.sin(startAngle),
                        xOuterEnd = x + outerR * Math.cos(endAngle),
                        yOuterEnd = y - outerR * Math.sin(endAngle),
                        xInnerStart = x + innerR * Math.cos(endAngle),
                        yInnerStart = y - innerR * Math.sin(endAngle),
                        xInnerEnd = x + innerR * Math.cos(startAngle),
                        yInnerEnd = y - innerR * Math.sin(startAngle);
                    return [['M', xOuterStart, yOuterStart], ['A', outerR, outerR, 0, longFlag, 0, xOuterEnd, yOuterEnd], ['L', xInnerStart, yInnerStart], ['A', innerR, innerR, 0, longFlag, 1, xInnerEnd, yInnerEnd], ['Z']]
                },
                prepareSegments: function(params) {
                    if (!('x' in params) && !('y' in params) && !('outerRadius' in params) && !('innerRadius' in params) && !('startAngle' in params) && !('endAngle' in params))
                        return;
                    var x = utils.isNumber(params.x) ? Number(params.x) : 0,
                        y = utils.isNumber(params.y) ? Number(params.y) : 0,
                        outerR = utils.isNumber(params.outerRadius) ? Number(params.outerRadius) : 0,
                        innerR = utils.isNumber(params.innerRadius) ? Number(params.innerRadius) : 0,
                        startAngle = utils.isNumber(params.startAngle) ? Number(params.startAngle) : 0,
                        endAngle = utils.isNumber(params.endAngle) ? Number(params.endAngle) : 360;
                    this.segments = [['M', 0, 0], ['Z']];
                    if (outerR || innerR) {
                        var tmp = Math.min(outerR, innerR);
                        outerR = Math.max(outerR, innerR);
                        innerR = tmp;
                        if (Math.round(startAngle) != Math.round(endAngle)) {
                            if (Math.abs(endAngle - startAngle) % 360 == 0)
                                endAngle -= 0.0001;
                            if (startAngle > 360)
                                startAngle = startAngle % 360;
                            if (endAngle > 360)
                                endAngle = endAngle % 360;
                            if (startAngle > endAngle)
                                startAngle -= 360;
                            startAngle = startAngle * Math.PI / 180;
                            endAngle = endAngle * Math.PI / 180;
                            this.segments = this.createArcSegments(x, y, innerR, outerR, startAngle, endAngle)
                        }
                    }
                    delete params.x;
                    delete params.y;
                    delete params.outerRadius;
                    delete params.innerRadius;
                    delete params.startAngle;
                    delete params.endAngle;
                    this.combinePathParams(params)
                }
            });
        var CircleSvgElement = BaseSvgElement.inherit({
                defaultSettings: function() {
                    return {
                            cx: 0,
                            cy: 0,
                            r: 0
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'circle', params)
                }
            });
        var TextSvgElement = BaseSvgElement.inherit({
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0
                        }
                },
                ctor: function(renderer, params) {
                    this.tspans = [];
                    this.callBase(renderer, 'text', params)
                },
                dispose: function() {
                    this.tspans = null;
                    this.callBase()
                },
                updateText: function(text) {
                    if (!utils.isDefined(text))
                        text = '';
                    this.applySettings({text: text})
                },
                adjustSettings: function() {
                    if (!('text' in this.settings)) {
                        this.changeX();
                        return
                    }
                    this._createElementWithText(this.settings.text)
                },
                changeX: function() {
                    for (var i = 0; i < this.tspans.length; i++)
                        if (this.tspans[i].settings.x != undefined)
                            this.tspans[i].applySettings({x: this.settings.x})
                },
                _createElementWithText: function(text) {
                    var div,
                        i;
                    this.clear();
                    text = text.toString().replace(/\r/g, "");
                    text = text.replace(/\n/g, "<br/>");
                    div = doc.createElement("div");
                    div.innerHTML = text;
                    div.params = {style: {}};
                    this._orderText(div)
                },
                clear: function() {
                    this.callBase();
                    this.tspans = []
                },
                _orderText: function(node) {
                    var textArray = [],
                        defaultFontSize = (this.settings.font ? this.settings.font.size : 12) || 12;
                    var order = function(strCount, node, textArray) {
                            var params = {style: {}},
                                textArray = textArray || [];
                            node.params = node.params || {};
                            if (node.parentNode && node.nodeName != "#text")
                                if (node.parentNode.params)
                                    for (var i in node.parentNode.params)
                                        node.params[i] = node.parentNode.params[i];
                            switch (node.tagName) {
                                case"B" || "STRONG":
                                    node.params.fontWeight = "bold";
                                    break;
                                case"I" || "EM":
                                    node.params.fontStyle = "italic";
                                    break;
                                case"U":
                                    node.params.textDecoration = "underline";
                                    break;
                                case"BR":
                                    strCount++;
                                    break
                            }
                            if (node.style) {
                                if (node.style.fontSize)
                                    node.params.fontSize = node.style.fontSize.split('p')[0] || node.params.fontSize;
                                node.params.fill = node.style.color || node.params.fill;
                                node.params.fontStyle = node.style.fontStyle || node.params.fontStyle;
                                node.params.fontWeight = node.style.fontWeight || node.params.fontWeight;
                                node.params.textDecoration = node.style.textDecoration || node.params.textDecoration
                            }
                            var childnum = node.childNodes.length;
                            var count = 0;
                            while (count != childnum)
                                strCount = order(strCount, node.childNodes[count++], textArray);
                            if (node.wholeText != undefined) {
                                params.fill = node.parentNode.params.fill;
                                params.text = node.wholeText,
                                node.parentNode.params.fontSize && (params.style.fontSize = node.parentNode.params.fontSize);
                                node.parentNode.params.fontStyle && (params.style.fontStyle = node.parentNode.params.fontStyle);
                                node.parentNode.params.fontWeight && (params.style.fontWeight = node.parentNode.params.fontWeight);
                                node.parentNode.params.textDecoration && (params.style.textDecoration = node.parentNode.params.textDecoration);
                                textArray.push({
                                    params: params,
                                    line: strCount
                                })
                            }
                            return strCount
                        };
                    order(0, node, textArray);
                    for (var txt = 0; txt < textArray.length; txt++) {
                        if (txt != 0)
                            if (textArray[txt].line != textArray[txt - 1].line) {
                                textArray[txt].params.dy = textArray[txt].params.fontSize || defaultFontSize;
                                textArray[txt].params.x = this.settings.x
                            }
                            else {
                                textArray[txt].params.dy = 0;
                                textArray[txt].params.dx = 0
                            }
                        else {
                            textArray[txt].params.x = this.settings.x;
                            textArray[txt].params.dy = 0
                        }
                        var tspan = new TspanSvgElement(this.renderer, textArray[txt].params);
                        tspan.append(this);
                        this.tspans.push(tspan)
                    }
                }
            });
        var TspanSvgElement = BaseSvgElement.inherit({ctor: function(renderer, params) {
                    var text = params.text || '';
                    delete params.text;
                    this.callBase(renderer, 'tspan', params);
                    this.element.appendChild(doc.createTextNode(text))
                }});
        var GroupSvgElement = BaseSvgElement.inherit({
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'g', params)
                },
                update: $.noop
            });
        var PatternSvgElement = BaseSvgElement.inherit({
                ctor: function(renderer, params) {
                    this.__patternParams = $.extend({}, params);
                    var id = utils.getNextPatternId(),
                        color = params.color;
                    this.callBase(renderer, 'pattern', {
                        id: id,
                        width: 6,
                        height: 6
                    });
                    this.element.setAttribute('patternUnits', 'userSpaceOnUse');
                    this._lines = [];
                    if (params.hatching === 'right') {
                        this._lines.push(renderer.createLine(0, 0, 1, 1, {
                            strokeWidth: 1,
                            stroke: color,
                            opacity: 0.8
                        }).append(this));
                        this._lines.push(renderer.createLine(5, 5, 6, 6, {
                            strokeWidth: 1,
                            stroke: color,
                            opacity: 0.8
                        }).append(this));
                        this._lines.push(renderer.createLine(0, 6, 6, 0, {
                            strokeWidth: 2,
                            stroke: color
                        }).append(this))
                    }
                    else if (params.hatching === 'left') {
                        this._lines.push(renderer.createLine(5, 1, 6, 0, {
                            strokeWidth: 1,
                            stroke: color,
                            opacity: 0.8
                        }).append(this));
                        this._lines.push(renderer.createLine(0, 6, 1, 5, {
                            strokeWidth: 1,
                            stroke: color,
                            opacity: 0.8
                        }).append(this));
                        this._lines.push(renderer.createLine(0, 0, 6, 6, {
                            strokeWidth: 2,
                            stroke: color
                        }).append(this))
                    }
                    this.id = 'url(#' + id + ')'
                },
                append: function() {
                    return this.callBase(this.renderer.defsSvg)
                },
                clear: function() {
                    this.callBase();
                    this._lines = []
                },
                dispose: function() {
                    this._lines = null;
                    this.callBase()
                }
            });
        var ClipRectSvgElement = BaseSvgElement.inherit({
                ctor: function(renderer, params) {
                    this.__clipRectParams = $.extend({}, params);
                    var x = params.x,
                        y = params.y,
                        w = params.w,
                        h = params.h,
                        id = utils.getNextClipId();
                    delete params.x;
                    delete params.y;
                    delete params.w;
                    delete params.h;
                    this.callBase(renderer, 'clipPath', {id: id});
                    this.id = id;
                    this._rect = renderer.createRect(x, y, w, h, 0, params);
                    this._rect.append(this)
                },
                append: function() {
                    return this.callBase(this.renderer.defsSvg)
                },
                updateRectangle: function(settings) {
                    this._rect.applySettings(settings)
                },
                dispose: function() {
                    this._rect = null;
                    this.callBase()
                }
            });
        renderers.SvgRenderer = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._setAnimationOptions(options.animation || {});
                this.cssClass = options.cssClass || '';
                this.recreateCanvas(options.width, options.height)
            },
            dispose: function() {
                this.killContainer();
                this.animOptions = null
            },
            _setAnimationOptions: function(options) {
                this.animOptions = {
                    enabled: true,
                    duration: 1000,
                    easing: 'easeOutCubic'
                };
                if ('enabled' in options)
                    this.animOptions.enabled = options.enabled;
                if ('duration' in options)
                    this.animOptions.duration = options.duration;
                if ('easing' in options && easingFunctions[options.easing])
                    this.animOptions.easing = options.easing
            },
            updateAnimationOptions: function(newOptions) {
                this._setAnimationOptions($.extend(this.animOptions || {}, newOptions))
            },
            killContainer: function() {
                this.svgRoot && (this.svgRoot.remove(), this.svgRoot = null);
                this.defsSvg && (this.defsSvg.remove(), this.defsSvg = null);
                this.drawn = null
            },
            recreateCanvas: function(width, height, cssClass) {
                if (width > 0 && height > 0) {
                    if (!this.svgRoot) {
                        this.cssClass = cssClass || this.cssClass;
                        this.svgRoot = new RootSvgElement(this, {
                            width: width,
                            height: height,
                            'class': this.cssClass
                        })
                    }
                    else
                        this.svgRoot.applySettings({
                            width: width,
                            height: height
                        });
                    this.defsSvg && this.defsSvg.clear("pattern")
                }
            },
            resize: function(width, height) {
                var root = this.getRoot();
                root && width > 0 && height > 0 && root.applySettings({
                    width: width,
                    height: height
                })
            },
            getRoot: function() {
                return this.svgRoot
            },
            isInitialized: function() {
                return !!this.svgRoot
            },
            draw: function(container) {
                if (!container || this.drawn)
                    return;
                container.appendChild(this.getRoot().element);
                this.drawn = true
            },
            updateParams: function(params, options) {
                if (options && options.strokeWidth)
                    params.strokeWidth = options.strokeWidth
            },
            createRect: function(x, y, w, h, r, options) {
                var params = {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r
                    };
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new RectSvgElement(this, params)
            },
            createSegmentRect: function(x, y, w, h, r, segments, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r,
                        segments: segments
                    });
                return new SegmentRectSvgElement(this, params)
            },
            createClipRect: function(x, y, w, h) {
                var attr = {
                        x: x,
                        y: y,
                        w: w,
                        h: h,
                        fill: 'none',
                        stroke: 'none',
                        strokeWidth: 0
                    };
                if (!this.defsSvg) {
                    this.defsSvg = new BaseSvgElement(this, 'defs');
                    this.defsSvg.append()
                }
                return new ClipRectSvgElement(this, attr)
            },
            createPattern: function(color, hatching) {
                hatching = (hatching || '').toLowerCase();
                if (hatching !== 'right' && hatching !== 'left')
                    return {
                            id: color,
                            append: function() {
                                return this
                            },
                            clear: function(){}
                        };
                if (!this.defsSvg) {
                    this.defsSvg = new BaseSvgElement(this, 'defs');
                    this.defsSvg.append()
                }
                return new PatternSvgElement(this, {
                        hatching: hatching,
                        color: color
                    })
            },
            createImage: function(x, y, w, h, href, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h
                    });
                return new ImageSvgElement(this, params, href, params.location)
            },
            createLine: function(x1, y1, x2, y2, options) {
                var params = {points: [x1, y1, x2, y2]};
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new PathSvgElement(this, params)
            },
            createPath: function(points, options) {
                var params = {points: points};
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new PathSvgElement(this, params)
            },
            createBezierPath: function(points, options) {
                var params = {points: points};
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new BezierSvgElement(this, params)
            },
            createArea: function(points, options) {
                var params = {points: points};
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new AreaSvgElement(this, params)
            },
            createBezierArea: function(points, options) {
                var params = {points: points};
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new BezierAreaSvgElement(this, params)
            },
            createCircle: function(x, y, r, options) {
                var params = {
                        cx: x,
                        cy: y,
                        r: r
                    };
                if (options && !options.inh)
                    $.extend(params, options);
                return new CircleSvgElement(this, params)
            },
            createArc: function(x, y, outerRadius, innerRadius, startAngle, endAngle, options) {
                var params = {
                        x: x,
                        y: y,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius,
                        startAngle: startAngle,
                        endAngle: endAngle
                    };
                if (options && !options.inh)
                    $.extend(params, options);
                this.updateParams(params, options);
                return new ArcSvgElement(this, params)
            },
            createText: function(text, x, y, options) {
                var params = {
                        x: x,
                        y: y,
                        text: text
                    };
                if (options && !options.inh)
                    $.extend(params, options);
                return new TextSvgElement(this, params)
            },
            createGroup: function(options) {
                return new GroupSvgElement(this, options)
            }
        });
        renderers._svgRendererInternals = {
            BaseSvgElement: BaseSvgElement,
            RootSvgElement: RootSvgElement,
            RectSvgElement: RectSvgElement,
            ImageSvgElement: ImageSvgElement,
            PathSvgElement: PathSvgElement,
            AreaSvgElement: AreaSvgElement,
            BezierSvgElement: BezierSvgElement,
            BezierAreaSvgElement: BezierAreaSvgElement,
            CircleSvgElement: CircleSvgElement,
            TextSvgElement: TextSvgElement,
            TspanSvgElement: TspanSvgElement,
            GroupSvgElement: GroupSvgElement,
            ArcSvgElement: ArcSvgElement,
            RectSvgBaseElement: RectSvgBaseElement,
            SegmentRectSvgElement: SegmentRectSvgElement,
            ClipRectSvgElement: ClipRectSvgElement,
            PatternSvgElement: PatternSvgElement
        }
    })(jQuery, DevExpress);
    /*! Module viz, file vmlRenderer.js */
    (function($, DX) {
        var renderers = DX.viz.renderers,
            utils = DX.utils,
            doc = document,
            svgRendererInternals = renderers._svgRendererInternals;
        var defaultVmlSettings = {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                position: 'absolute'
            };
        var extendDefaultVmlOptions = function(customOptions, baseOptions) {
                return $.extend(true, baseOptions || {}, defaultVmlSettings, customOptions)
            };
        var parseRotateParameter = function(rotate, defaultX, defaultY) {
                var rotateObject;
                if (utils.isDefined(rotate))
                    if (utils.isNumber(rotate))
                        rotateObject = {
                            angle: rotate,
                            x: defaultX || 0,
                            y: defaultY || 0
                        };
                    else if ($.isArray(rotate))
                        rotateObject = {
                            angle: rotate[0] || 0,
                            x: rotate[1] || 0,
                            y: rotate[2] || 0
                        };
                    else if (utils.isObject(rotate))
                        rotateObject = {
                            angle: rotate.angle || 0,
                            x: rotate.x || 0,
                            y: rotate.y || 0
                        };
                return rotateObject
            };
        var applySubElementAttribute = function(vmlElement, params, name) {
                var element = vmlElement.element,
                    subElement,
                    value = params[name];
                if (name === 'opacity' || name === 'fillOpacity')
                    if (element.fill)
                        element.fill.opacity = value >= 0.002 ? value : 0.002;
                    else {
                        subElement = doc.createElement('vml:fill');
                        element.appendChild(subElement);
                        subElement.opacity = value >= 0.002 ? value : 0.002;
                        subElement.className = 'vml';
                        if (params.fillcolor)
                            subElement.color = params.fillcolor
                    }
                if (name === 'joinStyle')
                    if (element.stroke)
                        element.stroke.joinStyle = value;
                    else {
                        subElement = doc.createElement('vml:stroke');
                        vmlElement.element.appendChild(subElement);
                        subElement.className = 'vml';
                        subElement.joinStyle = value
                    }
                if (name === 'opacity' || name === 'strokeOpacity')
                    if (element.stroke)
                        element.stroke.opacity = value >= 0.002 ? value : 0.002;
                    else {
                        subElement = doc.createElement('vml:stroke');
                        vmlElement.element.appendChild(subElement);
                        subElement.className = 'vml';
                        subElement.opacity = value >= 0.002 ? value : 0.002;
                        if (params.strokecolor)
                            subElement.color = params.strokecolor
                    }
                if (name === 'dashstyle')
                    if (element.stroke)
                        element.stroke.dashstyle = value;
                    else {
                        subElement = doc.createElement('vml:stroke');
                        vmlElement.element.appendChild(subElement);
                        subElement.className = 'vml';
                        subElement.dashstyle = value
                    }
            };
        var getBoundingClientRect = function(element) {
                var i,
                    resultRect,
                    rect,
                    tagName = element.tagName.toLowerCase(),
                    points,
                    value,
                    halfStrokeWidth;
                if (tagName === 'div') {
                    if (element.childNodes.length > 0) {
                        resultRect = {};
                        for (i = 0; i < element.childNodes.length; i++) {
                            rect = getBoundingClientRect(element.childNodes[i]);
                            if (!rect)
                                continue;
                            resultRect.left = resultRect.left === undefined || rect.left < resultRect.left ? rect.left : resultRect.left;
                            resultRect.top = resultRect.top === undefined || rect.top < resultRect.top ? rect.top : resultRect.top;
                            resultRect.right = resultRect.right === undefined || rect.right > resultRect.right ? rect.right : resultRect.right;
                            resultRect.bottom = resultRect.bottom === undefined || rect.bottom > resultRect.bottom ? rect.bottom : resultRect.bottom
                        }
                    }
                }
                else if (tagName === 'shape' || tagName === 'vml:shape') {
                    points = (element.path.value || element.path).match(/[-0-9]+/g);
                    resultRect = {};
                    rect = element.getBoundingClientRect();
                    for (i = 0; i < points.length; i++) {
                        value = parseInt(points[i]);
                        if (i % 2) {
                            resultRect.top = resultRect.top === undefined || value < resultRect.top ? value : resultRect.top;
                            resultRect.bottom = resultRect.bottom === undefined || value > resultRect.bottom ? value : resultRect.bottom
                        }
                        else {
                            resultRect.left = resultRect.left === undefined || value < resultRect.left ? value : resultRect.left;
                            resultRect.right = resultRect.right === undefined || value > resultRect.right ? value : resultRect.right
                        }
                    }
                    resultRect.left = resultRect.left || 0;
                    resultRect.top = resultRect.top || 0;
                    resultRect.right = resultRect.right || 0;
                    resultRect.bottom = resultRect.bottom || 0;
                    if (rect.right - rect.left <= 1 && rect.top - rect.bottom <= 1) {
                        resultRect.right = resultRect.right + rect.left;
                        resultRect.bottom = resultRect.bottom + rect.top;
                        resultRect.left = resultRect.left + rect.left;
                        resultRect.top = resultRect.top + rect.top
                    }
                    else {
                        resultRect.right = resultRect.right - resultRect.left + rect.left;
                        resultRect.bottom = resultRect.bottom - resultRect.top + rect.top;
                        resultRect.left = rect.left;
                        resultRect.top = rect.top
                    }
                    halfStrokeWidth = Math.ceil(parseFloat(element.strokeweight) / 2);
                    if (halfStrokeWidth && halfStrokeWidth > 1) {
                        resultRect.left -= halfStrokeWidth;
                        resultRect.top -= halfStrokeWidth;
                        resultRect.right += halfStrokeWidth;
                        resultRect.bottom += halfStrokeWidth
                    }
                }
                else
                    resultRect = element.getBoundingClientRect();
                return resultRect
            };
        var BaseVmlElement = {
                isVml: function() {
                    return true
                },
                dispose: function() {
                    this.childElements = null;
                    this._style = null;
                    this.callBase()
                },
                defaultSettings: function(customOptions) {
                    return extendDefaultVmlOptions(customOptions, this.callBase ? this.callBase() : {})
                },
                createElement: function(nodeName) {
                    this._nodeName = nodeName;
                    this.childElements = [];
                    if (this.isVml()) {
                        var result = doc.createElement('vml:' + nodeName);
                        result.className = 'vml';
                        return result
                    }
                    else
                        return doc.createElement(nodeName)
                },
                clear: function() {
                    this.callBase();
                    this.childElements = []
                },
                _fillAttributesFromCurrentStyle: function(attributes) {
                    var element = this.element,
                        backgroundColor,
                        root = this.renderer.getRoot(),
                        defaultColor = root && root.element.currentStyle && root.element.currentStyle.color;
                    if (this.isVml() && element.style && element.currentStyle) {
                        if (element.style.backgroundColor === 'transparent')
                            element.style.backgroundColor = '';
                        if (element.currentStyle.backgroundColor !== 'transparent') {
                            backgroundColor = element.currentStyle.backgroundColor;
                            if (!(this instanceof RectVmlElement))
                                element.style.backgroundColor = 'transparent';
                            attributes.filled = 't';
                            attributes.fillcolor = backgroundColor;
                            if (element.currentStyle.opacity) {
                                element.style.filter = 'alpha(opacity=' + element.currentStyle.opacity * 100 + ')';
                                delete attributes.opacity;
                                delete attributes.fillOpacity
                            }
                        }
                        if (defaultColor && element.currentStyle.color !== defaultColor) {
                            attributes.stroked = 't';
                            attributes.strokecolor = this.element.currentStyle.color;
                            if (element.currentStyle.opacity)
                                attributes.strokeOpacity = element.currentStyle.opacity
                        }
                    }
                },
                _applyAttributes: function(params) {
                    var name,
                        value;
                    if (params && params.arcsize !== undefined) {
                        try {
                            this.element.setAttribute('arcsize', params.arcsize)
                        }
                        catch(e) {}
                        this.__appliedSettings = {arcsize: params.arcsize};
                        delete params.arcsize
                    }
                    if (!this._isAppended) {
                        this._delayedAttributes = params;
                        if (utils.isDefined(params['class']))
                            if (!this.isVml())
                                this.element.className = params['class']
                    }
                    else {
                        params = params || this._delayedAttributes;
                        if (params) {
                            this._fillAttributesFromCurrentStyle(params);
                            for (name in params) {
                                value = params[name];
                                if (name === 'opacity' || name === 'fillOpacity' || name === 'strokeOpacity' || name === 'dashstyle' || name === 'joinStyle')
                                    applySubElementAttribute(this, params, name);
                                else if (name === 'class')
                                    if (this.isVml())
                                        this.element.className = 'vml ' + value;
                                    else
                                        this.element.className = value;
                                else
                                    this.element[name] = value
                            }
                            this.__appliedSettings = params;
                            delete this._delayedAttributes
                        }
                    }
                },
                appendComplete: function() {
                    this._isAppended = true;
                    this._applyAttributes();
                    $.each(this.childElements, function(_, child) {
                        child.appendComplete()
                    })
                },
                append: function(element) {
                    var root = this.renderer.getRoot(),
                        toElement = element || root;
                    if (toElement) {
                        toElement.element.appendChild(this.element);
                        toElement.childElements.push(this)
                    }
                    if (toElement === root || toElement._isAppended)
                        this.appendComplete();
                    return this
                },
                _normalizeSettings: function(settings) {
                    var key,
                        style = {},
                        normalized = {},
                        clipRect,
                        pos,
                        prop,
                        value,
                        styleName,
                        firstChar,
                        cssProperties = ['position', 'display', 'visibility', 'filter', 'margin', 'marginTop', 'marginLeft', 'marginRight', 'marginBottom', 'whiteSpace', 'clip'];
                    for (key in settings) {
                        prop = key;
                        value = settings[prop];
                        if (prop === 'x' || prop === 'translateX') {
                            pos = settings.x || 0;
                            if (settings.translateX)
                                pos += settings.translateX;
                            style.left = pos + 'px'
                        }
                        else if (prop === 'y' || prop === 'translateY') {
                            pos = settings.y || 0;
                            if (settings.translateY)
                                pos += settings.translateY;
                            style.top = pos + 'px'
                        }
                        else if (prop === 'width')
                            style.width = value + 'px';
                        else if (prop === 'height')
                            style.height = value + 'px';
                        else if (prop === 'align')
                            style.textAlign = value;
                        else if ($.inArray(prop, cssProperties) != -1)
                            style[prop] = value;
                        else if (prop === 'fill')
                            if (this.isVml()) {
                                normalized.filled = value === 'none' ? 'f' : 't';
                                normalized.fillcolor = value
                            }
                            else
                                style['color'] = value;
                        else if (prop === 'opacity')
                            normalized.opacity = value < 0.002 ? '99f' : value;
                        else if (prop === 'stroke') {
                            normalized.stroked = value === 'none' ? 'f' : 't';
                            normalized.strokecolor = value
                        }
                        else if (prop === 'strokeWidth')
                            normalized.strokeweight = value + 'px';
                        else if (prop === 'lineJoin')
                            normalized.joinStyle = value;
                        else if (prop === 'font') {
                            if (!$.isPlainObject(value))
                                continue;
                            $.each(value, function(fontSettingName) {
                                switch (fontSettingName) {
                                    case'color':
                                    case'cursor':
                                        styleName = fontSettingName;
                                        break;
                                    case'opacity':
                                        styleName = 'opacity';
                                        break;
                                    default:
                                        firstChar = fontSettingName.charAt(0);
                                        styleName = 'font' + fontSettingName.replace(firstChar, firstChar.toUpperCase())
                                }
                                style[styleName] = value[fontSettingName]
                            })
                        }
                        else if (prop === 'style')
                            $.extend(true, style, value);
                        else if (prop === 'rotate')
                            this['_rotate'] = value;
                        else if (prop === 'dashStyle') {
                            value = value.toLowerCase();
                            if (value !== 'solid')
                                normalized.dashstyle = value
                        }
                        else if (prop === 'clipId') {
                            clipRect = this.renderer.getClipRect(value, this);
                            if (clipRect) {
                                var width = clipRect.width,
                                    height = clipRect.height,
                                    x = clipRect.x,
                                    y = clipRect.y,
                                    clipWidth = width + x,
                                    clipHeight = height + y;
                                style.width = clipRect.cSize.width;
                                style.height = clipRect.cSize.height;
                                style.clip = "rect(" + y + "px, " + clipWidth + "px, " + clipHeight + "px, " + x + "px)"
                            }
                        }
                        else if (prop === 'segments')
                            continue;
                        else
                            normalized[prop] = value
                    }
                    this['_style'] = style;
                    return normalized
                },
                _getBBox: function() {
                    var width,
                        height,
                        rect,
                        rootRect,
                        x = 0,
                        y = 0,
                        element = this.element;
                    try {
                        rect = getBoundingClientRect(element);
                        width = rect.right - rect.left;
                        height = rect.bottom - rect.top;
                        rootRect = this.renderer.getRoot().element.getBoundingClientRect();
                        x = rect.left - rootRect.left;
                        y = rect.top - rootRect.top;
                        if (element.tagName.toLowerCase() === 'div') {
                            x = x - parseInt(element.style.left, 10);
                            y = y - parseInt(element.style.top, 10)
                        }
                    }
                    catch(e) {
                        width = element.offsetWidth || 0;
                        height = element.offsetHeight || 0
                    }
                    return {
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        }
                },
                getBBox: function() {
                    return this._getBBox()
                },
                sharpEdges: function(){}
            };
        var convertSvgPathCommandToVml = function(command) {
                switch (command) {
                    case'M':
                        return 'm';
                    case'L':
                        return 'l';
                    case'Z':
                        return 'x e'
                }
                return command
            };
        var BasePathVmlElement = {
                defaultSettings: function() {
                    return $.extend(this.callBase(), {
                            coordsize: '1,1',
                            fill: 'none',
                            strokecolor: 'black',
                            stroked: 't'
                        })
                },
                getNodeName: function() {
                    return 'shape'
                },
                getPathAttributeName: function() {
                    return 'path'
                },
                customizeSegments: function(segments) {
                    var result = segments;
                    if (segments)
                        result = $.map(segments, function(s, i) {
                            var pos,
                                segmentArray = [],
                                command = convertSvgPathCommandToVml(s[0]);
                            segmentArray.push(command);
                            for (pos = 1; pos < s.length; pos++)
                                segmentArray.push(Math.floor(s[pos]));
                            return [segmentArray]
                        });
                    return result
                }
            };
        var RootVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
                isVml: function() {
                    return false
                },
                defaultSettings: function() {
                    return {
                            width: 0,
                            height: 0,
                            position: 'relative',
                            display: 'inline-block',
                            overflow: 'hidden'
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'div', params)
                }
            });
        var ImageVmlElement = svgRendererInternals.BaseSvgElement.inherit(svgRendererInternals.RectSvgBaseElement).inherit(BaseVmlElement).inherit({
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'image', params)
                },
                defaultSettings: function() {
                    return $.extend(this.callBase(), {strokeWidth: 0})
                },
                adjustSettings: function() {
                    this.callBase();
                    if (this.settings.href) {
                        this.settings.src = this.settings.href;
                        delete this.settings.href
                    }
                }
            });
        var RectVmlElement = svgRendererInternals.BaseSvgElement.inherit(svgRendererInternals.RectSvgBaseElement).inherit(BaseVmlElement).inherit({
                defaultSettings: function() {
                    return extendDefaultVmlOptions({
                            stroked: 'f',
                            strokeWidth: 0,
                            rx: 0,
                            ry: 0
                        })
                },
                recreateElement: function(name) {
                    this._nodeName = name;
                    var parent = this.$element.parent()[0];
                    if (parent) {
                        var $oldElement = this.$element;
                        this.element = this.createElement(name);
                        this.$element = $(this.element);
                        this.$element.insertBefore($oldElement);
                        $oldElement.remove()
                    }
                    else {
                        this.element = this.createElement(name);
                        this.$element = $(this.element)
                    }
                    this.applySettings()
                },
                _adjustArcSize: function() {
                    var settings = this.settings;
                    var rx = settings.rx || 0,
                        ry = settings.ry || 0,
                        width = settings.width,
                        height = settings.height,
                        r,
                        halfsize,
                        arcsize;
                    if (settings.rx !== undefined || settings.ry !== undefined) {
                        r = Math.max(rx, ry);
                        halfsize = Math.max(width, height) / 2;
                        arcsize = r / halfsize;
                        settings.arcsize = arcsize;
                        if ($.isNumeric(arcsize) && arcsize != 0)
                            this._nodeName !== 'roundrect' && this.recreateElement('roundrect');
                        else
                            this._nodeName === 'roundrect' && this.recreateElement('rect');
                        delete settings.rx;
                        delete settings.ry
                    }
                },
                _adjustRotation: function() {
                    var settings = this.settings;
                    var rotate = this.settings.rotate,
                        rotateAngle,
                        radianAngle,
                        cos,
                        sin,
                        rotateX,
                        rotateY,
                        marginTop,
                        marginLeft,
                        cx,
                        cy,
                        rotateObject;
                    rotateObject = parseRotateParameter(rotate, settings.x, settings.y);
                    if (rotateObject) {
                        rotateAngle = rotateObject.angle;
                        rotateX = rotateObject.x;
                        rotateY = rotateObject.y;
                        radianAngle = rotateAngle * Math.PI / 180.0;
                        cos = Math.cos(radianAngle);
                        sin = Math.sin(radianAngle);
                        cx = settings.x + (settings.translateX || 0) + settings.width / 2;
                        cy = settings.y + (settings.translateY || 0) + settings.height / 2;
                        marginLeft = (cx - rotateX) * cos - (cy - rotateY) * sin + rotateX - cx;
                        marginTop = (cx - rotateX) * sin + (cy - rotateY) * cos + rotateY - cy;
                        this.settings.marginLeft = Math.round(marginLeft) + 'px';
                        this.settings.marginTop = Math.round(marginTop) + 'px';
                        this.settings.rotation = rotateAngle
                    }
                },
                adjustSettings: function() {
                    this.callBase();
                    this._adjustArcSize();
                    this._adjustRotation()
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'rect', params)
                }
            });
        var PathVmlElement = svgRendererInternals.PathSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({prepareSegments: function(settings) {
                    var rotate = settings.rotate,
                        rotateAngle,
                        rotateX,
                        rotateY,
                        oldSegments,
                        radianAngle,
                        cos,
                        sin,
                        x,
                        y,
                        rotatedX,
                        rotatedY,
                        rotateObject;
                    this.callBase(settings);
                    oldSegments = this.segments;
                    rotateObject = parseRotateParameter(rotate, settings.x, settings.y);
                    if (rotateObject) {
                        rotateAngle = rotateObject.angle;
                        rotateX = rotateObject.x;
                        rotateY = rotateObject.y;
                        if (this.segments) {
                            radianAngle = rotateAngle * Math.PI / 180.0;
                            cos = Math.cos(radianAngle);
                            sin = Math.sin(radianAngle);
                            this.segments = $.map(this.segments, function(s, i) {
                                if (s.length === 3) {
                                    x = s[1],
                                    y = s[2];
                                    rotatedX = (x - rotateX) * cos - (y - rotateY) * sin + rotateX;
                                    rotatedY = (x - rotateX) * sin + (y - rotateY) * cos + rotateY;
                                    return [[s[0], Math.floor(rotatedX), Math.floor(rotatedY)]]
                                }
                                else
                                    return [s]
                            });
                            this.combinePathParams(settings);
                            this.segments = oldSegments
                        }
                    }
                }});
        var AreaVmlElement = PathVmlElement.inherit({
                defaultSettings: function() {
                    var baseOptions = this.callBase();
                    return extendDefaultVmlOptions({
                            points: {
                                x: 0,
                                y: 0
                            },
                            fill: 'black',
                            stroke: 'none'
                        }, baseOptions)
                },
                ctor: function(renderer, params) {
                    this.closePath = true;
                    this.callBase(renderer, params)
                }
            });
        var SegmentRectVmlElement = svgRendererInternals.SegmentRectSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({
                defaultSettings: function() {
                    var settings = this.callBase();
                    settings.lineJoin = 'miter';
                    delete settings.fill;
                    delete settings.stroke;
                    delete settings.strokecolor;
                    delete settings.stroked;
                    return settings
                },
                prepareSegments: function() {
                    this.callBase();
                    this.segments = this.customizeSegments(this.segments);
                    this.settings.x = 0;
                    this.settings.y = 0;
                    this.settings.width = 1;
                    this.settings.height = 1
                },
                applySettings: function(settings) {
                    var x = settings.x,
                        y = settings.y,
                        w = settings.width,
                        h = settings.height;
                    this.callBase(settings);
                    this.settings.x = x;
                    this.settings.y = y;
                    this.settings.width = w;
                    this.settings.height = h
                }
            });
        var BezierVmlElement = svgRendererInternals.BezierSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement);
        var BezierAreaVmlElement = BezierVmlElement.inherit({
                defaultSettings: function() {
                    var baseOptions = this.callBase();
                    return extendDefaultVmlOptions({
                            points: {
                                x: 0,
                                y: 0
                            },
                            fill: 'black',
                            stroke: 'none'
                        }, baseOptions)
                },
                ctor: function(renderer, params) {
                    this.closePath = true;
                    this.callBase(renderer, params)
                }
            });
        var ArcVmlElement = svgRendererInternals.ArcSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({createArcSegments: function(x, y, innerR, outerR, startAngle, endAngle) {
                    var xOuterStart = x + outerR * Math.cos(startAngle),
                        yOuterStart = y - outerR * Math.sin(startAngle),
                        xOuterEnd = x + outerR * Math.cos(endAngle),
                        yOuterEnd = y - outerR * Math.sin(endAngle),
                        xInnerStart = x + innerR * Math.cos(endAngle),
                        yInnerStart = y - innerR * Math.sin(endAngle),
                        xInnerEnd = x + innerR * Math.cos(startAngle),
                        yInnerEnd = y - innerR * Math.sin(startAngle);
                    return [['wr', x - innerR, y - innerR, x + innerR, y + innerR, xInnerStart, yInnerStart, xInnerEnd, yInnerEnd], ['at', x - outerR, y - outerR, x + outerR, y + outerR, xOuterStart, yOuterStart, xOuterEnd, yOuterEnd], ['x e']]
                }});
        var CircleVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
                defaultSettings: function() {
                    return extendDefaultVmlOptions({
                            cx: 0,
                            cy: 0,
                            r: 0
                        })
                },
                applySettings: function(settings) {
                    settings.cx = settings.cx || settings.x;
                    settings.cy = settings.cy || settings.y;
                    return this.callBase(settings)
                },
                adjustSettings: function() {
                    var r,
                        cx,
                        cy;
                    if (this.settings.cx !== undefined || this.settings.cy !== undefined || this.settings.r !== undefined) {
                        r = 'r' in this.settings ? this.settings.r : this.settings.width / 2;
                        cx = 'cx' in this.settings ? this.settings.cx : this.settings.x + this.settings.width / 2;
                        cy = 'cy' in this.settings ? this.settings.cy : this.settings.y + this.settings.width / 2;
                        this.settings.x = cx - r;
                        this.settings.y = cy - r;
                        this.settings.width = this.settings.height = r * 2;
                        delete this.settings.cx;
                        delete this.settings.cy;
                        delete this.settings.r
                    }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'oval', params)
                }
            });
        var TextVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
                isVml: function() {
                    return false
                },
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0,
                            position: 'absolute',
                            whiteSpace: 'nowrap'
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'span', params)
                },
                adjustSettings: function() {
                    var text;
                    if ('text' in this.settings) {
                        text = utils.isDefined(this.settings.text) ? this.settings.text : '';
                        text = text.toString().replace(/\r/g, "");
                        text = text.replace(/\n/g, "<br/>");
                        $(this.element).html(text);
                        delete this.settings.text
                    }
                },
                updateText: function(text) {
                    this.applySettings({text: utils.isDefined(text) ? text : ''})
                },
                _applyAttributes: function(settings) {
                    this.callBase(settings);
                    var settings = this.settings,
                        rotate = this.settings.rotate,
                        rotateAngle = 0,
                        rotateX,
                        rotateY,
                        cos = 1,
                        sin = 0,
                        rad,
                        y = this.settings.y + (this.settings.translateY || 0),
                        x = this.settings.x + (this.settings.translateX || 0),
                        align = this.settings.align,
                        bBox = this.getBBox(),
                        style = this._style || {},
                        marginLeft = 0,
                        marginTop = 0,
                        fontHeightOffset,
                        alignMultiplier,
                        rotateObject;
                    var textWidth = bBox.width,
                        textHeight = bBox.height;
                    rotateObject = parseRotateParameter(rotate, x, y);
                    if (rotateObject) {
                        rotateAngle = rotateObject.angle;
                        rotateX = rotateObject.x;
                        rotateY = rotateObject.y;
                        if (Math.abs(rotateAngle) > 360)
                            rotateAngle = rotateAngle % 360;
                        if (rotateAngle < 0)
                            rotateAngle = rotateAngle + 360;
                        if (rotateAngle) {
                            rad = rotateAngle * Math.PI / 180.0;
                            cos = Math.cos(rad);
                            sin = Math.sin(rad);
                            style.filter = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos.toFixed(5) + ', M12 = ' + (-sin).toFixed(5) + ', M21 = ' + sin.toFixed(5) + ', M22 = ' + cos.toFixed(5) + ')'
                        }
                        else
                            style.filter = '';
                        marginLeft = (x - rotateX) * (cos - 1) - (y - rotateY) * sin;
                        marginTop = (x - rotateX) * sin + (y - rotateY) * (cos - 1)
                    }
                    if (textHeight || textWidth) {
                        fontHeightOffset = textHeight * (0.55 + 0.45 / 2);
                        if (rotateAngle < 90) {
                            marginTop -= fontHeightOffset * cos;
                            marginLeft -= (textHeight - fontHeightOffset) * sin
                        }
                        else if (rotateAngle < 180) {
                            marginTop += (textHeight - fontHeightOffset) * cos;
                            marginLeft += textWidth * cos - (textHeight - fontHeightOffset) * sin
                        }
                        else if (rotateAngle < 270) {
                            marginTop += (textHeight - fontHeightOffset) * cos + textWidth * sin;
                            marginLeft += textWidth * cos + fontHeightOffset * sin
                        }
                        else {
                            marginTop += textWidth * sin - fontHeightOffset * cos;
                            marginLeft += fontHeightOffset * sin
                        }
                        alignMultiplier = {
                            center: 0.5,
                            right: 1
                        }[align];
                        if (alignMultiplier) {
                            marginLeft -= textWidth * alignMultiplier * cos;
                            marginTop -= textWidth * alignMultiplier * sin
                        }
                        style.marginLeft = Math.round(marginLeft) + 'px';
                        style.marginTop = Math.round(marginTop) + 'px'
                    }
                    this.applyStyle(style)
                }
            });
        var GroupVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
                isVml: function() {
                    return false
                },
                defaultSettings: function() {
                    return {
                            x: 0,
                            y: 0,
                            position: 'absolute'
                        }
                },
                ctor: function(renderer, params) {
                    this.callBase(renderer, 'div', params)
                },
                applySettings: function(settings) {
                    var callBase = this.callBase,
                        rotate;
                    settings = settings || {};
                    rotate = settings.rotate;
                    if (rotate) {
                        if (utils.isNumber(rotate))
                            rotate = [rotate, settings.x || 0, settings.y || 0];
                        $.each(this.childElements, function(_, child) {
                            child.applySettings({rotate: rotate})
                        })
                    }
                    delete settings.rotate;
                    settings.x = 0;
                    settings.y = 0;
                    this.callBase = callBase;
                    return this.callBase(settings)
                },
                getBBox: function() {
                    return this._getBBox()
                },
                update: function() {
                    if (this.settings.clipId) {
                        var bbox = this.getBBox();
                        this.applyStyle({
                            left: bbox.x + (this.settings.translateX || 0),
                            right: bbox.y + (this.settings.translateY || 0),
                            width: bbox.width,
                            height: bbox.height
                        })
                    }
                }
            });
        renderers.VmlRenderer = renderers.SvgRenderer.inherit({
            ctor: function(options) {
                options = options || {};
                options.animation = {enabled: false};
                if (document.namespaces && !document.namespaces.vml) {
                    document.namespaces.add('vml', 'urn:schemas-microsoft-com:vml');
                    document.createStyleSheet().addRule('.vml', 'behavior: url(#default#VML); display: inline-block;')
                }
                this._clipRects = {};
                this.cssClass = options.cssClass || '';
                this.callBase(options)
            },
            dispose: function() {
                this.callBase();
                this._clipRects = null;
                this._size = null
            },
            updateAnimationOptions: $.noop,
            recreateCanvas: function(width, height, cssClass) {
                if (width > 0 && height > 0) {
                    this._size = {
                        width: width,
                        height: height
                    };
                    if (!this.svgRoot) {
                        this.cssClass = cssClass || this.cssClass;
                        this.svgRoot = new RootVmlElement(this, {
                            width: width,
                            height: height,
                            'class': this.cssClass
                        })
                    }
                    else
                        this.svgRoot.applySettings({
                            width: width,
                            height: height
                        });
                    this.defsSvg && this.defsSvg.clear()
                }
            },
            _getSize: function() {
                return this._size || {}
            },
            createRect: function(x, y, w, h, r, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r
                    });
                return new RectVmlElement(this, params)
            },
            createSegmentRect: function(x, y, w, h, r, segments, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r,
                        segments: segments
                    });
                return new SegmentRectVmlElement(this, params)
            },
            createClipRect: function(x, y, width, height) {
                var clipId = utils.getNextClipId(),
                    elements = [],
                    clipRect = {
                        id: clipId,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        cSize: this._getSize(),
                        addElement: function(element) {
                            var hasElement = false;
                            $.each(elements, function() {
                                if (this === element) {
                                    hasElement = true;
                                    return false
                                }
                            });
                            if (!hasElement)
                                elements.push(element)
                        },
                        append: function() {
                            return this
                        },
                        remove: function(){},
                        updateRectangle: function(settings) {
                            if ('x' in settings)
                                this.x = settings.x;
                            if ('translateX' in settings)
                                this.x += settings.translateX;
                            if ('y' in settings)
                                this.y = settings.y;
                            if ('translateY' in settings)
                                this.y += settings.translateY;
                            if ('width' in settings)
                                this.width = settings.width;
                            if ('height' in settings)
                                this.height = settings.height;
                            $.each(elements, function() {
                                this.applySettings({clipId: clipId})
                            });
                            return this
                        }
                    };
                this._clipRects[clipId] = clipRect;
                return clipRect
            },
            getClipRect: function(clipId, element) {
                var clipRect = this._clipRects[clipId];
                if (clipRect && element)
                    clipRect.addElement(element);
                return this._clipRects[clipId]
            },
            createImage: function(x, y, w, h, href, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        href: href
                    });
                return new ImageVmlElement(this, params)
            },
            createLine: function(x1, y1, x2, y2, options) {
                var params = $.extend(true, {}, options || {}, {points: [x1, y1, x2, y2]});
                return new PathVmlElement(this, params)
            },
            createPath: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                return new PathVmlElement(this, params)
            },
            createBezierPath: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                return new BezierVmlElement(this, params)
            },
            createArea: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                return new AreaVmlElement(this, params)
            },
            createBezierArea: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                return new BezierAreaVmlElement(this, params)
            },
            createCircle: function(x, y, r, options) {
                var params = $.extend(true, {}, options || {}, {
                        cx: x,
                        cy: y,
                        r: r
                    });
                return new CircleVmlElement(this, params)
            },
            createArc: function(x, y, outerRadius, innerRadius, startAngle, endAngle, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius,
                        startAngle: startAngle,
                        endAngle: endAngle
                    });
                return new ArcVmlElement(this, params)
            },
            createText: function(text, x, y, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        text: text
                    });
                return new TextVmlElement(this, params)
            },
            createGroup: function(options) {
                return new GroupVmlElement(this, options)
            },
            createPattern: function(color) {
                return {
                        id: color,
                        append: function() {
                            return this
                        },
                        clear: function(){}
                    }
            }
        });
        renderers.__vmlRendererInternals = {
            RootVmlElement: RootVmlElement,
            RectVmlElement: RectVmlElement,
            ImageVmlElement: ImageVmlElement,
            PathVmlElement: PathVmlElement,
            AreaVmlElement: AreaVmlElement,
            BezierVmlElement: BezierVmlElement,
            BezierAreaVmlElement: BezierAreaVmlElement,
            CircleVmlElement: CircleVmlElement,
            TextVmlElement: TextVmlElement,
            GroupVmlElement: GroupVmlElement,
            ArcVmlElement: ArcVmlElement,
            SegmentRectVmlElement: SegmentRectVmlElement
        }
    })(jQuery, DevExpress);
    /*! Module viz, file renderer.js */
    (function($, DX) {
        function supportSVG() {
            return !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', "svg").createSVGRect
        }
        var renderers = DX.viz.renderers,
            browser = DX.browser;
        if (browser.msie && browser.version < 9)
            renderers.Renderer = renderers.VmlRenderer;
        else if (supportSVG())
            renderers.Renderer = renderers.SvgRenderer
    })(jQuery, DevExpress);
    /*! Module viz, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.charts = {series: {}}
    })(DevExpress);
    /*! Module viz, file range.js */
    (function($, DX, undefined) {
        var isDefinedUtils = DX.utils.isDefined,
            isDateUtils = DX.utils.isDate;
        var NUMBER_EQUALITY_CORRECTION = 1,
            DATETIME_EQUALITY_CORRECTION = 60000;
        DX.viz.charts.Range = DX.Class.inherit(function() {
            var ctor = function(range) {
                    range && $.extend(this, range)
                };
            var dispose = function() {
                    this.categoriesY = null;
                    this.categoriesX = null
                };
            var otherLessThan = function(thisValue, otherValue) {
                    return otherValue < thisValue
                };
            var otherGreaterThan = function(thisValue, otherValue) {
                    return otherValue > thisValue
                };
            var compareAndReplace = function(thisValue, otherValue, setValue, compare) {
                    var thisValueDefined = thisValue !== undefined,
                        otherValueDefined = otherValue !== undefined;
                    if (thisValueDefined) {
                        if (otherValueDefined && compare(thisValue, otherValue))
                            setValue(otherValue)
                    }
                    else if (otherValueDefined)
                        setValue(otherValue)
                };
            var getBoundRange = function(otherRange) {
                    getBoundRangeX.call(this, otherRange);
                    getBoundRangeY.call(this, otherRange);
                    return this
                };
            var getBoundRangeY = function(otherRange) {
                    var self = this,
                        categoriesY = self.categoriesY,
                        otherCategoriesY = otherRange.categoriesY,
                        i;
                    var setIndentByPriority = function(prefix) {
                            var priorityRelation = (self[prefix + 'Priority'] || 0) - (otherRange[prefix + 'Priority'] || 0);
                            if ((self[prefix] || 0) < otherRange[prefix] && priorityRelation === 0 || priorityRelation < 0) {
                                self[prefix] = otherRange[prefix];
                                self[prefix + 'Priority'] = otherRange[prefix + 'Priority']
                            }
                        };
                    self.invertY = self.invertY || otherRange.invertY;
                    self.stickY = self.stickY || otherRange.stickY;
                    self.keepValueMarginsY = self.keepValueMarginsY || otherRange.keepValueMarginsY;
                    compareAndReplace(self.minY, otherRange.minY, function(value) {
                        self.minY = value
                    }, otherLessThan);
                    compareAndReplace(self.intervalY, otherRange.intervalY, function(value) {
                        self.intervalY = value
                    }, otherLessThan);
                    compareAndReplace(self.maxY, otherRange.maxY, function(value) {
                        self.maxY = value
                    }, otherGreaterThan);
                    compareAndReplace(self.minVisibleY, otherRange.minVisibleY, function(value) {
                        self.minVisibleY = value
                    }, otherLessThan);
                    compareAndReplace(self.maxVisibleY, otherRange.maxVisibleY, function(value) {
                        self.maxVisibleY = value
                    }, otherGreaterThan);
                    setIndentByPriority('minValueMarginY');
                    setIndentByPriority('maxValueMarginY');
                    if (categoriesY === undefined)
                        self.categoriesY = otherCategoriesY;
                    else if (otherCategoriesY && otherCategoriesY.length)
                        for (i = 0; i < otherCategoriesY.length; i++)
                            if ($.inArray(otherCategoriesY[i], categoriesY) === -1)
                                categoriesY.push(otherCategoriesY[i]);
                    return this
                };
            var getBoundRangeX = function(otherRange) {
                    var self = this,
                        categoriesX = self.categoriesX,
                        otherCategoriesX = otherRange.categoriesX,
                        i;
                    var setIndentByPriority = function(prefix) {
                            var priorityRelation = (self[prefix + 'Priority'] || 0) - (otherRange[prefix + 'Priority'] || 0);
                            if ((self[prefix] || 0) < otherRange[prefix] && priorityRelation === 0 || priorityRelation < 0) {
                                self[prefix] = otherRange[prefix];
                                self[prefix + 'Priority'] = otherRange[prefix + 'Priority']
                            }
                        };
                    self.invertX = self.invertX || otherRange.invertX;
                    self.stickX = self.stickX || otherRange.stickX;
                    self.keepValueMarginsX = self.keepValueMarginsX || otherRange.keepValueMarginsX;
                    compareAndReplace(self.minX, otherRange.minX, function(value) {
                        self.minX = value
                    }, otherLessThan);
                    compareAndReplace(self.intervalX, otherRange.intervalX, function(value) {
                        self.intervalX = value
                    }, otherLessThan);
                    compareAndReplace(self.maxX, otherRange.maxX, function(value) {
                        self.maxX = value
                    }, otherGreaterThan);
                    compareAndReplace(self.minVisibleX, otherRange.minVisibleX, function(value) {
                        self.minVisibleX = value
                    }, otherLessThan);
                    compareAndReplace(self.maxVisibleX, otherRange.maxVisibleX, function(value) {
                        self.maxVisibleX = value
                    }, otherGreaterThan);
                    setIndentByPriority('minValueMarginX');
                    setIndentByPriority('maxValueMarginX');
                    if (categoriesX === undefined)
                        self.categoriesX = otherCategoriesX;
                    else if (otherCategoriesX && otherCategoriesX.length)
                        for (i = 0; i < otherCategoriesX.length; i++)
                            if ($.inArray(otherCategoriesX[i], categoriesX) === -1)
                                categoriesX.push(otherCategoriesX[i]);
                    return this
                };
            var isDefined = function() {
                    return isDefinedX.call(this) || isDefinedY.call(this)
                };
            var isDefinedX = function() {
                    return isDefinedUtils(this.minX) && isDefinedUtils(this.maxX) || isDefinedUtils(this.categoriesX)
                };
            var isDefinedY = function() {
                    return isDefinedUtils(this.minY) && isDefinedUtils(this.maxY) || isDefinedUtils(this.categoriesY)
                };
            var setStubData = function(dataType) {
                    setStubDataX.call(this, dataType);
                    setStubDataY.call(this, dataType)
                };
            var setStubDataX = function(dataType) {
                    var year = (new Date).getYear() - 1;
                    var STUB_RANGE_MIN = dataType === 'datetime' ? new Date(year, 0, 1) : 0,
                        STUB_RANGE_MAX = dataType === 'datetime' ? new Date(year, 11, 31) : 10;
                    $.extend(this, {
                        minX: STUB_RANGE_MIN,
                        maxX: STUB_RANGE_MAX,
                        stubDataX: true
                    })
                };
            var setStubDataY = function(dataType) {
                    var year = (new Date).getYear() - 1;
                    var STUB_RANGE_MIN = dataType === 'datetime' ? new Date(year, 0, 1) : 0,
                        STUB_RANGE_MAX = dataType === 'datetime' ? new Date(year, 11, 31) : 10;
                    $.extend(this, {
                        minY: STUB_RANGE_MIN,
                        maxY: STUB_RANGE_MAX,
                        stubDataY: true
                    })
                };
            var correctValueMarginsToZeroIfNeeded = function(self) {
                    var lengthX,
                        lengthY,
                        xDateTime = isDateUtils(self.maxX) || isDateUtils(self.minX),
                        yDateTime = isDateUtils(self.maxY) || isDateUtils(self.minY);
                    if (isDefinedUtils(self.maxX) && isDefinedUtils(self.minX))
                        lengthX = self.maxX - self.minX;
                    if (isDefinedUtils(self.maxY) && isDefinedUtils(self.minY))
                        lengthY = self.maxY - self.minY;
                    if (lengthY && !yDateTime && !self.keepValueMarginsY) {
                        if (self.minY <= 0 && self.maxY <= 0 && self.maxValueMarginY && self.maxValueMarginY > self.maxY / (self.minY - self.maxY)) {
                            self.maxValueMarginY = 0;
                            self.maxY = 0
                        }
                        if (self.minY >= 0 && self.maxY >= 0 && self.minValueMarginY && self.minValueMarginY > self.minY / (self.maxY - self.minY)) {
                            self.minValueMarginY = 0;
                            self.minY = 0
                        }
                    }
                    if (lengthX && !xDateTime && !self.keepValueMarginsX) {
                        if (self.minX <= 0 && self.maxX <= 0 && self.maxValueMarginX && self.maxValueMarginX > self.maxX / (self.minX - self.maxX)) {
                            self.maxValueMarginX = 0;
                            self.maxX = 0
                        }
                        if (self.minX >= 0 && self.maxX >= 0 && self.minValueMarginX && self.minValueMarginX > self.minX / (self.maxX - self.minX)) {
                            self.minValueMarginX = 0;
                            self.minX = 0
                        }
                    }
                };
            var applyValueMargins = function() {
                    var self = this,
                        lengthX,
                        lengthY,
                        lengthVisibleX,
                        lengthVisibleY,
                        xDateTime = isDateUtils(self.maxX) || isDateUtils(self.minX),
                        yDateTime = isDateUtils(self.maxY) || isDateUtils(self.minY);
                    correctValueMarginsToZeroIfNeeded(self);
                    if (isDefinedUtils(self.maxX) && isDefinedUtils(self.minX))
                        lengthX = self.maxX - self.minX;
                    if (isDefinedUtils(self.maxY) && isDefinedUtils(self.minY))
                        lengthY = self.maxY - self.minY;
                    if (!isDefinedUtils(self.minVisibleX) || self.minVisibleX < self.minX || self.minVisibleX > self.maxX)
                        self.minVisibleX = self.minX;
                    if (!isDefinedUtils(self.maxVisibleX) || self.maxVisibleX < self.minX || self.maxVisibleX > self.maxX)
                        self.maxVisibleX = self.maxX;
                    if (!isDefinedUtils(self.minVisibleY) || self.minVisibleY < self.minY || self.minVisibleY > self.maxY)
                        self.minVisibleY = self.minY;
                    if (!isDefinedUtils(self.maxVisibleY) || self.maxVisibleY < self.minY || self.maxVisibleY > self.maxY)
                        self.maxVisibleY = self.maxY;
                    lengthVisibleX = self.maxVisibleX - self.minVisibleX;
                    lengthVisibleY = self.maxVisibleY - self.minVisibleY;
                    if (isDefinedUtils(self.minX) && self.minValueMarginX)
                        if (xDateTime)
                            self.minX = new Date(self.minX.valueOf() - lengthX * self.minValueMarginX);
                        else
                            self.minX -= lengthX * self.minValueMarginX;
                    if (isDefinedUtils(self.minVisibleX) && self.minValueMarginX)
                        if (xDateTime)
                            self.minVisibleX = new Date(self.minVisibleX.valueOf() - lengthVisibleX * self.minValueMarginX);
                        else
                            self.minVisibleX -= lengthVisibleX * self.minValueMarginX;
                    if (isDefinedUtils(self.maxX) && self.maxValueMarginX)
                        if (xDateTime)
                            self.maxX = new Date(self.maxX.valueOf() + lengthX * self.maxValueMarginX);
                        else
                            self.maxX += lengthX * self.maxValueMarginX;
                    if (isDefinedUtils(self.maxVisibleX) && self.maxValueMarginX)
                        if (xDateTime)
                            self.maxVisibleX = new Date(self.maxVisibleX.valueOf() + lengthVisibleX * self.maxValueMarginX);
                        else
                            self.maxVisibleX += lengthVisibleX * self.maxValueMarginX;
                    if (isDefinedUtils(self.minY) && self.minValueMarginY)
                        if (yDateTime)
                            self.minY = new Date(self.minY.valueOf() - lengthY * self.minValueMarginY);
                        else
                            self.minY -= lengthY * self.minValueMarginY;
                    if (isDefinedUtils(self.minVisibleY) && self.minValueMarginY)
                        if (yDateTime)
                            self.minVisibleY = new Date(self.minVisibleY.valueOf() - lengthVisibleY * self.minValueMarginY);
                        else
                            self.minVisibleY -= lengthVisibleY * self.minValueMarginY;
                    if (isDefinedUtils(self.maxY) && self.maxValueMarginY)
                        if (yDateTime)
                            self.maxY = new Date(self.maxY.valueOf() + lengthY * self.maxValueMarginY);
                        else
                            self.maxY += lengthY * self.maxValueMarginY;
                    if (isDefinedUtils(self.maxVisibleY) && self.maxValueMarginY)
                        if (yDateTime)
                            self.maxVisibleY = new Date(self.maxVisibleY.valueOf() + lengthVisibleY * self.maxValueMarginY);
                        else
                            self.maxVisibleY += lengthVisibleY * self.maxValueMarginY;
                    self.applyEqualLimitsMargins()
                };
            var applyEqualLimitsMargins = function() {
                    var self = this,
                        xDateTime = isDateUtils(self.maxX) || isDateUtils(self.minX),
                        yDateTime = isDateUtils(self.maxY) || isDateUtils(self.minY);
                    if (isDefinedUtils(self.minX) && isDefinedUtils(self.maxX) && self.minX.valueOf() === self.maxX.valueOf())
                        if (xDateTime) {
                            self.minX = new Date(self.minX.valueOf() - DATETIME_EQUALITY_CORRECTION);
                            self.maxX = new Date(self.maxX.valueOf() + DATETIME_EQUALITY_CORRECTION)
                        }
                        else {
                            self.minX = self.minX - NUMBER_EQUALITY_CORRECTION;
                            self.maxX = self.maxX + NUMBER_EQUALITY_CORRECTION
                        }
                    if (isDefinedUtils(self.minVisibleX) && isDefinedUtils(self.maxVisibleX) && self.minVisibleX.valueOf() === self.maxVisibleX.valueOf())
                        if (xDateTime) {
                            self.minVisibleX = self.minVisibleX.valueOf() - DATETIME_EQUALITY_CORRECTION < self.minX.valueOf() ? self.minX : new Date(self.minVisibleX.valueOf() - DATETIME_EQUALITY_CORRECTION);
                            self.maxVisibleX = self.maxVisibleX.valueOf() + DATETIME_EQUALITY_CORRECTION > self.maxX.valueOf() ? self.maxX : new Date(self.maxVisibleX.valueOf() + DATETIME_EQUALITY_CORRECTION)
                        }
                        else {
                            self.minVisibleX = self.minVisibleX - NUMBER_EQUALITY_CORRECTION < self.minX ? self.minX : self.minVisibleX - NUMBER_EQUALITY_CORRECTION;
                            self.maxVisibleX = self.maxVisibleX + NUMBER_EQUALITY_CORRECTION > self.maxX ? self.maxX : self.maxVisibleX + NUMBER_EQUALITY_CORRECTION
                        }
                    if (isDefinedUtils(self.minY) && isDefinedUtils(self.maxY) && self.minY.valueOf() === self.maxY.valueOf())
                        if (yDateTime) {
                            self.minY = new Date(self.minY.valueOf() - DATETIME_EQUALITY_CORRECTION);
                            self.maxY = new Date(self.maxY.valueOf() + DATETIME_EQUALITY_CORRECTION)
                        }
                        else {
                            self.minY = self.minY - NUMBER_EQUALITY_CORRECTION;
                            self.maxY = self.maxY + NUMBER_EQUALITY_CORRECTION
                        }
                    if (isDefinedUtils(self.minVisibleY) && isDefinedUtils(self.maxVisibleY) && self.minVisibleY.valueOf() === self.maxVisibleY.valueOf())
                        if (yDateTime) {
                            self.minVisibleY = self.minVisibleY.valueOf() - DATETIME_EQUALITY_CORRECTION < self.minY.valueOf() ? self.minY : new Date(self.minVisibleY.valueOf() - DATETIME_EQUALITY_CORRECTION);
                            self.maxVisibleY = self.maxVisibleY.valueOf() + DATETIME_EQUALITY_CORRECTION > self.maxY.valueOf() ? self.maxY : new Date(self.maxVisibleY.valueOf() + DATETIME_EQUALITY_CORRECTION)
                        }
                        else {
                            self.minVisibleY = self.minVisibleY - NUMBER_EQUALITY_CORRECTION < self.minY ? self.minY : self.minVisibleY - NUMBER_EQUALITY_CORRECTION;
                            self.maxVisibleY = self.maxVisibleY + NUMBER_EQUALITY_CORRECTION > self.maxY ? self.maxY : self.maxVisibleY + NUMBER_EQUALITY_CORRECTION
                        }
                };
            return {
                    ctor: ctor,
                    dispose: dispose,
                    getBoundRange: getBoundRange,
                    getBoundRangeX: getBoundRangeX,
                    getBoundRangeY: getBoundRangeY,
                    isDefined: isDefined,
                    isDefinedX: isDefinedX,
                    isDefinedY: isDefinedY,
                    setStubData: setStubData,
                    setStubDataX: setStubDataX,
                    setStubDataY: setStubDataY,
                    applyValueMargins: applyValueMargins,
                    applyEqualLimitsMargins: applyEqualLimitsMargins
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file legend.js */
    (function($, DX, undefined) {
        DX.viz.charts.Legend = DX.Class.inherit({
            ctor: function(userOptions, group, trackerGroup) {
                this.legendGroup = group;
                this.trackerGroup = trackerGroup;
                this._init(userOptions)
            },
            update: function(userOptions) {
                this._init(userOptions)
            },
            dispose: function() {
                var _this = this;
                $.each(_this.trackers || [], function(_, tracker) {
                    tracker.removeData()
                });
                _this.trackers = null;
                _this.labelFormatObject = null;
                _this.seriesGroups = null;
                _this.insideLegendGroup = null;
                _this.legendGroup = null;
                _this.trackerGroup = null;
                _this.renderer = null;
                _this.series = null;
                _this.options = null
            },
            _init: function(options) {
                var debug = DX.utils.debug;
                debug.assertParam(options.visible, 'Visibility was not passed');
                debug.assertParam(options.renderer, 'renderer was not passed');
                debug.assertParam(options.margin, 'margin was not passed');
                debug.assertParam(options.markerSize, 'markerSize was not passed');
                debug.assertParam(options.font.color, 'fontColor was not passed');
                debug.assertParam(options.font.family, 'fontFamily was not passed');
                debug.assertParam(options.font.size, 'fontSize was not passed');
                debug.assertParam(options.paddingLeftRight, 'paddingLeftRight was not passed');
                debug.assertParam(options.paddingTopBottom, 'paddingTopBottom was not passed');
                debug.assertParam(options.columnItemSpacing, 'columnItemSpacing was not passed');
                debug.assertParam(options.rowItemSpacing, 'rowItemSpacing was not passed');
                debug.assertParam(options.equalColumnWidth, 'equalColumnWidth was not passed');
                var i,
                    series = [];
                this.renderer = options.renderer;
                options.renderer = null;
                options.horizontalAlignment = (options.horizontalAlignment || '').toLowerCase();
                if (options.horizontalAlignment !== 'center' && options.horizontalAlignment !== 'right' && options.horizontalAlignment !== 'left')
                    options.horizontalAlignment = 'right';
                options.verticalAlignment = (options.verticalAlignment || '').toLowerCase();
                if (options.verticalAlignment !== 'top' && options.verticalAlignment !== 'bottom') {
                    if (options.horizontalAlignment === 'center')
                        options.verticalAlignment = 'bottom';
                    if (options.horizontalAlignment === 'right' || options.horizontalAlignment === 'left')
                        options.verticalAlignment = 'top'
                }
                options.layout = (options.layout || '').toLowerCase();
                if (options.layout !== 'horizontal' && options.layout !== 'vertical') {
                    if (options.horizontalAlignment === 'center')
                        options.layout = 'horizontal';
                    if (options.horizontalAlignment === 'right' || options.horizontalAlignment === 'left')
                        options.layout = 'vertical'
                }
                options.position = (options.position || '').toLowerCase();
                if (options.position !== 'outside' && options.position !== 'inside')
                    options.position = 'outside';
                options.hoverMode = (options.hoverMode || '').toLowerCase();
                options.customizeText = $.isFunction(options.customizeText) ? options.customizeText : function() {
                    return this.seriesName
                };
                this.series = $.map(options.series || [], function(series) {
                    if (series.options.showInLegend)
                        return series;
                    return null
                });
                options.series = null;
                this.options = options;
                this.__initialized = true
            },
            formatLabel: function(options) {
                return options.customizeText.call(this, this)
            },
            draw: function() {
                var self = this,
                    renderer = self.renderer,
                    options = self.options,
                    series = self.series || {},
                    x = 0,
                    y = 0,
                    seriesGroups = [],
                    i,
                    j,
                    label,
                    marker,
                    singleSeriesGroup,
                    markerSize = options.markerSize,
                    isHorizontal = options.layout === 'horizontal',
                    box,
                    labelBox,
                    cols = options.columnCount,
                    rows = options.rowCount,
                    horisontalTextPosition,
                    background,
                    equalColumnWidth = options.equalColumnWidth,
                    trackers = [],
                    labelText,
                    data,
                    legendBox,
                    autoEdit = false,
                    canvas = self.canvas,
                    backgroundSettings,
                    borderVisible = options.border.visible && options.border.width && options.border.color && options.border.color !== 'none';
                if (!(options.visible && series && series.length))
                    return;
                this.createClipRect();
                if (this.legendGroup) {
                    this.legendGroup.clear();
                    this.trackerGroup.clear();
                    this.legendGroup.move(0, 0);
                    this.trackerGroup.move(0, 0);
                    this.clipRect && this.legendGroup.applySettings({clipId: this.clipRect.id})
                }
                if (this.insideLegendGroup) {
                    this.insideLegendGroup.detach();
                    this.insideLegendGroup.remove();
                    this.insideLegendGroup = null
                }
                if (options.position === 'inside' || options.backgroundColor || borderVisible)
                    background = renderer.createRect(0, 0, 0, 0, 0, {
                        fill: options.backgroundColor || (options.position === 'inside' ? options.containerBackgroundColor : 'none'),
                        'class': 'dxc-border'
                    }).append(this.legendGroup);
                this.insideLegendGroup = renderer.createGroup().append(this.legendGroup);
                for (i = 0; i < series.length; i++) {
                    singleSeriesGroup = renderer.createGroup({'class': 'dxc-item'});
                    singleSeriesGroup.append(this.insideLegendGroup);
                    marker = renderer.createRect(x, y, markerSize, markerSize, 0, {
                        fill: series[i].styles.themeColor,
                        'class': series[i].className
                    }).append(singleSeriesGroup);
                    box = marker.getBBox();
                    if (!options.itemTextPosition)
                        horisontalTextPosition = !isHorizontal;
                    else
                        horisontalTextPosition = options.itemTextPosition === 'right';
                    self.labelFormatObject = {
                        seriesName: series[i].name,
                        seriesNumber: series[i].index,
                        seriesColor: series[i].styles.themeColor
                    };
                    labelText = self.formatLabel.call(self.labelFormatObject, options);
                    label = renderer.createText(labelText, horisontalTextPosition ? x + box.width + 7 : x, horisontalTextPosition ? y : y + box.height + 2, {
                        font: options.font,
                        align: !horisontalTextPosition ? 'center' : 'left'
                    }).append(singleSeriesGroup);
                    labelBox = label.getBBox();
                    if (horisontalTextPosition)
                        label.move(0, ~~(box.y + box.height / 2 - (labelBox.y + labelBox.height / 2)));
                    else
                        label.move(~~(box.x + box.width / 2 - (labelBox.x + labelBox.width / 2)), box.y + box.height + 2 - labelBox.y);
                    trackers.push(renderer.createRect(0, 0, 0, 0, 0, {
                        stroke: 'none',
                        fill: 'grey',
                        opacity: 0.0001,
                        inh: true
                    }));
                    seriesGroups.push(singleSeriesGroup)
                }
                if (cols && !rows)
                    rows = Math.ceil(series.length / cols);
                else if (!cols && rows)
                    cols = Math.ceil(series.length / rows);
                else if (cols && rows) {
                    if (isHorizontal && cols < Math.ceil(series.length / rows))
                        cols = Math.ceil(series.length / rows);
                    else if (!isHorizontal && rows < Math.ceil(series.length / cols))
                        rows = Math.ceil(series.length / cols)
                }
                else {
                    autoEdit = true;
                    if (isHorizontal) {
                        rows = 1;
                        cols = series.length
                    }
                    else {
                        cols = 1;
                        rows = series.length
                    }
                }
                data = self.getDataRowsColumns(seriesGroups, cols, rows);
                self.moveItems(data, seriesGroups, this.insideLegendGroup, horisontalTextPosition, trackers);
                if (autoEdit && rows === 1) {
                    legendBox = this.insideLegendGroup.getBBox();
                    while (legendBox.width > canvas.width - canvas.right - canvas.left && cols > 1) {
                        cols = Math.ceil(cols / 2);
                        rows = Math.ceil(series.length / cols);
                        data = self.getDataRowsColumns(seriesGroups, cols, rows);
                        self.moveItems(data, seriesGroups, this.insideLegendGroup, horisontalTextPosition, trackers);
                        legendBox = this.insideLegendGroup.getBBox()
                    }
                }
                else if (autoEdit && cols === 1) {
                    legendBox = this.insideLegendGroup.getBBox();
                    while (legendBox.height > canvas.height - canvas.top - canvas.bottom && rows > 1) {
                        rows = Math.ceil(rows / 2);
                        cols = Math.ceil(series.length / rows);
                        data = self.getDataRowsColumns(seriesGroups, cols, rows);
                        self.moveItems(data, seriesGroups, this.insideLegendGroup, horisontalTextPosition, trackers);
                        legendBox = this.insideLegendGroup.getBBox()
                    }
                }
                if (background) {
                    legendBox = this.legendGroup.getBBox();
                    backgroundSettings = {
                        x: Math.round(legendBox.x),
                        y: Math.round(legendBox.y),
                        width: Math.round(legendBox.width) + 2 * options.paddingLeftRight,
                        height: Math.round(legendBox.height) + 2 * options.paddingTopBottom
                    };
                    if (borderVisible) {
                        backgroundSettings.strokeWidth = options.border.width;
                        backgroundSettings.stroke = options.border.color;
                        backgroundSettings.strokeOpacity = options.border.opacity;
                        backgroundSettings.dashStyle = options.border.dashStyle;
                        backgroundSettings.rx = options.border.cornerRadius || 0;
                        backgroundSettings.ry = options.border.cornerRadius || 0
                    }
                    background.applySettings(backgroundSettings);
                    self.insideLegendGroup.move(options.paddingLeftRight, options.paddingTopBottom);
                    $.each(trackers, function(_, tracker) {
                        tracker.move(options.paddingLeftRight, options.paddingTopBottom)
                    })
                }
                self.seriesGroups = seriesGroups;
                self.trackers = trackers;
                self.drawTrackers()
            },
            drawTrackers: function() {
                var _this = this;
                $.each(_this.trackers || [], function(i, tracker) {
                    tracker.data({
                        series: _this.series[i],
                        mode: _this.options.hoverMode
                    });
                    tracker.append(_this.trackerGroup)
                })
            },
            getDataRowsColumns: function(seriesGroups, cols, rows) {
                var self = this,
                    i,
                    j,
                    options = self.options,
                    equalColumnWidth = options.equalColumnWidth,
                    series = self.series || {},
                    maxWidthPerColumn = [],
                    maxWidthColumn = 0,
                    maxHeightRow = 0,
                    group,
                    box;
                for (i = 0; i < cols; i++)
                    maxWidthPerColumn[i] = 0;
                for (i = 0; i < rows; i++)
                    for (j = 0; j < cols; j++) {
                        if (rows < cols)
                            group = seriesGroups[i * cols + j];
                        else
                            group = seriesGroups[i + j * rows];
                        if (!group)
                            break;
                        box = group.getBBox();
                        if (maxHeightRow < box.height)
                            maxHeightRow = box.height;
                        if (!equalColumnWidth) {
                            if (maxWidthPerColumn[j] < box.width)
                                maxWidthPerColumn[j] = box.width
                        }
                        else if (maxWidthColumn < box.width)
                            maxWidthColumn = box.width
                    }
                return {
                        rows: rows,
                        cols: cols,
                        maxWidthPerColumn: maxWidthPerColumn,
                        maxWidthColumn: maxWidthColumn,
                        maxHeightRow: maxHeightRow
                    }
            },
            moveItems: function(data, seriesGroups, insideLegendGroup, horisontalTextPosition, trackers) {
                var self = this,
                    i,
                    j,
                    rows,
                    cols,
                    number,
                    group,
                    box,
                    xShift = 0,
                    yShift = 0,
                    widthColumn,
                    options = self.options,
                    xPadding = options.columnItemSpacing,
                    yPadding = options.rowItemSpacing,
                    equalColumnWidth = options.equalColumnWidth,
                    renderer = self.renderer,
                    maxWidthPerColumn = [],
                    maxWidthColumn = 0,
                    maxHeightRow = 0;
                rows = data.rows;
                cols = data.cols;
                maxHeightRow = data.maxHeightRow;
                maxWidthColumn = data.maxWidthColumn;
                maxWidthPerColumn = data.maxWidthPerColumn;
                for (i = 0; i < rows; i++) {
                    for (j = 0; j < cols; j++) {
                        if (rows < cols)
                            number = i * cols + j;
                        else
                            number = i + j * rows;
                        group = seriesGroups[number];
                        if (!group)
                            break;
                        box = group.getBBox();
                        widthColumn = !equalColumnWidth ? maxWidthPerColumn[j] : maxWidthColumn;
                        if (horisontalTextPosition) {
                            group.move(xShift - box.x, yShift);
                            trackers[number].applySettings({
                                x: xShift - xPadding / 2,
                                y: yShift + box.y - yPadding / 2,
                                height: maxHeightRow + yPadding,
                                width: widthColumn + xPadding
                            })
                        }
                        else {
                            group.move(xShift - box.x - box.width / 2 + widthColumn / 2, yShift);
                            trackers[number].applySettings({
                                x: xShift - xPadding / 2,
                                y: yShift + box.y - yPadding / 2,
                                height: maxHeightRow + yPadding,
                                width: widthColumn + xPadding
                            })
                        }
                        xShift = xShift + widthColumn + xPadding
                    }
                    yShift = yShift + maxHeightRow + yPadding;
                    xShift = 0
                }
            },
            getBoundingRect: function() {
                if (this.legendGroup)
                    return this.legendGroup.getBBox();
                return {}
            },
            toForeground: function() {
                this.legendGroup && this.legendGroup.toForeground()
            },
            createClipRect: function() {
                var canvas = this.canvas;
                if (canvas)
                    if (!this.clipRect)
                        this.clipRect = this.renderer.createClipRect(canvas.left, canvas.top, canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom).append();
                    else
                        this.clipRect.updateRectangle({
                            x: canvas.left,
                            y: canvas.top,
                            width: canvas.width - canvas.left - canvas.right,
                            height: canvas.height - canvas.top - canvas.bottom
                        })
            },
            updateClip: function(settings) {
                this.clipRect && this.clipRect.updateRectangle({
                    translateX: -settings.translateX,
                    translateY: -settings.translateY
                });
                this.legendGroup.update()
            },
            shift: function(x, y) {
                var settings = {};
                x && (settings.translateX = x);
                y && (settings.translateY = y);
                this.legendGroup.applySettings(settings);
                this.trackerGroup.applySettings(settings);
                this.updateClip(settings)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file tooltip.js */
    (function($, DX, undefined) {
        var formatHelper = DX.formatHelper;
        DX.viz.charts.Tooltip = DX.Class.inherit({
            ctor: function(options, group) {
                this.style = {visibility: 'hidden'};
                this.textStyle = {
                    align: 'center',
                    visibility: 'hidden'
                };
                this.tooltipGroup = group;
                this._reinit(options)
            },
            dispose: function() {
                this.shadow = null;
                this.cloud = null;
                this.text = null;
                this.tooltipGroup = null;
                this.options = null;
                this.style = null;
                this.textStyle = null;
                this.renderer = null
            },
            update: function(options) {
                this._reinit(options)
            },
            _reinit: function(options) {
                options = options || {};
                this.renderer = options.renderer || this.renderer;
                this.customColor = options.color || this.customColor;
                this.textStyle.font = options.font || this.textStyle.font;
                this.canvasWidth = options.canvasWidth || this.canvasWidth;
                this.canvasHeight = options.canvasHeight || this.canvasHeight;
                delete options.renderer;
                delete options.font;
                this.options = $.extend(true, {}, this.options || {}, options)
            },
            formatValueTooltip: function(options) {
                return formatHelper.format(this.value, options.format, options.precision)
            },
            formatTooltip: function(options) {
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                if (this.percent !== undefined)
                    this.percentText = formatHelper.format(this.percent, 'percent', options.percentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            _getData: function() {
                var SHADOW_OFFSET = 4,
                    x = this.x,
                    y = this.y,
                    xt = x,
                    yt = y,
                    i,
                    align = 'center',
                    pointsOfShadow = [],
                    points = [],
                    bbox = this.text.getBBox(),
                    paddingLeftRight = this.options.paddingLeftRight,
                    paddingTopBottom = this.options.paddingTopBottom,
                    arrowLength = this.options.arrowLength > 0 ? this.options.arrowLength : 0,
                    cloudWidth = bbox.width + paddingLeftRight * 2,
                    cloudHeight = bbox.height + paddingTopBottom * 2,
                    updatedText;
                updatedText = this._checkWidthText(cloudWidth, cloudHeight);
                if (updatedText) {
                    bbox = updatedText.bbox;
                    cloudWidth = updatedText.cloudWidth;
                    cloudHeight = updatedText.cloudHeight;
                    paddingLeftRight = updatedText.paddingLeftRight;
                    paddingTopBottom = updatedText.paddingTopBottom
                }
                if (cloudWidth / 2 > x) {
                    points = this._setArrowLeft(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                    align = 'left';
                    xt += paddingLeftRight
                }
                else if (x + cloudWidth / 2 > this.canvasWidth) {
                    points = this._setArrowRight(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                    align = 'right';
                    xt -= paddingLeftRight
                }
                else
                    points = this._setArrowCenter(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                if (cloudHeight + arrowLength < y)
                    yt -= arrowLength + cloudHeight / 2 - bbox.height / 2 + this.tooltipOffset;
                else
                    yt += arrowLength + cloudHeight / 2 + bbox.height / 2 + this.tooltipOffset;
                $.extend(pointsOfShadow, points);
                for (i = 1; i < pointsOfShadow.length; i += 2)
                    if (cloudHeight + arrowLength < y)
                        pointsOfShadow[i] += SHADOW_OFFSET;
                    else
                        pointsOfShadow[i] -= SHADOW_OFFSET;
                if (arrowLength > 0) {
                    if (cloudHeight + arrowLength < y)
                        pointsOfShadow[1] += 2;
                    else
                        pointsOfShadow[1] -= 2;
                    if (cloudWidth / 2 > x)
                        pointsOfShadow[2] += 2;
                    else if (x + cloudWidth / 2 > this.canvasWidth)
                        pointsOfShadow[pointsOfShadow.length - 2] -= 2;
                    else {
                        pointsOfShadow[2] += 2;
                        pointsOfShadow[pointsOfShadow.length - 2] -= 2
                    }
                }
                return {
                        points: points,
                        text: {
                            x: xt,
                            y: yt,
                            align: align
                        },
                        pointsOfShadow: pointsOfShadow
                    }
            },
            _updateTooltip: function() {
                var box,
                    data,
                    scale;
                this.text.updateText(this.tooltipText);
                data = this._getData();
                this.shadow.applySettings({points: data.pointsOfShadow});
                this.cloud.applySettings({
                    points: data.points,
                    fill: this.style.fill,
                    'class': this.className
                });
                this.text.applySettings({y: data.text.y});
                box = this.text.getBBox();
                this.text.applySettings({
                    x: data.text.x,
                    y: data.text.y - (box.y + box.height - data.text.y),
                    align: data.text.align
                });
                box = this.tooltipGroup.getBBox();
                if (box.y + box.height > this.canvasHeight) {
                    scale = (this.canvasHeight - box.y) / box.height;
                    this.tooltipGroup.applySettings({
                        scale: scale,
                        translateX: this.x * (1 - scale),
                        translateY: this.y * (1 - scale)
                    })
                }
            },
            draw: function() {
                if (!this.shadow) {
                    this.shadow = this.renderer.createPath({}, {
                        fill: '#000000',
                        stroke: 'none',
                        visibility: 'hidden',
                        opacity: 0.1
                    });
                    this.cloud = this.renderer.createArea({}, this.style);
                    this.text = this.renderer.createText('0', 0, 0, this.textStyle)
                }
                this.shadow.append(this.tooltipGroup);
                this.cloud.append(this.tooltipGroup);
                this.text.append(this.tooltipGroup)
            },
            show: function() {
                this.cloud.applySettings({visibility: "visible"});
                this.text.applySettings({visibility: "visible"});
                this.shadow.applySettings({visibility: "visible"})
            },
            hide: function() {
                this.cloud.applySettings({visibility: 'hidden'});
                this.text.applySettings({visibility: 'hidden'});
                this.shadow.applySettings({visibility: "hidden"})
            },
            move: function(x, y, offset, text, color, className) {
                this.x = x;
                this.y = y;
                this.tooltipOffset = offset;
                this.tooltipText = text;
                this.style.fill = this.customColor || color;
                this.className = className;
                this._updateTooltip()
            },
            _setArrowCenter: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth / 2;
                points.push(xc, yc);
                xc += cloudWidth / 2 - arrowWidth / 2;
                points.push(xc, yc);
                if (verticalInvert)
                    yc += cloudHeight;
                else
                    yc -= cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight;
                else
                    yc += cloudHeight;
                points.push(xc, yc);
                xc += cloudWidth / 2 - arrowWidth / 2;
                points.push(xc, yc);
                return points
            },
            _setArrowLeft: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth;
                points.push(xc, yc);
                xc += cloudWidth - arrowWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc += cloudHeight;
                else
                    yc -= cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight + arrowLength;
                else
                    yc += cloudHeight + arrowLength;
                points.push(xc, yc);
                return points
            },
            _setArrowRight: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength + cloudHeight;
                else
                    yc += arrowLength + cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight;
                else
                    yc += cloudHeight;
                points.push(xc, yc);
                xc += cloudWidth - arrowWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth;
                points.push(xc, yc);
                return points
            },
            _checkWidthText: function(cloudWidth, cloudHeight) {
                var x = this.x,
                    y = this.y,
                    text = this.tooltipText,
                    index,
                    paddingLeftRight = this.options.paddingLeftRight,
                    paddingTopBottom = this.options.paddingTopBottom,
                    textLength,
                    maxTooltipWidth,
                    remainLength,
                    newIndex,
                    bbox = this.text.getBBox();
                if (cloudWidth < x || x + cloudWidth < this.canvasWidth || cloudWidth / 2 < x && x + cloudWidth / 2 < this.canvasWidth)
                    return false;
                if (text.indexOf("<br/>") === -1 && text.indexOf(" ") !== -1) {
                    maxTooltipWidth = Math.max(x, this.canvasWidth - x, 2 * Math.min(x, this.canvasWidth - x));
                    textLength = text.length * maxTooltipWidth / bbox.width;
                    index = text.substr(0, ~~textLength).lastIndexOf(" ");
                    if (index === -1)
                        index = text.substr(0).indexOf(" ");
                    remainLength = text.substr(index + 1).length;
                    this.tooltipText = text.substr(0, index) + "<br/>";
                    while (textLength <= remainLength) {
                        newIndex = text.substr(index + 1, ~~textLength).lastIndexOf(" ");
                        if (newIndex === -1)
                            newIndex = text.substr(index + 1).indexOf(" ");
                        if (newIndex !== -1) {
                            this.tooltipText += text.substr(index + 1, newIndex) + "<br/>";
                            remainLength = text.substr(index + 1 + newIndex).length;
                            index += newIndex + 1
                        }
                        else
                            break
                    }
                    this.tooltipText += text.substr(index + 1);
                    this.text.updateText(this.tooltipText);
                    bbox = this.text.getBBox();
                    cloudWidth = bbox.width + paddingLeftRight * 2;
                    cloudHeight = bbox.height + paddingTopBottom * 2
                }
                if (cloudWidth > x && x + cloudWidth > this.canvasWidth && (cloudWidth / 2 > x || x + cloudWidth / 2 > this.canvasWidth)) {
                    paddingLeftRight = 5;
                    paddingTopBottom = 5;
                    cloudWidth = bbox.width + 2 * paddingLeftRight;
                    cloudHeight = bbox.height + 2 * paddingTopBottom
                }
                return {
                        bbox: bbox,
                        cloudWidth: cloudWidth,
                        cloudHeight: cloudHeight,
                        paddingTopBottom: paddingTopBottom,
                        paddingLeftRight: paddingLeftRight
                    }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file chartTitle.js */
    (function($, DX, undefined) {
        var isDefined = DX.utils.isDefined,
            endsWith = function(value, pattern) {
                return value.substr(value.length - pattern.length) === pattern
            },
            startsWith = function(value, pattern) {
                return value.indexOf(pattern) === 0
            };
        DX.viz.charts.ChartTitle = DX.Class.inherit({
            ctor: function(renderer, canvas, options, group) {
                var _this = this;
                _this._init(canvas, options);
                _this.renderer = renderer;
                _this.clipRect = _this.createClipRect();
                _this.titleGroup = group;
                _this.titleGroup && _this.clipRect && _this.titleGroup.applySettings({clipId: _this.clipRect.id})
            },
            dispose: function() {
                var _this = this;
                _this.renderer = null;
                _this.clipRect = null;
                _this.title = null;
                _this.innerTitleGroup = null;
                _this.titleGroup = null;
                _this.options = null;
                _this.canvas = null
            },
            update: function(canvas, options) {
                this._init(canvas, options)
            },
            _init: function(canvas, options) {
                var _this = this;
                if (options) {
                    _this._parseAlignments(options);
                    _this.horizontalAlignment = options.horizontalAlignment;
                    _this.verticalAlignment = options.verticalAlignment;
                    _this.options = options
                }
                _this.canvas = canvas || _this.canvas
            },
            _parseAlignments: function(options) {
                if (isDefined(options.position) && !(isDefined(options.verticalAlignment) && isDefined(options.horizontalAlignment))) {
                    options.position = options.position.toLowerCase();
                    options.verticalAlignment = endsWith(options.position, 'top') ? 'top' : 'bottom';
                    options.horizontalAlignment = startsWith(options.position, 'left') ? 'left' : startsWith(options.position, 'center') && 'center' || 'right';
                    return
                }
                options.verticalAlignment = (options.verticalAlignment || '').toLowerCase();
                options.horizontalAlignment = (options.horizontalAlignment || '').toLowerCase();
                if (options.verticalAlignment !== 'top' && options.verticalAlignment !== 'bottom')
                    options.verticalAlignment = 'top';
                if (options.horizontalAlignment !== 'left' && options.horizontalAlignment !== 'center' && options.horizontalAlignment !== 'right')
                    options.horizontalAlignment = 'center'
            },
            render: function() {
                var _this = this,
                    titleOptions = _this.options,
                    renderer = _this.renderer,
                    attr;
                if (!titleOptions.text)
                    return;
                if (!_this.innerTitleGroup)
                    _this.innerTitleGroup = renderer.createGroup();
                else
                    _this.innerTitleGroup.clear();
                _this.innerTitleGroup.append(_this.titleGroup);
                attr = {
                    font: titleOptions.font,
                    align: _this.horizontalAlignment,
                    style: titleOptions.fontStyle
                };
                _this.title = renderer.createText(titleOptions.text, _this.canvas.left, _this.canvas.top, attr).append(_this.innerTitleGroup);
                _this.title.text = titleOptions.text;
                _this.correctTitleLength()
            },
            correctTitleLength: function() {
                var _this = this,
                    canvas = _this.canvas,
                    text = _this.title.text,
                    updateText,
                    lineLength,
                    canvasWidth = canvas.width - canvas.right - canvas.left,
                    box = _this.getBoundingRect();
                if (canvasWidth > box.width || text.indexOf("<br/>") != -1)
                    return;
                lineLength = text.length * canvasWidth / box.width;
                updateText = text.substr(0, ~~lineLength - 1 - 3) + "...";
                _this.title.updateText(updateText);
                _this.title.text = updateText
            },
            getBoundingRect: function() {
                var options = this.options,
                    box;
                if (!this.innerTitleGroup)
                    return {
                            width: 0,
                            height: 0,
                            x: 0,
                            y: 0
                        };
                box = this.innerTitleGroup.getBBox();
                if (isDefined(options.placeholderSize))
                    box.height = options.placeholderSize;
                return box
            },
            shift: function(x, y) {
                this.innerTitleGroup.move(x, y)
            },
            createClipRect: function() {
                if (isDefined(this.options.placeholderSize))
                    return this.renderer.createClipRect(0, 0, 0, 0)
            },
            setClipRectSettings: function() {
                var canvas = this.canvas,
                    verticalAlignment = this.verticalAlignment,
                    clipRect = this.clipRect;
                if (clipRect) {
                    clipRect.append();
                    if (verticalAlignment === 'top')
                        clipRect.updateRectangle({
                            x: 0,
                            y: 0,
                            width: canvas.width,
                            height: canvas.top
                        });
                    else if (verticalAlignment === 'bottom')
                        clipRect.updateRectangle({
                            x: 0,
                            y: canvas.height - canvas.bottom,
                            width: canvas.width,
                            height: canvas.bottom
                        })
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file axis.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            mathAbs = Math.abs,
            AXIS_VALUE_MARGIN_PRIORITY = 100,
            DEFAULT_AXIS_LABEL_SPACING = 5,
            AXIS_STAGGER_OVERLAPPING_KOEF = 2,
            MAX_GRID_BORDER_ADHENSION = 4,
            CANVAS_POSITION_PREFIX = 'canvas_position_',
            CANVAS_POSITION_BOTTOM = 'canvas_position_bottom',
            CANVAS_POSITION_TOP = 'canvas_position_top',
            CANVAS_POSITION_LEFT = 'canvas_position_left',
            CANVAS_POSITION_RIGHT = 'canvas_position_right';
        DX.viz.charts.AXIS_STAGGER_OVERLAPPING_KOEF = AXIS_STAGGER_OVERLAPPING_KOEF;
        DX.viz.charts.Axis = DX.Class.inherit(function() {
            var ctor = function(renderer, options) {
                    var debug = DX.utils.debug;
                    debug.assertParam(renderer, 'renderer was not passed');
                    debug.assertParam(options.label, 'label was not passed');
                    debug.assertParam(options.tick, 'tick was not passed');
                    debug.assertParam(options.grid, 'grid was not passed');
                    debug.assertParam(options.title, 'title was not passed');
                    debug.assert(options.axisDivisionFactor, 'axisDivisionFactor was not passed');
                    debug.assert(options.stripStyle, 'stripStyle was not passed');
                    debug.assert(options.position, 'position was not passed');
                    debug.assertParam(options.isHorizontal, 'isHorizontal was not passed');
                    this.renderer = renderer;
                    this.init(options);
                    this._$axis = $(this)
                };
            var dispose = function() {
                    var _this = this;
                    _this._axisElementsGroup && _this._axisElementsGroup.dispose();
                    $.each(_this.labels || [], function(_, label) {
                        label.removeData()
                    });
                    _this._$axis = null;
                    _this.labels = null;
                    _this.title = null;
                    _this.stripLabels = null;
                    _this.stripRects = null;
                    _this._axisStripGroup = null;
                    _this._axisLineGroup = null;
                    _this._axisElementsGroup = null;
                    _this._axisGridGroup = null;
                    _this._axisGroup = null;
                    _this.axesContainerGroup = null;
                    _this.stripsGroup = null;
                    _this.renderer = null;
                    _this.translator = null;
                    _this.options = null;
                    _this.textOptions = null;
                    _this._tickValues = null;
                    _this._fullTickValues = null;
                    _this._fullTickPositions = null
                };
            var init = function(options) {
                    var categories = options.categories,
                        labelOptions = options.label;
                    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : 'none';
                    this.hasLabelFormat = labelOptions.format !== '' && utils.isDefined(labelOptions.format);
                    this.options = options;
                    this.staggered = labelOptions.staggered;
                    labelOptions.minSpacing = utils.isDefined(labelOptions.minSpacing) ? labelOptions.minSpacing : DEFAULT_AXIS_LABEL_SPACING;
                    this._testStaggeringSpacing = labelOptions.staggeringSpacing;
                    processCustomOptions(options);
                    if (categories) {
                        this.labelsNumber = categories.length;
                        this.ticksNumber = this.labelsNumber
                    }
                    options.range = {
                        min: options.min,
                        max: options.max,
                        categories: options.categories && options.categories.slice(0)
                    };
                    this.pane = options.pane;
                    this.textOptions = {
                        align: labelOptions.alignment,
                        font: labelOptions.font,
                        opacity: labelOptions.opacity,
                        style: labelOptions.style
                    }
                };
            var updateTranslatorInterval = function(self) {
                    var i,
                        tickValues,
                        options = self.options,
                        businessRange = self.translator.getBusinessRange(),
                        interval;
                    if (businessRange && businessRange.getBoundRange && !options.categories) {
                        tickValues = self.getTickValues();
                        for (i = 0; i < tickValues.length - 1; i++) {
                            interval = mathAbs(tickValues[i] - tickValues[i + 1]);
                            if (options.isHorizontal)
                                businessRange.getBoundRange({intervalX: interval});
                            else
                                businessRange.getBoundRange({intervalY: interval})
                        }
                    }
                };
            var updateRotationAngle = function(self) {
                    var options = self.options,
                        rotationAngle,
                        labelOptions = options.label;
                    if (!options.isHorizontal || !labelOptions || !utils.isDefined(labelOptions.overlappingBehavior))
                        return;
                    switch (labelOptions.overlappingBehavior.mode) {
                        case'enlargeTickInterval':
                        case'stagger':
                            rotationAngle = null;
                            break;
                        case'rotate':
                            rotationAngle = labelOptions.overlappingBehavior.rotationAngle;
                            break;
                        default:
                            rotationAngle = labelOptions.rotationAngle
                    }
                    if (!labelOptions.userAlignment)
                        self.textOptions.align = rotationAngle ? 'left' : 'center';
                    self.textOptions.rotate = rotationAngle
                };
            var getStaggeringSpacing = function(self) {
                    var self = this,
                        labelOptions = self.options.label;
                    if (labelOptions) {
                        if (!self.staggered && self.isStaggerOverlapping)
                            return labelOptions.overlappingBehavior.staggeringSpacing;
                        return labelOptions.staggeringSpacing
                    }
                    return 0
                };
            var setTranslator = function(translator) {
                    var debug = DX.utils.debug;
                    debug.assertParam(translator, 'translator was not passed');
                    this.translator = translator;
                    this.needsLabelAdjustment = false;
                    this.resetTicks();
                    updateTranslatorInterval(this)
                };
            var resetTicks = function() {
                    this._tickValues = this._tickPositions = this._fullTickValues = this._fullTickPositions = null
                };
            var setRange = function(range) {
                    var debug = DX.utils.debug;
                    debug.assertParam(range, 'range was not passed');
                    var self = this,
                        options = self.options;
                    if (options.isHorizontal) {
                        options.min = range.minVisibleX;
                        options.max = range.maxVisibleX;
                        options.categories = range.categoriesX;
                        options.stubData = range.stubDataX
                    }
                    else {
                        options.min = range.minVisibleY;
                        options.max = range.maxVisibleY;
                        options.categories = range.categoriesY;
                        options.stubData = range.stubDataY
                    }
                    self.needsLabelAdjustment = false;
                    this.resetTicks()
                };
            var processCustomOptions = function(options) {
                    var label = options.label,
                        left = 'left',
                        right = 'right',
                        top = 'top',
                        bottom = 'bottom';
                    if (options.isHorizontal) {
                        if (!(options.position === bottom || options.position === top))
                            options.position = bottom
                    }
                    else if (!(options.position === left || options.position === right))
                        options.position = left;
                    if (options.position === right) {
                        label.indentFromAxis *= -1;
                        if (!label.userAlignment)
                            label.alignment = left
                    }
                    if (options.position === top)
                        label.indentFromAxis *= -1;
                    if (label.rotationAngle && options.isHorizontal)
                        if (!label.userAlignment)
                            label.alignment = left
                };
            var getXAxisPosition = function(self) {
                    var delta = 0;
                    if (self.delta)
                        delta = self.delta[self.options.position] || 0;
                    return self.translator.translateX(CANVAS_POSITION_PREFIX + self.options.position) + delta
                };
            var getYAxisPosition = function(self) {
                    var delta = 0;
                    if (self.delta)
                        delta = self.delta[self.options.position] || 0;
                    return self.translator.translateY(CANVAS_POSITION_PREFIX + self.options.position) + delta
                };
            var drawAxis = function drawAxis(self, group) {
                    var translator = self.translator,
                        options = self.options,
                        lineOptions = options,
                        axisAttr = {
                            strokeWidth: lineOptions.width,
                            stroke: lineOptions.color,
                            strokeOpacity: lineOptions.opacity
                        },
                        axis,
                        axisPosition = self.axisPosition,
                        start,
                        end;
                    if (!lineOptions.visible)
                        return;
                    if (self.options.isHorizontal) {
                        if (options.categories) {
                            start = translator.translateX(CANVAS_POSITION_LEFT);
                            end = translator.translateX(CANVAS_POSITION_RIGHT)
                        }
                        else {
                            start = translator.translateX(options.min);
                            end = translator.translateX(options.max)
                        }
                        axis = self.renderer.createLine(start, axisPosition, end, axisPosition, axisAttr)
                    }
                    else {
                        if (options.categories) {
                            start = translator.translateY(CANVAS_POSITION_TOP);
                            end = translator.translateY(CANVAS_POSITION_BOTTOM)
                        }
                        else {
                            start = translator.translateY(options.min);
                            end = translator.translateY(options.max)
                        }
                        axis = self.renderer.createLine(axisPosition, start, axisPosition, end, axisAttr)
                    }
                    axis.append(group)
                };
            var getTickValues = function() {
                    var self = this,
                        options = self.options,
                        tickProvider = options.tickProvider,
                        translator = self.translator,
                        labelOptions = options.label,
                        categories = options.categories,
                        step,
                        ticksOptions,
                        overlappingBehavior = labelOptions.overlappingBehavior,
                        getPosition = options.isHorizontal ? self.translator.translateX : self.translator.translateY,
                        correctedScreenDelta;
                    ticksOptions = getTicksOptions(self, options, getPosition, categories);
                    if (!self._tickValues) {
                        self.textOptions.rotate = labelOptions.rotationAngle;
                        self.textOptions.align = labelOptions.alignment;
                        self._fullTickValues = self._tickValues = $.isArray(categories) ? categories : tickProvider.getTicks(ticksOptions);
                        this._needProcessOverlapping = true
                    }
                    if (self.options.stubData) {
                        self._testSkippedFormattingAndOverlapping = true;
                        return self._tickValues
                    }
                    if ((utils.isDate(options.min) || utils.isDate(categories && categories[0])) && !this.hasLabelFormat)
                        labelOptions.format = DX.formatHelper.getDateFormatByTicks(self._tickValues);
                    correctedScreenDelta = self._tickValues && self._tickValues.length ? getPosition.call(self.translator, self._tickValues[self._tickValues.length - 1]) - getPosition.call(self.translator, self._tickValues[0]) : null;
                    if (correctedScreenDelta) {
                        ticksOptions.screenDelta = mathAbs(correctedScreenDelta);
                        ticksOptions.ticksCount = self._tickValues.length - 1
                    }
                    else
                        ticksOptions.ticksCount = self._tickValues.length;
                    if (this._needProcessOverlapping && overlappingBehavior && overlappingBehavior.mode !== 'ignore') {
                        if (overlappingBehavior.mode === 'stagger')
                            ticksOptions.screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
                        step = tickProvider.getAutoArrangementStep(self._tickValues, ticksOptions);
                        self._testTKScreenDelta = ticksOptions.screenDelta;
                        self._testIsAutoArrangement = Boolean(step - 1);
                        self._autoArrangementStep = step;
                        if (step > 1) {
                            self.staggered = false;
                            updateRotationAngle(self);
                            step = tickProvider.getAutoArrangementStep(self._tickValues, ticksOptions);
                            self._tickValues = step > 1 ? tickProvider.getAutoArrangementTicks(self._tickValues, ticksOptions, step) : self._tickValues
                        }
                        else {
                            self.staggered = labelOptions.staggered;
                            self.staggeringSpacing = labelOptions.staggeringSpacing
                        }
                        this._needProcessOverlapping = false;
                        tickProvider._removeInvalidDatesWithUnitBegining(self._tickValues, ticksOptions)
                    }
                    if (!$.isArray(categories))
                        self._fullTickValues = self._tickValues;
                    return self._tickValues
                };
            var setTickValues = function(tickValues) {
                    this.resetTicks();
                    this._fullTickValues = this._tickValues = tickValues;
                    if (tickValues)
                        this._needProcessOverlapping = true
                };
            var getTicksOptions = function(self, options, getPosition, categories) {
                    var bpRange = options.isHorizontal ? [CANVAS_POSITION_LEFT, CANVAS_POSITION_RIGHT] : [CANVAS_POSITION_BOTTOM, CANVAS_POSITION_TOP],
                        screenDelta = mathAbs(getPosition.call(self.translator, bpRange[1]) - getPosition.call(self.translator, bpRange[0])),
                        digitPosition = utils.getSignificantDigitPosition(mathAbs(options.max - options.min) / screenDelta),
                        correctingValue,
                        min = options.min,
                        max = options.max;
                    if (utils.isNumber(min)) {
                        min = utils.roundValue(options.min, digitPosition);
                        if (min < options.min) {
                            correctingValue = Math.pow(10, -digitPosition);
                            min = utils.applyPrecisionByMinDelta(min, correctingValue, min + correctingValue)
                        }
                        if (min > max)
                            min = options.min
                    }
                    if (categories && categories.length > 0) {
                        min = categories[0];
                        max = categories[categories.length - 1]
                    }
                    return {
                            min: min,
                            max: max,
                            textOptions: self.textOptions,
                            getText: function(value) {
                                return formatLabel(value, options.label)
                            },
                            renderer: self.renderer,
                            textSpacing: self.options.label.minSpacing,
                            translator: self.translator,
                            tickInterval: self.options.stubData ? null : options.tickInterval,
                            screenDelta: screenDelta,
                            gridSpacingFactor: options.axisDivisionFactor,
                            isHorizontal: options.isHorizontal,
                            setTicksAtUnitBeginning: options.setTicksAtUnitBeginning,
                            incidentOccured: options.incidentOccured
                        }
                };
            var prepareLabelsToDraw = function prepareLabelsToDraw(self) {
                    var options = self.options,
                        ticksValues,
                        ticks = [],
                        getPosition,
                        i;
                    if (options.isHorizontal)
                        getPosition = self.translator.translateX;
                    else
                        getPosition = self.translator.translateY;
                    ticksValues = self.getTickValues();
                    if (ticksValues.hideLabels || options.stubData)
                        ticks.hideLabels = true;
                    for (i = 0; i < ticksValues.length; i++)
                        ticks.push({
                            text: ticksValues[i],
                            pos: getPosition.call(self.translator, ticksValues[i])
                        });
                    return ticks
                };
            var correctTicksPosition = function(self, ticks) {
                    var options = self.options,
                        translator = self.translator,
                        tickDelta,
                        i;
                    if (options.categories && (options.discreteAxisDivisionMode !== 'crossLabels' || !options.discreteAxisDivisionMode)) {
                        if (options.isHorizontal) {
                            tickDelta = translator.getIntervalX() / 2;
                            if (!options.valueMarginsEnabled)
                                ticks = ticks.slice(0, ticks.length - 1)
                        }
                        else {
                            tickDelta = -translator.getIntervalY() / 2;
                            if (!options.valueMarginsEnabled)
                                ticks = ticks.slice(1, ticks.length)
                        }
                        for (i = 0; i < ticks.length; i++)
                            ticks[i].pos = ticks[i].pos + tickDelta
                    }
                    return ticks
                };
            var prepareFullTicksToDraw = function prepareFullTicksToDraw(self) {
                    var options = self.options,
                        ticksValues = self._fullTickValues,
                        ticks = [],
                        getPosition = options.isHorizontal ? self.translator.translateX : self.translator.translateY,
                        i;
                    if (!self._fullTickPositions) {
                        if (!ticksValues) {
                            self.getTickValues();
                            ticksValues = self._fullTickValues || []
                        }
                        for (i = 0; i < ticksValues.length; i++)
                            ticks.push({pos: getPosition.call(self.translator, ticksValues[i])});
                        self._fullTickPositions = correctTicksPosition(self, ticks)
                    }
                    return self._fullTickPositions
                };
            var drawTicks = function drawTicks(self, group) {
                    var renderer = self.renderer,
                        options = self.options,
                        ticksOptions = options.tick,
                        categories = options.categories,
                        tickDelta = options.discreteAxisDivisionMode === 'crossLabels' ? 0 : 0.5,
                        i,
                        defaultTickLength = 8,
                        attr = {
                            strokeWidth: 1,
                            stroke: ticksOptions.color,
                            strokeOpacity: ticksOptions.opacity
                        },
                        currentTickConstant,
                        axisPosition = self.axisPosition,
                        tickPositionStart,
                        tickPositionEnd,
                        tick,
                        ticksToDraw;
                    if (!ticksOptions.visible)
                        return;
                    ticksToDraw = prepareFullTicksToDraw(self);
                    if (self.options.isHorizontal)
                        for (i = 0; i < ticksToDraw.length; i++) {
                            tick = ticksToDraw[i];
                            renderer.createLine(tick.pos, axisPosition - defaultTickLength / 2, tick.pos, axisPosition + defaultTickLength / 2, attr).append(group)
                        }
                    else
                        for (i = 0; i < ticksToDraw.length; i++) {
                            tick = ticksToDraw[i];
                            renderer.createLine(axisPosition - defaultTickLength / 2, tick.pos, axisPosition + defaultTickLength / 2, tick.pos, attr).append(group)
                        }
                };
            var formatLabel = function formatLabel(value, options) {
                    var formatObject = {
                            value: value,
                            valueText: DX.formatHelper.format(value, options.format, options.precision) || ''
                        };
                    return options.customizeText ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText
                };
            var setPercentLabelFormat = function() {
                    var labelOptions = this.options.label;
                    if (!labelOptions.format)
                        labelOptions.format = 'percent'
                };
            var createTextForVerticalLabels = function(text, y, x, textOptions) {
                    return this.createText(text, x, y, textOptions)
                };
            var drawLabels = function drawLabels(self, group) {
                    var i,
                        options = self.options,
                        categories = options.categories,
                        renderer = self.renderer,
                        axisPosition = self.axisPosition,
                        labelOptions = options.label,
                        labelOffset = labelOptions.indentFromAxis,
                        labelsToDraw,
                        labelPoint,
                        label,
                        labels = [],
                        createText = options.isHorizontal ? renderer.createText : createTextForVerticalLabels,
                        currentLabelConst = options.isHorizontal ? axisPosition + labelOffset : axisPosition - labelOffset,
                        text;
                    if (!labelOptions.visible)
                        return;
                    labelsToDraw = prepareLabelsToDraw(self);
                    if (labelsToDraw.length === 0 || labelsToDraw.hideLabels)
                        return true;
                    for (i = 0; i < labelsToDraw.length; i++) {
                        labelPoint = labelsToDraw[i];
                        text = formatLabel(labelPoint.text, labelOptions);
                        if (utils.isDefined(text) && text !== '') {
                            label = createText.call(renderer, text, labelPoint.pos, currentLabelConst, self.textOptions);
                            labels.push(label);
                            label.append(group);
                            label.data({argument: labelPoint.text})
                        }
                    }
                    self.labels = labels
                };
            var getMultipleAxesSpacing = function() {
                    return this.options.multipleAxesSpacing || 0
                };
            var drawTitle = function drawTitle(self, group) {
                    var i,
                        options = self.options,
                        renderer = self.renderer,
                        axisPosition = self.axisPosition,
                        titleOptions = options.title,
                        margin = titleOptions.margin,
                        title,
                        attr = {
                            font: titleOptions.font,
                            opacity: titleOptions.opacity,
                            align: 'center',
                            'class': 'dx-chart-axis-title'
                        };
                    if (!titleOptions.text)
                        return;
                    if (self.options.isHorizontal)
                        if (self.options.position === 'bottom')
                            title = renderer.createText(titleOptions.text, self.translator.canvas.left + self.translator.width / 2, axisPosition, attr);
                        else
                            title = renderer.createText(titleOptions.text, self.translator.canvas.left + self.translator.width / 2, axisPosition, attr);
                    else if (self.options.position === 'left') {
                        attr.rotate = 270;
                        title = renderer.createText(titleOptions.text, axisPosition, self.translator.canvas.top + self.translator.height / 2, attr)
                    }
                    else {
                        attr.rotate = 90;
                        title = renderer.createText(titleOptions.text, axisPosition, self.translator.canvas.top + self.translator.height / 2, attr)
                    }
                    title.append(group);
                    self.title = title
                };
            var drawGrid = function drawGrid(self, group, borderOptions) {
                    var renderer = self.renderer,
                        options = self.options,
                        gridOptions = options.grid,
                        categories = options.categories,
                        translator = self.translator,
                        tickDelta = options.discreteAxisDivisionMode === 'crossLabels' ? 0 : 0.5,
                        positionsToDraw,
                        i,
                        attr = {
                            strokeWidth: gridOptions.width,
                            stroke: gridOptions.color,
                            strokeOpacity: gridOptions.opacity
                        },
                        currentTickConstant,
                        axisPosition = self.axisPosition,
                        positionFrom,
                        positionTo,
                        tick,
                        firstBorderLinePosition,
                        lastBorderLinePosition,
                        borderOptions = borderOptions || {visible: false};
                    if (!gridOptions.visible)
                        return;
                    positionsToDraw = prepareFullTicksToDraw(self);
                    if (self.options.isHorizontal) {
                        positionFrom = translator.translateY(CANVAS_POSITION_BOTTOM);
                        positionTo = translator.translateY(CANVAS_POSITION_TOP);
                        firstBorderLinePosition = borderOptions.visible && borderOptions.left ? translator.translateX(CANVAS_POSITION_LEFT) : undefined;
                        lastBorderLinePosition = borderOptions.visible && borderOptions.right ? translator.translateX(CANVAS_POSITION_RIGHT) : undefined;
                        for (i = 0; i < positionsToDraw.length; i++) {
                            tick = positionsToDraw[i];
                            if (mathAbs(tick.pos - firstBorderLinePosition) < MAX_GRID_BORDER_ADHENSION || mathAbs(tick.pos - lastBorderLinePosition) < MAX_GRID_BORDER_ADHENSION)
                                continue;
                            renderer.createLine(tick.pos, positionFrom, tick.pos, positionTo, attr).append(group)
                        }
                    }
                    else {
                        positionFrom = translator.translateX(CANVAS_POSITION_LEFT);
                        positionTo = translator.translateX(CANVAS_POSITION_RIGHT);
                        firstBorderLinePosition = borderOptions.visible && borderOptions.top ? translator.translateY(CANVAS_POSITION_TOP) : undefined;
                        lastBorderLinePosition = borderOptions.visible && borderOptions.bottom ? translator.translateY(CANVAS_POSITION_BOTTOM) : undefined;
                        for (i = 0; i < positionsToDraw.length; i++) {
                            tick = positionsToDraw[i];
                            if (mathAbs(tick.pos - firstBorderLinePosition) < MAX_GRID_BORDER_ADHENSION || mathAbs(tick.pos - lastBorderLinePosition) < MAX_GRID_BORDER_ADHENSION)
                                continue;
                            renderer.createLine(positionFrom, tick.pos, positionTo, tick.pos, attr).append(group)
                        }
                    }
                };
            var drawStrip = function drawStrip(self, group) {
                    var renderer = self.renderer,
                        options = self.options,
                        stripData = options.strips,
                        translator = self.translator,
                        i,
                        stripLabels = [],
                        stripRects = [],
                        rect,
                        stripOptions,
                        positionFrom,
                        positionTo,
                        stripPos;
                    if (options.stubData)
                        return;
                    var getPos = function(startV, endV, isHorizontal, range) {
                            var isContinous = isHorizontal ? !!(range.minVisibleX || range.maxVisibleX) : !!(range.minVisibleY || range.maxVisibleY),
                                cateories = (isHorizontal ? range.categoriesX : range.categoriesY) || [],
                                translate = isHorizontal ? function(val) {
                                    return translator.translateX(val)
                                } : function(val) {
                                    return translator.translateY(val)
                                },
                                invert = isHorizontal ? !!range.invertX : range.invertY,
                                defaultPos = isHorizontal ? [CANVAS_POSITION_LEFT, CANVAS_POSITION_RIGHT] : [CANVAS_POSITION_BOTTOM, CANVAS_POSITION_TOP],
                                pos,
                                start = translate(startV),
                                end = translate(endV),
                                min = isHorizontal ? range.minVisibleX : range.maxVisibleY,
                                max = isHorizontal ? range.maxVisibleX : range.maxVisibleY;
                            invert && defaultPos.reverse();
                            if (!isContinous && ($.inArray(startV, cateories) === -1 || $.inArray(endV, cateories) === -1))
                                return {
                                        stripFrom: 0,
                                        stripTo: 0
                                    };
                            if (!utils.isDefined(start) && isContinous)
                                start = startV < min ? translate(defaultPos[0]) : translate(defaultPos[1]);
                            if (!utils.isDefined(end) && isContinous)
                                end = endV < min ? translate(defaultPos[0]) : translate(defaultPos[1]);
                            return start < end ? {
                                    stripFrom: start,
                                    stripTo: end
                                } : {
                                    stripFrom: end,
                                    stripTo: start
                                }
                        };
                    if (self.options.isHorizontal) {
                        positionFrom = translator.translateY(CANVAS_POSITION_BOTTOM);
                        positionTo = translator.translateY(CANVAS_POSITION_TOP);
                        for (i = 0; i < stripData.length; i++) {
                            stripOptions = stripData[i];
                            if (stripOptions.startValue !== undefined && stripOptions.endValue !== undefined && stripOptions.color !== undefined) {
                                stripPos = getPos(stripOptions.startValue, stripOptions.endValue, true, translator.businessRange);
                                if (stripPos.stripTo - stripPos.stripFrom === 0)
                                    continue;
                                rect = renderer.createRect(stripPos.stripFrom, positionTo, stripPos.stripTo - stripPos.stripFrom, positionFrom - positionTo, 0, {fill: stripOptions.color});
                                rect.append(group);
                                stripRects.push(rect);
                                if (stripOptions.label && stripOptions.label.text)
                                    stripLabels.push(drawStripLabel(self, stripOptions.label, stripPos.stripFrom, stripPos.stripTo, group));
                                else
                                    stripLabels.push(null)
                            }
                        }
                    }
                    else {
                        positionFrom = translator.translateX(CANVAS_POSITION_LEFT);
                        positionTo = translator.translateX(CANVAS_POSITION_RIGHT);
                        for (i = 0; i < stripData.length; i++) {
                            stripOptions = stripData[i];
                            if (stripOptions.startValue !== undefined && stripOptions.endValue !== undefined && stripOptions.color !== undefined) {
                                stripPos = getPos(stripOptions.startValue, stripOptions.endValue, false, translator.businessRange);
                                if (stripPos.stripTo - stripPos.stripFrom === 0)
                                    continue;
                                rect = renderer.createRect(positionFrom, stripPos.stripFrom, positionTo - positionFrom, stripPos.stripTo - stripPos.stripFrom, 0, {fill: stripOptions.color});
                                rect.append(group);
                                stripRects.push(rect);
                                if (stripOptions.label && stripOptions.label.text)
                                    stripLabels.push(drawStripLabel(self, stripOptions.label, stripPos.stripFrom, stripPos.stripTo, group));
                                else
                                    stripLabels.push(null)
                            }
                        }
                    }
                    self.stripLabels = stripLabels;
                    self.stripRects = stripRects
                };
            var drawStripLabel = function drawStripLabel(self, labelOptions, stripFrom, stripTo, group) {
                    var renderer = self.renderer,
                        text = labelOptions.text,
                        canvas = self.translator.canvas,
                        attr = {
                            align: self.options.isHorizontal ? 'center' : 'left',
                            font: labelOptions.font || self.options.label.font
                        },
                        label,
                        x,
                        y;
                    if (self.options.isHorizontal) {
                        if (labelOptions.horizontalAlignment === 'center') {
                            x = stripFrom + (stripTo - stripFrom) / 2;
                            attr.align = 'center'
                        }
                        else if (labelOptions.horizontalAlignment === 'left') {
                            x = stripFrom;
                            attr.align = 'left'
                        }
                        else if (labelOptions.horizontalAlignment === 'right') {
                            x = stripTo;
                            attr.align = 'right'
                        }
                        if (labelOptions.verticalAlignment === 'top')
                            y = canvas.top;
                        else if (labelOptions.verticalAlignment === 'center')
                            y = (canvas.height - canvas.top - canvas.bottom) / 2 + canvas.top;
                        else if (labelOptions.verticalAlignment === 'bottom')
                            y = canvas.height - canvas.bottom
                    }
                    else {
                        if (labelOptions.horizontalAlignment === 'center') {
                            x = (canvas.width - canvas.left - canvas.right) / 2 + canvas.left;
                            attr.align = 'center'
                        }
                        else if (labelOptions.horizontalAlignment === 'left') {
                            x = canvas.left;
                            attr.align = 'left'
                        }
                        else if (labelOptions.horizontalAlignment === 'right') {
                            x = canvas.width - canvas.right;
                            attr.align = 'right'
                        }
                        if (labelOptions.verticalAlignment === 'top')
                            y = stripFrom;
                        else if (labelOptions.verticalAlignment === 'center')
                            y = stripTo + (stripFrom - stripTo) / 2;
                        else if (labelOptions.verticalAlignment === 'bottom')
                            y = stripTo
                    }
                    label = renderer.createText(text, x, y, attr);
                    label.append(group);
                    return label
                };
            var initAxisPositions = function(self) {
                    if (self.options.isHorizontal)
                        self.axisPosition = getYAxisPosition(self);
                    else
                        self.axisPosition = getXAxisPosition(self)
                };
            var checkNeedsLabelAdjustment = function(self, labels) {
                    var i,
                        labelOptions = self.options.label,
                        boxLeft,
                        boxRight,
                        labelLeft,
                        labelRight,
                        needsLabelAdjustment = !!self.staggered;
                    labels = self.options.inverted ? labels.slice(0).reverse() : labels;
                    if (!self.options.isHorizontal)
                        needsLabelAdjustment = false;
                    else if (labelOptions.overlappingBehavior && labelOptions.overlappingBehavior.mode === 'stagger')
                        for (i = 1; i < labels.length; i++) {
                            labelLeft = labels[i - 1];
                            labelRight = labels[i];
                            boxLeft = labelLeft.getBBox();
                            boxRight = labelRight.getBBox();
                            if (boxRight.x < boxLeft.x + boxLeft.width + labelOptions.minSpacing) {
                                self.isStaggerOverlapping = true;
                                needsLabelAdjustment = true
                            }
                        }
                    self.needsLabelAdjustment = self.needsLabelAdjustment || needsLabelAdjustment;
                    return self.needsLabelAdjustment
                };
            var adjustLabels = function(self) {
                    var options = self.options,
                        labels = self.labels,
                        labelOptions = options.label,
                        label,
                        labelHeight,
                        isNeedLabelAdjustment,
                        staggeringSpacing,
                        i,
                        box;
                    if (!options.label.visible || !labels || !labels.length)
                        return;
                    for (i = 0; i < labels.length; i++) {
                        label = labels[i];
                        box = label.getBBox();
                        if (options.isHorizontal && options.position === 'bottom')
                            label.applySettings({y: 2 * label.settings.y - box.y});
                        else if (!options.isHorizontal && (options.position === 'left' || options.position === 'right'))
                            label.applySettings({y: label.settings.y + ~~(label.settings.y - box.y - box.height / 2)});
                        else if (options.isHorizontal && options.position === 'top')
                            label.applySettings({y: 2 * label.settings.y - box.y - box.height})
                    }
                    isNeedLabelAdjustment = checkNeedsLabelAdjustment(self, labels);
                    self._testIsNeedLabelAdjustment = isNeedLabelAdjustment;
                    if (isNeedLabelAdjustment) {
                        labelHeight = 0;
                        for (i = 0; i < labels.length; i = i + 2) {
                            label = labels[i];
                            box = label.getBBox();
                            if (box.height > labelHeight)
                                labelHeight = box.height
                        }
                        staggeringSpacing = self.getStaggeringSpacing(self);
                        self._testStaggeringSpacing = staggeringSpacing;
                        labelHeight = Math.round(labelHeight) + staggeringSpacing;
                        for (i = 1; i < labels.length; i = i + 2) {
                            label = labels[i];
                            if (options.position === 'bottom')
                                label.move(0, labelHeight);
                            else if (options.position === 'top')
                                label.move(0, -labelHeight)
                        }
                        for (i = 0; i < labels.length; i++)
                            labels[i].rotate(0)
                    }
                };
            var adjustStripLabels = function(self) {
                    var options = self.options,
                        labelOptions,
                        labels = self.stripLabels,
                        rects = self.stripRects,
                        rect,
                        label,
                        i,
                        box,
                        rectBox,
                        stripOptions,
                        x,
                        y;
                    if (labels === undefined && rects === undefined)
                        return;
                    for (i = 0; i < labels.length; i++) {
                        x = y = 0;
                        stripOptions = options.strips[i];
                        labelOptions = stripOptions.label;
                        label = labels[i];
                        if (label !== null) {
                            rect = rects[i];
                            box = label.getBBox();
                            rectBox = rect.getBBox();
                            if (labelOptions.horizontalAlignment === 'left')
                                x += stripOptions.paddingLeftRight;
                            else if (labelOptions.horizontalAlignment === 'right')
                                x -= stripOptions.paddingLeftRight;
                            if (labelOptions.verticalAlignment === 'top')
                                y += rectBox.y - box.y + stripOptions.paddingTopBottom;
                            else if (labelOptions.verticalAlignment === 'center')
                                y += rectBox.y + rectBox.height / 2 - box.y - box.height / 2;
                            else if (labelOptions.verticalAlignment === 'bottom')
                                y -= stripOptions.paddingTopBottom;
                            label.move(x, y)
                        }
                    }
                };
            var adjustTitle = function(self, group) {
                    var options = self.options,
                        axisPosition = self.axisPosition,
                        boxGroup,
                        boxTitle,
                        title = self.title;
                    if (!title)
                        return;
                    boxTitle = title.getBBox();
                    boxGroup = group.getBBox();
                    if (self.options.isHorizontal)
                        if (self.options.position === 'bottom')
                            title.move(0, boxGroup.y + boxGroup.height - boxTitle.y + options.title.margin);
                        else
                            title.move(0, boxGroup.y - boxTitle.y - boxTitle.height - options.title.margin);
                    else if (self.options.position === 'left')
                        title.move(boxGroup.x - boxTitle.x - boxTitle.width - options.title.margin, 0);
                    else
                        title.move(boxGroup.x + boxGroup.width - boxTitle.x + options.title.margin, 0)
                };
            var draw = function(externalOptions) {
                    var _this = this,
                        cssClass = _this.options.isHorizontal ? 'dxc-h-axis' : 'dxc-v-axis',
                        stripClass = _this.options.isHorizontal ? 'dxc-h-strips' : 'dxc-v-strips',
                        axisClipRectID = _this.clipRectID && _this.options.placeholderSize ? _this.clipRectID : undefined;
                    externalOptions = externalOptions || {};
                    var debug = DX.utils.debug;
                    debug.assertParam(this.translator, 'translator was not set before Draw call');
                    if (_this._axisGroup) {
                        _this._axisGroup.detach();
                        _this._axisStripGroup.detach();
                        _this._axisGridGroup.clear();
                        _this._axisElementsGroup.clear();
                        _this._axisLineGroup.clear();
                        _this._axisStripGroup.clear()
                    }
                    else {
                        _this._axisGroup = _this.renderer.createGroup({
                            'class': cssClass,
                            clipId: axisClipRectID
                        });
                        _this._axisStripGroup = _this.renderer.createGroup({'class': stripClass});
                        _this._axisGridGroup = _this.renderer.createGroup({'class': 'dxc-grid'}).append(_this._axisGroup);
                        _this._axisElementsGroup = _this.renderer.createGroup({'class': 'dxc-elements'}).append(_this._axisGroup);
                        _this._axisLineGroup = _this.renderer.createGroup({'class': 'dxc-line'}).append(_this._axisGroup)
                    }
                    initAxisPositions(_this);
                    if (!_this._virtual) {
                        drawAxis(_this, _this._axisLineGroup);
                        drawTicks(_this, _this._axisLineGroup);
                        drawLabels(_this, _this._axisElementsGroup);
                        if (_this.options.title.text)
                            drawTitle(_this, _this._axisElementsGroup)
                    }
                    if (_this.options.strips)
                        drawStrip(_this, _this._axisStripGroup);
                    drawGrid(_this, _this._axisGridGroup, externalOptions.borderOptions);
                    _this._axisStripGroup.append(_this.stripsGroup);
                    _this._axisGroup.append(_this.axesContainerGroup);
                    adjustLabels(_this);
                    adjustStripLabels(_this);
                    adjustTitle(_this, _this._axisElementsGroup)
                };
            var getBoundingRect = function() {
                    var box = this._axisElementsGroup.getBBox(),
                        lineBox = this._axisLineGroup.getBBox(),
                        placeholderSize = this.options.placeholderSize,
                        start,
                        isHorizontal = this.options.isHorizontal,
                        coord = isHorizontal && 'y' || 'x',
                        side = isHorizontal && 'height' || 'width',
                        positionCondition = this.options.position === (isHorizontal && 'bottom' || 'right');
                    if (!(box.x || box.y || box.width || box.height))
                        return box;
                    start = lineBox[coord] || this.axisPosition;
                    if (positionCondition) {
                        box[side] = placeholderSize || box[side] - (start - box[coord]);
                        box[coord] = start
                    }
                    else
                        box[side] = placeholderSize || lineBox[side] + start - box[coord];
                    return box
                };
            var shift = function(x, y) {
                    var settings = {};
                    if (x)
                        settings.translateX = x;
                    if (y)
                        settings.translateY = y;
                    this._axisGroup.applySettings(settings)
                };
            var applyClipRectForStrips = function(clipId) {
                    this._axisStripGroup.applySettings({clipId: clipId})
                };
            var getRangeData = function() {
                    var options = this.options,
                        range = {};
                    var addValueMarginToRange = function(prefix, dim) {
                            if (options['valueMarginsEnabled']) {
                                if (utils.isDefined(options[prefix])) {
                                    range[prefix + dim] = options[prefix];
                                    range[prefix + dim + 'Priority'] = AXIS_VALUE_MARGIN_PRIORITY
                                }
                            }
                            else {
                                range[prefix + dim] = 0;
                                range[prefix + dim + 'Priority'] = AXIS_VALUE_MARGIN_PRIORITY
                            }
                        };
                    if (options.isHorizontal) {
                        range.minX = options.range.min;
                        range.maxX = options.range.max;
                        range.minVisibleX = options.range.min;
                        range.maxVisibleX = options.range.max;
                        addValueMarginToRange('minValueMargin', 'X');
                        addValueMarginToRange('maxValueMargin', 'X');
                        range.invertX = options.inverted;
                        range.stickX = !options.valueMarginsEnabled;
                        range.categoriesX = options.range.categories
                    }
                    else {
                        range.minY = options.range.min;
                        range.maxY = options.range.max;
                        range.minVisibleY = options.range.min;
                        range.maxVisibleY = options.range.max;
                        range.invertY = options.inverted || options.type === 'discrete' && options.oppositeDirectionYAxis;
                        range.stickY = !options.valueMarginsEnabled;
                        addValueMarginToRange('minValueMargin', 'Y');
                        addValueMarginToRange('maxValueMargin', 'Y');
                        range.categoriesY = options.range.categories
                    }
                    return range
                };
            var on = function(events, data, handler) {
                    this._$axis && this._$axis.on(events, data, handler);
                    return this
                };
            var off = function(events) {
                    this._$axis && this._$axis.off(events);
                    return this
                };
            var prototypeObject = {
                    ctor: ctor,
                    dispose: dispose,
                    init: init,
                    resetTicks: resetTicks,
                    getStaggeringSpacing: getStaggeringSpacing,
                    setTranslator: setTranslator,
                    getTickValues: getTickValues,
                    setTickValues: setTickValues,
                    getRangeData: getRangeData,
                    getMultipleAxesSpacing: getMultipleAxesSpacing,
                    setRange: setRange,
                    setPercentLabelFormat: setPercentLabelFormat,
                    draw: draw,
                    getBoundingRect: getBoundingRect,
                    shift: shift,
                    on: on,
                    off: off,
                    applyClipRectForStrips: applyClipRectForStrips
                };
            prototypeObject.getTicksOptions = getTicksOptions;
            prototypeObject.drawAxis = drawAxis;
            prototypeObject.drawTicks = drawTicks;
            prototypeObject.drawGrid = drawGrid;
            prototypeObject.drawStrip = drawStrip;
            prototypeObject.drawLabels = drawLabels;
            prototypeObject.adjustLabels = adjustLabels;
            prototypeObject.adjustStripLabels = adjustStripLabels;
            prototypeObject.drawTitle = drawTitle;
            prototypeObject.adjustTitle = adjustTitle;
            prototypeObject.checkNeedsLabelAdjustment = checkNeedsLabelAdjustment;
            prototypeObject.initAxisPositions = initAxisPositions;
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file baseChart.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            charts = DX.viz.charts,
            utils = DX.utils,
            dataUtils = DX.data.utils,
            REDRAW_DELAY = 100,
            resizeRedrawOptions = {animate: false},
            ACTIONS_BY_PRIORITY = ['processAxesOption', 'reinit', '_reinitDataSource', '_handleDataSourceChanged', 'force_render'];
        charts.BaseChart = ui.Component.inherit({
            _defaultOptions: function() {
                return {
                        done: $.noop,
                        drawn: $.noop,
                        redrawOnResize: true,
                        incidentOccured: $.noop,
                        margin: {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0
                        },
                        size: {
                            width: undefined,
                            height: undefined
                        },
                        title: {text: null},
                        legend: {hoverMode: 'includePoints'},
                        animation: {
                            enabled: true,
                            duration: 1000,
                            easing: 'easeOutCubic',
                            maxPointCountSupported: 300,
                            asyncSeriesRendering: true,
                            asyncTrackersRendering: true,
                            trackerRenderingDelay: 1200
                        },
                        seriesSelectionMode: 'single',
                        pointSelectionMode: 'single',
                        seriesClick: $.noop,
                        pointClick: $.noop,
                        argumentAxisClick: $.noop,
                        seriesHover: $.noop,
                        pointHover: $.noop,
                        seriesSelected: $.noop,
                        pointSelected: $.noop
                    }
            },
            _init: function() {
                var _this = this;
                _this._saveUserCanvas();
                _this._initRenderer();
                _this._createHtmlStructure();
                _this._needHandleRenderComplete = true;
                _this.layoutManager = charts.factory.createChartLayoutManager();
                _this._reinit()
            },
            _reinit: function() {
                var _this = this;
                _this.layoutManager.update(_this);
                if (_this.option('redrawOnResize') && window) {
                    if (!_this._resizeHandlerCallback) {
                        _this._resizeHandlerCallback = _this._resizeHandler();
                        utils.windowResizeCallbacks.add(_this._resizeHandlerCallback)
                    }
                }
                else {
                    utils.windowResizeCallbacks.remove(_this._resizeHandlerCallback);
                    delete _this._resizeHandlerCallback
                }
                if (!$.isFunction(_this.option('incidentOccured'))) {
                    utils.debug.assert(false, 'Function should be passed as "incidentOccured" callback');
                    _this.option('incidentOccured', $.noop)
                }
                if (_this.option('incidentOccured') === $.noop)
                    _this.option('incidentOccured', utils.logger.warn);
                _this._createTracker();
                _this._reinitDataSource()
            },
            _createHtmlStructure: function() {
                var _this = this,
                    renderer = _this.renderer;
                _this._panesBackgroundGroup = renderer.createGroup({'class': 'dxc-background'});
                _this._titleGroup = renderer.createGroup({'class': 'dxc-title'});
                _this._legendGroup = renderer.createGroup({'class': 'dxc-legend'});
                _this._stripsGroup = renderer.createGroup({'class': 'dxc-strips-group'});
                _this._axesGroup = renderer.createGroup({'class': 'dxc-axes-group'});
                _this._panesBorderGroup = renderer.createGroup({'class': 'dxc-border'});
                _this._seriesGroup = renderer.createGroup({'class': 'dxc-series-group'});
                _this._labelsGroup = renderer.createGroup({'class': 'dxc-labels-group'});
                _this._tooltipGroup = renderer.createGroup({'class': 'dxc-tooltip'});
                _this._trackerGroup = renderer.createGroup({
                    'class': 'dxc-trackers',
                    opacity: 0.0001
                });
                _this._seriesTrackerGroup = renderer.createGroup({'class': 'dxc-series-trackers'}).append(_this._trackerGroup);
                _this._markerTrackerGroup = renderer.createGroup({
                    'class': 'dxc-markers-trackers',
                    stroke: 'none',
                    fill: 'grey'
                }).append(_this._trackerGroup);
                _this._legendTrackerGroup = renderer.createGroup({
                    'class': 'dxc-legend-trackers',
                    stroke: 'none',
                    fill: 'grey'
                }).append(_this._trackerGroup)
            },
            _cleanHtmlStructure: function() {
                var _this = this;
                _this._legendGroup.detach();
                _this._stripsGroup.detach();
                _this._axesGroup.detach();
                _this._seriesGroup.detach();
                _this._labelsGroup.detach();
                _this._trackerGroup.detach();
                _this._panesBackgroundGroup.clear();
                _this._titleGroup.clear();
                _this._legendGroup.clear();
                _this._stripsGroup.clear();
                _this._axesGroup.clear();
                _this._panesBorderGroup.clear();
                _this._seriesGroup.clear();
                _this._labelsGroup.clear();
                _this._tooltipGroup.clear();
                _this._seriesTrackerGroup.clear();
                _this._markerTrackerGroup.clear();
                _this._legendTrackerGroup.clear()
            },
            _disposeObjectsInArray: function(propName) {
                $.each(this[propName] || [], function(_, item) {
                    item && item.dispose()
                });
                this[propName] = null
            },
            _dispose: function() {
                var _this = this,
                    disposeObject = function(propName) {
                        _this[propName] && _this[propName].dispose(),
                        _this[propName] = null
                    },
                    disposeObjectsInArray = this._disposeObjectsInArray;
                clearTimeout(_this.delayedRedraw);
                if (_this._resizeHandlerCallback) {
                    _this._resizeHandlerCallback.stop();
                    utils.windowResizeCallbacks.remove(_this._resizeHandlerCallback);
                    _this._resizeHandlerCallback = null
                }
                _this.callBase();
                disposeObjectsInArray.call(_this, "businessRanges");
                disposeObjectsInArray.call(_this, "translators");
                disposeObjectsInArray.call(_this, "series");
                disposeObject("layoutManager");
                disposeObject("themeManager");
                disposeObject("renderer");
                disposeObject("tracker");
                disposeObject("tooltip");
                disposeObject("chartTitle");
                _this.paneAxis = null;
                _this._userOptions = null;
                _this.dirtyCanvas = null;
                _this.canvas = null;
                _this._legendGroup.detach();
                _this._stripsGroup.detach();
                _this._axesGroup.detach();
                _this._seriesGroup.detach();
                _this._labelsGroup.detach();
                _this._trackerGroup.detach();
                disposeObject("canvasClipRect");
                disposeObject("_panesBackgroundGroup");
                disposeObject("_titleGroup");
                disposeObject("_legendGroup");
                disposeObject("_stripsGroup");
                disposeObject("_axesGroup");
                disposeObject("_panesBorderGroup");
                disposeObject("_seriesGroup");
                disposeObject("_labelsGroup");
                disposeObject("_tooltipGroup");
                disposeObject("_seriesTrackerGroup");
                disposeObject("_markerTrackerGroup");
                disposeObject("_legendTrackerGroup");
                disposeObject("_trackerGroup")
            },
            _clean: function _clean() {
                var _this = this;
                _this._cleanHtmlStructure();
                _this.callBase();
                _this._saveDirtyCanvas()
            },
            _initRenderer: function _initRenderer() {
                if (this.renderer)
                    return;
                var _this = this,
                    animationOptions = _this.option('animation');
                animationOptions = animationOptions === true ? _this._defaultOptions().animation : animationOptions;
                _this.renderer = charts.factory.createRenderer({
                    animation: animationOptions,
                    cssClass: 'dxc dxc-chart'
                })
            },
            _initSeries: function() {
                var _this = this;
                _this.series = _this.series || _this._populateSeries()
            },
            _reinitDataSource: function() {
                this._initDataSource();
                this._loadDataSource()
            },
            _initOptions: function(options) {
                var _this = this,
                    changedTitle;
                _this._optionsInitializing = true;
                changedTitle = _this._processTitleOption(options.title, _this.option('title'));
                if (changedTitle)
                    options.title = changedTitle;
                _this._userOptions = options;
                _this._processAxesOption(options);
                _this._createThemeManager(options);
                _this.option(_this.themeManager.applyChartTheme(options));
                delete _this._userOptions.userCommonAxisSettings
            },
            _processTitleOption: function(title, oldTitle) {
                if (utils.isString(title)) {
                    var text = title;
                    title = oldTitle;
                    title.text = text;
                    return title
                }
            },
            _processAxesOption: function(options) {
                var argumentAxesOptions = $.isArray(options.argumentAxis) ? options.argumentAxis : [options.argumentAxis],
                    valueAxesOptions = $.isArray(options.valueAxis) ? options.valueAxis : [options.valueAxis],
                    checkOptions = function(axesOptions) {
                        var axisOptions,
                            text,
                            i = 0;
                        for (i = 0; i < axesOptions.length; i++) {
                            axisOptions = axesOptions[i];
                            if (axisOptions && axisOptions.title)
                                if (utils.isString(axisOptions.title)) {
                                    text = axisOptions.title;
                                    axisOptions.title = {};
                                    axisOptions.title.text = text
                                }
                            if (axisOptions && axisOptions.label) {
                                if (axisOptions.label.alignment)
                                    axisOptions.label['userAlignment'] = true;
                                if (utils.isString(axisOptions.label.overlappingBehavior))
                                    axisOptions.label.overlappingBehavior = {mode: axisOptions.label.overlappingBehavior};
                                if (!axisOptions.label.overlappingBehavior || !axisOptions.label.overlappingBehavior.mode) {
                                    axisOptions.label.overlappingBehavior = axisOptions.label.overlappingBehavior || {};
                                    if (axisOptions.label.rotationAngle) {
                                        axisOptions.label.overlappingBehavior.mode = 'rotate';
                                        if (!axisOptions.label.overlappingBehavior.rotationAngle)
                                            axisOptions.label.overlappingBehavior.rotationAngle = axisOptions.label.rotationAngle
                                    }
                                    if (axisOptions.label.staggered) {
                                        axisOptions.label.overlappingBehavior.mode = 'stagger';
                                        if (!axisOptions.label.overlappingBehavior.staggeringSpacing)
                                            axisOptions.label.overlappingBehavior.staggeringSpacing = axisOptions.label.staggeringSpacing
                                    }
                                }
                            }
                        }
                    };
                options.userCommonAxisSettings = this._userOptions.commonAxisSettings;
                checkOptions([options.commonAxisSettings]);
                checkOptions(argumentAxesOptions);
                checkOptions(valueAxesOptions)
            },
            _saveUserCanvas: function() {
                var canvas = this.option('size');
                if (canvas.width !== undefined)
                    canvas.userWidth = canvas.width;
                if (canvas.height !== undefined)
                    canvas.userHeight = canvas.height
            },
            _saveDirtyCanvas: function() {
                this.dirtyCanvas = this._calculateCanvas()
            },
            _resizeHandler: function() {
                var _this = this;
                return utils.createResizeHandler(function() {
                        _this._render(resizeRedrawOptions)
                    })
            },
            _createThemeManager: function(options) {
                options = options || {};
                var _this = this;
                _this.themeManager && _this.themeManager.dispose();
                _this.themeManager = charts.factory.createThemeManager({
                    theme: options.theme,
                    palette: options.palette
                })
            },
            _calculateCanvas: function() {
                var _this = this,
                    canvas = _this.option('size'),
                    container = _this._element();
                if (!utils.isDefined(canvas.userWidth)) {
                    canvas.width = container.width();
                    if (!canvas.width)
                        canvas.width = 400
                }
                if (!utils.isDefined(canvas.userHeight)) {
                    canvas.height = container.height();
                    if (!canvas.height)
                        canvas.height = 400
                }
                return $.extend({}, canvas, _this.option('margin'))
            },
            _createTracker: function() {
                var _this = this,
                    rotated = _this.option('rotated'),
                    tooltipOptions = _this.option('tooltip') || {};
                if (_this.tracker)
                    _this.tracker.dispose();
                _this.tracker = charts.factory.createTracker({
                    series: _this.series,
                    valueAxis: rotated ? _this.horizontalAxes : _this.verticalAxes,
                    argumentAxis: rotated ? _this.verticalAxes : _this.horizontalAxes,
                    seriesSelectionMode: _this.option('seriesSelectionMode'),
                    pointSelectionMode: _this.option('pointSelectionMode'),
                    tooltipShown: _this.option('tooltipShown'),
                    tooltipHidden: _this.option('tooltipHidden'),
                    markerTrackerGroup: _this._markerTrackerGroup,
                    seriesTrackerGroup: _this._seriesTrackerGroup,
                    legendGroup: _this._legendTrackerGroup,
                    seriesGroup: _this._seriesGroup,
                    tooltipEnabled: tooltipOptions.enabled,
                    events: {
                        seriesClick: _this.option('seriesClick'),
                        pointClick: _this.option('pointClick'),
                        argumentAxisClick: _this.option('argumentAxisClick'),
                        seriesHover: _this.option('seriesHover'),
                        seriesSelected: _this.option('seriesSelected'),
                        pointHover: _this.option('pointHover'),
                        pointSelected: _this.option('pointSelected')
                    }
                })
            },
            _updateTracker: function() {
                var _this = this,
                    rotated = _this.option('rotated');
                if (!_this.tracker)
                    _this._createTracker();
                else
                    _this.tracker._reinit({
                        series: _this.series,
                        valueAxis: rotated ? _this.horizontalAxes : _this.verticalAxes,
                        argumentAxis: rotated ? _this.verticalAxes : _this.horizontalAxes
                    })
            },
            _render: function(drawOptions) {
                this._optionsInitializing = false;
                var _this = this,
                    renderer = _this.renderer,
                    translators = _this.translators,
                    updatedCanvas = _this.canvas,
                    container = this._element(),
                    currentDirtyCanvas = _this._calculateCanvas(),
                    oldDirtyCanvas = _this.dirtyCanvas;
                drawOptions = drawOptions || {recreateCanvas: true};
                drawOptions.recreateCanvas = drawOptions.recreateCanvas || !renderer.isInitialized();
                if (!drawOptions.force && oldDirtyCanvas && oldDirtyCanvas.width === currentDirtyCanvas.width && oldDirtyCanvas.height === currentDirtyCanvas.height && !_this.hiddenContainer) {
                    _this.stopRedraw = true;
                    return
                }
                clearTimeout(_this.delayedRedraw);
                if (drawOptions.recreateCanvas)
                    updatedCanvas = _this._calculateCanvas();
                if (updatedCanvas.width && updatedCanvas.height && container.is(':visible'))
                    _this.hiddenContainer = false;
                else {
                    _this.option('incidentOccured')('Chart can not be drawn as container is not visible');
                    _this.hiddenContainer = true;
                    _this.stopRedraw = true;
                    renderer.killContainer();
                    return
                }
                if (drawOptions.recreateCanvas) {
                    _this.canvas = updatedCanvas;
                    renderer.recreateCanvas(_this.canvas.width, _this.canvas.height);
                    renderer.draw(_this._element()[0]);
                    _this._createCanvasClipRect();
                    if (translators)
                        translators.length = 0
                }
                _this.layoutManager.update(_this);
                _this._cleanGroups(drawOptions);
                _this._saveDirtyCanvas()
            },
            _cleanGroups: function(drawOptions) {
                var _this = this;
                _this._stripsGroup.detach();
                _this._axesGroup.detach();
                _this._seriesGroup.detach();
                _this._labelsGroup.detach();
                _this._trackerGroup.detach();
                _this._tooltipGroup.detach();
                if (!drawOptions || drawOptions.drawLegend) {
                    _this._legendGroup.detach();
                    _this._legendGroup.clear()
                }
                _this._stripsGroup.clear();
                _this._axesGroup.clear();
                _this._seriesGroup.clear();
                _this._labelsGroup.clear();
                _this._tooltipGroup.clear();
                _this._seriesTrackerGroup.clear();
                _this._markerTrackerGroup.clear();
                _this._legendTrackerGroup.clear()
            },
            _drawTitle: function() {
                var _this = this;
                if (_this.chartTitle)
                    _this.chartTitle.update(_this.canvas, _this.option('title'));
                else
                    _this.chartTitle = charts.factory.createTitle(_this.renderer, _this.canvas, _this.option('title'), _this._titleGroup);
                _this.chartTitle.render()
            },
            _createTooltip: function() {
                var _this = this,
                    tooltipCoords,
                    point = _this.tracker.pointAtShownTooltip,
                    tooltipOptions = $.extend(true, {
                        renderer: _this.renderer,
                        canvasWidth: _this.canvas.width,
                        canvasHeight: _this.canvas.height
                    }, _this.option('tooltip') || {});
                if (!$.isFunction(tooltipOptions.customizeText) && utils.isDefined(tooltipOptions.customizeText)) {
                    _this.option('incidentOccured').call(null, 'customizeText can not be applied as it is not a function');
                    tooltipOptions.customizeText = undefined
                }
                if (_this.tooltip)
                    _this.tooltip.update(tooltipOptions);
                else
                    _this.tooltip = charts.factory.createTooltip(tooltipOptions, _this._tooltipGroup);
                _this.tooltip.draw();
                _this.tracker.tooltip = _this.tooltip;
                if (point) {
                    tooltipCoords = point.getTooltipCoords();
                    _this.tooltip.move(~~tooltipCoords.x, ~~tooltipCoords.y, tooltipCoords.offset, _this.tooltip.tooltipText, _this.tooltip.style.fill, _this.tooltip.className)
                }
            },
            _prepareDrawOptions: function(drawOptions) {
                var animationOptions = this.option('animation'),
                    options;
                animationOptions = animationOptions === true ? this._defaultOptions().animation : animationOptions;
                options = $.extend({}, {
                    force: false,
                    adjustAxes: true,
                    drawLegend: true,
                    drawTitle: true,
                    adjustSeriesLabels: true,
                    animate: animationOptions.enabled,
                    animationPointsLimit: animationOptions.maxPointCountSupported,
                    asyncSeriesRendering: animationOptions.asyncSeriesRendering,
                    asyncTrackersRendering: animationOptions.asyncTrackersRendering,
                    trackerRenderingDelay: animationOptions.trackerRenderingDelay
                }, drawOptions);
                if (!utils.isDefined(options.recreateCanvas))
                    options.recreateCanvas = !(!options.adjustAxes || !options.drawLegend || !options.drawTitle);
                return options
            },
            _processRefreshData: function(newRefreshAction) {
                var _this = this,
                    currentRefreshActionPosition = $.inArray(_this._currentRefreshData, ACTIONS_BY_PRIORITY),
                    newRefreshActionPosition = $.inArray(newRefreshAction, ACTIONS_BY_PRIORITY);
                if (!_this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition)
                    _this._currentRefreshData = newRefreshAction
            },
            _disposeSeries: function() {
                var _this = this;
                $.each(_this.series || [], function(_, series) {
                    series.dispose()
                });
                _this.series = null;
                $.each(_this.seriesFamilies || [], function(_, family) {
                    family.dispose()
                });
                _this.seriesFamilies = null
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                if (name === 'valueAxis' || name === 'argumentAxis' || name === 'commonAxisSettings' || name === 'userCommonAxisSettings')
                    if (oldValue && newValue)
                        if (utils.isArray(newValue) && !utils.isArray(oldValue)) {
                            oldValue.strips = null;
                            oldValue.categories = null
                        }
                        else if (!utils.isArray(newValue) && !utils.isArray(oldValue)) {
                            newValue.strips && (oldValue.strips = null);
                            newValue.categories && (oldValue.categories = null)
                        }
                return this.callBase.apply(this, arguments)
            },
            _optionChanged: function(name, value, prevValue) {
                var _this = this,
                    changedTitle;
                if (!_this._optionsInitializing) {
                    _this._optionValuesEqual(name, _this._userOptions[name], value);
                    dataUtils.compileSetter(name)(_this._userOptions, value, {
                        functionsAsIs: true,
                        merge: true
                    })
                }
                if (name == 'animation') {
                    _this.renderer.updateAnimationOptions(value);
                    return
                }
                clearTimeout(_this.delayedRedraw);
                switch (name) {
                    case'dataSource':
                        _this._needHandleRenderComplete = true;
                        _this._processRefreshData('_reinitDataSource');
                        break;
                    case'palette':
                        _this.themeManager.updatePalette(value);
                        _this._disposeSeries();
                        _this._needHandleRenderComplete = true;
                        _this._processRefreshData('_handleDataSourceChanged');
                        break;
                    case'series':
                    case'commonSeriesSettings':
                    case'backgroundColor':
                        _this._disposeSeries();
                        _this._needHandleRenderComplete = true;
                        _this._processRefreshData('_handleDataSourceChanged');
                        break;
                    case'legend':
                    case'seriesTemplate':
                        _this._processRefreshData('_handleDataSourceChanged');
                        break;
                    case'title':
                        changedTitle = _this._processTitleOption(value, prevValue);
                        if (changedTitle) {
                            _this.option('title', prevValue);
                            return
                        }
                        _this._processRefreshData('force_render');
                        break;
                    case'valueAxis':
                    case'argumentAxis':
                    case'commonAxisSettings':
                        _this._needHandleRenderComplete = true;
                        _this._processRefreshData('processAxesOption');
                        _this._disposeSeries();
                        _this.paneAxis = {};
                        break;
                    case'panes':
                    case'defaultPane':
                        _this._disposeSeries();
                        _this.paneAxis = {};
                        _this._needHandleRenderComplete = true;
                        _this._processRefreshData('reinit');
                        break;
                    case'size':
                        _this._saveUserCanvas();
                        _this._processRefreshData('force_render');
                        break;
                    case'theme':
                        _this._initOptions(_this._userOptions);
                        _this._processRefreshData('reinit');
                        break;
                    default:
                        _this._processRefreshData('reinit')
                }
                _this.callBase.apply(_this, arguments)
            },
            _refresh: function() {
                var _this = this;
                _this._clean();
                if (_this._currentRefreshData) {
                    switch (_this._currentRefreshData) {
                        case'force_render':
                            _this._render({force: true});
                            break;
                        case'processAxesOption':
                            _this._processAxesOption(_this._options);
                            _this._reinit(true);
                            break;
                        case'reinit':
                            _this._reinit(true);
                            break;
                        default:
                            _this[_this._currentRefreshData] && _this[_this._currentRefreshData]()
                    }
                    delete _this._currentRefreshData
                }
                else
                    _this._render({force: true})
            },
            _dataSourceOptions: function() {
                return {
                        paginate: false,
                        _preferSync: true
                    }
            },
            _createCanvasClipRect: function() {
                var _this = this,
                    canvas = _this.canvas;
                if (!_this.canvasClipRect)
                    _this.canvasClipRect = _this.renderer.createClipRect(canvas.left, canvas.top, canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom).append();
                else
                    _this.canvasClipRect.updateRectangle({
                        x: canvas.left,
                        y: canvas.top,
                        width: canvas.width - canvas.left - canvas.right,
                        height: canvas.height - canvas.top - canvas.bottom
                    })
            },
            _getCanvasClipRectID: function() {
                return this.canvasClipRect.id
            },
            _handleDataSourceChanged: function() {
                this._dataSpecificInit(true)
            },
            _dataSpecificInit: function(needRedraw) {
                var _this = this;
                _this._initSeries();
                _this._repopulateSeries();
                _this._handleSeriesPopulated(needRedraw)
            },
            _processSeriesTemplate: function() {
                var _this = this,
                    seriesTemplate = _this.option('seriesTemplate'),
                    customizeSeries = utils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : $.noop,
                    nameField = seriesTemplate.nameField || 'series',
                    dataSource = _this._dataSource;
                if (!dataSource)
                    return;
                var generatedSeries = {},
                    seriesOrder = [],
                    items = dataSource.items(),
                    series;
                for (var i = 0, length = items.length; i < length; i++) {
                    var data = items[i];
                    series = generatedSeries[data[nameField]];
                    if (!series) {
                        series = generatedSeries[data[nameField]] = {
                            name: data[nameField],
                            data: []
                        };
                        seriesOrder.push(series.name)
                    }
                    series.data.push(data)
                }
                _this._templatedSeries = $.map(seriesOrder, function(orderedName) {
                    var group = generatedSeries[orderedName],
                        seriesOptions = customizeSeries.call(null, group.name);
                    return $.extend(group, seriesOptions)
                });
                _this._populateSeries();
                delete _this._templatedSeries
            },
            _processSingleSeries: function(){},
            _repopulateSeries: function() {
                var _this = this,
                    data = _this._dataSource && _this._dataSource.items(),
                    seriesTemplate = _this.option('seriesTemplate');
                _this.themeManager.resetPalette();
                if (_this._dataSource && seriesTemplate)
                    _this._processSeriesTemplate();
                else
                    data && $.each(_this.series, function(_, singleSeries) {
                        singleSeries.reinitData(data);
                        _this._processSingleSeries(singleSeries, singleSeries.userOptions)
                    })
            },
            _handleRenderComplete: function() {
                var _this = this,
                    userHandle = _this.option('done'),
                    allSeriesInited = true;
                if (_this._needHandleRenderComplete) {
                    $.each(_this.series, function(_, s) {
                        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle()
                    });
                    if (allSeriesInited) {
                        $.isFunction(userHandle) && userHandle.call(_this);
                        _this._needHandleRenderComplete = false
                    }
                }
            },
            getAllSeries: function getAllSeries() {
                return this.series.slice()
            },
            getSeriesByName: function getSeriesByName(name) {
                var found = null;
                $.each(this.series, function(i, singleSeries) {
                    if (singleSeries.name === name) {
                        found = singleSeries;
                        return false
                    }
                });
                return found
            },
            getSeriesByPos: function getSeriesByPos(pos) {
                return this.series[pos]
            },
            getSelectedSeries: function getSelectedSeries() {
                return null
            },
            clearSelection: function clearSelection() {
                this.tracker.clearSelection()
            },
            hideTooltip: function() {
                this.tracker._hideTooltip(null, true)
            },
            render: function(renderOptions) {
                this._render(renderOptions)
            }
        }).include(ui.DataHelperMixin)
    })(jQuery, DevExpress);
    /*! Module viz, file chart.js */
    (function($, DX, undefined) {
        var charts = DX.viz.charts,
            utils = DX.utils,
            MAX_ADJUSTMENT_ATTEMPTS = 5,
            DEFAULT_PANE_NAME = 'default',
            DEFAULT_AXIS_NAME = 'defaultAxisName',
            DEFAULT_BUSINESS_RANGE_VALUE_MARGIN = 0.1;
        charts.Chart = charts.BaseChart.inherit({
            _defaultOptions: function() {
                return $.extend(true, this.callBase(), {
                        commonSeriesSettings: {
                            type: 'line',
                            maxLabelCount: undefined,
                            stack: 'default',
                            label: {
                                visible: false,
                                alignment: 'center',
                                rotationAngle: 0,
                                horizontalOffset: 0,
                                verticalOffset: 0,
                                radialOffset: 0,
                                format: '',
                                argumentFormat: '',
                                precision: 0,
                                argumentPrecision: 0,
                                percentPrecision: 0,
                                customizeText: undefined,
                                position: 'outside',
                                connector: {
                                    visible: false,
                                    width: 0
                                }
                            }
                        },
                        defaultPane: DEFAULT_PANE_NAME,
                        adjustOnZoom: true,
                        rotated: false,
                        synchronizeMultiAxes: true,
                        equalBarWidth: true,
                        commonPaneSettings: {
                            backgroundColor: 'none',
                            border: {
                                visible: false,
                                top: true,
                                bottom: true,
                                left: true,
                                right: true,
                                dashStyle: 'solid'
                            }
                        },
                        panes: [{
                                name: DEFAULT_PANE_NAME,
                                border: {}
                            }],
                        commonAxisSettings: {
                            tickInterval: undefined,
                            setTicksAtUnitBeginning: true,
                            valueMarginsEnabled: true,
                            placeholderSize: null
                        }
                    })
            },
            _dispose: function() {
                var _this = this,
                    disposeObjectsInArray = this._disposeObjectsInArray;
                _this.callBase();
                _this.panes = null;
                _this.legend.dispose(),
                _this.legend = null;
                disposeObjectsInArray.call(_this, "panesBackground");
                disposeObjectsInArray.call(_this, "panesClipRects");
                disposeObjectsInArray.call(_this, "horizontalAxes");
                disposeObjectsInArray.call(_this, "verticalAxes");
                disposeObjectsInArray.call(_this, "seriesFamilies");
                $.each(_this._paneTrackerGroups || [], function(_, groups) {
                    groups.paneSeriesGroup.dispose();
                    groups.paneMarkerGroup.dispose()
                });
                _this._paneTrackerGroups = null
            },
            _init: function() {
                this.paneAxis = {};
                this.callBase()
            },
            _reinit: function(needRedraw) {
                var _this = this;
                _this._disposeObjectsInArray("translators");
                _this.translators = [];
                _this.panes = _this._createPanes();
                _this._populateAxes();
                _this.callBase();
                delete _this._seriesInitializing;
                if (!_this.series)
                    _this._dataSpecificInit();
                else
                    _this._correctValueAxes();
                needRedraw && _this._render({force: true})
            },
            _correctBusinessRange: function(range, tickInterval, field, setTicksAtUnitBeginning) {
                var min = 'min' + field,
                    max = 'max' + field;
                if (!tickInterval || !utils.isDefined(range[min]) || !utils.isDefined(range[max]))
                    return false;
                var tickIntervalRange = {},
                    originInterval = tickInterval;
                tickInterval = $.isNumeric(tickInterval) ? tickInterval : utils.convertDateTickIntervalToMilliseconds(tickInterval);
                if (tickInterval >= Math.abs(range[max] - range[min])) {
                    if (utils.isDate(range[min])) {
                        if (!$.isNumeric(originInterval)) {
                            tickIntervalRange[min] = utils.addInterval(range[min], originInterval, true);
                            tickIntervalRange[max] = utils.addInterval(range[max], originInterval, false)
                        }
                        else {
                            tickIntervalRange[min] = new Date(range[min].valueOf() - tickInterval);
                            tickIntervalRange[max] = new Date(range[max].valueOf() + tickInterval)
                        }
                        if (setTicksAtUnitBeginning) {
                            utils.correctDateWithUnitBeginning(tickIntervalRange[max], originInterval);
                            utils.correctDateWithUnitBeginning(tickIntervalRange[min], originInterval)
                        }
                    }
                    else {
                        tickIntervalRange[min] = range[min] - tickInterval;
                        tickIntervalRange[max] = range[max] + tickInterval
                    }
                    range.getBoundRange(tickIntervalRange);
                    return true
                }
                return false
            },
            _populateBusinessRange: function(visibleArea) {
                var _this = this,
                    panes = _this.panes,
                    businessRanges = [],
                    range,
                    i,
                    rotated = _this.option('rotated'),
                    singleSeriesRange,
                    valAxes = rotated ? _this.horizontalAxes : _this.verticalAxes,
                    argAxes = rotated ? _this.verticalAxes : _this.horizontalAxes,
                    valueField = rotated && 'X' || 'Y',
                    argumentField = rotated && 'Y' || 'X',
                    valueBoundRange = 'getBoundRange' + valueField,
                    argumentBoundRange = 'getBoundRange' + argumentField,
                    businessLength,
                    paneList = $.map(panes, function(pane) {
                        return pane.name
                    }),
                    series = _this.series,
                    argumentTickInterval,
                    setTicksAtUnitBeginning;
                _this._disposeObjectsInArray("businessRanges");
                var hideGridsOnNonFirstValueAxisForPane = function(paneName) {
                        var axesForPane = [],
                            firstShownAxis;
                        $.each(valAxes, function(_, axis) {
                            if (axis.pane === paneName)
                                axesForPane.push(axis)
                        });
                        if (axesForPane.length > 1 && _this.option('synchronizeMultiAxes'))
                            $.each(axesForPane, function(_, axis) {
                                var gridOpt = axis.options.grid;
                                if (firstShownAxis && gridOpt && gridOpt.visible)
                                    gridOpt.visible = false;
                                else
                                    firstShownAxis = firstShownAxis ? firstShownAxis : gridOpt && gridOpt.visible
                            })
                    };
                var paneAxis = _this.paneAxis;
                var argRange = new charts.Range;
                var getFirstAxisNameForPane = function(axes, paneName) {
                        var result;
                        for (var i = 0; i < axes.length; i++)
                            if (axes[i].pane === paneName) {
                                result = axes[i].name;
                                break
                            }
                        if (!result)
                            result = valAxes[0].name;
                        return result
                    };
                $.each(series, function(i, particularSeries) {
                    particularSeries.axis = particularSeries.axis || getFirstAxisNameForPane(valAxes, particularSeries.pane);
                    if (particularSeries.axis) {
                        paneAxis[particularSeries.pane] = paneAxis[particularSeries.pane] || {};
                        paneAxis[particularSeries.pane][particularSeries.axis] = true
                    }
                });
                $.each(valAxes, function(_, axis) {
                    if (axis.name && axis.pane && $.inArray(axis.pane, paneList) != -1) {
                        paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                        paneAxis[axis.pane][axis.name] = true
                    }
                });
                _this._correctValueAxes();
                $.each(paneAxis, function(paneName, pane) {
                    hideGridsOnNonFirstValueAxisForPane(paneName);
                    $.each(pane, function(axisName, _) {
                        var seriesForRange = [],
                            valueAxesForRange = [],
                            argumentAxesForRange = [],
                            valRange = new charts.Range({
                                pane: paneName,
                                axis: axisName,
                                minValueMarginX: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                                maxValueMarginX: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                                minValueMarginY: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                                maxValueMarginY: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN
                            }),
                            valueType;
                        $.each(series, function(_, particularSeries) {
                            if (particularSeries.pane === paneName && particularSeries.axis === axisName)
                                seriesForRange.push(particularSeries)
                        });
                        $.each(argAxes, function(_, axis) {
                            argumentAxesForRange.push(axis)
                        });
                        $.each(valAxes, function(_, axis) {
                            if (axis.pane === paneName && axis.name === axisName)
                                valueAxesForRange.push(axis)
                        });
                        $.each(argumentAxesForRange, function(_, axis) {
                            axis.options.type = seriesForRange && seriesForRange.length ? seriesForRange[0].options.argumentAxisType : null;
                            argRange = argRange[argumentBoundRange](axis.getRangeData());
                            argumentTickInterval = axis.options.tickInterval;
                            setTicksAtUnitBeginning = axis.options.setTicksAtUnitBeginning
                        });
                        $.each(valueAxesForRange, function(_, axis) {
                            axis.options.type = seriesForRange && seriesForRange.length ? seriesForRange[0].options.valueAxisType : null;
                            var axisRange = new charts.Range(axis.getRangeData());
                            axisRange.applyEqualLimitsMargins();
                            valueType = valueType || axis.options.valueType === 'datetime' ? 'datetime' : undefined;
                            valRange = valRange[valueBoundRange](axisRange)
                        });
                        for (i = 0; i < seriesForRange.length; i++) {
                            singleSeriesRange = seriesForRange[i].getRangeData(visibleArea);
                            valRange = valRange[valueBoundRange](singleSeriesRange);
                            argRange = argRange[argumentBoundRange](singleSeriesRange)
                        }
                        if (!valRange['isDefined' + valueField]())
                            valRange['setStubData' + valueField](valueType);
                        businessRanges.push(valRange)
                    })
                });
                if (!argRange['isDefined' + argumentField]())
                    argRange['setStubData' + argumentField](argAxes[0].options.argumentType);
                var bussinesRangeCorrectedWithTickInterval = _this._correctBusinessRange(argRange, argumentTickInterval, argumentField, setTicksAtUnitBeginning);
                $.each(businessRanges, function(_, range) {
                    range = range.getBoundRange(argRange);
                    !bussinesRangeCorrectedWithTickInterval && range.applyValueMargins();
                    range['stubData' + argumentField] = argRange['stubData' + argumentField];
                    if (!range.isDefined())
                        range.setStubData()
                });
                _this.businessRanges = businessRanges
            },
            _createPanes: function() {
                var _this = this,
                    panes = _this.option('panes'),
                    bottomPaneName;
                $.each(_this.panesClipRects || [], function(i, clipRect) {
                    clipRect.remove()
                });
                _this.panesClipRects = [];
                _this.defaultPane = _this.option('defaultPane');
                panes = $.isArray(panes) ? panes : panes ? [panes] : [];
                if (!_this._doesPaneExists(panes, _this.defaultPane) && panes.length > 0) {
                    bottomPaneName = panes[panes.length - 1].name;
                    _this.option('incidentOccured')('Pane "' + _this.defaultPane + '" does not exist. Use pane "' + bottomPaneName + '" instead');
                    _this.defaultPane = bottomPaneName
                }
                if (_this.option('rotated'))
                    panes = panes.reverse();
                return panes
            },
            _doesPaneExists: function(panes, paneName) {
                var found = false;
                $.each(panes, function(_, pane) {
                    if (pane.name === paneName) {
                        found = true;
                        return false
                    }
                });
                return found
            },
            _populateSeries: function() {
                var _this = this,
                    hasSeriesTemplate = !!_this.option('seriesTemplate'),
                    series = hasSeriesTemplate ? _this._templatedSeries : _this.option('series'),
                    allSeriesOptions = $.isArray(series) ? series : series ? [series] : [],
                    argumentAxisOptions = _this.option('argumentAxis'),
                    valueAxisOptions = _this.option('valueAxis'),
                    themeManager = _this.themeManager,
                    data,
                    particularSeriesOptions,
                    commonSeriesSettings = _this.option('commonSeriesSettings'),
                    userCommonSeriesSettings = _this._userOptions.commonSeriesSettings,
                    particularSeries,
                    rotated = _this.option('rotated'),
                    incidentOccured = _this.option('incidentOccured'),
                    i,
                    paneList = $.map(_this.panes, function(pane) {
                        return pane.name
                    }),
                    paneName,
                    paneIndex;
                $.each(_this._paneTrackerGroups || [], function(_, groups) {
                    groups.paneSeriesGroup.remove();
                    groups.paneMarkerGroup.remove()
                });
                _this._paneTrackerGroups = [];
                $.each(_this.panes, function(_, pane) {
                    var paneSeriesTrackerGroup = _this.renderer.createGroup({'class': 'dxc-pane-tracker'}),
                        paneMarkerTrackerGroup = _this.renderer.createGroup({'class': 'dxc-pane-tracker'});
                    _this._paneTrackerGroups.push({
                        paneSeriesGroup: paneSeriesTrackerGroup,
                        paneMarkerGroup: paneMarkerTrackerGroup
                    })
                });
                _this._disposeSeries();
                _this.series = [];
                themeManager.resetPalette();
                commonSeriesSettings.containerBackgroundColor = _this.option('containerBackgroundColor');
                for (i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = allSeriesOptions[i];
                    if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                        particularSeriesOptions.type = '';
                    data = particularSeriesOptions.data;
                    particularSeriesOptions.data = null;
                    particularSeriesOptions.rotated = rotated;
                    if (argumentAxisOptions) {
                        particularSeriesOptions.argumentCategories = argumentAxisOptions.categories;
                        particularSeriesOptions.argumentAxisType = argumentAxisOptions.type;
                        particularSeriesOptions.argumentType = argumentAxisOptions.argumentType
                    }
                    if (valueAxisOptions)
                        if (utils.isArray(valueAxisOptions))
                            $.each(valueAxisOptions, function(iter, options) {
                                if (!particularSeriesOptions.axis && !iter || particularSeriesOptions.axis === options.name) {
                                    particularSeriesOptions.valueCategories = options.categories;
                                    particularSeriesOptions.valueAxisType = options.type;
                                    particularSeriesOptions.valueType = options.valueType
                                }
                            });
                        else {
                            particularSeriesOptions.valueCategories = valueAxisOptions.categories;
                            particularSeriesOptions.valueAxisType = valueAxisOptions.type;
                            particularSeriesOptions.valueType = valueAxisOptions.valueType
                        }
                    particularSeriesOptions.incidentOccured = incidentOccured;
                    if (!particularSeriesOptions.name)
                        particularSeriesOptions.name = 'Series ' + (i + 1).toString();
                    var seriesTheme = themeManager.applyNextSeriesTheme(particularSeriesOptions, commonSeriesSettings, userCommonSeriesSettings);
                    seriesTheme.pane = seriesTheme.pane || _this.defaultPane;
                    paneName = seriesTheme.pane;
                    paneIndex = _this._getPaneIndex(paneName);
                    if ($.inArray(paneName, paneList) === -1)
                        continue;
                    seriesTheme.seriesGroup = _this._seriesGroup;
                    seriesTheme.seriesLabelsGroup = _this._labelsGroup;
                    seriesTheme.seriesTrackerGroup = _this._paneTrackerGroups[paneIndex].paneSeriesGroup;
                    seriesTheme.markerTrackerGroup = _this._paneTrackerGroups[paneIndex].paneMarkerGroup;
                    particularSeries = charts.factory.createSeries(seriesTheme.type, _this.renderer, data, seriesTheme);
                    if (!particularSeries)
                        incidentOccured.call(null, 'Unknown series type requested: ' + seriesTheme.type);
                    else {
                        particularSeries.index = i;
                        _this.series.push(particularSeries)
                    }
                    particularSeriesOptions.data = data
                }
                return _this.series
            },
            _createValueAxis: function(axisOptions, rotated, tickProvider) {
                var _this = this,
                    axis;
                axisOptions = $.extend({
                    isHorizontal: rotated,
                    tickProvider: tickProvider,
                    incidentOccured: _this.option('incidentOccured')
                }, axisOptions);
                axisOptions = $.extend(true, {}, _this.option('commonAxisSettings'), _this.option(rotated ? 'horizontalAxis' : 'verticalAxis'), _this.option('valueAxisStyle'), _this.option('userCommonAxisSettings'), _this.option('valueAxis'), axisOptions);
                if (axisOptions.strips)
                    $.each(axisOptions.strips, function(i, strips) {
                        axisOptions.strips[i] = $.extend(true, {}, axisOptions.stripStyle, axisOptions.strips[i])
                    });
                axis = charts.factory.createAxis(_this.renderer, axisOptions);
                axis.name = axisOptions.name;
                axis.pane = axis.pane || axisOptions.pane;
                axis.priority = axisOptions.priority;
                return axis
            },
            _disposeAxes: function() {
                var _this = this;
                $.each(_this.horizontalAxes || [], function(_, axis) {
                    axis.dispose()
                });
                $.each(_this.verticalAxes || [], function(_, axis) {
                    axis.dispose()
                });
                _this.horizontalAxes = null;
                _this.verticalAxes = null
            },
            _populateAxes: function() {
                var _this = this,
                    horizontalAxes = [],
                    verticalAxes = [],
                    panes = _this.panes,
                    rotated = _this.option('rotated'),
                    themeManager = _this.themeManager,
                    valueAxisOptions = _this.option('valueAxis') || {},
                    argumentOption = _this.option('argumentAxis') || {},
                    argumentAxesOptions = $.isArray(argumentOption) ? argumentOption : [argumentOption],
                    valueAxesOptions = $.isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                    i,
                    axis,
                    axisNames = [],
                    axisOptions,
                    tickProvider = charts.factory.getAxisTickProvider(),
                    paneWithNonVirtualAxis;
                _this._disposeAxes();
                var createArgumentAxis = function(axisOptions, virtual) {
                        axisOptions = $.extend(true, {
                            isHorizontal: !rotated,
                            tickProvider: tickProvider,
                            pane: _this.defaultPane,
                            incidentOccured: _this.option('incidentOccured')
                        }, axisOptions);
                        axisOptions = $.extend(true, {}, _this.option('commonAxisSettings'), _this.option(rotated ? 'verticalAxis' : 'horizontalAxis'), _this.option('argumentAxisStyle'), _this.option('userCommonAxisSettings'), _this.option('argumentAxis'), axisOptions);
                        if (axisOptions.strips)
                            $.each(axisOptions.strips, function(i, strips) {
                                axisOptions.strips[i] = $.extend(true, {}, axisOptions.stripStyle, axisOptions.strips[i])
                            });
                        axis = charts.factory.createAxis(_this.renderer, axisOptions);
                        axis._virtual = virtual;
                        if (axisOptions.isHorizontal)
                            horizontalAxes.push(axis);
                        else
                            verticalAxes.push(axis)
                    };
                if (rotated)
                    paneWithNonVirtualAxis = argumentAxesOptions[0].position === 'right' ? panes[panes.length - 1].name : panes[0].name;
                else
                    paneWithNonVirtualAxis = argumentAxesOptions[0].position === 'top' ? panes[0].name : panes[panes.length - 1].name;
                $.each(panes, function(_, pane) {
                    var paneName = pane.name,
                        virtual = paneName != paneWithNonVirtualAxis;
                    var axisOptions = $.extend(true, {}, {pane: paneName}, argumentAxesOptions[0]);
                    createArgumentAxis(axisOptions, virtual)
                });
                var createValueAxis = function(axisOptions) {
                        var axis = _this._createValueAxis(axisOptions, rotated, tickProvider);
                        if (rotated)
                            horizontalAxes.push(axis);
                        else
                            verticalAxes.push(axis)
                    };
                var valueAxesCounter = 0;
                var getNextAxisName = function() {
                        return DEFAULT_AXIS_NAME + valueAxesCounter++
                    };
                var unique = function(array) {
                        var values = {},
                            i,
                            len = array.length;
                        for (i = 0; i < len; i++)
                            values[array[i]] = true;
                        return $.map(values, function(_, key) {
                                return key
                            })
                    };
                $.each(valueAxesOptions, function(priority, axisOptions) {
                    var axisPanes = [],
                        name = axisOptions.name;
                    if (name && $.inArray(name, axisNames) != -1) {
                        _this.option('incidentOccured').call(null, 'The valueAxis configuration array contains axes with the same name.');
                        return
                    }
                    name && axisNames.push(name);
                    if (axisOptions.pane)
                        axisPanes.push(axisOptions.pane);
                    if (axisOptions.panes && axisOptions.panes.length)
                        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
                    axisPanes = unique(axisPanes);
                    if (!axisPanes.length)
                        axisPanes.push(undefined);
                    $.each(axisPanes, function(_, pane) {
                        createValueAxis($.extend(true, {}, axisOptions, {
                            name: name || getNextAxisName(),
                            pane: pane,
                            priority: priority
                        }))
                    })
                });
                _this.horizontalAxes = horizontalAxes;
                _this.verticalAxes = verticalAxes
            },
            _correctValueAxes: function() {
                var _this = this,
                    rotated = _this.option('rotated'),
                    themeManager = _this.themeManager,
                    valueAxisOptions = _this.option('valueAxis') || {},
                    valueAxesOptions = $.isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                    tickProvider = charts.factory.getAxisTickProvider(),
                    valueAxes = (rotated ? _this.horizontalAxes : _this.verticalAxes) || [],
                    defaultAxisName = valueAxes[0].name,
                    paneAxis = _this.paneAxis || {},
                    panes = _this.panes,
                    i,
                    neededAxis = {};
                var getPaneForAxis = function(axisNameWithoutPane) {
                        var result;
                        $.each(_this.paneAxis, function(paneName, pane) {
                            $.each(pane, function(axisName, _) {
                                if (axisNameWithoutPane == axisName) {
                                    result = paneName;
                                    return false
                                }
                            })
                        });
                        return result
                    };
                var axesWithoutPanes = $.map(valueAxes, function(axis) {
                        if (axis.pane)
                            return null;
                        return axis
                    });
                $.each(axesWithoutPanes, function(_, axis) {
                    axis.pane = getPaneForAxis(axis.name);
                    if (!axis.pane) {
                        axis.pane = _this.defaultPane;
                        paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                        paneAxis[axis.pane][axis.name] = true
                    }
                    axis.options.pane = axis.pane
                });
                for (i = 0; i < panes.length; i++)
                    if (!paneAxis[panes[i].name]) {
                        paneAxis[panes[i].name] = {};
                        paneAxis[panes[i].name][defaultAxisName] = true
                    }
                var findAxisOptions = function(axisName) {
                        var result,
                            axInd;
                        for (axInd = 0; axInd < valueAxesOptions.length; axInd++)
                            if (valueAxesOptions[axInd].name == axisName) {
                                result = valueAxisOptions[axInd];
                                result.priority = axInd;
                                break
                            }
                        if (!result)
                            for (axInd = 0; axInd < valueAxes.length; axInd++)
                                if (valueAxes[axInd].name == axisName) {
                                    result = valueAxes[axInd].options;
                                    result.priority = valueAxes[axInd].priority;
                                    break
                                }
                        if (!result) {
                            _this.option('incidentOccured').call(null, 'Value axis with name "' + axisName + '" does not exist. It was created.');
                            result = {
                                name: axisName,
                                priority: valueAxes.length
                            }
                        }
                        return result
                    };
                var findAxis = function(paneName, axisName) {
                        var axis;
                        for (i = 0; i < valueAxes.length; i++) {
                            axis = valueAxes[i];
                            if (axis.name === axisName && axis.pane === paneName)
                                return axis
                        }
                    };
                $.each(_this.paneAxis, function(paneName, axisNames) {
                    $.each(axisNames, function(axisName, _) {
                        neededAxis[axisName + '-' + paneName] = true;
                        if (!findAxis(paneName, axisName)) {
                            var axisOptions = findAxisOptions(axisName);
                            if (axisOptions)
                                valueAxes.push(_this._createValueAxis($.extend(true, {}, axisOptions, {
                                    pane: paneName,
                                    name: axisName
                                }), rotated, tickProvider))
                        }
                    })
                });
                valueAxes = $.grep(valueAxes, function(elem) {
                    return !!neededAxis[elem.name + '-' + elem.pane]
                });
                valueAxes.sort(function(a, b) {
                    return a.priority - b.priority
                });
                rotated ? _this.horizontalAxes = valueAxes : _this.verticalAxes = valueAxes
            },
            _processSeriesFamilies: function() {
                var _this = this,
                    types = [],
                    families = [],
                    paneSeries,
                    rotated = _this.option('rotated');
                if (_this.seriesFamilies && _this.seriesFamilies.length)
                    return;
                $.each(_this.series, function(_, item) {
                    if ($.inArray(item.type, types) === -1)
                        types.push(item.type)
                });
                $.each(_this.panes, function(_, pane) {
                    paneSeries = [];
                    $.each(_this.series, function(_, oneSeries) {
                        if (oneSeries.pane === pane.name)
                            paneSeries.push(oneSeries)
                    });
                    $.each(types, function(_, type) {
                        var family = charts.factory.createSeriesFamily({
                                type: type,
                                pane: pane.name,
                                rotated: rotated,
                                equalBarWidth: _this.option('equalBarWidth')
                            });
                        family.add(paneSeries);
                        family.adjustSeriesValues();
                        families.push(family)
                    })
                });
                _this.seriesFamilies = families
            },
            _createLegend: function() {
                var _this = this,
                    legendOptions = $.extend(true, {
                        renderer: _this.renderer,
                        series: _this.series,
                        containerBackgroundColor: _this.option('commonSeriesSettings').containerBackgroundColor
                    }, _this.option('legend'));
                if (_this.legend)
                    _this.legend.update(legendOptions);
                else
                    _this.legend = charts.factory.createLegend(legendOptions, _this._legendGroup, _this._legendTrackerGroup)
            },
            _createTranslator: function(range, canvas) {
                return new DX.viz.core.LinearTranslator(range, canvas)
            },
            _createPanesBorderOptions: function() {
                var commonBorderOptions = this.option('commonPaneSettings').border,
                    panesBorderOptions = {};
                $.each(this.panes, function(_, pane) {
                    var borderOptions = $.extend(true, {}, commonBorderOptions, pane.border);
                    panesBorderOptions[pane.name] = borderOptions
                });
                return panesBorderOptions
            },
            _render: function(drawOptions) {
                var _this = this,
                    renderer = _this.renderer,
                    translators = _this.translators,
                    rotated = _this.option('rotated'),
                    i,
                    layoutManager = _this.layoutManager,
                    titleOptions = _this.option('title'),
                    adjustmentCounter = 0,
                    paneName,
                    multiAxesSynchronizer = new charts.MultiAxesSynchronizer,
                    panesBorderOptions = _this._createPanesBorderOptions();
                var updateAxesPerPane = function(_this, axes) {
                        var translator,
                            axis,
                            axisName;
                        for (i = 0; i < axes.length; i++) {
                            axis = axes[i];
                            paneName = axis.pane;
                            axisName = axis.name;
                            translator = _this._getTranslator(paneName, axisName);
                            if (translator) {
                                translator.init();
                                axis.setRange(translator.getBusinessRange());
                                axis.setTranslator(translator)
                            }
                        }
                    };
                var drawSeries = function drawSeries() {
                        var particularSeries;
                        $.each(_this.seriesFamilies || [], function(_, seriesFamily) {
                            var translator = _this._getTranslator(seriesFamily.pane);
                            seriesFamily.updateSeriesValues(translator);
                            seriesFamily.adjustSeriesDimensions(translator)
                        });
                        for (i = 0; i < _this.series.length; i++) {
                            particularSeries = _this.series[i];
                            particularSeries.elementsClipRectID = _this._getElementsClipRectID(_this.series[i].pane);
                            particularSeries.markersClipRectID = _this._getMarkersClipRectID(_this.series[i].pane);
                            particularSeries.adjustSeriesLabels = drawOptions.adjustSeriesLabels;
                            particularSeries.draw(_this._getTranslator(particularSeries.pane, particularSeries.axis));
                            if (drawOptions.animate && particularSeries.getPoints().length <= drawOptions.animationPointsLimit)
                                particularSeries.animate()
                        }
                        if (drawOptions.drawLegend && _this.legend && _this.legend.options.position === 'inside') {
                            _this.legend.canvas = _this.canvas;
                            _this._legendGroup.append();
                            _this._tooltipGroup.append();
                            _this.legend.draw();
                            layoutManager.applyLegendLayout()
                        }
                        else
                            _this.legend.options.position == 'inside' && _this.legend.toForeground();
                        _this.option('drawn')();
                        var drawChartTrackers = function drawChartTrackers() {
                                $.each(_this._paneTrackerGroups || [], function(_, groups) {
                                    groups.paneSeriesGroup.clear();
                                    groups.paneMarkerGroup.clear()
                                });
                                for (i = 0; i < _this.series.length; i++)
                                    _this.series[i].drawTrackers();
                                _this.legend && _this.legend.drawTrackers();
                                _this.tracker._prepare();
                                $.each(_this._paneTrackerGroups, function(index, paneGroups) {
                                    var borderVisible = _this._getPaneBorderVisibility(index),
                                        clipId = _this.panesClipRects[index].id;
                                    paneGroups.paneSeriesGroup.applySettings({clipId: clipId});
                                    if (borderVisible)
                                        paneGroups.paneMarkerGroup.applySettings({clipId: clipId});
                                    paneGroups.paneSeriesGroup.append(_this._seriesTrackerGroup);
                                    paneGroups.paneMarkerGroup.append(_this._markerTrackerGroup)
                                });
                                _this._trackerGroup.append();
                                _this._handleRenderComplete()
                            };
                        _this._createTooltip();
                        if (drawOptions.asyncTrackersRendering)
                            _this.delayedRedraw = setTimeout(drawChartTrackers, drawOptions.trackerRenderingDelay);
                        else
                            drawChartTrackers()
                    };
                drawOptions = _this._prepareDrawOptions(drawOptions);
                _this.callBase(drawOptions);
                if (_this.stopRedraw) {
                    _this.stopRedraw = false;
                    return
                }
                _this._createPanesBackground();
                if (titleOptions.text && drawOptions.drawTitle) {
                    _this._titleGroup.append();
                    _this._drawTitle();
                    layoutManager.applyTitleLayout()
                }
                if (drawOptions.drawLegend && _this.legend && _this.legend.options.position === 'outside') {
                    _this.legend.canvas = _this.canvas;
                    _this._legendGroup.append();
                    _this.legend.draw();
                    layoutManager.applyLegendLayout();
                    if (layoutManager.isCanvasExceeded(false)) {
                        _this.option('incidentOccured')('Container is too small to draw chart with current settings');
                        _this._clean();
                        return
                    }
                }
                _this._setPanesClipRectPadding(panesBorderOptions, rotated);
                if (drawOptions.recreateCanvas) {
                    layoutManager.createPanesCanvases();
                    $.each(_this.paneAxis, function(paneName, pane) {
                        $.each(pane, function(axisName, _) {
                            var translator = _this._createTranslator(new charts.Range(_this._getBusinessRange(paneName, axisName)), _this._getCanvasForPane(paneName));
                            translator.pane = paneName;
                            translator.axis = axisName;
                            translators.push(translator)
                        })
                    })
                }
                else
                    $.each(translators, function(_, translator) {
                        translator.updateBusinessRange(new charts.Range(_this._getBusinessRange(translator.pane, translator.axis)));
                        translator.init()
                    });
                updateAxesPerPane(_this, _this.horizontalAxes);
                updateAxesPerPane(_this, _this.verticalAxes);
                _this._stripsGroup.append();
                _this._axesGroup.append();
                do {
                    for (i = 0; i < _this.horizontalAxes.length; i++)
                        _this.horizontalAxes[i].resetTicks();
                    for (i = 0; i < _this.verticalAxes.length; i++)
                        _this.verticalAxes[i].resetTicks();
                    if (_this.option('synchronizeMultiAxes'))
                        multiAxesSynchronizer.synchronize(rotated ? _this.horizontalAxes : _this.verticalAxes, rotated);
                    for (i = 0; i < _this.horizontalAxes.length; i++) {
                        _this.horizontalAxes[i].clipRectID = _this._getCanvasClipRectID();
                        _this.horizontalAxes[i].stripsGroup = _this._stripsGroup;
                        _this.horizontalAxes[i].axesContainerGroup = _this._axesGroup;
                        _this.horizontalAxes[i].draw({borderOptions: panesBorderOptions[_this.horizontalAxes[i].pane]})
                    }
                    layoutManager.requireAxesRedraw = false;
                    if (drawOptions.adjustAxes) {
                        layoutManager.applyHorizontalAxesLayout();
                        $.each(translators, function(_, translator) {
                            translator.init()
                        })
                    }
                    for (i = 0; i < _this.verticalAxes.length; i++) {
                        _this.verticalAxes[i].clipRectID = _this._getCanvasClipRectID();
                        _this.verticalAxes[i].stripsGroup = _this._stripsGroup;
                        _this.verticalAxes[i].axesContainerGroup = _this._axesGroup;
                        _this.verticalAxes[i].draw({borderOptions: panesBorderOptions[_this.verticalAxes[i].pane]})
                    }
                    if (drawOptions.adjustAxes) {
                        layoutManager.applyVerticalAxesLayout();
                        $.each(translators, function(_, translator) {
                            translator.init()
                        })
                    }
                    adjustmentCounter = adjustmentCounter + 1;
                    if (layoutManager.isCanvasExceeded(true)) {
                        _this.option('incidentOccured')('Container is too small to draw chart with current settings');
                        _this._clean();
                        _this.__axisAdjustmentsCount = adjustmentCounter;
                        return
                    }
                } while (layoutManager.requireAxesRedraw && adjustmentCounter < MAX_ADJUSTMENT_ATTEMPTS);
                _this.__axisAdjustmentsCount = adjustmentCounter;
                if (_this.chartTitle)
                    _this.chartTitle.setClipRectSettings();
                _this._drawPanesBorders(panesBorderOptions);
                _this._createClipRectsForPanes();
                for (i = 0; i < _this.horizontalAxes.length; i++)
                    _this.horizontalAxes[i].applyClipRectForStrips(_this._getElementsClipRectID(_this.horizontalAxes[i].pane));
                for (i = 0; i < _this.verticalAxes.length; i++)
                    _this.verticalAxes[i].applyClipRectForStrips(_this._getElementsClipRectID(_this.verticalAxes[i].pane));
                _this._fillPanesBackground();
                _this._seriesGroup.append();
                _this._labelsGroup.append();
                _this._tooltipGroup.append();
                if (drawOptions.asyncSeriesRendering)
                    _this.delayedRedraw = setTimeout(drawSeries, 25);
                else
                    drawSeries()
            },
            _isInBarTypes: function(type) {
                return type.slice(-3) === 'bar' ? true : false
            },
            _setPanesClipRectPadding: function(panesBorderOptions, rotated) {
                var _this = this,
                    allPanesHaveBorder = true,
                    firstPaneHasBorder = panesBorderOptions[_this.panes[0].name].visible,
                    lastPaneHasBorder = panesBorderOptions[_this.panes[_this.panes.length - 1].name].visible,
                    position = '';
                $.each(_this.panes, function(_, pane) {
                    allPanesHaveBorder = allPanesHaveBorder && !!panesBorderOptions[pane.name].visible
                });
                $.each(_this.horizontalAxes, function(_, axis) {
                    position += axis.options.position
                });
                $.each(_this.verticalAxes, function(_, axis) {
                    position += axis.options.position
                })
            },
            _createPanesBackground: function() {
                var _this = this,
                    defaultBackgroundColor = _this.option('commonPaneSettings').backgroundColor,
                    backgroundColor,
                    renderer = _this.renderer,
                    rect,
                    i,
                    rects = [];
                _this._panesBackgroundGroup && _this._panesBackgroundGroup.clear();
                for (i = 0; i < _this.panes.length; i++) {
                    backgroundColor = _this.panes[i].backgroundColor || defaultBackgroundColor;
                    if (!backgroundColor || backgroundColor === 'none') {
                        rects.push(null);
                        continue
                    }
                    rect = renderer.createRect(0, 0, 0, 0, 0, {
                        fill: backgroundColor,
                        strokeWidth: 0
                    }).append(_this._panesBackgroundGroup);
                    rects.push(rect)
                }
                _this.panesBackground = rects;
                _this._panesBackgroundGroup.append()
            },
            _fillPanesBackground: function() {
                var _this = this,
                    bc;
                $.each(_this.panes, function(i, pane) {
                    bc = pane.borderCoords;
                    if (_this.panesBackground[i] != null)
                        _this.panesBackground[i].applySettings({
                            x: bc.left,
                            y: bc.top,
                            width: bc.width,
                            height: bc.height
                        })
                })
            },
            _calcPaneBorderCoords: function(pane, rotated) {
                var canvas = pane.canvas,
                    bc = pane.borderCoords = pane.borderCoords || {};
                bc.left = canvas.left;
                bc.top = canvas.top;
                bc.right = canvas.width - canvas.right;
                bc.bottom = canvas.height - canvas.bottom;
                bc.width = bc.right - bc.left;
                bc.height = bc.bottom - bc.top
            },
            _drawPanesBorders: function(panesBorderOptions) {
                var _this = this,
                    rotated = _this.option('rotated');
                _this._panesBorderGroup && (_this._panesBorderGroup.detach(), _this._panesBorderGroup.clear());
                $.each(_this.panes, function(i, pane) {
                    var bc,
                        borderOptions = panesBorderOptions[pane.name],
                        attr = {
                            fill: 'none',
                            stroke: borderOptions.color,
                            strokeOpacity: borderOptions.opacity,
                            strokeWidth: borderOptions.width,
                            dashStyle: borderOptions.dashStyle
                        };
                    _this._calcPaneBorderCoords(pane, rotated);
                    if (!borderOptions.visible)
                        return;
                    bc = pane.borderCoords;
                    _this.renderer.createSegmentRect(bc.left, bc.top, bc.width, bc.height, 0, borderOptions, attr).append(_this._panesBorderGroup)
                });
                _this._panesBorderGroup.append()
            },
            _createClipRectsForPanes: function() {
                var _this = this;
                $.each(_this.panes, function(i, pane) {
                    var bc = pane.borderCoords,
                        clipRect = _this.panesClipRects[i];
                    if (!clipRect) {
                        clipRect = _this.renderer.createClipRect(bc.left, bc.top, bc.width, bc.height).append();
                        _this.panesClipRects.push(clipRect)
                    }
                    else
                        clipRect.updateRectangle({
                            x: bc.left,
                            y: bc.top,
                            width: bc.width,
                            height: bc.height
                        })
                })
            },
            _getPaneIndex: function(paneName) {
                var paneIndex;
                $.each(this.panes, function(index, pane) {
                    if (pane.name === paneName) {
                        paneIndex = index;
                        return false
                    }
                });
                return paneIndex
            },
            _getPaneBorderVisibility: function(paneIndex) {
                var commonPaneBorderVisible = this.option('commonPaneSettings').border.visible,
                    pane = this.panes[paneIndex] || {},
                    paneBorder = pane.border || {};
                return 'visible' in paneBorder ? paneBorder.visible : commonPaneBorderVisible
            },
            _getElementsClipRectID: function(paneName) {
                return this.panesClipRects[this._getPaneIndex(paneName)].id
            },
            _getMarkersClipRectID: function(paneName) {
                var _this = this,
                    paneIndex = _this._getPaneIndex(paneName),
                    borderVisible = _this._getPaneBorderVisibility(paneIndex);
                if (borderVisible)
                    return _this._getElementsClipRectID(paneName);
                else
                    return undefined
            },
            _getTranslator: function(paneName, axisName) {
                var translators = this.translators,
                    translatorsNumber = translators.length,
                    foundTranslator = null,
                    i;
                for (i = 0; i < translatorsNumber; i++)
                    if (translators[i].pane === paneName && translators[i].axis === axisName) {
                        foundTranslator = translators[i];
                        break
                    }
                if (!foundTranslator)
                    for (i = 0; i < translatorsNumber; i++)
                        if (translators[i].pane === paneName) {
                            foundTranslator = translators[i];
                            break
                        }
                return foundTranslator
            },
            _getCanvasForPane: function(paneName) {
                var panes = this.panes,
                    panesNumber = panes.length,
                    i;
                for (i = 0; i < panesNumber; i++)
                    if (panes[i].name === paneName)
                        return panes[i].canvas
            },
            _getBusinessRange: function(paneName, axisName) {
                var ranges = this.businessRanges || [],
                    rangesNumber = ranges.length,
                    foundRange,
                    i;
                for (i = 0; i < rangesNumber; i++)
                    if (ranges[i].pane === paneName && ranges[i].axis === axisName) {
                        foundRange = ranges[i];
                        break
                    }
                if (!foundRange)
                    for (i = 0; i < rangesNumber; i++)
                        if (ranges[i].pane === paneName) {
                            foundRange = ranges[i];
                            break
                        }
                return foundRange
            },
            _handleSeriesPopulated: function(needRedraw) {
                var _this = this;
                _this._processSeriesFamilies();
                _this._createLegend();
                _this._populateBusinessRange();
                _this._processValueAxisFormat();
                _this._updateTracker();
                needRedraw && _this._render({force: true})
            },
            _processValueAxisFormat: function() {
                var _this = this,
                    valueAxes = _this.option('rotated') ? _this.horizontalAxes : _this.verticalAxes,
                    axesWithFullStackedFormat = [];
                $.each(_this.series, function() {
                    if (this.isFullStackedSeries() && $.inArray(this.axis, axesWithFullStackedFormat) === -1)
                        axesWithFullStackedFormat.push(this.axis)
                });
                $.each(valueAxes, function() {
                    if ($.inArray(this.name, axesWithFullStackedFormat) !== -1)
                        this.setPercentLabelFormat()
                })
            },
            zoomArgument: function(min, max) {
                var _this = this;
                if (_this.option('adjustOnZoom'))
                    _this._populateBusinessRange({
                        minArg: min,
                        maxArg: max
                    });
                $.each(_this.paneAxis, function(paneName, pane) {
                    $.each(pane, function(axisName, _) {
                        var translator = _this._getTranslator(paneName, axisName);
                        var range = _this._getBusinessRange(paneName, axisName);
                        translator.updateBusinessRange(range);
                        if (min || max) {
                            if (_this._options.rotated)
                                translator.zoomY(min, max);
                            else
                                translator.zoomX(min, max);
                            translator.init()
                        }
                    })
                });
                _this._render({
                    force: true,
                    drawTitle: false,
                    drawLegend: false,
                    adjustAxes: false,
                    animate: false,
                    adjustSeriesLabels: false,
                    asyncSeriesRendering: false
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file pieChart.js */
    (function($, DX, undefined) {
        var charts = DX.viz.charts,
            utils = DX.utils,
            PANE_CLIP_RECT_PADDING = 12;
        charts.PieChart = charts.BaseChart.inherit({
            _defaultOptions: function() {
                return $.extend(true, this.callBase(), {
                        commonSeriesSettings: {
                            type: 'pie',
                            pie: {label: {percentPrecision: 0}}
                        },
                        legend: {hoverMode: 'markPoint'}
                    })
            },
            _reinit: function(needRedraw) {
                var _this = this;
                _this.callBase();
                if (!_this.series)
                    _this._dataSpecificInit();
                needRedraw && _this._render({force: true})
            },
            _populateBusinessRange: function() {
                var businessRanges = [],
                    series = this.series,
                    singleSeries = series[0],
                    range,
                    singleSeriesRange;
                this._disposeObjectsInArray("businessRanges");
                if (singleSeries) {
                    range = new charts.Range({series: singleSeries});
                    singleSeriesRange = singleSeries.getRangeData();
                    range = range.getBoundRange(singleSeriesRange);
                    if (!range.isDefined())
                        range.setStubData();
                    businessRanges.push(range)
                }
                this.businessRanges = businessRanges
            },
            _createTranslator: function(range, canvas) {
                return new DevExpress.viz.core.Translator1D(range.minY, range.maxY, 360 - 0.0001, 0)
            },
            _populateSeries: function() {
                var _this = this,
                    renderer = _this.renderer,
                    hasSeriesTemplate = !!_this.option('seriesTemplate'),
                    seriesOptions = hasSeriesTemplate ? _this._templatedSeries : _this.option('series'),
                    allSeriesOptions = $.isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [],
                    themeManager = _this.themeManager,
                    data,
                    particularSeriesOptions,
                    particularSeries,
                    seriesTheme,
                    seriesType,
                    commonSeriesSettings = _this.option('commonSeriesSettings'),
                    userCommonSeriesSettings = _this._userOptions.commonSeriesSettings,
                    incidentOccured = _this.option('incidentOccured');
                _this._disposeSeries();
                _this.series = [];
                themeManager.resetPalette();
                if (allSeriesOptions.length) {
                    particularSeriesOptions = allSeriesOptions[0];
                    if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                        particularSeriesOptions.type = '';
                    data = particularSeriesOptions.data;
                    particularSeriesOptions.data = null;
                    particularSeriesOptions.incidentOccured = incidentOccured;
                    seriesTheme = themeManager.applyPieSeriesTheme(particularSeriesOptions, commonSeriesSettings, userCommonSeriesSettings);
                    seriesTheme.seriesGroup = _this._seriesGroup;
                    seriesTheme.trackerGroup = _this._trackerGroup;
                    seriesTheme.seriesLabelsGroup = _this._labelsGroup;
                    seriesTheme.seriesTrackerGroup = _this._seriesTrackerGroup;
                    seriesTheme.markerTrackerGroup = _this._markerTrackerGroup;
                    seriesType = seriesTheme.type !== undefined ? seriesTheme.type : _this.option('commonSeriesSettings').type;
                    particularSeries = charts.factory.createSeries(seriesType, renderer, data, seriesTheme);
                    if (!particularSeries)
                        incidentOccured.call(null, 'Unknown series type requested: ' + seriesType);
                    else {
                        _this._processSingleSeries(particularSeries, particularSeries.userOptions);
                        _this.series.push(particularSeries)
                    }
                    particularSeriesOptions.data = data
                }
                return _this.series
            },
            _processSingleSeries: function(singleSeries, options) {
                var _this = this,
                    commonSeriesSettings = _this.option('commonSeriesSettings'),
                    points,
                    seriesGroup = options.seriesGroup,
                    trackerGroup = options.trackerGroup,
                    seriesTrackerGroup = options.seriesTrackerGroup,
                    markerTrackerGroup = options.markerTrackerGroup,
                    seriesLabelsGroup = options.seriesLabelsGroup;
                singleSeries.arrangePoints();
                points = singleSeries && singleSeries.getPoints() || [];
                options.seriesGroup = null;
                options.trackerGroup = null;
                options.seriesTrackerGroup = null;
                options.markerTrackerGroup = null;
                options.seriesLabelsGroup = null;
                for (var j = 0; j < points.length; j++) {
                    var theme = _this.themeManager.applyNextPieSegmentTheme(options, commonSeriesSettings);
                    var convertedTheme = singleSeries.parseStyleOptions(theme);
                    points[j].setOptions(convertedTheme.point);
                    points[j].index = j
                }
                options.seriesGroup = seriesGroup;
                options.trackerGroup = trackerGroup;
                options.seriesTrackerGroup = seriesTrackerGroup;
                options.markerTrackerGroup = markerTrackerGroup;
                options.seriesLabelsGroup = seriesLabelsGroup
            },
            _handleSeriesPopulated: function(needRedraw) {
                var _this = this;
                _this._populateBusinessRange();
                _this._createLegend();
                _this._updateTracker();
                needRedraw && _this._render({
                    force: true,
                    recreateCanvas: true
                })
            },
            _createLegend: function() {
                var _this = this,
                    legendOptions = $.extend(true, {
                        renderer: _this.renderer,
                        series: $.map(_this.series[0] ? _this.series[0].getPoints() : [], function(item) {
                            item.name = item.argument;
                            item.options.showInLegend = true,
                            item.styles = {themeColor: item.options.attributes.fill};
                            return item
                        })
                    }, _this.option('legend'));
                if (legendOptions.position !== 'outside')
                    legendOptions.position = 'outside';
                _this.legend = charts.factory.createLegend(legendOptions, _this._legendGroup, _this._legendTrackerGroup)
            },
            _setPaddings: function(side) {
                var _this = this,
                    originalSide = 'original' + side,
                    sideLowCase = side.toLowerCase(),
                    delta = PANE_CLIP_RECT_PADDING - _this.canvas[sideLowCase];
                if (delta > 0) {
                    _this.canvas[originalSide] += delta;
                    _this.canvas[sideLowCase] += delta
                }
            },
            _render: function(drawOptions) {
                var _this = this,
                    titleOptions = _this.option('title'),
                    layoutManager = _this.layoutManager;
                drawOptions = _this._prepareDrawOptions(drawOptions);
                _this.callBase(drawOptions);
                if (_this.stopRedraw) {
                    _this.stopRedraw = false;
                    return
                }
                if (titleOptions.text && drawOptions.drawTitle) {
                    _this._titleGroup.append();
                    _this._drawTitle();
                    layoutManager.applyTitleLayout()
                }
                if (drawOptions.drawLegend && _this.legend) {
                    _this.legend.canvas = _this.canvas;
                    _this._legendGroup.append();
                    _this.legend.draw();
                    layoutManager.applyLegendLayout()
                }
                if (layoutManager.isCanvasExceeded(false)) {
                    _this.option('incidentOccured')('Container is too small to draw chart with current settings');
                    _this._clean();
                    return
                }
                if (_this.chartTitle)
                    _this.chartTitle.setClipRectSettings();
                _this._setPaddings('Bottom');
                _this._setPaddings('Top');
                _this._setPaddings('Left');
                _this._setPaddings('Right');
                if (_this.series && _this.series[0]) {
                    if (!layoutManager.applyPieChartSeriesLayout()) {
                        _this.option('incidentOccured')('Container is too small to draw chart with current settings');
                        _this._clean();
                        return
                    }
                    _this._seriesGroup.append();
                    _this._labelsGroup.append();
                    _this.series[0].canvas = _this.canvas;
                    _this.series[0].draw(_this._createTranslator(_this.businessRanges[0], _this.canvas));
                    if (_this.series[0].redraw) {
                        _this._seriesGroup.detach();
                        _this._trackerGroup.detach();
                        _this._labelsGroup.detach();
                        _this._seriesGroup.clear();
                        _this._labelsGroup.clear();
                        _this._seriesGroup.append();
                        _this._labelsGroup.append();
                        layoutManager.applyPieChartSeriesLayout();
                        _this.series[0].draw(_this._createTranslator(_this.businessRanges[0], _this.canvas))
                    }
                    _this.series[0].animate();
                    _this._tooltipGroup.append();
                    _this._trackerGroup.append();
                    _this._createTooltip();
                    _this.series[0].drawTrackers();
                    _this.tracker._prepare('pieChart')
                }
                _this._handleRenderComplete()
            },
            getSeries: function getSeries() {
                return this.series && this.series[0]
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file themeManager.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            Palette = viz.core.Palette,
            isArray = DX.utils.isArray;
        var BORDER_COLOR_HIGHLIGHTING = 120,
            HOVER_COLOR_HIGHLIGHTING = 20,
            HOVER_BORDER_COLOR_HIGHLIGHTING = 20,
            POINT_DARKENING = 20,
            POINT_BORDER_DARKENING = 30,
            POINT_HOVER_BORDER_DARKENING = 20,
            HIGHLIGHTING_STEP = 50;
        viz.charts.ThemeManager = viz.core.BaseThemeManager.inherit(function() {
            var ctor = function(options, themeGroupName) {
                    var _this = this;
                    options = options || {};
                    _this.callBase(options.theme, themeGroupName || 'chart');
                    _this.palette = new Palette(options.palette || _this.theme.defaultPalette, HIGHLIGHTING_STEP);
                    _this.init()
                };
            var dispose = function() {
                    this.palette.dispose();
                    this.palette = null;
                    this.callBase()
                };
            var init = function() {
                    var _this = this;
                    _this.theme.legend = _this.theme.legend || {};
                    _this.theme.legend.font = _this.theme.legend.font || {};
                    _this.initializeFont(_this.theme.legend.font);
                    initDefaultSeriesTheme(_this);
                    initAxisTheme(_this);
                    _this.theme.title = _this.theme.title || {};
                    _this.theme.title.font = _this.theme.title.font || {};
                    _this.initializeFont(_this.theme.title.font);
                    _this.theme.tooltip = _this.theme.tooltip || {};
                    _this.theme.tooltip.font = _this.theme.tooltip.font || {};
                    _this.initializeFont(_this.theme.tooltip.font)
                };
            var initDefaultSeriesTheme = function(self) {
                    var theme = self.theme,
                        commonSeriesSettings = theme.commonSeriesSettings,
                        fontOptions = theme.font,
                        pointTheme;
                    commonSeriesSettings.point = commonSeriesSettings.point || {};
                    commonSeriesSettings.containerBackgroundColor = commonSeriesSettings.containerBackgroundColor || theme.containerBackgroundColor;
                    commonSeriesSettings.label = commonSeriesSettings.label || {};
                    self.initializeFont(commonSeriesSettings.label.font)
                };
            var initAxisTheme = function(self) {
                    var theme = self.theme,
                        axisTheme = theme.commonAxisSettings,
                        fontOptions = theme.font,
                        titleTheme,
                        labelTheme;
                    if (axisTheme) {
                        axisTheme.label = axisTheme.label || {};
                        axisTheme.grid = axisTheme.grid || {};
                        axisTheme.ticks = axisTheme.ticks || {};
                        axisTheme.line = axisTheme.line || {};
                        axisTheme.title = axisTheme.title || {};
                        axisTheme.label.font = axisTheme.label.font || {};
                        self.initializeFont(axisTheme.label.font);
                        axisTheme.title.font = axisTheme.title.font || {};
                        self.initializeFont(axisTheme.title.font)
                    }
                };
            var applyChartTheme = function(userOptions) {
                    var self = this,
                        refs = {
                            dataSource: userOptions.dataSource,
                            series: userOptions.series
                        },
                        result;
                    delete userOptions.dataSource;
                    delete userOptions.series;
                    if (userOptions.valueAxis && isArray(userOptions.valueAxis) && !userOptions.valueAxis.length || $.isEmptyObject(userOptions.valueAxis))
                        delete userOptions.valueAxis;
                    if (userOptions.panes && isArray(userOptions.panes) && !userOptions.panes.length || $.isEmptyObject(userOptions.panes))
                        delete userOptions.panes;
                    result = self.applyTheme(self.theme, userOptions);
                    result.dataSource = refs.dataSource;
                    result.series = refs.series;
                    userOptions.series = refs.series;
                    return result
                };
            var applyNextSeriesTheme = function(userOptions, commonSeriesSettings, userCommonSeriesSettings) {
                    var debug = DX.utils.debug;
                    debug.assertParam(userOptions, 'User options were not passed');
                    if (commonSeriesSettings) {
                        debug.assertParam(commonSeriesSettings.hoverStyle, 'hoverStyle option was not passed');
                        debug.assertParam(commonSeriesSettings.selectionStyle, 'selectionStyle option was not passed');
                        debug.assertParam(commonSeriesSettings.point, 'point option was not passed');
                        debug.assertParam(commonSeriesSettings.point.hoverStyle, 'point.hoverStyle option was not passed');
                        debug.assertParam(commonSeriesSettings.point.selectionStyle, 'point.selectionStyle option was not passed')
                    }
                    var self = this,
                        mergedSettings = $.extend(true, {}, commonSeriesSettings || self.theme.commonSeriesSettings),
                        mergedUserSettings = $.extend(true, {}, userCommonSeriesSettings || {}),
                        seriesType = ((userOptions.type || mergedSettings.type || '') + '').toLowerCase(),
                        isAreaOrBar = ~seriesType.indexOf('area') || ~seriesType.indexOf('bar');
                    mergedUserSettings = $.extend(true, mergedUserSettings, mergedUserSettings[seriesType]);
                    mergedSettings = $.extend(true, mergedSettings, mergedSettings[seriesType], mergedUserSettings);
                    userOptions = userOptions || {};
                    var mainColor = new DX.Color(userOptions.color || mergedUserSettings.color || self.palette.getNextColor());
                    mergedSettings.color = mainColor.toHex();
                    mergedSettings.border.color = mergedSettings.border.color || mainColor.toHex();
                    mergedSettings.hoverStyle.color = mergedSettings.hoverStyle.color || isAreaOrBar && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                    mergedSettings.hoverStyle.border.color = mergedSettings.hoverStyle.border.color || mainColor.toHex();
                    mergedSettings.selectionStyle.color = mergedSettings.selectionStyle.color || isAreaOrBar && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                    mergedSettings.selectionStyle.border.color = mergedSettings.selectionStyle.border.color || mainColor.toHex();
                    mergedSettings.point.color = mergedSettings.point.color || mainColor.toHex();
                    mergedSettings.point.border.color = mergedSettings.point.border.color || mainColor.toHex();
                    mergedSettings.point.hoverStyle.color = mergedSettings.point.hoverStyle.color || mergedSettings.containerBackgroundColor;
                    mergedSettings.point.hoverStyle.border.color = mergedSettings.point.hoverStyle.border.color || mainColor.toHex();
                    mergedSettings.point.selectionStyle.color = mergedSettings.point.selectionStyle.color || mergedSettings.containerBackgroundColor;
                    mergedSettings.point.selectionStyle.border.color = mergedSettings.point.selectionStyle.border.color || mainColor.toHex();
                    return self.applyTheme(mergedSettings, userOptions)
                };
            var applyPieSeriesTheme = function applyPieSeriesTheme(userOptions, commonSeriesSettings, userCommonSeriesSettings) {
                    var self = this,
                        commonSettings = commonSeriesSettings || self.theme.commonSeriesSettings || {},
                        seriesType = (userOptions.type || commonSettings.type || '').toLowerCase();
                    if (seriesType && seriesType !== 'pie')
                        commonSettings[seriesType] = $.extend(true, {}, commonSettings[seriesType], commonSettings.pie);
                    userCommonSeriesSettings = userCommonSeriesSettings || {};
                    userOptions = userOptions || {};
                    userOptions = $.extend(true, {}, commonSettings, commonSettings[seriesType], userCommonSeriesSettings, userCommonSeriesSettings[seriesType], userOptions);
                    return userOptions
                };
            var applyNextPieSegmentTheme = function applyNextPieSegmentTheme(userOptions, commonSeriesSettings) {
                    var self = this,
                        commonSettings = commonSeriesSettings || self.theme.commonSeriesSettings || {},
                        mergedSettings = $.extend(true, {}, commonSettings.pie),
                        seriesType = userOptions.type || mergedSettings.type || '';
                    userOptions = userOptions || {};
                    var mainColor = new DX.Color(userOptions.color || self.palette.getNextColor());
                    mergedSettings.color = mainColor.toHex();
                    mergedSettings.border.color = mergedSettings.border.color || mainColor.toHex();
                    mergedSettings.hoverStyle.color = mergedSettings.hoverStyle.color || mainColor.highlight(20);
                    mergedSettings.hoverStyle.border.color = mergedSettings.hoverStyle.border.color || mainColor.toHex();
                    mergedSettings.selectionStyle.color = mergedSettings.selectionStyle.color || mainColor.highlight(20);
                    mergedSettings.selectionStyle.border.color = mergedSettings.selectionStyle.border.color || mainColor.toHex();
                    return self.applyTheme(mergedSettings, userOptions)
                };
            var resetPalette = function() {
                    this.palette.reset()
                };
            var updatePalette = function(palette) {
                    this.palette = new Palette(palette || this.theme.defaultPalette, HIGHLIGHTING_STEP)
                };
            return {
                    ctor: ctor,
                    dispose: dispose,
                    init: init,
                    applyChartTheme: applyChartTheme,
                    applyNextSeriesTheme: applyNextSeriesTheme,
                    applyPieSeriesTheme: applyPieSeriesTheme,
                    applyNextPieSegmentTheme: applyNextPieSegmentTheme,
                    resetPalette: resetPalette,
                    updatePalette: updatePalette
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file layoutManager.js */
    (function($, DX, undefined) {
        var isNumber = DX.utils.isNumber,
            round = Math.round;
        DX.viz.charts.LayoutManager = DX.Class.inherit(function() {
            var update = function(chart) {
                    this.chart = chart;
                    setCanvasValues(chart && chart.canvas)
                };
            var dispose = function() {
                    this.chart = null
                };
            var setCanvasValues = function(canvas) {
                    if (canvas) {
                        canvas.originalTop = canvas.top;
                        canvas.originalBottom = canvas.bottom;
                        canvas.originalLeft = canvas.left;
                        canvas.originalRight = canvas.right
                    }
                };
            var createPanesCanvases = function() {
                    var debug = DX.utils.debug;
                    $.each(this.chart.panes, function(i, item) {
                        debug.assert(item, 'pane is null object');
                        debug.assert(item.name, 'Pane does not have name')
                    });
                    var chart = this.chart,
                        canvas = chart.canvas,
                        panes = chart.panes,
                        pane,
                        i,
                        panesNumber = panes.length,
                        paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
                        paneSpaceWidth = canvas.width - canvas.left - canvas.right,
                        weightSum = 0,
                        oneWeightHeight,
                        oneWeightWidth,
                        padding = panes.padding || 10,
                        distributedTopSpace = 0,
                        distributedLeftSpace = 0;
                    for (i = 0; i < panesNumber; i++) {
                        pane = panes[i];
                        pane.weight = pane.weight || 1;
                        weightSum = weightSum + pane.weight
                    }
                    oneWeightHeight = (paneSpaceHeight - padding * (panesNumber - 1)) / weightSum;
                    oneWeightWidth = (paneSpaceWidth - padding * (panesNumber - 1)) / weightSum;
                    if (!chart.option('rotated'))
                        for (i = 0; i < panesNumber; i++) {
                            pane = panes[i];
                            pane.calcHeight = round(pane.weight * oneWeightHeight);
                            pane.canvas = $.extend({}, canvas);
                            pane.canvas.top = pane.canvas.originalTop = canvas.top + distributedTopSpace;
                            pane.canvas.bottom = pane.canvas.originalBottom = canvas.bottom + (paneSpaceHeight - pane.calcHeight - distributedTopSpace);
                            distributedTopSpace = distributedTopSpace + pane.calcHeight + padding
                        }
                    else
                        for (i = 0; i < panesNumber; i++) {
                            pane = panes[i];
                            pane.calcWidth = round(pane.weight * oneWeightWidth);
                            pane.canvas = $.extend({}, canvas);
                            pane.canvas.left = pane.canvas.originalLeft = canvas.left + distributedLeftSpace;
                            pane.canvas.right = pane.canvas.originalRight = canvas.right + (paneSpaceWidth - pane.calcWidth - distributedLeftSpace);
                            distributedLeftSpace = distributedLeftSpace + pane.calcWidth + padding
                        }
                };
            var applyTitleLayout = function() {
                    var chart = this.chart,
                        canvas = chart.canvas,
                        title = chart.chartTitle,
                        box,
                        horizontalPadding = 15,
                        verticalPadding = 10,
                        shiftX,
                        shiftY;
                    if (!title)
                        return;
                    box = title.getBoundingRect();
                    switch (title.horizontalAlignment) {
                        case'left':
                            shiftX = round(horizontalPadding + canvas.left);
                            break;
                        case'center':
                            shiftX = round((canvas.width - canvas.left - canvas.right - box.width) / 2 + canvas.left) - box.x;
                            break;
                        case'right':
                            shiftX = round(canvas.width - canvas.right - box.x - box.width - horizontalPadding);
                            break
                    }
                    if (title.verticalAlignment === 'top') {
                        shiftY = round(canvas.top - box.y);
                        canvas.top = canvas.top + box.height + verticalPadding
                    }
                    else {
                        shiftY = round(canvas.height - canvas.bottom - box.height - box.y);
                        canvas.bottom = canvas.bottom + box.height + verticalPadding
                    }
                    title.shift(shiftX, shiftY);
                    setCanvasValues(canvas)
                };
            var adjustTitleLayout = function adjustTitleLayout() {
                    var chart = this.chart,
                        canvas = chart.canvas,
                        title = chart.chartTitle,
                        horizontalPadding = 15,
                        box,
                        shiftX,
                        shiftY = title.innerTitleGroup.settings.translateY || 0;
                    title.canvas = canvas;
                    title.correctTitleLength();
                    box = title.getBoundingRect();
                    switch (title.horizontalAlignment) {
                        case'left':
                            shiftX = round(horizontalPadding + canvas.left);
                            break;
                        case'center':
                            shiftX = round((canvas.width - canvas.right - canvas.left - box.width) / 2 + canvas.left - box.x);
                            break;
                        case'right':
                            shiftX = round(canvas.width - canvas.right - box.x - box.width - horizontalPadding);
                            break
                    }
                    title.shift(shiftX, shiftY)
                };
            var applyLegendLayout = function applyLegendLayout() {
                    var _this = this,
                        chart = _this.chart,
                        canvas = chart.canvas,
                        legend = chart.legend,
                        title = chart.chartTitle,
                        panes = chart.panes,
                        options = legend.options,
                        rect = legend.getBoundingRect(),
                        verticalPadding = 10,
                        horizontalPadding = 10,
                        shiftX,
                        shiftY;
                    if (!options.visible)
                        return;
                    if (!isNumber(rect.width) || !isNumber(rect.height))
                        return;
                    if (options.position === 'outside') {
                        switch (options.horizontalAlignment) {
                            case'left':
                                shiftX = round(canvas.left - rect.x + horizontalPadding);
                                canvas.left = canvas.left + rect.width + options.margin + horizontalPadding;
                                if (title)
                                    _this.adjustTitleLayout();
                                break;
                            case'center':
                                shiftX = round((canvas.width - canvas.left - canvas.right - rect.width) / 2 + canvas.left - rect.x);
                                break;
                            case'right':
                                shiftX = round(canvas.width - canvas.right - rect.width - rect.x - horizontalPadding);
                                canvas.right = canvas.right + rect.width + options.margin + horizontalPadding;
                                if (title)
                                    _this.adjustTitleLayout();
                                break
                        }
                        switch (options.verticalAlignment) {
                            case'top':
                                shiftY = round(verticalPadding + canvas.top - rect.y);
                                if (options.horizontalAlignment === 'center')
                                    canvas.top = canvas.top + rect.height + options.margin + verticalPadding;
                                break;
                            case'bottom':
                                shiftY = round(canvas.height - rect.height - canvas.bottom - verticalPadding - rect.y);
                                if (options.horizontalAlignment === 'center')
                                    canvas.bottom = canvas.bottom + rect.height + options.margin + verticalPadding;
                                break
                        }
                        legend.shift(shiftX, shiftY);
                        setCanvasValues(canvas)
                    }
                    else {
                        canvas = $.extend(true, {}, panes[0].canvas);
                        canvas.bottom = panes[panes.length - 1].canvas.bottom;
                        canvas.right = panes[panes.length - 1].canvas.right;
                        switch (options.horizontalAlignment) {
                            case'left':
                                shiftX = round(canvas.left - rect.x + options.margin);
                                break;
                            case'center':
                                shiftX = round((canvas.width - canvas.left - canvas.right - rect.width) / 2 + canvas.left - rect.x);
                                break;
                            case'right':
                                shiftX = round(canvas.width - canvas.right - rect.width - rect.x - options.margin);
                                break
                        }
                        switch (options.verticalAlignment) {
                            case'top':
                                shiftY = round(canvas.top - rect.y + options.margin);
                                break;
                            case'bottom':
                                shiftY = round(canvas.height - rect.height - canvas.bottom - options.margin - rect.y);
                                break
                        }
                        legend.shift(shiftX, shiftY)
                    }
                };
            var applyPieChartSeriesLayout = function() {
                    var chart = this.chart,
                        canvas = chart.canvas,
                        singleSeries = chart.series[0] || {},
                        paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
                        paneSpaceWidth = canvas.width - canvas.left - canvas.right,
                        min = paneSpaceWidth < paneSpaceHeight ? paneSpaceWidth : paneSpaceHeight,
                        accessibleRadius,
                        outerRadius = singleSeries.outerRadius,
                        innerRadius = singleSeries.type === 'pie' ? 0 : singleSeries.innerRadius || 0;
                    if (!(singleSeries && singleSeries.correctPosition))
                        return;
                    if (singleSeries.type !== 'pie')
                        if (!isNumber(innerRadius))
                            innerRadius = 0.5;
                        else {
                            innerRadius = Number(innerRadius);
                            if (innerRadius < 0.2)
                                innerRadius = 0.2;
                            if (innerRadius > 0.8)
                                innerRadius = 0.8
                        }
                    if (min < singleSeries.labelSpace)
                        return false;
                    accessibleRadius = outerRadius || (min - singleSeries.labelSpace - singleSeries.hoverSpace) / 2;
                    singleSeries.correctPosition({
                        centerX: round(paneSpaceWidth / 2 + canvas.left),
                        centerY: round(paneSpaceHeight / 2 + canvas.top),
                        radiusInner: round(accessibleRadius * innerRadius),
                        radiusOuter: round(accessibleRadius)
                    });
                    return true
                };
            var isValidBox = function isValidBox(box) {
                    return !!(box.x || box.y || box.width || box.height)
                };
            var correctDeltaMarginValue = function(panes, canvasesGrid, marginSides) {
                    var axisPanePosition,
                        canvasCell,
                        canvas,
                        deltaSide,
                        requireAxesRedraw;
                    $.each(panes, function(_, pane) {
                        axisPanePosition = getPanePosition(canvasesGrid, pane.name);
                        canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                        canvas = canvasCell.canvas;
                        $.each(marginSides, function(_, side) {
                            deltaSide = 'delta' + side;
                            canvasCell[deltaSide] = Math.max(canvasCell[deltaSide] - (canvas[side.toLowerCase()] - canvas['original' + side]), 0);
                            if (canvasCell[deltaSide] > 0)
                                requireAxesRedraw = true
                        })
                    });
                    return requireAxesRedraw
                };
            var applyVerticalAxesLayout = function() {
                    var _this = this,
                        chart = _this.chart,
                        axes = chart.verticalAxes,
                        canvas,
                        axisPanePosition,
                        axisPosition,
                        canvasesGrid,
                        canvasCell,
                        box,
                        delta,
                        axis,
                        axisWidth,
                        commonAxisWidht = 0,
                        direction,
                        directionMultiplier,
                        i;
                    canvasesGrid = distributeCanvases(_this, chart.panes);
                    for (i = 0; i < axes.length; i++) {
                        axis = axes[i];
                        axisPosition = axis.options.position || 'left';
                        axis.delta = {};
                        box = axis.getBoundingRect();
                        if (!isValidBox(box))
                            continue;
                        axisPanePosition = getPanePosition(canvasesGrid, axes[i].pane);
                        canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                        canvas = canvasCell.canvas;
                        if (axisPosition == 'right') {
                            direction = 'deltaRight';
                            directionMultiplier = 1
                        }
                        else {
                            direction = 'deltaLeft';
                            directionMultiplier = -1
                        }
                        axisWidth = box.width;
                        if (!axis.delta[axisPosition] && canvasCell[direction] > 0)
                            canvasCell[direction] += axes[i].getMultipleAxesSpacing();
                        axes[i].delta[axisPosition] = axes[i].delta[axisPosition] || 0;
                        axes[i].delta[axisPosition] += canvasCell[direction] * directionMultiplier;
                        canvasCell[direction] += axisWidth;
                        delta = box.y + box.height - (canvas.height - canvas.originalBottom);
                        if (delta > 0) {
                            _this.requireAxesRedraw = true;
                            canvasCell.deltaBottom += delta
                        }
                        delta = canvas.originalTop - box.y;
                        if (delta > 0) {
                            _this.requireAxesRedraw = true;
                            canvasCell.deltaTop += delta
                        }
                    }
                    _this.requireAxesRedraw = correctDeltaMarginValue(chart.panes, canvasesGrid, ['Left', 'Right']) || _this.requireAxesRedraw;
                    applyFoundExceedings(canvasesGrid)
                };
            var applyHorizontalAxesLayout = function() {
                    var _this = this,
                        chart = _this.chart,
                        panes = chart.panes,
                        axes = chart.horizontalAxes,
                        canvas,
                        axisPanePosition,
                        canvasesGrid,
                        canvasCell,
                        box,
                        delta,
                        axis,
                        axisHeight,
                        direction,
                        directionMultiplier,
                        axisPosition,
                        i;
                    canvasesGrid = distributeCanvases(_this, panes);
                    for (i = axes.length - 1; i >= 0; i--) {
                        axis = axes[i];
                        axisPosition = axis.options.position || 'bottom';
                        axes[i].delta = {};
                        box = axes[i].getBoundingRect();
                        if (!isValidBox(box))
                            continue;
                        axisPanePosition = getPanePosition(canvasesGrid, axes[i].pane);
                        canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                        canvas = canvasCell.canvas;
                        if (axisPosition == 'top') {
                            direction = 'deltaTop';
                            directionMultiplier = -1
                        }
                        else {
                            direction = 'deltaBottom';
                            directionMultiplier = 1
                        }
                        axisHeight = box.height;
                        if (!axis.delta[axisPosition] && canvasCell[direction] > 0)
                            canvasCell[direction] += axes[i].getMultipleAxesSpacing();
                        axes[i].delta[axisPosition] = axes[i].delta[axisPosition] || 0;
                        axes[i].delta[axisPosition] += canvasCell[direction] * directionMultiplier;
                        canvasCell[direction] += axisHeight;
                        delta = canvas.originalLeft - box.x;
                        if (delta > 0) {
                            _this.requireAxesRedraw = true;
                            canvasCell.deltaLeft += delta
                        }
                        delta = box.x + box.width - (canvas.width - canvas.originalRight);
                        if (delta > 0) {
                            _this.requireAxesRedraw = true;
                            canvasCell.deltaRight = delta
                        }
                    }
                    _this.requireAxesRedraw = correctDeltaMarginValue(panes, canvasesGrid, ['Bottom', 'Top']) || _this.requireAxesRedraw;
                    applyFoundExceedings(canvasesGrid)
                };
            var distributeCanvases = function distributeCanvases(_this, panes) {
                    var panesLength = panes.length,
                        i,
                        j,
                        canvasesGrid = [],
                        canvasesRow = [],
                        rotated = _this.chart.option('rotated');
                    for (i = 0; i < panesLength; i++) {
                        if (!rotated)
                            canvasesRow = [];
                        canvasesRow.push({
                            canvas: panes[i].canvas,
                            pane: panes[i].name,
                            deltaLeft: 0,
                            deltaRight: 0,
                            deltaTop: 0,
                            deltaBottom: 0
                        });
                        !rotated && canvasesGrid.push(canvasesRow)
                    }
                    rotated && canvasesGrid.push(canvasesRow);
                    return canvasesGrid
                };
            var getPanePosition = function getPanePosition(canvasesGrid, pane) {
                    var row,
                        col;
                    for (row = 0; row < canvasesGrid.length; row++)
                        for (col = 0; col < canvasesGrid[row].length; col++)
                            if (canvasesGrid[row][col].pane === pane)
                                return {
                                        row: row,
                                        col: col
                                    }
                };
            var changeRowCanvas = function changeRowCanvas(canvasesGrid, row, callback) {
                    var col;
                    for (col = 0; col < canvasesGrid[row].length; col++)
                        callback(canvasesGrid[row][col].canvas)
                };
            var changeColumnCanvas = function changeRowCanvas(canvasesGrid, col, callback) {
                    var row;
                    for (row = 0; row < canvasesGrid.length; row++)
                        callback(canvasesGrid[row][col].canvas)
                };
            var applyFoundExceedings = function applyFoundExceedings(canvasesGrid) {
                    var col,
                        row,
                        canvasesRow,
                        maxLeft = 0,
                        maxRight = 0,
                        maxTop = 0,
                        maxBottom = 0,
                        maxColNumber = 0;
                    for (row = 0; row < canvasesGrid.length; row++) {
                        maxTop = 0;
                        maxBottom = 0;
                        canvasesRow = canvasesGrid[row];
                        if (canvasesRow.length > maxColNumber)
                            maxColNumber = canvasesRow.length;
                        for (col = 0; col < canvasesRow.length; col++) {
                            if (canvasesRow[col] && canvasesRow[col].deltaTop > maxTop)
                                maxTop = canvasesRow[col].deltaTop;
                            if (canvasesRow[col] && canvasesRow[col].deltaBottom > maxBottom)
                                maxBottom = canvasesRow[col].deltaBottom
                        }
                        if (maxTop)
                            changeRowCanvas(canvasesGrid, row, function(canvas) {
                                canvas.top += maxTop
                            });
                        if (maxBottom)
                            changeRowCanvas(canvasesGrid, row, function(canvas) {
                                canvas.bottom += maxBottom
                            })
                    }
                    for (col = 0; col < maxColNumber; col++) {
                        maxLeft = 0;
                        maxRight = 0;
                        for (row = 0; row < canvasesGrid.length; row++) {
                            canvasesRow = canvasesGrid[row];
                            if (canvasesRow[col] && canvasesRow[col].deltaLeft > maxLeft)
                                maxLeft = canvasesRow[col].deltaLeft;
                            if (canvasesRow[col] && canvasesRow[col].deltaRight > maxRight)
                                maxRight = canvasesRow[col].deltaRight
                        }
                        if (maxLeft)
                            changeColumnCanvas(canvasesGrid, col, function(canvas) {
                                canvas.left += maxLeft
                            });
                        if (maxRight)
                            changeColumnCanvas(canvasesGrid, col, function(canvas) {
                                canvas.right += maxRight
                            })
                    }
                };
            var isSingleCanvasExceeded = function isSingleCanvasExceeded(canvas) {
                    if (canvas.left > canvas.width - canvas.right || canvas.right > canvas.width - canvas.left || canvas.top > canvas.height - canvas.bottom || canvas.bottom > canvas.height - canvas.top)
                        return true
                };
            var isCanvasExceeded = function isCanvasExceeded(includePanes) {
                    var chart = this.chart,
                        paneCanvasesExceed = false;
                    if (isSingleCanvasExceeded(chart.canvas))
                        return true;
                    if (includePanes)
                        $.each(chart && chart.panes || {}, function(_, pane) {
                            if (pane.canvas && isSingleCanvasExceeded(pane.canvas)) {
                                paneCanvasesExceed = true;
                                return false
                            }
                        });
                    return paneCanvasesExceed
                };
            return {
                    update: update,
                    createPanesCanvases: createPanesCanvases,
                    applyLegendLayout: applyLegendLayout,
                    applyTitleLayout: applyTitleLayout,
                    adjustTitleLayout: adjustTitleLayout,
                    applyVerticalAxesLayout: applyVerticalAxesLayout,
                    applyHorizontalAxesLayout: applyHorizontalAxesLayout,
                    applyPieChartSeriesLayout: applyPieChartSeriesLayout,
                    isCanvasExceeded: isCanvasExceeded,
                    dispose: dispose
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file multiAxesSynchronizer.js */
    (function($, DX, undefined) {
        var charts = DX.viz.charts,
            utils = DX.utils;
        charts.MultiAxesSynchronizer = DX.Class.inherit(function() {
            var getValueAxesPerPanes = function(valueAxes) {
                    var result = {};
                    $.each(valueAxes, function() {
                        if (!result[this.pane])
                            result[this.pane] = [];
                        result[this.pane].push(this)
                    });
                    return result
                };
            var restoreOriginalBusinessRange = function(axis, argumentField) {
                    var businessRange,
                        minVisible = 'minVisible' + argumentField,
                        maxVisible = 'maxVisible' + argumentField,
                        minArgumentVisibleValue,
                        maxArgumentVisibleValue;
                    if (!axis.translator._originalBusinessRange)
                        axis.translator._originalBusinessRange = new charts.Range(axis.translator.getBusinessRange());
                    else {
                        minArgumentVisibleValue = axis.translator.businessRange[minVisible];
                        maxArgumentVisibleValue = axis.translator.businessRange[maxVisible];
                        businessRange = new charts.Range(axis.translator._originalBusinessRange);
                        businessRange[minVisible] = minArgumentVisibleValue;
                        businessRange[maxVisible] = maxArgumentVisibleValue;
                        axis.translator.updateBusinessRange(businessRange);
                        axis.setRange(businessRange)
                    }
                };
            var populateAxesInfo = function(axes, rotated) {
                    var axesInfo = [];
                    $.each(axes, function() {
                        var tickValues,
                            minValue,
                            maxValue,
                            inverted,
                            axisInfo,
                            businessRange,
                            stubData = rotated && 'stubDataX' || 'stubDataY';
                        restoreOriginalBusinessRange(this, rotated ? 'Y' : 'X');
                        tickValues = this.getTickValues();
                        if (tickValues && tickValues.length > 0 && utils.isNumber(tickValues[0]) && this.options.type !== 'discrete') {
                            businessRange = this.translator.getBusinessRange();
                            minValue = rotated ? businessRange.minVisibleX : businessRange.minVisibleY;
                            maxValue = rotated ? businessRange.maxVisibleX : businessRange.maxVisibleY;
                            inverted = rotated ? businessRange.invertX : businessRange.invertY;
                            axisInfo = {
                                axis: this,
                                tickValues: tickValues,
                                minValue: minValue,
                                oldMinValue: minValue,
                                maxValue: maxValue,
                                oldMaxValue: maxValue,
                                inverted: inverted,
                                synchronizedValue: this.options.synchronizedValue
                            };
                            if (businessRange[stubData]) {
                                axisInfo.stubData = true;
                                axisInfo.tickInterval = axisInfo.axis.options.tickInterval
                            }
                            if (!axisInfo.tickInterval && tickValues.length > 1)
                                axisInfo.tickInterval = tickValues[1] - tickValues[0];
                            axesInfo.push(axisInfo)
                        }
                    });
                    return axesInfo
                };
            var updateTickValues = function(axesInfo) {
                    var maxTicksCount = 0,
                        ticksMultiplier,
                        ticksCount,
                        additionalStartTicksCount = 0;
                    $.each(axesInfo, function() {
                        maxTicksCount = Math.max(maxTicksCount, this.tickValues.length)
                    });
                    $.each(axesInfo, function() {
                        if (utils.isDefined(this.synchronizedValue)) {
                            this.baseTickValue = this.synchronizedValue;
                            this.invertedBaseTickValue = this.synchronizedValue;
                            this.tickValues = [this.baseTickValue]
                        }
                        else {
                            if (this.tickValues.length > 1 && this.tickInterval) {
                                ticksMultiplier = Math.floor((maxTicksCount + 1) / this.tickValues.length);
                                ticksCount = ticksMultiplier > 1 ? Math.floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
                                additionalStartTicksCount = Math.floor((ticksCount - this.tickValues.length) / 2);
                                while (additionalStartTicksCount > 0 && this.tickValues[0] !== 0) {
                                    this.tickValues.unshift(utils.adjustValue(this.tickValues[0] - this.tickInterval));
                                    additionalStartTicksCount--
                                }
                                while (this.tickValues.length < ticksCount)
                                    this.tickValues.push(utils.adjustValue(this.tickValues[this.tickValues.length - 1] + this.tickInterval));
                                this.tickInterval = this.tickInterval / ticksMultiplier
                            }
                            this.baseTickValue = this.tickValues[0];
                            this.invertedBaseTickValue = this.tickValues[this.tickValues.length - 1]
                        }
                    })
                };
            var getAxisRange = function(axisInfo) {
                    return axisInfo.maxValue - axisInfo.minValue
                };
            var getMainAxisInfo = function(axesInfo) {
                    var i;
                    for (i = 0; i < axesInfo.length; i++)
                        if (!axesInfo[i].stubData)
                            return axesInfo[i];
                    return null
                };
            var correctMinMaxValues = function(axesInfo) {
                    var mainAxisInfo = getMainAxisInfo(axesInfo);
                    $.each(axesInfo, function() {
                        var scale,
                            move,
                            mainAxisBaseValueOffset;
                        if (this !== mainAxisInfo) {
                            if (mainAxisInfo.tickInterval && this.tickInterval) {
                                if (this.stubData && utils.isDefined(this.synchronizedValue)) {
                                    this.oldMinValue = this.minValue = this.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfo.tickInterval * this.tickInterval;
                                    this.oldMaxValue = this.maxValue = this.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfo.tickInterval * this.tickInterval;
                                    this.stubData = false
                                }
                                scale = mainAxisInfo.tickInterval / getAxisRange(mainAxisInfo) / this.tickInterval * getAxisRange(this);
                                this.maxValue = this.minValue + getAxisRange(this) / scale
                            }
                            if (mainAxisInfo.inverted && !this.inverted || !mainAxisInfo.inverted && this.inverted)
                                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
                            else
                                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
                            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (this.baseTickValue - this.minValue) / getAxisRange(this)) * getAxisRange(this);
                            this.minValue -= move;
                            this.maxValue -= move
                        }
                    })
                };
            var calculatePaddings = function(axesInfo) {
                    var minPadding,
                        maxPadding,
                        startPadding = 0,
                        endPadding = 0;
                    $.each(axesInfo, function() {
                        minPadding = this.minValue > this.oldMinValue ? (this.minValue - this.oldMinValue) / getAxisRange(this) : 0;
                        maxPadding = this.maxValue < this.oldMaxValue ? (this.oldMaxValue - this.maxValue) / getAxisRange(this) : 0;
                        if (this.inverted) {
                            startPadding = Math.max(startPadding, maxPadding);
                            endPadding = Math.max(endPadding, minPadding)
                        }
                        else {
                            startPadding = Math.max(startPadding, minPadding);
                            endPadding = Math.max(endPadding, maxPadding)
                        }
                    });
                    return {
                            start: startPadding,
                            end: endPadding
                        }
                };
            var correctMinMaxValuesByPaddings = function(axesInfo, paddings) {
                    var range;
                    $.each(axesInfo, function() {
                        range = getAxisRange(this);
                        if (this.inverted) {
                            this.minValue -= paddings.end * range;
                            this.maxValue += paddings.start * range
                        }
                        else {
                            this.minValue -= paddings.start * range;
                            this.maxValue += paddings.end * range
                        }
                        this.minValue = Math.min(this.minValue, utils.adjustValue(this.minValue));
                        this.maxValue = Math.max(this.maxValue, utils.adjustValue(this.maxValue))
                    })
                };
            var updateTickValuesIfSyncronizedValueUsed = function(axesInfo) {
                    var hasSyncronizedValue = false;
                    $.each(axesInfo, function() {
                        hasSyncronizedValue = hasSyncronizedValue || utils.isDefined(this.synchronizedValue)
                    });
                    $.each(axesInfo, function() {
                        var lastTickValue;
                        if (hasSyncronizedValue && this.tickInterval) {
                            while (this.tickValues[0] - this.tickInterval >= this.minValue)
                                this.tickValues.unshift(utils.adjustValue(this.tickValues[0] - this.tickInterval));
                            lastTickValue = this.tickValues[this.tickValues.length - 1];
                            while ((lastTickValue = lastTickValue + this.tickInterval) <= this.maxValue)
                                this.tickValues.push(utils.adjustValue(lastTickValue))
                        }
                        while (this.tickValues[0] < this.minValue)
                            this.tickValues.shift();
                        while (this.tickValues[this.tickValues.length - 1] > this.maxValue)
                            this.tickValues.pop()
                    })
                };
            var applyMinMaxValues = function(axesInfo, rotated) {
                    var axis,
                        range,
                        stubData = rotated && 'stubDataX' || 'stubDataY';
                    $.each(axesInfo, function() {
                        axis = this.axis;
                        range = axis.translator.getBusinessRange();
                        if (rotated) {
                            if (range.minX === range.minVisibleX)
                                range.minX = this.minValue;
                            if (range.maxX === range.maxVisibleX)
                                range.maxX = this.maxValue;
                            range.minVisibleX = this.minValue;
                            range.maxVisibleX = this.maxValue
                        }
                        else {
                            if (range.minY === range.minVisibleY)
                                range.minY = this.minValue;
                            if (range.maxY === range.maxVisibleY)
                                range.maxY = this.maxValue;
                            range.minVisibleY = this.minValue;
                            range.maxVisibleY = this.maxValue
                        }
                        if (utils.isDefined(this.stubData))
                            range[stubData] = this.stubData;
                        axis.translator.updateBusinessRange(range);
                        axis.setRange(range);
                        axis.setTickValues(this.tickValues)
                    })
                };
            return {synchronize: function(valueAxes, rotated) {
                        var valueAxesPerPanes;
                        valueAxesPerPanes = getValueAxesPerPanes(valueAxes);
                        $.each(valueAxesPerPanes, function(i, axes) {
                            var axesInfo,
                                paddings;
                            if (axes.length > 1) {
                                axesInfo = populateAxesInfo(axes, rotated);
                                if (axesInfo.length === 0 || !getMainAxisInfo(axesInfo))
                                    return;
                                updateTickValues(axesInfo);
                                correctMinMaxValues(axesInfo);
                                paddings = calculatePaddings(axesInfo);
                                correctMinMaxValuesByPaddings(axesInfo, paddings);
                                updateTickValuesIfSyncronizedValueUsed(axesInfo);
                                applyMinMaxValues(axesInfo, rotated)
                            }
                        })
                    }}
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file seriesConsts.js */
    (function(DX) {
        DX.viz.charts.series.consts = {
            events: {
                mouseover: 'mouseover',
                mouseout: 'mouseout',
                mousemove: 'mousemove',
                touchstart: 'touchstart',
                touchmove: 'touchmove',
                touchend: 'touchend',
                mousedown: 'mousedown',
                mouseup: 'mouseup',
                click: 'click',
                selectSeries: 'selectseries',
                deselectSeries: 'deselectseries',
                selectPoint: 'selectpoint',
                deselectPoint: 'deselectpoint',
                showPointTooltip: 'showpointtooltip',
                hidePointTooltip: 'hidepointtooltip'
            },
            states: {
                hover: 'hover',
                normal: 'normal',
                selected: 'selected',
                normalMark: 0,
                hoverMark: 1,
                selectedMark: 2
            }
        }
    })(DevExpress);
    /*! Module viz, file basePoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            eventsConsts = series.consts.events,
            statesConsts = series.consts.states,
            utils = DX.utils,
            formatHelper = DX.formatHelper,
            CANVAS_POSITION_DEFAULT = 'canvas_position_default';
        series.BasePoint = DX.Class.inherit({
            ctor: function(data) {
                var debug = DX.utils.debug;
                debug.assertParam(data, 'data was not passed');
                debug.assertParam(data.options, 'options were not passed');
                this.LABEL_BACKGROUND_PADDING_X = 8;
                this.LABEL_BACKGROUND_PADDING_Y = 4;
                this.LABEL_OFFSET = 10;
                this.rotated = !!data.rotated;
                if (data.options.label && data.options.label.position && data.options.label.position !== 'outside' && data.options.label.position !== 'inside')
                    data.options.label.position = 'outside';
                this.options = data.options;
                this.series = data.series;
                this.value = this.initialValue = data.value;
                this.argument = this.initialArgument = data.argument;
                this.originalValue = data.originalValue;
                this.originalArgument = data.originalArgument;
                this.minValue = CANVAS_POSITION_DEFAULT;
                this.labelFormatObject = {
                    argument: this.initialArgument,
                    value: this.initialValue,
                    seriesName: this.options.seriesName,
                    originalValue: this.originalValue,
                    originalArgument: this.originalArgument
                };
                this.tag = data.tag;
                this.pointClassName = data.pointClassName || ''
            },
            dispose: function() {
                var _this = this;
                _this.off();
                _this.trackerGraphic && _this.trackerGraphic.removeData();
                _this.graphic = null;
                _this.trackerGraphic = null;
                _this.hoverPattern = null;
                _this.selectedPattern = null;
                _this.label = null;
                _this.labelBackground = null;
                _this.connector = null;
                _this.insideLabelGroup = null;
                _this.labelGroup = null;
                _this.points = null;
                _this.translator = null;
                _this.options = null;
                _this.series = null;
                _this.tag = null;
                _this.labelFormatObject = null
            },
            formatLabel: function(options) {
                this.valueText = formatHelper.format(this.value, options.format, options.precision);
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                if (this.percent !== undefined)
                    this.percentText = formatHelper.format(this.percent, 'percent', options.percentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            setOptions: function(options) {
                this.options = options
            },
            translate: function(translator) {
                this.translator = translator = translator || this.translator;
                if (!this.translator || !this.hasValue())
                    return;
                if (!this.rotated) {
                    this.y = translator.translateY(this.value);
                    this.minY = translator.translateY(this.minValue);
                    this.x = translator.translateX(this.argument);
                    this.defaultY = translator.translateY(CANVAS_POSITION_DEFAULT)
                }
                else {
                    this.y = translator.translateY(this.argument);
                    this.x = translator.translateX(this.value);
                    this.minX = translator.translateX(this.minValue);
                    this.defaultX = translator.translateX(CANVAS_POSITION_DEFAULT)
                }
                this._calculateVisibility(this.x, this.y, 0, 0);
                this.prepareStatesOptions()
            },
            _calculateVisibility: function(x, y, width, height) {
                var visibleArea;
                if (this.translator && this.translator.getCanvasVisibleArea) {
                    visibleArea = this.translator.getCanvasVisibleArea() || {};
                    if (visibleArea.minX > x + (width || 0) || visibleArea.maxX < x || visibleArea.minY > y + (height || 0) || visibleArea.maxY < y)
                        this.visible = false;
                    else
                        this.visible = true
                }
            },
            correctValue: function(correction) {
                this.value += correction;
                if (!utils.isNumber(this.minValue))
                    this.minValue = correction;
                else
                    this.minValue += correction;
                this.translate()
            },
            normalizeValue: function(total) {
                this.value = this.value / total || 0;
                if (utils.isNumber(this.minValue)) {
                    this.minValue = this.minValue / total || 0;
                    this.labelFormatObject.percent = this.value - this.minValue
                }
                else
                    this.labelFormatObject.percent = this.value;
                this.translate()
            },
            getCoords: function(min) {
                if (!min)
                    return {
                            x: this.x,
                            y: this.y
                        };
                if (!this.rotated)
                    return {
                            x: this.x,
                            y: this.minY
                        };
                return {
                        x: this.minX,
                        y: this.y
                    }
            },
            getDefaultCoords: function() {
                return !this.rotated ? {
                        x: this.x,
                        y: this.defaultY
                    } : {
                        x: this.defaultX,
                        y: this.y
                    }
            },
            getTooltipCoords: function() {
                if (this.graphic)
                    return {
                            x: this.x,
                            y: this.y,
                            offset: this.graphic.getBBox().height / 2
                        };
                else
                    return {
                            x: this.x,
                            y: this.y,
                            offset: 0
                        }
            },
            isInVisibleArea: function() {
                return this.visible
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var radius = this.options.attributes.r,
                    states = this.options.states.normal,
                    marker,
                    bbox;
                switch (this.options.symbol) {
                    case'circle':
                        marker = renderer.createCircle(this.x, this.y, radius, this.options.attributes).append(group);
                        break;
                    case'square':
                    case'polygon':
                    case'triangle':
                    case'cross':
                        marker = renderer.createArea(this.points, this.options.attributes).append(group);
                        break
                }
                this.graphic = marker;
                switch (this.state) {
                    case statesConsts.selected:
                        this.series.setPointSelectedState(this);
                        break;
                    case statesConsts.hover:
                        this.series.setPointHoverState(this);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
            },
            _trackerAttrs: {
                stroke: 'none',
                fill: 'grey',
                opacity: 0.0001,
                inh: true
            },
            storeTrackerR: function() {
                var navigator = window.navigator,
                    touchSupport = 'ontouchstart' in window || navigator.msPointerEnabled && navigator.msMaxTouchPoints > 0,
                    minTrackerSize = touchSupport ? 20 : 6;
                this.options.trackerR = this.options.attributes.r < minTrackerSize ? minTrackerSize : this.options.attributes.r;
                return this.options.trackerR
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                this.trackerGraphic = renderer.createCircle(this.x, this.y, this.options.trackerR || this.storeTrackerR(), this._trackerAttrs).append(trackerGroup);
                this.trackerGraphic.data({point: this})
            },
            select: function() {
                this.series.selectPoint(this)
            },
            clearSelection: function() {
                this.series.deselectPoint(this)
            },
            _populatePointShape: function(target, radius) {
                var self = this,
                    floorHalfRadius,
                    ceilHalfRadius;
                if (self.options.symbol === 'square')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y - radius
                        }];
                if (self.options.symbol === 'polygon')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y
                        }, {
                            x: self.x,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y
                        }, {
                            x: self.x,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y
                        }];
                if (self.options.symbol === 'triangle')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - radius
                        }, {
                            x: self.x,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y - radius
                        }];
                if (self.options.symbol === 'cross') {
                    floorHalfRadius = Math.floor(radius / 2);
                    ceilHalfRadius = Math.ceil(radius / 2);
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - floorHalfRadius
                        }, {
                            x: self.x - floorHalfRadius,
                            y: self.y - radius
                        }, {
                            x: self.x,
                            y: self.y - ceilHalfRadius
                        }, {
                            x: self.x + floorHalfRadius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - floorHalfRadius
                        }, {
                            x: self.x + ceilHalfRadius,
                            y: self.y
                        }, {
                            x: self.x + radius,
                            y: self.y + floorHalfRadius
                        }, {
                            x: self.x + floorHalfRadius,
                            y: self.y + radius
                        }, {
                            x: self.x,
                            y: self.y + ceilHalfRadius
                        }, {
                            x: self.x - floorHalfRadius,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y + floorHalfRadius
                        }, {
                            x: self.x - ceilHalfRadius,
                            y: self.y
                        }]
                }
            },
            prepareStatesOptions: function() {
                var self = this;
                if (self.options.states && self.options.states.normal)
                    self._populatePointShape(self, self.options.states.normal.r)
            },
            applyNormalStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.normal, this.options.states.normal.r);
                    this.graphic.applySettings(this.options.states.normal)
                }
                return this
            },
            applyHoverStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.hover, this.options.states.hover.r);
                    this.graphic.applySettings(this.options.states.hover);
                    this.graphic.toForeground();
                    this.graphic.addClass('dx-chart-hovered-point')
                }
                return this
            },
            applySelectionStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.selected, this.options.states.selected.r);
                    this.graphic.applySettings(this.options.states.selected);
                    this.graphic.toForeground();
                    this.graphic.addClass('dx-chart-selected-point')
                }
                return this
            },
            setHoverState: function() {
                this.series.setPointHoverState(this)
            },
            releaseHoverState: function() {
                this.series.releasePointHoverState(this);
                if (this.graphic) {
                    this.graphic.removeClass('dx-chart-hovered-point');
                    this.state !== 'selected' && this.graphic.toBackground()
                }
            },
            setSelectedState: function() {
                this.series.setPointSelectedState(this)
            },
            releaseSelectedState: function() {
                this.series.releasePointSelectedState(this);
                if (this.graphic)
                    this.graphic.removeClass('dx-chart-selected-point')
            },
            showTooltip: function() {
                this.series.showPointTooltip(this)
            },
            hideTooltip: function() {
                this.series.hidePointTooltip(this)
            },
            on: function(events, data, handler) {
                $(this).on(events, data, handler);
                return this
            },
            off: function(events) {
                $(this).off(events);
                return this
            },
            correctLabel: function() {
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.correctLabelPosition()
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    labelText = this.formatLabel.call(this.labelFormatObject, labelOptions);
                if (!utils.isDefined(labelText))
                    return;
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth)
                    this.connector = renderer.createPath([], labelOptions.connector).append(this.labelGroup);
                this.insideLabelGroup = renderer.createGroup().append(this.labelGroup);
                labelOptions.background['class'] = this.pointClassName;
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none')
                    this.labelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup);
                this.label = renderer.createText(labelText, this.x, this.y, labelOptions.attributes).append(this.insideLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition()
            },
            rotateLabel: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideLabelGroup.applySettings({
                    x: bbox.x + bbox.width / 2,
                    y: bbox.y + bbox.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            getGraphicSettings: function() {
                return {
                        x: this.graphic.settings.x || 0,
                        y: this.graphic.settings.y || 0,
                        height: this.graphic.settings.height || 0,
                        width: this.graphic.settings.width || 0
                    }
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    },
                    x = 0,
                    y = 0;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                if (!this.rotated)
                    if (this.initialValue > 0 || this.series.isFullStackedSeries())
                        y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                    else
                        y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET;
                else {
                    y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                    if (this.initialValue > 0 || this.series.isFullStackedSeries())
                        x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                    else
                        x += bboxgraphic.x - bbox.x - bbox.width - this.LABEL_OFFSET
                }
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y)
            },
            checkLabelPosition: function(bbox, x, y) {
                var bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    },
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                if (!this.rotated)
                    if (visibleArea.minX <= bboxgraphic.x + bboxgraphic.width && visibleArea.maxX >= bboxgraphic.x) {
                        if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                            x += visibleArea.minX - bbox.x;
                        if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                            x -= bbox.x + bbox.width - visibleArea.maxX;
                        if (visibleArea.minY > bbox.y)
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET;
                        if (visibleArea.maxY < bbox.y + bbox.height)
                            y -= bbox.y + bbox.height - bboxgraphic.y + this.LABEL_OFFSET
                    }
                if (this.rotated)
                    if (visibleArea.minY <= bboxgraphic.y + bboxgraphic.height && visibleArea.maxY >= bboxgraphic.y) {
                        if (visibleArea.minX > bbox.x)
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                        if (visibleArea.maxX < bbox.x + bbox.width)
                            x -= bbox.x + bbox.width - bboxgraphic.x + this.LABEL_OFFSET;
                        if (visibleArea.minY > bbox.y && this.adjustSeriesLabels)
                            y += visibleArea.minY - bbox.y;
                        if (visibleArea.maxY < bbox.y + bbox.height && this.adjustSeriesLabels)
                            y -= bbox.y + bbox.height - visibleArea.maxY
                    }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            correctBackgroundPosition: function() {
                if (!this.labelBackground)
                    return;
                var bbox = this.label.getBBox(),
                    x = bbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y = bbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width = bbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height = bbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.labelBackground.applySettings({
                    x: x,
                    y: y,
                    width: width,
                    height: height
                })
            },
            correctConnectorPosition: function(bboxgraphic) {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = bboxgraphic || (this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    }),
                    x1,
                    x2,
                    y1,
                    y2,
                    centerLabelY,
                    centerLabelX;
                if (!this.connector)
                    return;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                bbox.x = bbox.x + (this.insideLabelGroup.settings.translateX || 0);
                bbox.y = bbox.y + (this.insideLabelGroup.settings.translateY || 0);
                centerLabelY = this.labelBackground ? bbox.y + bbox.height / 2 : null;
                centerLabelX = this.labelBackground ? bbox.x + bbox.width / 2 : null;
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                this.connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getColor: function() {
                return this.options.attributes.fill
            },
            getTooltipFormatObject: function(tooltip) {
                var value = tooltip.formatValueTooltip.call({value: this.initialValue}, tooltip.options);
                return $.extend({}, this.labelFormatObject, {
                        point: this,
                        valueText: value
                    })
            },
            animate: function() {
                var self = this,
                    graphic = self.graphic;
                if (!graphic || !self.translator)
                    return;
                if (!self.rotated)
                    graphic.move(0, self.defaultY - self.y);
                else
                    graphic.move(self.defaultX - self.x, 0);
                graphic.move(0, 0, true)
            },
            hasValue: function() {
                return this.initialValue !== null
            },
            getClassName: function() {
                return this.pointClassName
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file barPoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            statesConsts = series.consts.states,
            CANVAS_POSITION_DEFAULT = 'canvas_position_default',
            isDefined = DX.utils.isDefined;
        var truncateCoord = function(coord, minBounce, maxBounce) {
                if (coord < minBounce)
                    return minBounce;
                if (coord > maxBounce)
                    return maxBounce;
                return coord
            };
        series.BarPoint = series.BasePoint.inherit({
            translate: function(translator) {
                var canvasVisibleArea,
                    minX,
                    minY,
                    y,
                    x;
                this.translator = translator = translator || this.translator;
                if (!this.translator || !this.hasValue())
                    return;
                canvasVisibleArea = translator.getCanvasVisibleArea() || {};
                if (!this.rotated) {
                    this.x = translator.translateX(this.argument) + (this.xCorrection || 0);
                    y = translator.translateY(this.value);
                    this.minY = isDefined(this.minY) ? this.minY : Infinity;
                    minY = translator.translateY(this.minValue);
                    this.height = Math.abs(minY - y);
                    this._calculateVisibility(this.x, Math.min(y, this.minY), 0, this.height);
                    y = truncateCoord(y, canvasVisibleArea.minY, canvasVisibleArea.maxY);
                    minY = truncateCoord(minY, canvasVisibleArea.minY, canvasVisibleArea.maxY);
                    this.height = Math.abs(minY - y);
                    this.y = Math.min(y, minY) + (this.yCorrection || 0);
                    this.minY = minY + (this.yCorrection || 0);
                    this.defaultY = translator.translateY(CANVAS_POSITION_DEFAULT)
                }
                else {
                    this.y = translator.translateY(this.argument) + (this.yCorrection || 0);
                    x = translator.translateX(this.value);
                    this.minX = isDefined(this.minX) ? this.minX : Infinity;
                    minX = translator.translateX(this.minValue);
                    this.width = Math.abs(x - minX);
                    this._calculateVisibility(Math.min(x, minX), this.y, this.width, 0);
                    x = truncateCoord(x, canvasVisibleArea.minX, canvasVisibleArea.maxX);
                    minX = truncateCoord(minX, canvasVisibleArea.minX, canvasVisibleArea.maxX);
                    this.minX = minX + (this.minXCorrection || 0);
                    this.width = Math.abs(x - minX);
                    this.x = Math.min(minX, x) + (this.xCorrection || 0);
                    this.defaultX = translator.translateX(CANVAS_POSITION_DEFAULT)
                }
            },
            getTooltipCoords: function() {
                var self = this,
                    x = self.x + self.width / 2,
                    y = self.y + self.height / 2;
                return {
                        x: x,
                        y: y,
                        offset: 0
                    }
            },
            correctCoordinates: function(correctOptions) {
                var correction = correctOptions.offset - Math.round(correctOptions.width / 2);
                if (!this.rotated) {
                    this.width = correctOptions.width;
                    this.xCorrection = correction;
                    this.minXCorrection = correction
                }
                else {
                    this.height = correctOptions.width;
                    this.yCorrection = correction;
                    this.minYCorrection = correction
                }
            },
            drawMarker: function(renderer, group) {
                var attributes;
                if (!this.hasValue())
                    return;
                switch (this.state) {
                    case statesConsts.hover:
                        attributes = this.options.states.hover;
                        break;
                    case statesConsts.selected:
                        attributes = this.options.states.selected;
                        break;
                    default:
                        attributes = this.options.attributes;
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                this.graphic = renderer.createRect(this.x, this.y, this.width, this.height, attributes.r, attributes).append(group)
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var _this = this,
                    y = _this.y,
                    height = _this.height,
                    x = _this.x,
                    width = _this.width;
                if (_this.rotated) {
                    if (width === 1) {
                        width = 9;
                        x -= 4
                    }
                }
                else if (height === 1) {
                    height = 9;
                    y -= 4
                }
                this.trackerGraphic = renderer.createRect(x, y, width, height, _this.options.attributes.r, _this._trackerAttrs).append(trackerGroup);
                this.trackerGraphic.data({point: _this})
            },
            correctConnectorPosition: function() {
                this.callBase(this.getBboxGraphic())
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue() || !this.options.label.showForZeroValues && !this.labelFormatObject.value)
                    return;
                else
                    this.callBase(renderer, group)
            },
            getBboxGraphic: function() {
                var bboxgraphic = this.graphic && this.graphic.getBBox(),
                    deltaX,
                    deltaY;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                deltaX = bboxgraphic.x - this.x;
                deltaY = bboxgraphic.y - this.y;
                bboxgraphic.x -= deltaX;
                bboxgraphic.y -= deltaY;
                bboxgraphic.width += 2 * deltaX;
                bboxgraphic.height += 2 * deltaY;
                return bboxgraphic
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.getBboxGraphic(),
                    businessRange = this.translator.getBusinessRange(),
                    isDiscreteValue = this.series.options.valueAxisType === 'discrete',
                    isTop = !isDiscreteValue && (this.initialValue >= 0 && !businessRange.invertY || this.initialValue < 0 && businessRange.invertY) || isDiscreteValue && !businessRange.invertY || this.series.isFullStackedSeries(),
                    isLeft = !isDiscreteValue && (this.initialValue >= 0 && !businessRange.invertX || this.initialValue < 0 && businessRange.invertX) || isDiscreteValue && !businessRange.invertX || this.series.isFullStackedSeries(),
                    x = 0,
                    y = 0;
                if (this.initialValue === 0 && this.series.isFullStackedSeries())
                    if (!this.rotated) {
                        x += bboxgraphic.width / 2;
                        y += this.defaultY - bbox.y - bbox.height - this.LABEL_OFFSET
                    }
                    else {
                        y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                        x += this.defaultX - bbox.x + this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        x += bboxgraphic.width / 2;
                        if (isTop)
                            y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                        else
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                        if (isLeft)
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                        else
                            x += bboxgraphic.x - bbox.x - bbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        x += bboxgraphic.width / 2;
                        if (isTop)
                            y += bboxgraphic.y - bbox.y - bbox.height + this.LABEL_OFFSET + bbox.height;
                        else
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y - this.LABEL_OFFSET - bbox.height
                    }
                    else {
                        y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                        if (isLeft)
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x - bbox.width - this.LABEL_OFFSET;
                        else
                            x += bboxgraphic.x - bbox.x + this.LABEL_OFFSET
                    }
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y, bboxgraphic)
            },
            checkLabelPosition: function(bbox, x, y, bboxgraphic) {
                var bboxgraphic = bboxgraphic || this.graphic.getBBox(),
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (visibleArea.minX <= bboxgraphic.x + bboxgraphic.width && visibleArea.maxX >= bboxgraphic.x && visibleArea.minY <= bboxgraphic.y + bboxgraphic.height && visibleArea.maxY >= bboxgraphic.y) {
                    if (!this.rotated) {
                        if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                            x += visibleArea.minX - bbox.x;
                        if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                            x -= bbox.x + bbox.width - visibleArea.maxX;
                        if (visibleArea.minY > bbox.y)
                            y += visibleArea.minY - bbox.y;
                        if (visibleArea.maxY < bbox.y + bbox.height)
                            y -= bbox.y + bbox.height - visibleArea.maxY
                    }
                    if (this.rotated) {
                        if (visibleArea.minX > bbox.x)
                            x += visibleArea.minX - bbox.x;
                        if (visibleArea.maxX < bbox.x + bbox.width)
                            x -= bbox.x + bbox.width - visibleArea.maxX;
                        if (visibleArea.minY > bbox.y && this.adjustSeriesLabels)
                            y += visibleArea.minY - bbox.y;
                        if (visibleArea.maxY < bbox.y + bbox.height && this.adjustSeriesLabels)
                            y -= bbox.y + bbox.height - visibleArea.maxY
                    }
                }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            animate: function() {
                var _this = this,
                    graphic = _this.graphic;
                if (!graphic || !_this.translator)
                    return;
                if (!_this.rotated) {
                    graphic.applySettings({
                        height: 0,
                        y: _this.defaultY,
                        sharpEdges: false
                    });
                    graphic.animate({
                        height: _this.height,
                        y: _this.y
                    })
                }
                else {
                    graphic.applySettings({
                        width: 0,
                        x: _this.defaultX,
                        sharpEdges: false
                    });
                    graphic.animate({
                        width: _this.width,
                        x: _this.x
                    })
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file ohlcPoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            utils = DX.utils,
            statesConsts = series.consts.states,
            formatHelper = DX.formatHelper;
        series.OhlcPoint = series.BasePoint.inherit({
            ctor: function(data) {
                var debug = DX.utils.debug;
                debug.assertParam(data, 'data was not passed');
                debug.assertParam(data.options, 'options were not passed');
                this.LABEL_BACKGROUND_PADDING_X = 8;
                this.LABEL_BACKGROUND_PADDING_Y = 4;
                this.LABEL_OFFSET = 10;
                this.argument = this.initialArgument = data.argument;
                this.openValue = data.openValue;
                this.highValue = data.highValue;
                this.lowValue = data.lowValue;
                this.closeValue = data.closeValue;
                this.value = this.initialValue = data.reductionValue;
                this.originalOpenValue = data.originalOpenValue;
                this.originalCloseValue = data.originalCloseValue;
                this.originalLowValue = data.originalLowValue;
                this.originalHighValue = data.originalHighValue;
                this.originalArgument = data.originalArgument;
                this.tag = data.tag;
                this.options = data.options;
                this.options.attributes && (this.options.attributes.inh = false);
                this.series = data.series;
                this.rotated = !!(this.series && this.series.options && this.series.options.rotated || false);
                this.labelFormatObject = {
                    openValue: this.openValue,
                    highValue: this.highValue,
                    lowValue: this.lowValue,
                    closeValue: this.closeValue,
                    reductionValue: this.initialValue,
                    argument: this.initialArgument,
                    value: this.initialValue,
                    seriesName: this.options.seriesName,
                    originalOpenValue: this.originalOpenValue,
                    originalCloseValue: this.originalCloseValue,
                    originalLowValue: this.originalLowValue,
                    originalHighValue: this.originalHighValue,
                    originalArgument: this.originalArgument
                };
                this.pointClassName = data.pointClassName || ''
            },
            formatLabel: function(options) {
                this.openValueText = formatHelper.format(this.openValue, options.format, options.precision);
                this.highValueText = formatHelper.format(this.highValue, options.format, options.precision);
                this.lowValueText = formatHelper.format(this.lowValue, options.format, options.precision);
                this.closeValueText = formatHelper.format(this.closeValue, options.format, options.precision);
                this.reductionValueText = formatHelper.format(this.reductionValue, options.format, options.precision);
                this.valueText = formatHelper.format(this.value, options.format, options.precision);
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            translate: function(translator) {
                var _this = this,
                    rotated = _this.rotated,
                    translateArg = rotated ? 'translateY' : 'translateX',
                    translateVal = rotated ? 'translateX' : 'translateY',
                    height;
                _this.translator = translator = translator || _this.translator;
                if (!_this.translator || !_this.hasValue())
                    return;
                _this.x = translator[translateArg](_this.argument) + (_this.xCorrection || 0);
                _this.openY = translator[translateVal](_this.openValue);
                _this.highY = translator[translateVal](_this.highValue);
                _this.lowY = translator[translateVal](_this.lowValue);
                _this.closeY = translator[translateVal](_this.closeValue);
                height = Math.abs(_this.lowY - _this.highY);
                if (!_this.rotated)
                    _this._calculateVisibility(_this.x - _this.width / 2, Math.min(_this.lowY, _this.highY), _this.width, height);
                else
                    _this._calculateVisibility(Math.min(_this.lowY, _this.highY), _this.x - _this.width / 2, height, _this.width)
            },
            correctCoordinates: function(correctOptions) {
                var minWidth = 1 + 2 * this.options.attributes.lineWidth,
                    maxWidth = 10;
                this.width = correctOptions.width < minWidth ? minWidth : correctOptions.width > maxWidth ? maxWidth : correctOptions.width;
                this.xCorrection = correctOptions.offset
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var _this = this,
                    attributes,
                    rotated = _this.rotated,
                    createPoint = rotated ? function(x, y) {
                        return {
                                x: y,
                                y: x
                            }
                    } : function(x, y) {
                        return {
                                x: x,
                                y: y
                            }
                    };
                switch (_this.state) {
                    case statesConsts.selected:
                        attributes = _this.options.states.selected;
                        break;
                    case statesConsts.hover:
                        attributes = _this.options.states.hover;
                        break;
                    default:
                        attributes = _this.options.attributes;
                        _this.state = statesConsts.normal;
                        _this.fullState = statesConsts.normalMark
                }
                if (_this.openValue > _this.closeValue)
                    _this.graphic = renderer.createArea([createPoint(_this.x, _this.highY), createPoint(_this.x, _this.openY), createPoint(_this.x + _this.width / 2, _this.openY), createPoint(_this.x + _this.width / 2, _this.closeY), createPoint(_this.x, _this.closeY), createPoint(_this.x, _this.lowY), createPoint(_this.x, _this.closeY), createPoint(_this.x - _this.width / 2, _this.closeY), createPoint(_this.x - _this.width / 2, _this.openY), createPoint(_this.x, _this.openY)], attributes).append(group);
                else if (_this.openValue < _this.closeValue)
                    _this.graphic = renderer.createArea([createPoint(_this.x, _this.highY), createPoint(_this.x, _this.closeY), createPoint(_this.x + _this.width / 2, _this.closeY), createPoint(_this.x + _this.width / 2, _this.openY), createPoint(_this.x, _this.openY), createPoint(_this.x, _this.lowY), createPoint(_this.x, _this.openY), createPoint(_this.x - _this.width / 2, _this.openY), createPoint(_this.x - _this.width / 2, _this.closeY), createPoint(_this.x, _this.closeY)], attributes).append(group);
                else if (_this.openValue === _this.closeValue)
                    _this.graphic = renderer.createArea([createPoint(_this.x, _this.highY), createPoint(_this.x, _this.lowY), createPoint(_this.x, _this.closeY), createPoint(_this.x - _this.width / 2, _this.closeY), createPoint(_this.x + _this.width / 2, _this.closeY), createPoint(_this.x, _this.closeY)], attributes).append(group)
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var _this = this,
                    highY = _this.highY,
                    lowY = _this.lowY,
                    rotated = _this.rotated,
                    math = Math,
                    x,
                    y,
                    width,
                    height;
                if (highY === lowY) {
                    highY = !rotated ? highY - 2 : highY + 2;
                    lowY = !rotated ? lowY + 2 : lowY - 2
                }
                if (!rotated) {
                    x = _this.x - _this.width / 2;
                    y = math.min(lowY, highY);
                    width = _this.width;
                    height = math.abs(lowY - highY)
                }
                else {
                    x = math.min(lowY, highY);
                    y = _this.x - _this.width / 2;
                    width = math.abs(lowY - highY);
                    height = _this.width
                }
                _this.trackerGraphic = renderer.createRect(x, y, width, height, 0, _this._trackerAttrs).append(trackerGroup);
                _this.trackerGraphic.data({point: _this})
            },
            animate: function(){},
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    labelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    rotated = this.rotated;
                if (!utils.isDefined(labelText))
                    return;
                this.labelGroup = renderer.createGroup().append(group);
                this.insideLabelGroup = renderer.createGroup().append(this.labelGroup);
                labelOptions.background['class'] = this.pointClassName;
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    labelOptions.background.fill = this.options.attributes.stroke;
                    this.labelBackground = rotated ? renderer.createRect(this.highY, this.x, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup) : renderer.createRect(this.x, this.highY, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup)
                }
                this.label = rotated ? renderer.createText(labelText, this.highY, this.x, labelOptions.attributes).append(this.insideLabelGroup) : renderer.createText(labelText, this.x, this.highY, labelOptions.attributes).append(this.insideLabelGroup);
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.correctLabelPosition()
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.graphic.getBBox(),
                    rotated = this.rotated,
                    x = 0,
                    y = 0;
                if (!rotated)
                    y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                else
                    x += bboxgraphic.x - bbox.x + bboxgraphic.width + this.LABEL_OFFSET;
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y)
            },
            checkLabelPosition: function(bbox, x, y) {
                var visibleArea = this.translator.getCanvasVisibleArea(),
                    bboxgraphic = this.graphic.getBBox();
                if (visibleArea.minX <= bboxgraphic.x + bboxgraphic.width && visibleArea.maxX >= bboxgraphic.x) {
                    if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                        x += visibleArea.minX - bbox.x;
                    if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                        x -= bbox.x + bbox.width - visibleArea.maxX;
                    if (visibleArea.minY > bbox.y)
                        y += visibleArea.minY - bbox.y;
                    if (visibleArea.maxY < bbox.y + bbox.height)
                        y -= bbox.y + bbox.height - visibleArea.maxY
                }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            getTooltipCoords: function() {
                var x,
                    y,
                    min,
                    max,
                    math = Math,
                    minValue = math.min(this.lowY, this.highY),
                    maxValue = math.max(this.lowY, this.highY),
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (this.graphic) {
                    if (!this.rotated) {
                        min = math.max(visibleArea.minY, minValue);
                        max = math.min(visibleArea.maxY, maxValue);
                        x = this.x;
                        y = min + (max - min) / 2
                    }
                    else {
                        min = math.max(visibleArea.minX, minValue);
                        max = math.min(visibleArea.maxX, maxValue);
                        y = this.x;
                        x = min + (max - min) / 2
                    }
                    return {
                            x: x,
                            y: y,
                            offset: 0
                        }
                }
            },
            getTooltipFormatObject: function(tooltip) {
                var highValue = tooltip.formatValueTooltip.call({value: this.highValue}, tooltip.options),
                    openValue = tooltip.formatValueTooltip.call({value: this.openValue}, tooltip.options),
                    closeValue = tooltip.formatValueTooltip.call({value: this.closeValue}, tooltip.options),
                    lowValue = tooltip.formatValueTooltip.call({value: this.lowValue}, tooltip.options);
                return $.extend({}, this.labelFormatObject, {
                        valueText: 'h: ' + highValue + ' o: ' + openValue + ' c: ' + closeValue + ' l: ' + lowValue,
                        highValueText: highValue,
                        openValueText: openValue,
                        closeValueText: closeValue,
                        lowValueText: lowValue,
                        point: this
                    })
            },
            getColor: function() {
                return this.options.attributes.stroke
            },
            hasValue: function() {
                return this.openValue !== null && this.closeValue !== null && this.highValue !== null && this.lowValue !== null
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file stockPoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            statesConsts = series.consts.states,
            OhlcPoint = series.OhlcPoint;
        series.StockPoint = series.OhlcPoint.inherit({
            correctCoordinates: function(correctOptions) {
                var minWidth = 2 + this.options.attributes.lineWidth,
                    maxWidth = 10;
                this.width = correctOptions.width < minWidth ? minWidth : correctOptions.width > maxWidth ? maxWidth : correctOptions.width;
                this.xCorrection = correctOptions.offset
            },
            drawMarker: function(renderer, group) {
                var _this = this,
                    attributes,
                    rotated = _this.rotated,
                    createPoint = rotated ? function(x, y) {
                        return {
                                x: y,
                                y: x
                            }
                    } : function(x, y) {
                        return {
                                x: x,
                                y: y
                            }
                    };
                if (!_this.hasValue())
                    return;
                switch (_this.state) {
                    case statesConsts.selected:
                        attributes = _this.options.states.selected;
                        break;
                    case statesConsts.hover:
                        attributes = _this.options.states.hover;
                        break;
                    default:
                        attributes = _this.options.attributes;
                        _this.state = statesConsts.normal;
                        _this.fullState = statesConsts.normalMark
                }
                _this.graphic = renderer.createPath([createPoint(_this.x, _this.highY), createPoint(_this.x, _this.openY), createPoint(_this.x - _this.width / 2, _this.openY), createPoint(_this.x, _this.openY), createPoint(_this.x, _this.closeY), createPoint(_this.x + _this.width / 2, _this.closeY), createPoint(_this.x, _this.closeY), createPoint(_this.x, _this.lowY)], attributes).append(group)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file rangePoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            utils = DX.utils,
            eventsConsts = series.consts.events,
            statesConsts = series.consts.states;
        series.RangePoint = series.BasePoint.inherit({
            ctor: function(data) {
                this.callBase(data);
                this.minValue = this.initialMinValue = data.minValue !== undefined ? data.minValue : 'default';
                this.originalMinValue = data.originalMinValue;
                this.minLabelFormatObject = {
                    argument: this.initialArgument,
                    value: this.initialMinValue,
                    seriesName: this.options.seriesName,
                    originalMinValue: this.originalMinValue,
                    originalArgument: this.originalArgument
                }
            },
            dispose: function() {
                var _this = this;
                _this.minLabel = null;
                _this.minLabelBackground = null;
                _this.minConnector = null;
                _this.insideMinLabelGroup = null;
                _this.minLabelGroup = null;
                _this.maxLabel = null;
                _this.maxLabelBackground = null;
                _this.maxConnector = null;
                _this.insideMaxLabelGroup = null;
                _this.maxLabelGroup = null;
                _this.topPoints = null;
                _this.bottomPoints = null;
                _this.minLabelFormatObject = null;
                _this.callBase()
            },
            getTooltipCoords: function() {
                var x,
                    y,
                    min,
                    max,
                    minValue,
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (!this.rotated) {
                    minValue = Math.min(this.y, this.minY);
                    x = this.x;
                    min = visibleArea.minY > minValue ? visibleArea.minY : minValue;
                    max = visibleArea.maxY < minValue + this.height ? visibleArea.maxY : minValue + this.height;
                    y = min + (max - min) / 2
                }
                else {
                    minValue = Math.min(this.x, this.minX);
                    y = this.y;
                    min = visibleArea.minX > minValue ? visibleArea.minX : minValue;
                    max = visibleArea.maxX < minValue + this.width ? visibleArea.maxX : minValue + this.width;
                    x = min + (max - min) / 2
                }
                return {
                        x: x,
                        y: y,
                        offset: 0
                    }
            },
            translate: function(translator) {
                this.minX = this.minY = translator.translateY(this.minValue);
                this.callBase(translator);
                if (!this.rotated) {
                    this.height = Math.abs(this.minY - this.y);
                    this.width = 0
                }
                else {
                    this.width = Math.abs(this.x - this.minX);
                    this.height = 0
                }
            },
            isInVisibleArea: function() {
                var minArgument = Math.min(this.minX, this.x) || this.x,
                    maxArgument = Math.max(this.minX, this.x) || this.x,
                    maxValue = Math.max(this.minY, this.y) || this.y,
                    minValue = Math.min(this.minY, this.y) || this.y,
                    notVisibleBothMarkersRight,
                    notVisibleBothMarkersLeft,
                    notVisibleBothMarkersBottom,
                    notVisibleBothMarkersTop,
                    visibleTopMarker = true,
                    visibleBottomMarker = true,
                    visibleRangeArea = true,
                    visibleArea;
                if (this.translator && this.translator.getCanvasVisibleArea) {
                    visibleArea = this.translator.getCanvasVisibleArea();
                    notVisibleBothMarkersRight = visibleArea.maxX < minArgument && visibleArea.maxX < maxArgument;
                    notVisibleBothMarkersLeft = visibleArea.minX > minArgument && visibleArea.minX > maxArgument;
                    notVisibleBothMarkersTop = visibleArea.minY > minValue && visibleArea.minY > maxValue;
                    notVisibleBothMarkersBottom = visibleArea.maxY < minValue && visibleArea.maxY < maxValue;
                    if (notVisibleBothMarkersTop || notVisibleBothMarkersBottom || notVisibleBothMarkersRight || notVisibleBothMarkersLeft)
                        visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;
                    else if (!this.rotated) {
                        visibleTopMarker = visibleArea.minY < minValue && visibleArea.maxY > minValue;
                        visibleBottomMarker = visibleArea.minY < maxValue && visibleArea.maxY > maxValue
                    }
                    else {
                        visibleBottomMarker = visibleArea.minX < minArgument && visibleArea.maxX > minArgument;
                        visibleTopMarker = visibleArea.minX < maxArgument && visibleArea.maxX > maxArgument
                    }
                }
                this.visibleTopMarker = visibleTopMarker;
                this.visibleBottomMarker = visibleBottomMarker;
                this.visibleRangeArea = visibleRangeArea;
                return visibleRangeArea
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var radius = this.options.attributes.r,
                    topMarker,
                    x,
                    y,
                    bottomMarker,
                    markerGroup = renderer.createGroup().append(group);
                switch (this.options.symbol) {
                    case'circle':
                        if (!this.rotated) {
                            x = this.x;
                            y = Math.min(this.y, this.minY)
                        }
                        else {
                            x = Math.min(this.x, this.minX);
                            y = this.y
                        }
                        topMarker = this.visibleTopMarker ? renderer.createCircle(x + this.width, y, radius, this.options.attributes).append(markerGroup) : null;
                        bottomMarker = this.visibleBottomMarker ? renderer.createCircle(x, y + this.height, radius, this.options.attributes).append(markerGroup) : null;
                        break;
                    case'square':
                    case'polygon':
                    case'triangle':
                    case'cross':
                        topMarker = this.visibleTopMarker ? renderer.createArea(this.topPoints, this.options.attributes).append(markerGroup) : null;
                        bottomMarker = this.visibleBottomMarker ? renderer.createArea(this.bottomPoints, this.options.attributes).append(markerGroup) : null;
                        break
                }
                this.graphic = markerGroup;
                this.graphic.topMarker = topMarker;
                this.graphic.bottomMarker = bottomMarker;
                switch (this.state) {
                    case statesConsts.selected:
                        this.series.setPointSelectedState(this);
                        break;
                    case statesConsts.hover:
                        this.series.setPointHoverState(this);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
            },
            _populatePointShape: function(target, radius) {
                var self = this,
                    floorHalfRadius,
                    ceilHalfRadius,
                    topX,
                    topY,
                    bottomX,
                    bottomY;
                if (!this.rotated) {
                    topX = bottomX = self.x;
                    topY = Math.min(self.y, self.minY);
                    bottomY = Math.max(self.y, self.minY)
                }
                else {
                    topX = Math.max(self.x, self.minX);
                    bottomX = Math.min(self.x, self.minX);
                    topY = bottomY = self.y
                }
                if (self.options.symbol === 'square') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY - radius
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY - radius
                        }]
                }
                if (self.options.symbol === 'polygon') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY
                        }, {
                            x: topX,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY
                        }, {
                            x: topX,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY
                        }, {
                            x: bottomX,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY
                        }, {
                            x: bottomX,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY
                        }]
                }
                if (self.options.symbol === 'triangle') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - radius
                        }, {
                            x: topX,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY - radius
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY - radius
                        }]
                }
                if (self.options.symbol === 'cross') {
                    floorHalfRadius = Math.floor(radius / 2);
                    ceilHalfRadius = Math.ceil(radius / 2);
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - floorHalfRadius
                        }, {
                            x: topX - floorHalfRadius,
                            y: topY - radius
                        }, {
                            x: topX,
                            y: topY - ceilHalfRadius
                        }, {
                            x: topX + floorHalfRadius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - floorHalfRadius
                        }, {
                            x: topX + ceilHalfRadius,
                            y: topY
                        }, {
                            x: topX + radius,
                            y: topY + floorHalfRadius
                        }, {
                            x: topX + floorHalfRadius,
                            y: topY + radius
                        }, {
                            x: topX,
                            y: topY + ceilHalfRadius
                        }, {
                            x: topX - floorHalfRadius,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY + floorHalfRadius
                        }, {
                            x: topX - ceilHalfRadius,
                            y: topY
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - floorHalfRadius
                        }, {
                            x: bottomX - floorHalfRadius,
                            y: bottomY - radius
                        }, {
                            x: bottomX,
                            y: bottomY - ceilHalfRadius
                        }, {
                            x: bottomX + floorHalfRadius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - floorHalfRadius
                        }, {
                            x: bottomX + ceilHalfRadius,
                            y: bottomY
                        }, {
                            x: bottomX + radius,
                            y: bottomY + floorHalfRadius
                        }, {
                            x: bottomX + floorHalfRadius,
                            y: bottomY + radius
                        }, {
                            x: bottomX,
                            y: bottomY + ceilHalfRadius
                        }, {
                            x: bottomX - floorHalfRadius,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY + floorHalfRadius
                        }, {
                            x: bottomX - ceilHalfRadius,
                            y: bottomY
                        }]
                }
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var _this = this,
                    options = _this.options,
                    radius = options.trackerR || _this.storeTrackerR(),
                    x,
                    y;
                if (!_this.rotated) {
                    x = _this.x - radius;
                    y = Math.min(_this.y, _this.minY) - radius
                }
                else {
                    x = Math.min(_this.x, _this.minX) - radius;
                    y = _this.y - radius
                }
                _this.trackerGraphic = renderer.createRect(x, y, _this.width + 2 * radius, _this.height + 2 * radius, 0, _this._trackerAttrs).append(trackerGroup);
                _this.trackerGraphic.data({point: _this})
            },
            applyStyle: function(style) {
                if (this.graphic) {
                    this._populatePointShape(style, style.r);
                    if (this.graphic.topMarker)
                        this.graphic.topMarker.applySettings(style.topPoints ? {
                            points: style.topPoints,
                            style: style
                        } : style);
                    if (this.graphic.bottomMarker)
                        this.graphic.bottomMarker.applySettings(style.bottomPoints ? {
                            points: style.bottomPoints,
                            style: style
                        } : style)
                }
            },
            applyNormalStyle: function() {
                this.applyStyle(this.options.states.normal);
                return this.callBase()
            },
            applyHoverStyle: function() {
                this.applyStyle(this.options.states.hover);
                return this.callBase()
            },
            applySelectionStyle: function() {
                this.applyStyle(this.options.states.selected);
                return this.callBase()
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value) || !utils.isDefined(this.minLabelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    maxLabelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    minLabelText = this.formatLabel.call(this.minLabelFormatObject, labelOptions),
                    businessRange = this.translator.getBusinessRange(),
                    isDiscreteValue = this.series.options.valueAxisType === 'discrete',
                    notInverted = isDiscreteValue && (!businessRange.invertY && !this.rotated || businessRange.invertX && this.rotated) || !isDiscreteValue && this.value > this.minValue && (!businessRange.invertY && !this.rotated || !businessRange.invertX && this.rotated);
                if (!utils.isDefined(maxLabelText) || !utils.isDefined(minLabelText))
                    return;
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth) {
                    if (this.visibleTopMarker)
                        this.maxConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup);
                    if (this.visibleBottomMarker)
                        this.minConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup)
                }
                this.maxLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMaxLabelGroup = renderer.createGroup().append(this.maxLabelGroup);
                this.minLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMinLabelGroup = renderer.createGroup().append(this.minLabelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    this.maxLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMaxLabelGroup);
                    this.minLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMinLabelGroup)
                }
                this.maxLabel = renderer.createText(notInverted ? maxLabelText : minLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMaxLabelGroup);
                this.minLabel = renderer.createText(notInverted ? minLabelText : maxLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMinLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition(this.maxLabelGroup.getBBox(), this.maxConnector);
                this.correctConnectorPosition(this.minLabelGroup.getBBox(), this.minConnector)
            },
            rotateLabel: function() {
                var bboxmax = this.insideMaxLabelGroup.getBBox(),
                    bboxmin = this.insideMinLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideMaxLabelGroup.applySettings({
                    x: bboxmax.x + bboxmax.width / 2,
                    y: bboxmax.y + bboxmax.height / 2,
                    rotate: labelOptions.rotationAngle
                });
                this.insideMinLabelGroup.applySettings({
                    x: bboxmin.x + bboxmin.width / 2,
                    y: bboxmin.y + bboxmin.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            correctLabelPosition: function() {
                var maxbbox = this.insideMaxLabelGroup.getBBox(),
                    minbbox = this.insideMinLabelGroup.getBBox(),
                    topBBoxgraphic = this.graphic && this.graphic.topMarker ? this.graphic.topMarker.getBBox() : {
                        x: this.rotated ? Math.max(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    bottomBBoxgraphic = this.graphic && this.graphic.bottomMarker ? this.graphic.bottomMarker.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.max(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    x1 = 0,
                    y1 = 0,
                    x2 = 0,
                    y2 = 0;
                if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        y1 += topBBoxgraphic.y - maxbbox.y - maxbbox.height - this.LABEL_OFFSET;
                        y2 += bottomBBoxgraphic.y + bottomBBoxgraphic.height - minbbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += topBBoxgraphic.y - maxbbox.y - maxbbox.height / 2 + topBBoxgraphic.height / 2;
                        x1 += topBBoxgraphic.x + topBBoxgraphic.width - maxbbox.x + this.LABEL_OFFSET;
                        x2 += bottomBBoxgraphic.x - minbbox.x - minbbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        y1 += topBBoxgraphic.y + topBBoxgraphic.height - maxbbox.y + this.LABEL_OFFSET;
                        y2 += bottomBBoxgraphic.y - minbbox.y - minbbox.height - this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += topBBoxgraphic.y - maxbbox.y - maxbbox.height / 2 + topBBoxgraphic.height / 2;
                        x1 += topBBoxgraphic.x - maxbbox.x - maxbbox.width - this.LABEL_OFFSET;
                        x2 += bottomBBoxgraphic.x + bottomBBoxgraphic.width - minbbox.x + this.LABEL_OFFSET
                    }
                x1 += this.options.label.horizontalOffset;
                y1 += this.options.label.verticalOffset;
                x2 += this.options.label.horizontalOffset;
                y2 += this.options.label.verticalOffset;
                this.checkLabelPosition(x1, y1, x2, y2)
            },
            checkLabelPosition: function(x1, y1, x2, y2) {
                var maxgroupbbox = this.insideMaxLabelGroup.getBBox(),
                    mingroupbbox = this.insideMinLabelGroup.getBBox(),
                    newMaxbbox = {},
                    newMinbbox = {},
                    topBBoxgraphic = this.graphic && this.graphic.topMarker ? this.graphic.topMarker.getBBox() : {
                        x: this.rotated ? Math.max(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    bottomBBoxgraphic = this.graphic && this.graphic.bottomMarker ? this.graphic.bottomMarker.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.max(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    maxX = maxgroupbbox.x + x1,
                    maxY = maxgroupbbox.y + y1,
                    minX = mingroupbbox.x + x2,
                    minY = mingroupbbox.y + y2;
                var visibleArea = this.translator.getCanvasVisibleArea();
                if (this.visibleRangeArea) {
                    if (!this.rotated) {
                        if (visibleArea.minX > maxX && this.adjustSeriesLabels)
                            x1 += visibleArea.minX - maxX;
                        if (visibleArea.minX > minX && this.adjustSeriesLabels)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width && this.adjustSeriesLabels)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.maxX < minX + mingroupbbox.width && this.adjustSeriesLabels)
                            x2 -= minX + mingroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > maxY)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        newMaxbbox.y = maxgroupbbox.y + y1;
                        newMinbbox.y = mingroupbbox.y + y2;
                        if (newMaxbbox.y + maxgroupbbox.height > newMinbbox.y) {
                            y1 -= (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            y2 += (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            newMaxbbox.y = maxgroupbbox.y + y1;
                            newMinbbox.y = mingroupbbox.y + y2;
                            if (visibleArea.minY > newMaxbbox.y) {
                                y2 += visibleArea.minY - newMaxbbox.y;
                                y1 += visibleArea.minY - newMaxbbox.y
                            }
                            else if (visibleArea.maxY < newMinbbox.y + mingroupbbox.height) {
                                y1 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY;
                                y2 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY
                            }
                        }
                    }
                    if (this.rotated) {
                        if (visibleArea.minX > minX)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > minY && this.adjustSeriesLabels)
                            y2 += visibleArea.minY - minY;
                        if (visibleArea.minY > maxY && this.adjustSeriesLabels)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height && this.adjustSeriesLabels)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        if (visibleArea.maxY < maxY + maxgroupbbox.height && this.adjustSeriesLabels)
                            y1 -= maxY + maxgroupbbox.height - visibleArea.maxY;
                        newMaxbbox.x = maxgroupbbox.x + x1;
                        newMinbbox.x = mingroupbbox.x + x2;
                        if (newMaxbbox.x < newMinbbox.x + mingroupbbox.width) {
                            x1 += (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            x2 -= (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            newMaxbbox.x = maxgroupbbox.x + x1;
                            newMinbbox.x = mingroupbbox.x + x2;
                            if (visibleArea.minX > newMinbbox.x) {
                                x2 += visibleArea.minX - newMinbbox.x;
                                x1 += visibleArea.minX - newMinbbox.x
                            }
                            else if (visibleArea.maxX < newMaxbbox.x + maxgroupbbox.width) {
                                x1 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX;
                                x2 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX
                            }
                        }
                    }
                }
                this.insideMaxLabelGroup.move(~~x1, ~~y1);
                this.insideMinLabelGroup.move(~~x2, ~~y2)
            },
            correctBackgroundPosition: function() {
                if (!this.maxLabelBackground || !this.minLabelBackground)
                    return;
                var maxbbox = this.maxLabel.getBBox(),
                    minbbox = this.minLabel.getBBox(),
                    x1 = maxbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    x2 = minbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y1 = maxbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    y2 = minbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width1 = maxbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    width2 = minbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height1 = maxbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y,
                    height2 = minbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.maxLabelBackground.applySettings({
                    x: x1,
                    y: y1,
                    width: width1,
                    height: height1
                });
                this.minLabelBackground.applySettings({
                    x: x2,
                    y: y2,
                    width: width2,
                    height: height2
                })
            },
            correctConnectorPosition: function(bbox, connector) {
                if (!connector)
                    return;
                var bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: this.height,
                        width: this.width
                    },
                    centerLabelY = this.maxLabelBackground || this.minLabelBackground ? bbox.y + bbox.height / 2 : null,
                    centerLabelX = this.maxLabelBackground || this.minLabelBackground ? bbox.x + bbox.width / 2 : null,
                    x1,
                    x2,
                    y1,
                    y2;
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return false;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return false;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getTooltipFormatObject: function(tooltip) {
                var minValue = tooltip.formatValueTooltip.call({value: this.initialMinValue}, tooltip.options),
                    value = tooltip.formatValueTooltip.call({value: this.initialValue}, tooltip.options);
                return {
                        argument: this.initialArgument,
                        valueText: minValue + ' - ' + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: this.initialMinValue,
                        rangeValue2: this.initialValue,
                        seriesName: this.options.seriesName,
                        point: this,
                        originalMinValue: this.originalMinValue,
                        originalValue: this.originalValue,
                        originalArgument: this.originalArgument
                    }
            },
            animate: function() {
                var _this = this,
                    graphic = _this.graphic;
                if (!graphic || !_this.translator)
                    return;
                if (!_this.rotated) {
                    if (graphic.topMarker)
                        graphic.topMarker.move(0, _this.defaultY - Math.min(_this.minY, _this.y));
                    if (graphic.bottomMarker)
                        graphic.bottomMarker.move(0, _this.defaultY - Math.max(_this.minY, _this.y))
                }
                else {
                    if (graphic.topMarker)
                        graphic.topMarker.move(_this.defaultX - Math.max(_this.minX, _this.x), 0);
                    if (graphic.bottomMarker)
                        graphic.bottomMarker.move(_this.defaultX - Math.min(_this.minX, _this.x), 0)
                }
                if (graphic.topMarker)
                    graphic.topMarker.move(0, 0, true);
                if (graphic.bottomMarker)
                    graphic.bottomMarker.move(0, 0, true)
            },
            hasValue: function() {
                return this.initialValue !== null && this.initialMinValue !== null
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file rangeBarPoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            BarPoint = series.BarPoint,
            utils = DX.utils;
        series.RangeBarPoint = series.BarPoint.inherit({
            ctor: function(data) {
                this.callBase(data);
                this.minValue = this.initialMinValue = data.minValue !== undefined ? data.minValue : 'default';
                this.originalMinValue = data.originalMinValue;
                this.minLabelFormatObject = {
                    argument: this.initialArgument,
                    value: this.initialMinValue,
                    seriesName: this.options.seriesName,
                    originalMinValue: this.originalMinValue,
                    originalArgument: this.originalArgument
                }
            },
            dispose: function() {
                var _this = this;
                _this.minLabel = null;
                _this.minLabelBackground = null;
                _this.minConnector = null;
                _this.insideMinLabelGroup = null;
                _this.minLabelGroup = null;
                _this.maxLabel = null;
                _this.maxLabelBackground = null;
                _this.maxConnector = null;
                _this.insideMaxLabelGroup = null;
                _this.maxLabelGroup = null;
                _this.minLabelFormatObject = null;
                _this.callBase()
            },
            translate: function(translator) {
                if (!this.hasValue())
                    return;
                this.callBase(translator);
                if (this.rotated)
                    this.width = this.width || 1;
                else
                    this.height = this.height || 1
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue() && (!utils.isDefined(this.labelFormatObject.value) || !utils.isDefined(this.minLabelFormatObject.value)))
                    return;
                var labelOptions = this.options.label,
                    maxLabelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    minLabelText = this.formatLabel.call(this.minLabelFormatObject, labelOptions),
                    businessRange = this.translator.getBusinessRange(),
                    isDiscreteValue = this.series.options.valueAxisType === 'discrete',
                    notInverted = isDiscreteValue && (!businessRange.invertY && !this.rotated || businessRange.invertX && this.rotated) || !isDiscreteValue && this.value > this.minValue && (!businessRange.invertY && !this.rotated || !businessRange.invertX && this.rotated);
                if (!utils.isDefined(maxLabelText) || !utils.isDefined(minLabelText))
                    return;
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth) {
                    this.maxConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup);
                    this.minConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup)
                }
                this.maxLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMaxLabelGroup = renderer.createGroup().append(this.maxLabelGroup);
                this.minLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMinLabelGroup = renderer.createGroup().append(this.minLabelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    this.maxLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMaxLabelGroup);
                    this.minLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMinLabelGroup)
                }
                this.maxLabel = renderer.createText(notInverted ? maxLabelText : minLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMaxLabelGroup);
                this.minLabel = renderer.createText(notInverted ? minLabelText : maxLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMinLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition(this.maxLabelGroup.getBBox(), this.maxConnector);
                this.correctConnectorPosition(this.minLabelGroup.getBBox(), this.minConnector)
            },
            rotateLabel: function() {
                var bboxmax = this.insideMaxLabelGroup.getBBox(),
                    bboxmin = this.insideMinLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideMaxLabelGroup.applySettings({
                    x: bboxmax.x + bboxmax.width / 2,
                    y: bboxmax.y + bboxmax.height / 2,
                    rotate: labelOptions.rotationAngle
                });
                this.insideMinLabelGroup.applySettings({
                    x: bboxmin.x + bboxmin.width / 2,
                    y: bboxmin.y + bboxmin.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            correctLabelPosition: function() {
                var maxbbox = this.insideMaxLabelGroup.getBBox(),
                    minbbox = this.insideMinLabelGroup.getBBox(),
                    bboxgraphic = this.graphic.getBBox(),
                    x1 = 0,
                    y1 = 0,
                    x2 = 0,
                    y2 = 0;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        x1 = x2 += bboxgraphic.width / 2;
                        y1 += bboxgraphic.y - maxbbox.y - maxbbox.height - this.LABEL_OFFSET;
                        y2 += bboxgraphic.y + bboxgraphic.height - minbbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += bboxgraphic.y - maxbbox.y - maxbbox.height / 2 + bboxgraphic.height / 2;
                        x1 += bboxgraphic.x + bboxgraphic.width - maxbbox.x + this.LABEL_OFFSET;
                        x2 += bboxgraphic.x - minbbox.x - minbbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        x1 = x2 += bboxgraphic.width / 2;
                        y1 += bboxgraphic.y - maxbbox.y + this.LABEL_OFFSET;
                        y2 += bboxgraphic.y + bboxgraphic.height - minbbox.y - minbbox.height - this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += bboxgraphic.y - maxbbox.y - maxbbox.height / 2 + bboxgraphic.height / 2;
                        x1 += bboxgraphic.x + bboxgraphic.width - maxbbox.x - maxbbox.width - this.LABEL_OFFSET;
                        x2 += bboxgraphic.x - minbbox.x + this.LABEL_OFFSET
                    }
                x1 += this.options.label.horizontalOffset;
                y1 += this.options.label.verticalOffset;
                x2 += this.options.label.horizontalOffset;
                y2 += this.options.label.verticalOffset;
                this.checkLabelPosition(x1, y1, x2, y2)
            },
            checkLabelPosition: function(x1, y1, x2, y2) {
                var maxgroupbbox = this.insideMaxLabelGroup.getBBox(),
                    mingroupbbox = this.insideMinLabelGroup.getBBox(),
                    newMaxbbox = {},
                    newMinbbox = {},
                    bboxgraphic = this.graphic.getBBox(),
                    maxX = maxgroupbbox.x + x1,
                    maxY = maxgroupbbox.y + y1,
                    minX = mingroupbbox.x + x2,
                    minY = mingroupbbox.y + y2;
                var visibleArea = this.translator.getCanvasVisibleArea();
                if (visibleArea.minX <= bboxgraphic.x + bboxgraphic.width && visibleArea.maxX >= bboxgraphic.x && visibleArea.minY <= bboxgraphic.y + bboxgraphic.height && visibleArea.maxY >= bboxgraphic.y) {
                    if (!this.rotated) {
                        if (visibleArea.minX > maxX && this.adjustSeriesLabels)
                            x1 += visibleArea.minX - maxX;
                        if (visibleArea.minX > minX && this.adjustSeriesLabels)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width && this.adjustSeriesLabels)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.maxX < minX + mingroupbbox.width && this.adjustSeriesLabels)
                            x2 -= minX + mingroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > maxY)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        newMaxbbox.y = maxgroupbbox.y + y1;
                        newMinbbox.y = mingroupbbox.y + y2;
                        if (newMaxbbox.y + maxgroupbbox.height > newMinbbox.y) {
                            y1 -= (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            y2 += (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            newMaxbbox.y = maxgroupbbox.y + y1;
                            newMinbbox.y = mingroupbbox.y + y2;
                            if (visibleArea.minY > newMaxbbox.y) {
                                y2 += visibleArea.minY - newMaxbbox.y;
                                y1 += visibleArea.minY - newMaxbbox.y
                            }
                            else if (visibleArea.maxY < newMinbbox.y + mingroupbbox.height) {
                                y1 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY;
                                y2 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY
                            }
                        }
                    }
                    if (this.rotated) {
                        if (visibleArea.minX > minX)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > minY && this.adjustSeriesLabels)
                            y2 += visibleArea.minY - minY;
                        if (visibleArea.minY > maxY && this.adjustSeriesLabels)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height && this.adjustSeriesLabels)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        if (visibleArea.maxY < maxY + maxgroupbbox.height && this.adjustSeriesLabels)
                            y1 -= maxY + maxgroupbbox.height - visibleArea.maxY;
                        newMaxbbox.x = maxgroupbbox.x + x1;
                        newMinbbox.x = mingroupbbox.x + x2;
                        if (newMaxbbox.x < newMinbbox.x + mingroupbbox.width) {
                            x1 += (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            x2 -= (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            newMaxbbox.x = maxgroupbbox.x + x1;
                            newMinbbox.x = mingroupbbox.x + x2;
                            if (visibleArea.minX > newMinbbox.x) {
                                x2 += visibleArea.minX - newMinbbox.x;
                                x1 += visibleArea.minX - newMinbbox.x
                            }
                            else if (visibleArea.maxX < newMaxbbox.x + maxgroupbbox.width) {
                                x1 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX;
                                x2 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX
                            }
                        }
                    }
                }
                this.insideMaxLabelGroup.move(~~x1, ~~y1);
                this.insideMinLabelGroup.move(~~x2, ~~y2)
            },
            correctBackgroundPosition: function() {
                if (!this.maxLabelBackground || !this.minLabelBackground)
                    return;
                var maxbbox = this.maxLabel.getBBox(),
                    minbbox = this.minLabel.getBBox(),
                    x1 = maxbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    x2 = minbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y1 = maxbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    y2 = minbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width1 = maxbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    width2 = minbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height1 = maxbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y,
                    height2 = minbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.maxLabelBackground.applySettings({
                    x: x1,
                    y: y1,
                    width: width1,
                    height: height1
                });
                this.minLabelBackground.applySettings({
                    x: x2,
                    y: y2,
                    width: width2,
                    height: height2
                })
            },
            correctConnectorPosition: function(bbox, connector) {
                if (!connector)
                    return;
                var bboxgraphic = this.graphic.getBBox(),
                    x1,
                    x2,
                    y1,
                    y2,
                    centerLabelY = this.maxLabelBackground || this.minLabelBackground ? bbox.y + bbox.height / 2 : null,
                    centerLabelX = this.maxLabelBackground || this.minLabelBackground ? bbox.x + bbox.width / 2 : null;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return false;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return false;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getTooltipFormatObject: function(tooltip) {
                var minValue = tooltip.formatValueTooltip.call({value: this.initialMinValue}, tooltip.options),
                    value = tooltip.formatValueTooltip.call({value: this.initialValue}, tooltip.options);
                return {
                        argument: this.initialArgument,
                        valueText: minValue + ' - ' + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: this.initialMinValue,
                        rangeValue2: this.initialValue,
                        seriesName: this.options.seriesName,
                        point: this,
                        originalMinValue: this.originalMinValue,
                        originalValue: this.originalValue,
                        originalArgument: this.originalArgument
                    }
            },
            hasValue: function() {
                return this.initialValue !== null && this.initialMinValue !== null
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file piePoint.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            statesConsts = series.consts.states,
            round = Math.round,
            getCosAndSin = DX.utils.getCosAndSin;
        series.PiePoint = series.BasePoint.inherit({
            ctor: function(data) {
                this.centerX = 300;
                this.centerY = 150;
                this.radiusOuter = 120;
                this.radiusInner = 0;
                this.INDENT_FROM_PIE = 30;
                this.CONNECTOR_LENGTH = 20;
                this.setLabelEllipsis = false;
                this.callBase(data);
                this.minValue = 0;
                this.tag = data.tag;
                this._pieTrackerAttrs = $.extend({}, this._trackerAttrs, {
                    inh: false,
                    fill: 'grey'
                })
            },
            translate: function(translator) {
                var self = this;
                self.translator = translator = translator || self.translator;
                if (!self.translator)
                    return;
                self.fromAngle = translator.translate(self.minValue);
                self.toAngle = translator.translate(self.value);
                self.middleAngle = translator.translate((self.value - self.minValue) / 2 + self.minValue)
            },
            correctValue: function(correction, percent) {
                var self = this;
                self.value += correction;
                self.minValue += correction;
                self.percent = percent;
                self.labelFormatObject.percent = percent
            },
            getTooltipCoords: function() {
                var angleFunctions = getCosAndSin(this.middleAngle);
                return {
                        x: this.centerX + (this.radiusInner + (this.radiusOuter - this.radiusInner) / 2) * angleFunctions.cos,
                        y: this.centerY - (this.radiusInner + (this.radiusOuter - this.radiusInner) / 2) * angleFunctions.sin,
                        offset: 0
                    }
            },
            correctPosition: function(correction) {
                var self = this;
                self.radiusInner = correction.radiusInner;
                self.radiusOuter = correction.radiusOuter;
                self.centerX = correction.centerX;
                self.centerY = correction.centerY
            },
            drawMarker: function(renderer, group) {
                this.options.attributes.inh = false;
                this.graphic = renderer.createArc(this.centerX, this.centerY, this.radiusOuter, this.radiusInner, this.toAngle, this.fromAngle, this.options.attributes).append(group);
                switch (this.state) {
                    case statesConsts.selected:
                        this.series.setPointSelectedState(this);
                        break;
                    case statesConsts.hover:
                        this.series.setPointHoverState(this);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                this.trackerGraphic = renderer.createArc(this.centerX, this.centerY, this.radiusOuter, this.radiusInner, this.toAngle, this.fromAngle, this._pieTrackerAttrs).append(trackerGroup);
                this.trackerGraphic.data({point: this})
            },
            correctLabel: function() {
                this.correctLabelPosition();
                this.checkEllipsis();
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.checkLabelPosition()
            },
            correctLabelPosition: function() {
                var bbox = this.label.getBBox(),
                    labelOptions = this.options.label,
                    angleFunctions = getCosAndSin(this.middleAngle),
                    align = 'center',
                    rad = this.radiusOuter + labelOptions.radialOffset,
                    x,
                    y;
                switch (labelOptions.position) {
                    case'outside':
                        rad += this.INDENT_FROM_PIE;
                        if (angleFunctions.cos > 0.1)
                            align = 'left';
                        else if (angleFunctions.cos < -0.1)
                            align = 'right';
                        x = this.centerX + rad * angleFunctions.cos;
                        break;
                    case'inside':
                        rad -= this.INDENT_FROM_PIE;
                        x = this.centerX + rad * angleFunctions.cos;
                        break;
                    case'columns':
                        rad += this.CONNECTOR_LENGTH;
                        if (angleFunctions.cos > 0) {
                            align = 'right';
                            x = this.series.canvas.width - this.series.canvas.right
                        }
                        else if (angleFunctions.cos < 0) {
                            align = 'left';
                            x = this.series.canvas.left
                        }
                        break
                }
                y = round(this.label.settings.y + this.centerY - rad * angleFunctions.sin - bbox.y - bbox.height / 2);
                this.label.applySettings({
                    x: x,
                    y: y,
                    align: align
                })
            },
            correctConnectorPosition: function() {
                if (this.options.label.position === 'inside')
                    return;
                if (!this.connector)
                    return;
                var angleFunctions = getCosAndSin(round(this.middleAngle)),
                    attributes = this.series.styles.attributes,
                    borderWidth = this.series.userOptions.containerBackgroundColor === attributes.stroke ? ~~(attributes.strokeWidth / 2) : ~~(-attributes.strokeWidth / 2),
                    rad = this.radiusOuter,
                    x1 = round(this.centerX + (rad - borderWidth) * angleFunctions.cos),
                    y1 = round(this.centerY - (rad - borderWidth) * angleFunctions.sin),
                    x2,
                    y2,
                    x3,
                    y3,
                    box,
                    labelOptions = this.options.label,
                    connector;
                x2 = round(this.centerX + (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.cos);
                if (labelOptions.position === 'outside') {
                    y2 = round(this.centerY - (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.sin);
                    this.connector.applySettings({points: [x1, y1, x2, y2]})
                }
                if (labelOptions.position === 'columns') {
                    box = this.insideLabelGroup.getBBox();
                    box.x = box.x + (this.insideLabelGroup.settings.translateX || 0);
                    box.y = box.y + (this.insideLabelGroup.settings.translateY || 0);
                    y2 = box.y + box.height / 2;
                    if (this.labelBackground)
                        x3 = box.x + box.width / 2;
                    else if (angleFunctions.cos < 0)
                        x3 = box.x + box.width;
                    else if (angleFunctions.cos > 0)
                        x3 = box.x;
                    y3 = y2;
                    this.connector.applySettings({points: [{
                                x: x1,
                                y: y1
                            }, {
                                x: x2,
                                y: y2
                            }, {
                                x: x3,
                                y: y3
                            }]})
                }
            },
            rotateLabel: function() {
                var labelOptions = this.options.label,
                    rad = this.radiusOuter + labelOptions.radialOffset,
                    angleFunctions = getCosAndSin(this.middleAngle),
                    x,
                    y,
                    box = this.insideLabelGroup.getBBox();
                switch (labelOptions.position) {
                    case'outside':
                        x = this.centerX + (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.cos;
                        y = this.centerY - (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.sin;
                        break;
                    case'inside':
                        x = box.x + box.width / 2;
                        y = box.y + box.height / 2;
                        break;
                    case'columns':
                        x = box.x + box.width / 2;
                        y = box.y + box.height / 2;
                        break
                }
                this.insideLabelGroup.applySettings({
                    x: x,
                    y: y,
                    rotate: labelOptions.rotationAngle
                })
            },
            checkEllipsis: function() {
                var self = this,
                    i,
                    LABEL_OFFSET = 10,
                    labelBox,
                    text,
                    textLength = 0,
                    linesLength = [],
                    numLastSpan = [],
                    maxLength,
                    numSpan,
                    index,
                    x,
                    y,
                    width,
                    rotationAngleFunction = getCosAndSin(self.options.label.rotationAngle),
                    canvas = self.series.canvas,
                    labelOptions = this.options.label,
                    angleFunctions = getCosAndSin(this.middleAngle),
                    borderX = this.centerX + (this.radiusOuter + this.CONNECTOR_LENGTH) * angleFunctions.cos;
                if (!self.label.tspans || !self.setLabelEllipsis)
                    return;
                labelBox = self.label.getBBox();
                x = labelBox.x + labelBox.width < self.centerX ? labelBox.x + labelBox.width : labelBox.x;
                y = labelBox.y + labelBox.height / 2;
                width = labelBox.x + labelBox.width < self.centerX ? -labelBox.width : labelBox.width;
                if (y + width * rotationAngleFunction.sin > canvas.height - canvas.bottom + LABEL_OFFSET || y + width * rotationAngleFunction.sin < canvas.top - LABEL_OFFSET || x + width * rotationAngleFunction.cos < canvas.left - LABEL_OFFSET || x + width * rotationAngleFunction.cos > canvas.width - canvas.right + LABEL_OFFSET || labelOptions.position === 'columns' && (angleFunctions.cos < 0 && borderX < x || angleFunctions.cos > 0 && borderX > x))
                    for (i = 0; i < self.label.tspans.length; i++) {
                        textLength += self.label.tspans[i].element.getNumberOfChars();
                        if (!self.label.tspans[i + 1] || self.label.tspans[i + 1].settings.dy > 0) {
                            linesLength.push(textLength);
                            numLastSpan.push(i);
                            textLength = 0
                        }
                    }
                while (y + width * rotationAngleFunction.sin > canvas.height - canvas.bottom + LABEL_OFFSET || y + width * rotationAngleFunction.sin < canvas.top - LABEL_OFFSET || x + width * rotationAngleFunction.cos < canvas.left - LABEL_OFFSET || x + width * rotationAngleFunction.cos > canvas.width - canvas.right + LABEL_OFFSET || labelOptions.position === 'columns' && (angleFunctions.cos < 0 && borderX < x || angleFunctions.cos > 0 && borderX > x)) {
                    maxLength = Math.max.apply(null, linesLength);
                    if (maxLength === 0)
                        break;
                    index = $.inArray(maxLength, linesLength);
                    numSpan = numLastSpan[index];
                    if (self.label.tspans[numSpan].element.textContent === "...") {
                        if (self.label.tspans[numSpan].settings.dy > 0 || !self.label.tspans[numSpan - 1])
                            linesLength[index] = 0;
                        else if (self.label.tspans[numSpan - 1]) {
                            self.label.tspans[numSpan].element.textContent = '';
                            numLastSpan[index] -= 1;
                            self.label.tspans[numSpan - 1].element.textContent += "..."
                        }
                    }
                    else {
                        text = self.label.tspans[numSpan].element.textContent;
                        text = text.substr(0, text.length - 1 - 3) + "...";
                        self.label.tspans[numSpan].element.textContent = text;
                        linesLength[index] -= 1
                    }
                    labelBox = self.label.getBBox();
                    x = labelBox.x + labelBox.width < self.centerX ? labelBox.x + labelBox.width : labelBox.x;
                    y = labelBox.y + labelBox.height / 2;
                    width = labelBox.x + labelBox.width < self.centerX ? -labelBox.width : labelBox.width
                }
            },
            checkLabelPosition: function() {
                var self = this,
                    groupBox = self.insideLabelGroup.getBBox(),
                    canvas = self.series.canvas;
                if (groupBox.y + groupBox.height > canvas.height - canvas.bottom)
                    self.insideLabelGroup.move(0, canvas.height - groupBox.y - groupBox.height - canvas.bottom);
                else if (groupBox.y < canvas.top)
                    self.insideLabelGroup.move(0, canvas.top - groupBox.y);
                if (groupBox.x + groupBox.width > canvas.width - canvas.right)
                    self.insideLabelGroup.move(canvas.width - canvas.right - groupBox.x - groupBox.width, 0);
                else if (groupBox.x < canvas.left)
                    self.insideLabelGroup.move(canvas.left - groupBox.x, 0)
            },
            animate: function(){},
            isInVisibleArea: function() {
                return true
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file pointFactory.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.pointFactory = {createPoint: function(seriesType, pointOptions) {
                seriesType = (seriesType || '').toLowerCase();
                switch (seriesType) {
                    case'line':
                        return new series.BasePoint(pointOptions);
                    case'stackedline':
                        return new series.BasePoint(pointOptions);
                    case'fullstackedline':
                        return new series.BasePoint(pointOptions);
                    case'area':
                        return new series.BasePoint(pointOptions);
                    case'stackedarea':
                        return new series.BasePoint(pointOptions);
                    case'fullstackedarea':
                        return new series.BasePoint(pointOptions);
                    case'bar':
                        return new series.BarPoint(pointOptions);
                    case'stackedbar':
                        return new series.BarPoint(pointOptions);
                    case'fullstackedbar':
                        return new series.BarPoint(pointOptions);
                    case'spline':
                        return new series.BasePoint(pointOptions);
                    case'splinearea':
                        return new series.BasePoint(pointOptions);
                    case'scatter':
                        return new series.BasePoint(pointOptions);
                    case'candlestick':
                        return new series.OhlcPoint(pointOptions);
                    case'stock':
                        return new series.StockPoint(pointOptions);
                    case'rangearea':
                        return new series.RangePoint(pointOptions);
                    case'rangesplinearea':
                        return new series.RangePoint(pointOptions);
                    case'rangebar':
                        return new series.RangeBarPoint(pointOptions);
                    case'pie':
                        return new series.PiePoint(pointOptions);
                    case'doughnut':
                        return new series.PiePoint(pointOptions);
                    case'stepline':
                        return new series.BasePoint(pointOptions);
                    case'steparea':
                        return new series.BasePoint(pointOptions);
                    default:
                        return null
                }
            }}
    })(jQuery, DevExpress);
    /*! Module viz, file baseSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            eventsConsts = series.consts.events,
            statesConsts = series.consts.states,
            utils = DX.utils,
            ParseUtils = DX.viz.core.ParseUtils,
            SERIES_VALUE_MARGIN_PRIORITY = 20,
            FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY = 15,
            SERIES_LABEL_VALUE_MARGIN = 0.3,
            ALL_SERIES_POINTS_MODE = 'allseriespoints',
            INCLUDE_POINTS_MODE = 'includepoints',
            HOVER_CHECK = 0,
            SELECTION_CHECK = 1,
            BAR_ZERO_VALUE_MARGIN_PRIORITY = 20;
        series.BaseSeries = DX.Class.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType || 'unknown';
                this.isRangeSeries = isRangeSeries;
                this.renderer = renderer;
                this._rawData = data || [];
                this._parseOptions(options);
                this._parsedUserOptions = $.extend(true, {}, options);
                this._parseInputData(this._rawData);
                this.userOptions = options;
                this.tag = options.tag
            },
            dispose: function() {
                var _this = this;
                _this.off();
                $.each(_this.points || [], function(_, point) {
                    point.dispose()
                });
                _this.points = null;
                $.each(_this.trackerElements || [], function(_, tracker) {
                    tracker.removeData()
                });
                _this.trackerElements = null;
                _this.hoverPattern = null;
                _this.selectedPattern = null;
                _this.seriesGroup = null;
                _this.pointsByArgument = null;
                _this.segments = null;
                _this.preparedSegments = null;
                _this.renderer = null;
                _this._rawData = null;
                _this._parsedUserOptions = null;
                _this.options = null;
                _this.userOptions = null;
                _this.tag = null;
                _this._validationResult = null;
                _this.rangeData = null;
                _this.translator = null;
                _this.styles = null;
                _this._parseUtils = null
            },
            _checkValue: function(params) {
                if (!utils.isDefined(params.value)) {
                    this._validationResult.error = this._errorMessages.missingFieldMessage(params.field);
                    this.options.incidentOccured.call(null, this._errorMessages.missingFieldMessage(params.field));
                    return false
                }
                if (utils.isString(params.value)) {
                    params.axisType = 'discrete';
                    params.type = 'string'
                }
                else if (utils.isDate(params.value)) {
                    params.axisType = params.axisType || 'continuous';
                    params.type = 'datetime'
                }
                else if (utils.isNumber(params.value)) {
                    params.axisType = params.axisType || 'continuous';
                    params.type = 'numeric'
                }
                else {
                    this._validationResult.error = this._errorMessages.unsupportedFieldMessage(params.field);
                    this.options.incidentOccured.call(null, this._errorMessages.unsupportedFieldMessage(params.field));
                    return false
                }
                return true
            },
            _correctAxisType: function(axisType, categories) {
                return axisType && (axisType === 'discrete' || axisType === 'continuous') ? axisType : categories && categories.length ? 'discrete' : ''
            },
            reinitData: function(data) {
                this._parseInputData(data)
            },
            _errorMessages: {
                missingFieldMessage: function(field) {
                    return "Data source does not contain the '" + field + "' field."
                },
                unsupportedFieldMessage: function(field) {
                    return "The '" + field + "' field contains data of unsupported type."
                },
                incorrectDataMessage: function() {
                    return "Data source contains unsupported data."
                },
                incompatibleTypesDataMessage: function(unit) {
                    if (unit === 'argument')
                        return "The agrument type and argument axis type are incompatible.";
                    return "The value type and value axis type are incompatible."
                },
                dataItemMissingMessage: function(entity) {
                    if (entity === 'argument')
                        return "An argument is missed in the specified data.";
                    return "A value is missed in the specified data."
                },
                numericParsingMessage: function(entity) {
                    return "A point's " + entity + " cannot be parsed to a correct numeric value."
                },
                dateParsingMessage: function(entity) {
                    return "A point's " + entity + " cannot be parsed to a correct date."
                }
            },
            getRangeData: function(visibleRange) {
                if (this._validationResult.error)
                    return {};
                var self = this,
                    options = self.options,
                    argumentCategories = options.argumentCategories,
                    discreteArgumentAxis = options.argumentAxisType === 'discrete',
                    argumentType = options.argumentType,
                    valueCategories = options.valueCategories,
                    discreteValueAxis = options.valueAxisType === 'discrete',
                    valueType = options.valueType,
                    rangeData = {
                        visibleValCategories: [],
                        categoriesVal: [],
                        categoriesArg: []
                    },
                    points = self.points,
                    pointsLength = points && points.length,
                    lastVisibleIndex,
                    intervalVal,
                    intervalArg;
                function addToVisibleVal(val) {
                    if (discreteValueAxis) {
                        if ($.inArray(val, rangeData.visibleValCategories) === -1)
                            rangeData.visibleValCategories.push(val)
                    }
                    else {
                        if (val < rangeData.minVisibleVal || !utils.isDefined(rangeData.minVisibleVal))
                            rangeData.minVisibleVal = val;
                        if (val > rangeData.maxVisibleVal || !utils.isDefined(rangeData.maxVisibleVal))
                            rangeData.maxVisibleVal = val
                    }
                }
                var processArgument = function(arg, prevArg) {
                        var interval;
                        if (arg < rangeData.minArg || !utils.isDefined(rangeData.minArg))
                            rangeData.minArg = arg;
                        if (arg > rangeData.maxArg || !utils.isDefined(rangeData.maxArg))
                            rangeData.maxArg = arg;
                        if (utils.isDefined(prevArg))
                            interval = Math.abs(arg - prevArg);
                        if (utils.isDefined(interval) && (interval < rangeData.minIntervalArg || !utils.isDefined(rangeData.minIntervalArg)))
                            rangeData.minIntervalArg = interval
                    };
                var processValue = function(val, minVal, prevVal, prevMinVal) {
                        var interval;
                        if (val < rangeData.minVal || !utils.isDefined(rangeData.minVal))
                            rangeData.minVal = val;
                        if (val > rangeData.maxVal || !utils.isDefined(rangeData.maxVal))
                            rangeData.maxVal = val;
                        if (self.isRangeSeries) {
                            if (minVal < rangeData.minVal || !utils.isDefined(rangeData.minVal))
                                rangeData.minVal = minVal;
                            if (minVal > rangeData.maxVal || !utils.isDefined(rangeData.maxVal))
                                rangeData.maxVal = minVal
                        }
                        if (utils.isDefined(prevVal))
                            interval = Math.abs(val - prevVal);
                        if (self.isRangeSeries && utils.isDefined(prevMinVal))
                            interval = Math.min(interval, Math.abs(minVal - prevMinVal));
                        if (utils.isDefined(interval) && (interval < rangeData.minIntervalVal || !utils.isDefined(rangeData.minIntervalVal)))
                            rangeData.minIntervalVal = interval
                    };
                function unique(array, field) {
                    var values = {};
                    return $.map(array, function(item) {
                            var value = item[field];
                            var result = !values[value] ? value : null;
                            values[value] = true;
                            return result
                        })
                }
                if (discreteArgumentAxis) {
                    rangeData.categoriesArg = unique(points, 'argument');
                    processArgument = $.noop
                }
                if (discreteValueAxis) {
                    rangeData.categoriesVal = unique(points, 'value');
                    processValue = $.noop
                }
                if (pointsLength) {
                    $.each(points, function(i, point) {
                        var prevPoint,
                            val = point.value,
                            minVal = point.minValue,
                            arg = point.argument,
                            prevVal,
                            prevMinVal,
                            prevArg;
                        if (i !== 0) {
                            prevPoint = points[i - 1];
                            prevVal = prevPoint.value;
                            prevMinVal = prevPoint.minValue;
                            prevArg = prevPoint.argument
                        }
                        if (point.hasValue())
                            processValue(val, minVal, prevVal, prevMinVal);
                        processArgument(arg, prevArg);
                        if (discreteArgumentAxis || !visibleRange || arg < visibleRange.minArg || arg > visibleRange.maxArg)
                            return;
                        if (!utils.isDefined(rangeData.minVisibleVal) && i)
                            if (prevPoint.hasValue()) {
                                addToVisibleVal(prevVal);
                                if (self.isRangeSeries)
                                    addToVisibleVal(prevMinVal)
                            }
                        if (point.hasValue()) {
                            lastVisibleIndex = i;
                            addToVisibleVal(val);
                            if (self.isRangeSeries)
                                addToVisibleVal(minVal)
                        }
                    });
                    if (utils.isDefined(lastVisibleIndex) && lastVisibleIndex < pointsLength - 1)
                        if (points[lastVisibleIndex + 1].hasValue()) {
                            addToVisibleVal(points[lastVisibleIndex + 1].value);
                            if (self.isRangeSeries)
                                addToVisibleVal(points[lastVisibleIndex + 1].minValue)
                        }
                    if (!self.options.rotated) {
                        if (utils.isDefined(rangeData.minVal)) {
                            rangeData.minY = rangeData.minVal;
                            rangeData.maxY = rangeData.maxVal;
                            rangeData.intervalY = undefined
                        }
                        if (utils.isDefined(rangeData.minArg)) {
                            rangeData.minX = rangeData.minArg;
                            rangeData.maxX = rangeData.maxArg;
                            rangeData.intervalX = rangeData.minIntervalArg
                        }
                        if (rangeData.categoriesArg.length)
                            rangeData.categoriesX = rangeData.categoriesArg.slice(0);
                        if (rangeData.categoriesVal.length)
                            rangeData.categoriesY = rangeData.categoriesVal.slice(0);
                        if (rangeData.visibleValCategories.length)
                            rangeData.visibleCategoriesY = rangeData.visibleValCategories.slice(0);
                        rangeData.minVisibleY = rangeData.minVisibleVal;
                        rangeData.maxVisibleY = rangeData.maxVisibleVal
                    }
                    else {
                        if (utils.isDefined(rangeData.minVal)) {
                            rangeData.minX = rangeData.minVal;
                            rangeData.maxX = rangeData.maxVal;
                            rangeData.intervalX = undefined
                        }
                        if (utils.isDefined(rangeData.minArg)) {
                            rangeData.minY = rangeData.minArg;
                            rangeData.maxY = rangeData.maxArg;
                            rangeData.intervalY = rangeData.minIntervalArg
                        }
                        if (rangeData.categoriesArg.length)
                            rangeData.categoriesY = rangeData.categoriesArg.slice(0);
                        if (rangeData.categoriesVal.length)
                            rangeData.categoriesX = rangeData.categoriesVal.slice(0);
                        if (rangeData.visibleValCategories.length)
                            rangeData.visibleCategoriesX = rangeData.visibleValCategories.slice(0);
                        rangeData.minVisibleX = rangeData.minVisibleVal;
                        rangeData.maxVisibleX = rangeData.maxVisibleVal
                    }
                }
                delete rangeData.minArg;
                delete rangeData.maxArg;
                delete rangeData.minVal;
                delete rangeData.maxVal;
                delete rangeData.minIntervalArg;
                delete rangeData.minIntervalVal;
                delete rangeData.minVisibleVal;
                delete rangeData.maxVisibleVal;
                delete rangeData.visibleValCategories;
                delete rangeData.categoriesArg;
                delete rangeData.categoriesVal;
                rangeData = this.addLabelPaddingsToRange(rangeData);
                rangeData = this.processRangeForFullStackedSeries(rangeData);
                this.rangeData = rangeData;
                rangeData = this.getRangeMinValue(rangeData);
                return rangeData
            },
            getRangeMinValue: function(range) {
                if (this.type.slice(-3) === "bar" || this.type.slice(-4) === "area") {
                    if (!range)
                        return range;
                    if (this.isRangeSeries)
                        return range;
                    if (!this.options.rotated)
                        range.keepValueMarginsX = true;
                    else
                        range.keepValueMarginsY = true;
                    if (range.minY !== undefined && !this.options.rotated) {
                        range.minY = range.minY > 0 ? 0 : range.minY;
                        this.setZeroPadding(range, range.minY, 'minValueMarginY');
                        range.maxY = range.maxY < 0 ? 0 : range.maxY;
                        if (range.maxY === 0 || range.maxY > 0 && range.minY < 0) {
                            range.minValueMarginY = range.maxValueMarginY;
                            range.minValueMarginYPriority = range.maxValueMarginYPriority
                        }
                        this.setZeroPadding(range, range.maxY, 'maxValueMarginY')
                    }
                    else if (range.minX !== undefined && this.options.rotated) {
                        range.minX = range.minX > 0 ? 0 : range.minX;
                        this.setZeroPadding(range, range.minX, 'minValueMarginX');
                        range.maxX = range.maxX < 0 ? 0 : range.maxX;
                        if (range.maxX === 0 || range.maxX > 0 && range.minX < 0) {
                            range.minValueMarginX = range.maxValueMarginX;
                            range.minValueMarginXPriority = range.maxValueMarginXPriority
                        }
                        this.setZeroPadding(range, range.maxX, 'maxValueMarginX')
                    }
                }
                return range
            },
            setZeroPadding: function(range, val, prefix) {
                if (val === 0)
                    this.setPadding(range, prefix, 0, BAR_ZERO_VALUE_MARGIN_PRIORITY)
            },
            setPadding: function(range, prefix, val, priority) {
                range[prefix] = val;
                range[prefix + 'Priority'] = priority
            },
            addLabelPaddingsToRange: function(rangeData) {
                var series = this;
                if (series.areLabelsVisible() && series.styles.point.label.position !== 'inside')
                    if (!series.options.rotated) {
                        this.setPadding(rangeData, 'maxValueMarginY', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY);
                        if (series.isRangeSeries)
                            this.setPadding(rangeData, 'minValueMarginY', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY)
                    }
                    else {
                        this.setPadding(rangeData, 'maxValueMarginX', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY);
                        if (series.isRangeSeries)
                            this.setPadding(rangeData, 'minValueMarginX', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY)
                    }
                return rangeData
            },
            isFullStackedSeries: function() {
                return this.type.indexOf('fullstacked') === 0
            },
            isStackedSeries: function() {
                return this.type.indexOf('stacked') === 0
            },
            processRangeForFullStackedSeries: function(rangeData) {
                var self = this,
                    indentName,
                    isRangeEmpty = $.isEmptyObject(rangeData);
                if (self.isFullStackedSeries())
                    if (!self.options.rotated) {
                        self.setPadding(rangeData, 'minValueMarginY', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        self.setPadding(rangeData, 'maxValueMarginY', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        !isRangeEmpty && (rangeData.minY = 0)
                    }
                    else {
                        self.setPadding(rangeData, 'minValueMarginX', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        self.setPadding(rangeData, 'maxValueMarginX', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        !isRangeEmpty && (rangeData.minX = 0)
                    }
                return rangeData
            },
            draw: function(translator) {
                var seriesContainerOptions = {'class': 'dxc-series'},
                    seriesElementsOptions = {'class': 'dxc-elements'},
                    seriesMarkersOptions = $.extend({'class': 'dxc-markers'}, this.styles.point.states.normal),
                    labelsGroupOptions = {'class': 'dxc-series-labels'},
                    seriesElementsGroup,
                    seriesMarkersGroup,
                    labelsGroup;
                if (!translator) {
                    throw new Error('Translator was not initialized before call Series Draw()');
                    return
                }
                this.translator = translator;
                this._translateCoors();
                if (this.elementsClipRectID) {
                    seriesElementsOptions.clipId = this.elementsClipRectID;
                    labelsGroupOptions.clipId = this.elementsClipRectID
                }
                if (this.markersClipRectID)
                    seriesMarkersOptions.clipId = this.markersClipRectID;
                if (!this.seriesGroup) {
                    this.seriesGroup = this.renderer.createGroup(seriesContainerOptions);
                    seriesElementsGroup = this.renderer.createGroup(seriesElementsOptions).append(this.seriesGroup);
                    seriesMarkersGroup = this.renderer.createGroup(seriesMarkersOptions).append(this.seriesGroup)
                }
                else {
                    this.seriesGroup.clear();
                    seriesElementsGroup = this.renderer.createGroup(seriesElementsOptions).append(this.seriesGroup);
                    seriesMarkersGroup = this.renderer.createGroup(seriesMarkersOptions).append(this.seriesGroup)
                }
                this.seriesGroup.append(this.options.seriesGroup);
                labelsGroup = this.renderer.createGroup(labelsGroupOptions).append(this.options.seriesLabelsGroup);
                if (!this.hoverPatternColor) {
                    this.hoverPatternColor = this.styles.states.hover.fill;
                    this.selectedPatternColor = this.styles.states.selected.fill
                }
                this.createPatterns();
                this.drawSeriesData(seriesElementsGroup, seriesMarkersGroup, labelsGroup);
                switch (this.state) {
                    case statesConsts.selected:
                        this.setSelectedState(this.lastSelectionMode);
                        break;
                    case statesConsts.hover:
                        this.setHoverState(this.lastHoverdMode);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                return this
            },
            createPatterns: function() {
                if (!this.hoverPattern) {
                    this.hoverPattern = this.renderer.createPattern(this.hoverPatternColor, this.styles.states.hover.hatching);
                    this.selectedPattern = this.renderer.createPattern(this.selectedPatternColor, this.styles.states.selected.hatching)
                }
                this.hoverPattern.append();
                this.selectedPattern.append()
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                if (this.hoverPattern) {
                    this.styles.states.hover.fill = this.hoverPattern.id;
                    this.styles.states.selected.fill = this.selectedPattern.id
                }
                this.drawPoints(seriesMarkersGroup, labelsGroup);
                return this
            },
            drawPoints: function(group, labelsGroup) {
                var series = this,
                    pointVisible = series.styles.point.visible,
                    labelVisible = series.areLabelsVisible();
                $.each(series.points, function drawPointMarker(i, point) {
                    point.adjustSeriesLabels = series.adjustSeriesLabels;
                    if (!point.isInVisibleArea(point.x, point.y, point.width || 0, point.height || 0))
                        return;
                    pointVisible && point.drawMarker(series.renderer, group);
                    labelVisible && point.drawLabel(series.renderer, labelsGroup)
                })
            },
            drawTrackers: function() {
                this.drawPointTrackers()
            },
            drawPointTrackers: function() {
                var series = this,
                    trackersVisible = !series._suppressTrackers;
                $.each(series.points, function drawPointTracker(i, point) {
                    if (!point.isInVisibleArea(point.x, point.y, point.width || 0, point.height || 0))
                        return;
                    trackersVisible && point.drawTrackerMarker(series.renderer, series.options.markerTrackerGroup)
                })
            },
            areLabelsVisible: function() {
                var series = this;
                return series.styles.point.label.visible && (!utils.isDefined(series.styles.maxLabelCount) || series.points.length <= series.styles.maxLabelCount)
            },
            getPoints: function() {
                return this.points
            },
            select: function() {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.selectSeries, {target: this}), this.options.selectionMode);
                this.seriesGroup && this.seriesGroup.toForeground();
                if (this.trackerElements && this.trackerElements.length)
                    $.each(this.trackerElements, function(_, element) {
                        element.toBackground()
                    })
            },
            clearSelection: function clearSelection() {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.deselectSeries, {target: this}), this.options.selectionMode)
            },
            selectPoint: function(point) {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.selectPoint), point)
            },
            deselectPoint: function(point) {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.deselectPoint), point)
            },
            showPointTooltip: function(point) {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.showPointTooltip), point)
            },
            hidePointTooltip: function(point) {
                this.options.seriesGroup && this.options.seriesGroup.trigger(new $.Event(eventsConsts.hidePointTooltip), point)
            },
            getAllPoints: function() {
                return this.points.slice()
            },
            getPointByPos: function(pos) {
                return this.points && this.points[pos]
            },
            getPointByArg: function(arg) {
                return this.pointsByArgument[arg.valueOf()] || null
            },
            animate: function() {
                if (this.styles.point.visible && this.segments)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            pt.animate()
                        })
                    })
            },
            on: function(events, data, handler) {
                $(this).on(events, data, handler);
                return this
            },
            off: function(events) {
                $(this).off(events);
                return this
            },
            applyNormalStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applyNormalStyle()
                        })
                    })
            },
            applyHoverStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applyHoverStyle()
                        })
                    })
            },
            applySelectionStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applySelectionStyle()
                        })
                    })
            },
            setHoverState: function(mode) {
                this.fullState = this.fullState | statesConsts.hoverMark;
                mode = mode || this.options.hoverMode;
                this.lastHoverMode = mode;
                if (!this._checkBehavior(mode, HOVER_CHECK))
                    return;
                this.state = statesConsts.hover;
                this.applyHoverStyle(mode)
            },
            releaseHoverState: function() {
                var mode = this.lastHoverMode || this.options.hoverMode;
                this.fullState = this.fullState & ~statesConsts.hoverMark;
                delete this.lastHoverMode;
                if (!this._checkBehavior(mode, HOVER_CHECK))
                    return;
                this.state = statesConsts.normal;
                this.applyNormalStyle(mode)
            },
            setSelectedState: function(mode) {
                this.state = statesConsts.selected;
                this.fullState = this.fullState | statesConsts.selectedMark;
                this.lastSelectionMode = mode;
                if (!this._checkBehavior(mode, SELECTION_CHECK))
                    return;
                if (this.lastHoverMode === ALL_SERIES_POINTS_MODE || this.lastHoverMode === INCLUDE_POINTS_MODE)
                    this.applyNormalStyle(INCLUDE_POINTS_MODE);
                mode = mode || this.options.selectionMode;
                this.applySelectionStyle(mode)
            },
            releaseSelectedState: function() {
                var mode = this.lastSelectionMode || this.options.selectionMode;
                this.fullState = this.fullState & ~statesConsts.selectedMark;
                if (!this._checkBehavior(mode, SELECTION_CHECK))
                    return;
                if (this.fullState & statesConsts.hoverMark) {
                    this.state = statesConsts.hover;
                    if ((mode === INCLUDE_POINTS_MODE || mode === ALL_SERIES_POINTS_MODE) && (this.lastHoverMode !== INCLUDE_POINTS_MODE || this.lastHoverMode === ALL_SERIES_POINTS_MODE))
                        this.applyNormalStyle(mode);
                    this.applyHoverStyle(this.lastHoverMode)
                }
                else {
                    this.state = statesConsts.normal;
                    this.applyNormalStyle(mode)
                }
                delete this.lastSelectionMode
            },
            _checkBehavior: function(mode, behavior) {
                if (mode === 'none')
                    return false;
                switch (behavior) {
                    case HOVER_CHECK:
                        if (!(this.fullState & statesConsts.selectedMark) || this.options.selectionMode === 'none')
                            return true;
                        return false;
                    case SELECTION_CHECK:
                        return true
                }
                return false
            },
            setPointHoverState: function(point) {
                point.fullState = point.fullState | statesConsts.hoverMark;
                if (!(this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)) && !(point.fullState & statesConsts.selectedMark)) {
                    point.state = statesConsts.hover;
                    point.applyHoverStyle()
                }
            },
            releasePointHoverState: function(point) {
                point.fullState = point.fullState & ~statesConsts.hoverMark;
                if (!(this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)) && !(point.fullState & statesConsts.selectedMark)) {
                    point.state = statesConsts.normal;
                    if (!(this.fullState & statesConsts.hoverMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)))
                        point.applyNormalStyle()
                }
            },
            setPointSelectedState: function(point) {
                point.state = statesConsts.selected;
                point.fullState = point.fullState | statesConsts.selectedMark;
                point.applySelectionStyle()
            },
            releasePointSelectedState: function(point) {
                point.state = statesConsts.normal;
                point.fullState = point.fullState & ~statesConsts.selectedMark;
                if (this.fullState & statesConsts.hoverMark && (this.lastHoverMode === ALL_SERIES_POINTS_MODE || this.lastHoverMode === INCLUDE_POINTS_MODE) || point.fullState & statesConsts.hoverMark) {
                    point.applyHoverStyle();
                    if (point.fullState & statesConsts.hoverMark)
                        point.state = statesConsts.hover
                }
                else if (this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE))
                    point.applySelectionStyle();
                else
                    point.applyNormalStyle()
            },
            _translateCoors: function() {
                var _this = this,
                    tr = _this.translator;
                $.each(_this.points, function(_, p) {
                    p.translate(tr)
                })
            },
            _checkAndPrepareInputData: function(data, argumentField, valueFields) {
                this._checkInputData(data, argumentField, valueFields);
                return this._validationResult.error ? null : this._prepareInputData(data, argumentField, valueFields)
            },
            _checkInputData: function(data, argumentField, valueFields) {
                this._validationResult = {error: null};
                this._parseUtils = new ParseUtils({incidentOccured: this.options.incidentOccured});
                var self = this,
                    dataLen = data.length,
                    i,
                    argFound,
                    valFound,
                    val1Found,
                    val2Found,
                    curPoint,
                    firstItem = data[0],
                    checkParams = {};
                if (!dataLen)
                    return;
                if ($.type(firstItem) !== 'object') {
                    self._validationResult.error = self._errorMessages.incorrectDataMessage();
                    self.options.incidentOccured.call(null, self._errorMessages.incorrectDataMessage());
                    return
                }
                self._checkArgumentAxisParams(data, argumentField);
                if (self._validationResult.error)
                    return;
                self._checkValueAxisParams(data, valueFields)
            },
            _checkArgumentAxisParams: function(data, argumentField) {
                var self = this,
                    options = self.options,
                    userOptions = self._parsedUserOptions,
                    argumentCategories = userOptions.argumentCategories,
                    argumentAxisType = self._correctAxisType(userOptions.argumentAxisType, userOptions.argumentCategories),
                    argumentType = self._parseUtils.correctValueType(userOptions.argumentType),
                    i,
                    argFound,
                    curPoint,
                    checkParams = {};
                argumentField = argumentField || options.argumentField || 'arg';
                options.userArgumentType = argumentType;
                options.userArgumentAxisType = argumentAxisType;
                switch (argumentType.toLowerCase()) {
                    case'numeric':
                    case'datetime':
                        if (!argumentAxisType) {
                            options.argumentAxisType = argumentAxisType = 'continuous';
                            options.argumentType = argumentType
                        }
                        else {
                            options.argumentAxisType = argumentAxisType;
                            options.argumentType = argumentType
                        }
                        return;
                    case'string':
                        if (argumentAxisType && argumentAxisType !== 'discrete') {
                            self._validationResult.error = self._errorMessages.incompatibleTypesDataMessage('argument');
                            self.options.incidentOccured.call(null, self._errorMessages.incompatibleTypesDataMessage('argument'))
                        }
                        options.argumentAxisType = argumentAxisType = 'discrete';
                        options.argumentType = argumentType;
                        return;
                    default:
                        break
                }
                for (i = 0; i < data.length; i++) {
                    curPoint = data[i];
                    if (self._isTypeSupported(curPoint[argumentField])) {
                        argFound = curPoint[argumentField];
                        break
                    }
                }
                checkParams.value = argFound;
                checkParams.field = argumentField;
                checkParams.axisType = argumentAxisType;
                checkParams.type = argumentType;
                if (self._checkValue(checkParams)) {
                    options.argumentAxisType = checkParams.axisType;
                    options.argumentType = checkParams.type
                }
                else
                    return
            },
            _checkValueAxisParams: function(data, valueFields) {
                var self = this,
                    options = self.options,
                    userOptions = self._parsedUserOptions,
                    valueField = options.valueField || 'val',
                    rangeValue1Field = options.rangeValue1Field || 'val1',
                    rangeValue2Field = options.rangeValue2Field || 'val2',
                    valueCategories = userOptions.valueCategories,
                    valueAxisType = self._correctAxisType(userOptions.valueAxisType, userOptions.valueCategories),
                    valueType = self._parseUtils.correctValueType(userOptions.valueType),
                    i,
                    j,
                    valFound = {},
                    val1Found,
                    val2Found,
                    curPoint,
                    checkParams = {},
                    foundedValueFields;
                valueFields = valueFields || [];
                if (!valueFields.length)
                    valueFields = self.isRangeSeries ? [rangeValue1Field, rangeValue2Field] : [valueField];
                options.userValueType = valueType;
                options.userValueAxisType = valueAxisType;
                switch (valueType.toLowerCase()) {
                    case'numeric':
                    case'datetime':
                        if (!valueAxisType) {
                            options.valueAxisType = valueAxisType = 'continuous';
                            options.valueType = valueType
                        }
                        else {
                            options.valueAxisType = valueAxisType;
                            options.valueType = valueType
                        }
                        return;
                    case'string':
                        if (valueAxisType && valueAxisType !== 'discrete') {
                            self._validationResult.error = self._errorMessages.incompatibleTypesDataMessage('value');
                            self.options.incidentOccured.call(null, self._errorMessages.incompatibleTypesDataMessage('value'))
                        }
                        options.valueAxisType = valueAxisType = 'discrete';
                        options.valueType = valueType;
                        return;
                    default:
                        break
                }
                checkParams.axisType = valueAxisType;
                checkParams.type = valueType;
                for (i = 0; i < data.length; i++) {
                    var allFieldsFound = true;
                    curPoint = data[i];
                    for (j = 0; j < valueFields.length; j++)
                        if (self._isTypeSupported(curPoint[valueFields[j]]))
                            valFound[valueFields[j]] = curPoint[valueFields[j]];
                    $.each(valueFields, function(i, field) {
                        return allFieldsFound = field in valFound
                    });
                    if (allFieldsFound)
                        break
                }
                for (i = 0; i < valueFields.length; i++) {
                    checkParams.value = valFound[valueFields[i]];
                    checkParams.field = valueFields[i];
                    if (!self._checkValue(checkParams))
                        return
                }
                options.valueAxisType = checkParams.axisType;
                options.valueType = checkParams.type
            },
            _prepareInputData: function(data, argumentField, valueFields) {
                var self = this,
                    options = self.options,
                    argumentCategories = options.argumentCategories,
                    argumentAxisType = options.argumentAxisType,
                    argumentType = options.argumentType,
                    errorMessages = self._errorMessages,
                    incidentOccured = self.options.incidentOccured,
                    valueField = options.valueField || 'val',
                    rangeValue1Field = options.rangeValue1Field || 'val1',
                    rangeValue2Field = options.rangeValue2Field || 'val2',
                    valueCategories = options.valueCategories,
                    valueAxisType = options.valueAxisType,
                    userValueType = options.userValueType,
                    userArgumentType = options.userArgumentType,
                    userValueAxisType = options.userValueAxisType,
                    userArgumentAxisType = options.userArgumentAxisType,
                    valueType = options.valueType,
                    tagField = options.tagField || 'tag',
                    query = DX.data.query,
                    argumentParser = $.noop,
                    valueParser = $.noop,
                    prepData = [];
                argumentField = argumentField || options.argumentField || 'arg';
                valueFields = valueFields || [];
                if (!valueFields.length)
                    valueFields = self.isRangeSeries ? [rangeValue1Field, rangeValue2Field] : [valueField];
                if (!data.length)
                    return prepData;
                function categorySort() {
                    var length = argumentCategories.length,
                        oIdx = length,
                        i,
                        sortHash = {};
                    for (i = 0; i < length; i++)
                        sortHash[argumentCategories[i]] = i;
                    return function(a, b) {
                            var argA = a[argumentField],
                                argB = b[argumentField],
                                aRank = sortHash[argA],
                                bRank = sortHash[argB];
                            if (!utils.isDefined(aRank))
                                aRank = oIdx;
                            if (!utils.isDefined(bRank))
                                bRank = oIdx;
                            return aRank - bRank
                        }
                }
                function argumentSort(a, b) {
                    return a[argumentField] - b[argumentField]
                }
                var getParser = function(entity, valueType, nullsNotAllowed) {
                        var parser = self._parseUtils.getParser(valueType.toLowerCase(), entity + 'Axis'),
                            parsingMessage;
                        switch (valueType.toLowerCase()) {
                            case'numeric':
                                parsingMessage = errorMessages.numericParsingMessage;
                                break;
                            case'datetime':
                                parsingMessage = errorMessages.dateParsingMessage;
                                break;
                            default:
                                parsingMessage = $.noop
                        }
                        return function(val) {
                                var parsedVal;
                                if (nullsNotAllowed && !utils.isDefined(val) || val === undefined) {
                                    incidentOccured.call(null, errorMessages.dataItemMissingMessage(entity));
                                    return undefined
                                }
                                if (val === null)
                                    return null;
                                parsedVal = parser(val);
                                if (!utils.isDefined(parsedVal))
                                    incidentOccured.call(null, parsingMessage(entity));
                                return parsedVal
                            }
                    };
                var parseArgument = getParser('argument', argumentType, true);
                var parseValue = getParser('value', valueType);
                prepData = $.map(data, function(src) {
                    var arg = userArgumentAxisType === 'discrete' && !userArgumentType ? src[argumentField] : parseArgument(src[argumentField]),
                        resultDataItem = {tag: src[tagField]},
                        val,
                        i;
                    if (!utils.isDefined(arg))
                        return null;
                    resultDataItem[argumentField] = arg;
                    resultDataItem['original' + argumentField] = src[argumentField];
                    for (i = 0; i < valueFields.length; i++) {
                        val = userValueAxisType === 'discrete' && !userValueType ? src[valueFields[i]] : parseValue(src[valueFields[i]]);
                        if (val === undefined)
                            return null;
                        resultDataItem[valueFields[i]] = val;
                        resultDataItem['original' + valueFields[i]] = src[valueFields[i]]
                    }
                    return resultDataItem
                });
                if (argumentAxisType === 'discrete' && argumentCategories && argumentCategories.length)
                    prepData.sort(categorySort());
                else if (argumentAxisType !== 'discrete')
                    prepData.sort(argumentSort);
                return prepData
            },
            _parseInputData: function(data) {
                var self = this,
                    createPoint = series.pointFactory.createPoint,
                    rotated = self.options.rotated,
                    pointStyles = self.styles.point,
                    prepData,
                    i = 0,
                    curPoint,
                    point,
                    valueField,
                    rangeValue1Field,
                    rangeValue2Field,
                    options = self.options,
                    argumentField = argumentField || options.argumentField || 'arg',
                    tagField = options.tagField || 'tag';
                if (data && data.length)
                    this._canRenderCompleteHandle = true;
                self.points = [];
                self.pointsByArgument = {};
                self.segments = [];
                prepData = self._checkAndPrepareInputData(data);
                if (!prepData || self._validationResult.error)
                    return;
                if (!self.isRangeSeries) {
                    valueField = options.valueField || 'val';
                    for (; i < prepData.length; i++) {
                        curPoint = prepData[i];
                        point = createPoint(self.type, {
                            value: curPoint[valueField],
                            argument: curPoint[argumentField],
                            originalValue: curPoint['original' + valueField],
                            originalArgument: curPoint['original' + argumentField],
                            rotated: rotated,
                            options: pointStyles,
                            tag: curPoint.tag,
                            series: self
                        });
                        self.points.push(point);
                        self.pointsByArgument[point.argument.valueOf()] = self.pointsByArgument[point.argument.valueOf()] || point
                    }
                }
                else {
                    rangeValue1Field = options.rangeValue1Field || 'val1';
                    rangeValue2Field = options.rangeValue2Field || 'val2';
                    for (; i < prepData.length; i++) {
                        curPoint = prepData[i];
                        point = createPoint(self.type, {
                            minValue: curPoint[rangeValue1Field],
                            value: curPoint[rangeValue2Field],
                            argument: curPoint[argumentField],
                            originalMinValue: curPoint['original' + rangeValue1Field],
                            originalValue: curPoint['original' + rangeValue2Field],
                            originalArgument: curPoint['original' + argumentField],
                            rotated: rotated,
                            options: pointStyles,
                            tag: curPoint.tag,
                            series: self
                        });
                        self.pointsByArgument[point.argument] = self.pointsByArgument[point.argument] || point;
                        self.points.push(point)
                    }
                }
                this._segmenting()
            },
            _segmenting: function() {
                var self = this,
                    segment = [];
                $.each(this.points, function(_, point) {
                    if (point.hasValue())
                        segment.push(point);
                    else if (segment.length !== 0) {
                        self.segments.push(segment);
                        segment = []
                    }
                });
                if (segment.length)
                    this.segments.push(segment)
            },
            _parseOptions: function(options) {
                this.options = {
                    incidentOccured: options.incidentOccured,
                    rotated: !!options.rotated,
                    seriesGroup: options.seriesGroup,
                    seriesLabelsGroup: options.seriesLabelsGroup,
                    seriesTrackerGroup: options.seriesTrackerGroup,
                    markerTrackerGroup: options.markerTrackerGroup,
                    argumentCategories: options.argumentCategories,
                    argumentAxisType: options.argumentAxisType,
                    argumentType: options.argumentType,
                    argumentField: options.argumentField,
                    valueCategories: options.valueCategories,
                    valueAxisType: options.valueAxisType,
                    valueType: options.valueType,
                    valueField: options.valueField,
                    rangeValue1Field: options.rangeValue1Field,
                    rangeValue2Field: options.rangeValue2Field,
                    tagField: options.tagField,
                    selectionMode: (options.selectionMode || '').toLowerCase(),
                    hoverMode: (options.hoverMode || '').toLowerCase(),
                    showInLegend: options.showInLegend !== undefined ? options.showInLegend : true
                };
                if (!$.isFunction(this.options.incidentOccured))
                    this.options.incidentOccured = $.noop;
                this.name = options.name;
                this.axis = options.axis;
                this.pane = options.pane;
                this.styles = this.parseStyleOptions(options);
                if (this.adjustOptions)
                    this.adjustOptions()
            },
            parseStyleOptions: function(options) {
                var combinedOptions = $.extend(true, {}, this.getDefaultStyleOptions(), options);
                var normalState = {
                        strokeWidth: combinedOptions.border.visible ? combinedOptions.border.width || 0 : 0,
                        stroke: combinedOptions.border.visible && combinedOptions.border.width ? combinedOptions.border.color : 'none',
                        fill: combinedOptions.color,
                        dashStyle: combinedOptions.dashStyle,
                        lineWidth: combinedOptions.width,
                        r: combinedOptions.cornerRadius
                    };
                var hoverState = {
                        strokeWidth: combinedOptions.hoverStyle.border.visible ? combinedOptions.hoverStyle.border.width || 0 : 0,
                        stroke: combinedOptions.hoverStyle.border.visible && combinedOptions.hoverStyle.border.width ? combinedOptions.hoverStyle.border.color : 'none',
                        fill: combinedOptions.hoverStyle.color,
                        dashStyle: combinedOptions.hoverStyle.dashStyle || combinedOptions.dashStyle,
                        lineWidth: combinedOptions.hoverStyle.width,
                        hatching: combinedOptions.hoverStyle.hatching
                    };
                var selectedState = {
                        strokeWidth: combinedOptions.selectionStyle.border.visible ? combinedOptions.selectionStyle.border.width || 0 : 0,
                        stroke: combinedOptions.selectionStyle.border.visible && combinedOptions.selectionStyle.border.width ? combinedOptions.selectionStyle.border.color : 'none',
                        fill: combinedOptions.selectionStyle.color,
                        dashStyle: combinedOptions.selectionStyle.dashStyle || combinedOptions.dashStyle,
                        lineWidth: combinedOptions.selectionStyle.width,
                        hatching: combinedOptions.selectionStyle.hatching
                    };
                var attr = {};
                $.each(['align', 'translateX', 'translateY', 'rotate', 'linejoin', 'linecap', 'opacity', 'style'], function(i, val) {
                    if (combinedOptions[val])
                        attr[val] = combinedOptions[val]
                });
                var attributes = $.extend(true, {}, normalState, attr);
                var pointNormalState = {
                        strokeWidth: combinedOptions.point.border.visible ? combinedOptions.point.border.width || 0 : 0,
                        stroke: combinedOptions.point.border.visible && combinedOptions.point.border.width ? combinedOptions.point.border.color : 'none',
                        fill: combinedOptions.point.color,
                        r: combinedOptions.point.size + (combinedOptions.point.border.visible && combinedOptions.point.size !== 0 ? ~~(combinedOptions.point.border.width / 2) || 0 : 0),
                        inh: true
                    };
                var pointHoverState = {
                        strokeWidth: combinedOptions.point.hoverStyle.border.visible ? combinedOptions.point.hoverStyle.border.width || 0 : 0,
                        stroke: combinedOptions.point.hoverStyle.border.visible && combinedOptions.point.hoverStyle.border.width ? combinedOptions.point.hoverStyle.border.color : 'none',
                        fill: combinedOptions.point.hoverStyle.color,
                        r: combinedOptions.point.hoverStyle.size + (combinedOptions.point.hoverStyle.border.visible && combinedOptions.point.hoverStyle.size !== 0 ? ~~(combinedOptions.point.hoverStyle.border.width / 2) || 0 : 0)
                    };
                var pointSelectedState = {
                        strokeWidth: combinedOptions.point.selectionStyle.border.visible ? combinedOptions.point.selectionStyle.border.width || 0 : 0,
                        stroke: combinedOptions.point.selectionStyle.border.visible && combinedOptions.point.selectionStyle.border.width ? combinedOptions.point.selectionStyle.border.color : 'none',
                        fill: combinedOptions.point.selectionStyle.color,
                        r: combinedOptions.point.selectionStyle.size + (combinedOptions.point.selectionStyle.border.visible && combinedOptions.point.selectionStyle.size !== 0 ? ~~(combinedOptions.point.selectionStyle.border.width / 2) || 0 : 0)
                    };
                var pointAttr = {};
                $.each(['align', 'translateX', 'translateY', 'rotate', 'linejoin', 'linecap', 'style'], function(i, val) {
                    if (val in combinedOptions.point)
                        pointAttr[val] = combinedOptions.point[val]
                });
                var pointAttributes = $.extend(true, {}, pointNormalState, pointAttr);
                var labelAttributes = {
                        align: combinedOptions.label.alignment,
                        font: {
                            color: combinedOptions.label.backgroundColor === 'none' && combinedOptions.label.font.color.toLowerCase() === '#ffffff' && combinedOptions.label.position !== 'inside' ? combinedOptions.color : combinedOptions.label.font.color,
                            family: combinedOptions.label.font.family,
                            weight: combinedOptions.label.font.weight,
                            size: combinedOptions.label.font.size,
                            opacity: combinedOptions.label.font.opacity
                        },
                        style: combinedOptions.label.style
                    };
                var backgroundAttr = {
                        fill: combinedOptions.label.backgroundColor || combinedOptions.color,
                        strokeWidth: combinedOptions.label.border.visible ? combinedOptions.label.border.width || 0 : 0,
                        stroke: combinedOptions.label.border.visible && combinedOptions.label.border.width ? combinedOptions.label.border.color : 'none',
                        dashStyle: combinedOptions.label.border.dashStyle
                    };
                var connectorAttr = {
                        stroke: combinedOptions.label.connector.visible && combinedOptions.label.connector.width ? combinedOptions.label.connector.color || combinedOptions.color : 'none',
                        strokeWidth: combinedOptions.label.connector.visible ? combinedOptions.label.connector.width || 0 : 0
                    };
                return {
                        themeColor: combinedOptions.color,
                        attributes: attributes,
                        maxLabelCount: combinedOptions.maxLabelCount,
                        minBarSize: combinedOptions.minBarSize,
                        reduction: {
                            color: combinedOptions.reduction.color,
                            level: combinedOptions.reduction.level,
                            innerColor: combinedOptions.innerColor
                        },
                        states: {
                            normal: normalState,
                            hover: hoverState,
                            selected: selectedState
                        },
                        point: {
                            visible: combinedOptions.point.visible,
                            symbol: combinedOptions.point.symbol,
                            minShownBarSize: combinedOptions.point.minShownBarSize,
                            attributes: pointAttributes,
                            seriesName: combinedOptions.point.seriesName,
                            selectionMode: (combinedOptions.point.selectionMode || '').toLowerCase(),
                            hoverMode: (combinedOptions.point.hoverMode || '').toLowerCase(),
                            states: {
                                normal: pointNormalState,
                                hover: pointHoverState,
                                selected: pointSelectedState
                            },
                            label: {
                                format: combinedOptions.label.format,
                                argumentFormat: combinedOptions.label.argumentFormat,
                                precision: combinedOptions.label.precision,
                                argumentPrecision: combinedOptions.label.argumentPrecision,
                                percentPrecision: combinedOptions.label.percentPrecision,
                                customizeText: $.isFunction(combinedOptions.label.customizeText) ? combinedOptions.label.customizeText : undefined,
                                attributes: labelAttributes,
                                visible: combinedOptions.label.font.size !== 0 ? combinedOptions.label.visible : false,
                                showForZeroValues: combinedOptions.label.showForZeroValues,
                                horizontalOffset: combinedOptions.label.horizontalOffset,
                                verticalOffset: combinedOptions.label.verticalOffset,
                                radialOffset: combinedOptions.label.radialOffset,
                                background: backgroundAttr,
                                position: combinedOptions.label.position,
                                connector: connectorAttr,
                                rotationAngle: combinedOptions.label.rotationAngle
                            }
                        }
                    }
            },
            canRenderCompleteHandle: function() {
                var result = this._canRenderCompleteHandle;
                delete this._canRenderCompleteHandle;
                return !!result
            },
            _isTypeSupported: function(data) {
                return utils.isString(data) || utils.isNumber(data) || utils.isDate(data)
            },
            getDefaultStyleOptions: function() {
                return {
                        color: '#000000',
                        border: {
                            visible: false,
                            width: 1,
                            color: '#000000'
                        },
                        width: 2,
                        dashStyle: 'solid',
                        cornerRadius: 0,
                        innerColor: '#ffffff',
                        reduction: {color: '#FF0000'},
                        maxLabelCount: undefined,
                        minBarSize: undefined,
                        point: {
                            visible: true,
                            symbol: 'circle',
                            color: '#000000',
                            size: 6,
                            seriesName: this.name,
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            hoverStyle: {
                                color: '#000000',
                                border: {
                                    visible: true,
                                    width: 2,
                                    color: '#ffffff'
                                },
                                size: 6
                            },
                            selectionStyle: {
                                color: '#000000',
                                border: {
                                    visible: true,
                                    width: 2,
                                    color: '#ffffff'
                                },
                                size: 6
                            }
                        },
                        label: {
                            visible: false,
                            showForZeroValues: true,
                            alignment: 'center',
                            font: {
                                family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                                weight: 400,
                                color: '#ffffff',
                                size: 14
                            },
                            rotationAngle: 0,
                            horizontalOffset: 0,
                            verticalOffset: 0,
                            radialOffset: 0,
                            format: '',
                            argumentFormat: '',
                            precision: 0,
                            argumentPrecision: 0,
                            position: 'outside',
                            connector: {
                                visible: false,
                                width: 1
                            },
                            border: {
                                visible: false,
                                width: 1,
                                color: '#808080',
                                dashStyle: 'solid'
                            }
                        },
                        hoverStyle: {
                            hatching: 'none',
                            color: '#000000',
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            width: 3
                        },
                        selectionStyle: {
                            hatching: 'right',
                            color: '#000000',
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            width: 3
                        }
                    }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file lineSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.LineSeries = series.BaseSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'line';
                this.callBase(renderer, data, options, isRangeSeries);
                this.paths = this.paths || []
            },
            dispose: function() {
                this.paths = null;
                this.callBase()
            },
            drawSegment: function(segment, attributes) {
                return this.renderer.createPath(segment, attributes)
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                var self = this;
                self.preparedSegments = [];
                self.paths = [];
                if (!self.points.length)
                    return;
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                if (self.styles.attributes.strokeWidth > 0)
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesElementsGroup))
                    });
                self.callBase(seriesElementsGroup, seriesMarkersGroup, labelsGroup)
            },
            prepareSegments: function(index) {
                this.preparedSegments = this.preparedSegments || [];
                this.preparedSegments[index] = this.segments[index]
            },
            drawTrackers: function() {
                var self = this,
                    styles = this.styles,
                    strokeWidth;
                self.callBase();
                if (!self.preparedSegments) {
                    self.preparedSegments = [];
                    $.each(self.segments, function(index) {
                        self.prepareSegments(index)
                    })
                }
                if (this._suppressTrackers)
                    return;
                strokeWidth = styles.attributes.strokeWidth < 20 ? 20 : styles.attributes.strokeWidth;
                self.trackerElements = [];
                $.each(this.preparedSegments, function(_, segment) {
                    var tracker = self.drawSegment(segment, {
                            strokeWidth: strokeWidth,
                            stroke: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.trackerElements.push(tracker);
                    tracker.data({series: self})
                });
                return this
            },
            applyNormalStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        path.applySettings(self.styles.states.normal)
                    });
                    return self.callBase(mode)
                }
            },
            applyHoverStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        path.applySettings(self.styles.states.hover)
                    });
                    return self.callBase(mode)
                }
            },
            applySelectionStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        if (path)
                            path.applySettings(self.styles.states.selected)
                    });
                    return self.callBase(mode)
                }
            },
            animate: function() {
                this.callBase();
                this.animatePath()
            },
            animatePath: function() {
                var self = this,
                    segments = self.preparedSegments;
                if (segments && segments.length && self.paths)
                    $.each(self.paths, function(i, path) {
                        var fromPoints = self.getZeroPathPoints(i);
                        path.applySettings({points: fromPoints});
                        path.animate({points: segments[i]})
                    })
            },
            getZeroPathPoints: function(i) {
                return $.map(this.preparedSegments[i], function(pt) {
                        return pt.getDefaultCoords()
                    })
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal;
                attributes.stroke = attributes.fill;
                attributes.fill = 'none';
                attributes.strokeWidth = attributes.lineWidth;
                normal.stroke = normal.fill;
                normal.fill = 'none';
                normal.strokeWidth = normal.lineWidth;
                hover.stroke = hover.fill;
                hover.fill = 'none';
                hover.strokeWidth = hover.lineWidth;
                selected.stroke = selected.fill;
                selected.fill = 'none';
                selected.strokeWidth = selected.lineWidth
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file areaSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.AreaSeries = series.LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'area';
                this.callBase(renderer, data, options, isRangeSeries);
                this.areas = this.areas || [];
                this.areaSegments = this.areaSegments || []
            },
            dispose: function() {
                var _this = this;
                _this.areas = null;
                _this.areaSegments = null;
                _this.paths = null;
                _this.callBase()
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                var self = this;
                self.resetLineColors();
                if (self.isStackedSeries() || self.isFullStackedSeries())
                    self.seriesGroup.toBackground();
                self.areas = [];
                if (!self.points.length)
                    return;
                self.paths = [];
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                $.each(self.preparedSegments, function(index, segment) {
                    self.prepareAreaPoints(index);
                    if (self.areaSegments[index].length === 2) {
                        var stickArea = self.drawSegment(self.areaSegments[index], self.styles.stick).append(seriesElementsGroup);
                        stickArea.stick = true;
                        self.areas.push(stickArea);
                        return
                    }
                    self.areas.push(self.renderer.createArea(self.areaSegments[index], self.styles.area).append(seriesElementsGroup))
                });
                if (self.styles.attributes.strokeWidth > 0 || self.styles.states.hover.strokeWidth > 0 || self.styles.states.selected.strokeWidth > 0)
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesElementsGroup))
                    });
                self.drawPoints(seriesMarkersGroup, labelsGroup);
                if (self.hoverPattern) {
                    self.styles.area.states.hover.fill = self.hoverPattern.id;
                    self.styles.area.states.selected.fill = self.selectedPattern.id;
                    self.styles.states.hover.fill = 'none';
                    self.styles.states.selected.fill = 'none'
                }
                return self
            },
            resetLineColors: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal;
                attributes.fill = 'none';
                delete attributes.lineWidth;
                normal.fill = 'none';
                delete normal.lineWidth;
                hover.fill = 'none';
                delete hover.lineWidth;
                selected.fill = 'none';
                delete selected.lineWidth
            },
            drawTrackers: function() {
                var self = this;
                if (this._suppressTrackers)
                    return;
                self.drawPointTrackers();
                self.trackerElements = [];
                $.each(this.areaSegments, function(_, segment) {
                    var tracker;
                    if (segment.length === 2)
                        tracker = self.drawSegment(segment, {
                            strokeWidth: 20,
                            stroke: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    else
                        tracker = self.renderer.createArea(segment, {
                            strokeWidth: 0,
                            fill: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.trackerElements.push(tracker);
                    tracker.data({series: self})
                });
                return series
            },
            prepareAreaPoints: function(index) {
                var segments = this.preparedSegments;
                var fwPoints = $.map(segments[index], function(pt) {
                        return pt.getCoords()
                    });
                var bwPoints = $.map(segments[index].slice().reverse(), function(pt) {
                        return pt.getCoords(true)
                    });
                this.areaSegments[index] = fwPoints.concat(bwPoints)
            },
            applyStyle: function(mode, style) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        if (!area.stick)
                            area.applySettings(self.styles.area.states[style]);
                        else
                            area.applySettings(self.styles.stick.states[style])
                    })
            },
            applyNormalStyle: function(mode) {
                this.applyStyle(mode, 'normal');
                return this.callBase(mode)
            },
            applyHoverStyle: function(mode) {
                this.applyStyle(mode, 'hover');
                return this.callBase(mode)
            },
            applySelectionStyle: function(mode) {
                this.applyStyle(mode, 'selected');
                return this.callBase(mode)
            },
            animate: function() {
                var self = this;
                this.callBase();
                if (this.preparedSegments && this.preparedSegments.length && this.areas)
                    $.each(this.areas, function(i, area) {
                        var fromPoints = self.getZeroAreaPoints(i);
                        area.applySettings({points: fromPoints});
                        area.animate({points: self.areaSegments[i]})
                    })
            },
            getZeroAreaPoints: function(i) {
                var fwPoints,
                    bwPoints,
                    segments = this.preparedSegments;
                fwPoints = $.map(segments[i], function(pt) {
                    return pt.getDefaultCoords()
                });
                bwPoints = $.map(segments[i].slice().reverse(), function(pt) {
                    return pt.getDefaultCoords()
                });
                return fwPoints.concat(bwPoints)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal,
                    areaNormal = {},
                    areaHover = {},
                    areaSelected = {},
                    stickNormal = {},
                    stickHover = {},
                    stickSelected = {},
                    opacity;
                opacity = 'opacity' in attributes ? attributes.opacity : 0.5;
                areaNormal = {
                    fill: normal.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaHover = {
                    fill: hover.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaSelected = {
                    fill: selected.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                stickNormal = {
                    fill: 'none',
                    stroke: normal.fill,
                    strokeWidth: 1,
                    opacity: opacity
                };
                stickHover = {
                    fill: 'none',
                    stroke: hover.fill,
                    strokeWidth: 1,
                    opacity: opacity
                };
                stickSelected = {
                    fill: 'none',
                    stroke: selected.fill,
                    strokeWidth: 1,
                    opacity: opacity
                };
                styles.area = {
                    fill: attributes.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity,
                    states: {
                        normal: areaNormal,
                        hover: areaHover,
                        selected: areaSelected
                    }
                };
                styles.stick = {
                    fill: 'none',
                    stroke: attributes.fill,
                    strokeWidth: 1,
                    opacity: opacity,
                    states: {
                        normal: stickNormal,
                        hover: stickHover,
                        selected: stickSelected
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file barSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.BarSeries = series.BaseSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'bar';
                this.callBase(renderer, data, options, isRangeSeries);
                this.stackName = options.stack || 'default'
            },
            getStackName: function() {
                if (this.type === 'stackedbar' || this.type === 'fullstackedbar')
                    return this.stackName;
                return null
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                var series = this;
                if (series.points.length && series.hoverPattern) {
                    series.styles.point.states.hover.fill = series.hoverPattern.id;
                    series.styles.point.states.selected.fill = series.selectedPattern.id
                }
                return this.callBase(seriesElementsGroup, seriesMarkersGroup, labelsGroup)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    options = this.options,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal,
                    hoverMode = options.hoverMode,
                    selectionMode = options.selectionMode,
                    func = function(mode) {
                        if (!mode)
                            return false;
                        switch (mode.toLowerCase()) {
                            case"allseriespoints":
                            case"allargumentpoints":
                            case"none":
                                return true
                        }
                    };
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r;
                styles.point.hoverMode = func(hoverMode) && hoverMode;
                styles.point.selectionMode = func(selectionMode) && selectionMode;
                styles.point.visible = true
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file candleStickSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            isDefined = DX.utils.isDefined;
        series.CandleStickSeries = series.BaseSeries.inherit({
            ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'candlestick';
                this.callBase(renderer, data, options)
            },
            getRangeData: function() {
                var self = this,
                    options = self.options,
                    rotated = options.rotated,
                    valAxis = rotated ? 'X' : 'Y',
                    argAxis = rotated ? 'Y' : 'X',
                    points = self.points,
                    vals = [],
                    args = [];
                var compareNumeric = function(a, b) {
                        return a - b
                    };
                $.each(this.points, function(i, val) {
                    isDefined(val.argument) && args.push(val.argument);
                    if (val.hasValue()) {
                        vals.push(val.highValue);
                        vals.push(val.lowValue)
                    }
                });
                self.rangeData = {};
                var processArgument = function(arg, prevArg) {
                        var interval;
                        if (isDefined(prevArg))
                            interval = Math.abs(arg - prevArg);
                        if (isDefined(interval) && (interval < self.rangeData.intervalX || !isDefined(self.rangeData.intervalX)))
                            self.rangeData.intervalX = interval
                    };
                if (vals.length) {
                    vals.sort(compareNumeric);
                    self.rangeData['max' + valAxis] = vals[vals.length - 1];
                    self.rangeData['min' + valAxis] = vals[0];
                    $.each(points, function(i, point) {
                        var prevPoint,
                            arg = point.argument,
                            prevArg;
                        if (i !== 0) {
                            prevPoint = points[i - 1];
                            prevArg = prevPoint.argument
                        }
                        processArgument(arg, prevArg)
                    })
                }
                if (args.length && !(options.argumentAxisType === 'discrete')) {
                    args.sort(compareNumeric);
                    self.rangeData['min' + argAxis] = args[0];
                    self.rangeData['max' + argAxis] = args[args.length - 1]
                }
                else
                    self.rangeData['categories' + argAxis] = args;
                return this.rangeData
            },
            _parseInputData: function(data) {
                var self = this,
                    level,
                    pointFactory = series.pointFactory,
                    argumentField = this.options.argumentField || 'date',
                    openValueField = this.options.openValueField || 'open',
                    highValueField = this.options.highValueField || 'high',
                    lowValueField = this.options.lowValueField || 'low',
                    closeValueField = this.options.closeValueField || 'close',
                    tagField = this.options.tagField || 'tag',
                    pointStyles = this.styles.point,
                    reductionColor = this.styles.reduction.color,
                    innerColor = this.styles.reduction.innerColor,
                    prepData,
                    prevLevelValue,
                    className;
                this.points = [];
                this.segments = [];
                if (!data.length)
                    return;
                prepData = self._checkAndPrepareInputData(data, argumentField, [openValueField, highValueField, lowValueField, closeValueField]);
                self._validationResult = {
                    inputNotations: 0,
                    error: null
                };
                switch ((this.styles.reduction.level || '').toLowerCase()) {
                    case'open':
                        level = openValueField;
                        break;
                    case'high':
                        level = highValueField;
                        break;
                    case'low':
                        level = lowValueField;
                        break;
                    default:
                        level = closeValueField;
                        break
                }
                self.pointsByArgument = {};
                this.points = $.map(prepData, function(val, i) {
                    var pointStylesReduct = $.extend(true, {}, pointStyles || {}),
                        point;
                    className = 'dx-candle-default';
                    if (val[openValueField] !== null && val[highValueField] !== null && val[lowValueField] !== null & val[closeValueField] !== null) {
                        if (i != 0)
                            if (prevLevelValue != null && val[level] < prevLevelValue) {
                                pointStylesReduct.attributes.fill = pointStylesReduct.states.normal.fill = pointStylesReduct.states.hover.fill = pointStylesReduct.states.selected.fill = reductionColor;
                                pointStylesReduct.attributes.stroke = pointStylesReduct.states.normal.stroke = pointStylesReduct.states.hover.stroke = pointStylesReduct.states.selected.stroke = reductionColor;
                                className = 'dx-candle-reduction'
                            }
                        prevLevelValue = val[level];
                        if (val[openValueField] < val[closeValueField]) {
                            pointStylesReduct.attributes.fill = pointStylesReduct.states.normal.fill = pointStylesReduct.states.hover.fill = pointStylesReduct.states.selected.fill = innerColor;
                            className = (className ? className : '') + ' dx-candle-positive'
                        }
                    }
                    pointStylesReduct.attributes['class'] = className;
                    self.className = 'dx-candle-default';
                    point = pointFactory.createPoint(self.type, {
                        openValue: val[openValueField],
                        pointClassName: className,
                        highValue: val[highValueField],
                        lowValue: val[lowValueField],
                        closeValue: val[closeValueField],
                        argument: val[argumentField],
                        originalOpenValue: val['original' + openValueField],
                        originalHighValue: val['original' + highValueField],
                        originalLowValue: val['original' + lowValueField],
                        originalCloseValue: val['original' + closeValueField],
                        originalArgument: val['original' + argumentField],
                        options: pointStylesReduct,
                        tag: val.tag,
                        reductionValue: val[level],
                        series: self
                    });
                    self.pointsByArgument[point.argument.valueOf()] = self.pointsByArgument[point.argument.valueOf()] || point;
                    return point
                });
                this._segmenting()
            },
            _parseOptions: function(options) {
                this.callBase(options);
                $.extend(true, this.options, {
                    openValueField: options.openValueField,
                    closeValueField: options.closeValueField,
                    highValueField: options.highValueField,
                    lowValueField: options.lowValueField
                })
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                var self = this;
                if (self.hoverPattern)
                    $.each(self.points, function(i, point) {
                        point.options.states.hover.fill = self.hoverPattern.id;
                        point.options.states.selected.fill = self.selectedPattern.id
                    });
                this.callBase(seriesElementsGroup, seriesMarkersGroup, labelsGroup);
                return this
            },
            adjustOptions: function() {
                var styles = this.styles,
                    options = this.options,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal,
                    hoverMode = options.hoverMode,
                    selectionMode = options.selectionMode,
                    func = function(mode) {
                        if (!mode)
                            return false;
                        switch (mode.toLowerCase()) {
                            case"allseriespoints":
                            case"allargumentpoints":
                            case"none":
                                return true
                        }
                    };
                attributes.stroke = attributes.fill;
                attributes.strokeWidth = attributes.lineWidth;
                normal.stroke = normal.fill;
                normal.strokeWidth = normal.lineWidth;
                hover.stroke = hover.fill;
                hover.strokeWidth = hover.lineWidth;
                selected.stroke = selected.fill;
                selected.strokeWidth = selected.lineWidth;
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r = 0;
                styles.point.hoverMode = func(hoverMode) && hoverMode;
                styles.point.selectionMode = func(selectionMode) && selectionMode;
                styles.point.visible = true
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file splineSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.SplineSeries = series.LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'spline';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            drawSegment: function(segment, attributes) {
                return this.renderer.createBezierPath(segment, attributes)
            },
            prepareSegments: function(index) {
                var self = this,
                    bezierPoints = [],
                    pointsCopy = self.segments[index];
                self.preparedSegments = self.preparedSegments || [];
                var checkExtr = function(otherPointCoord, pointCoord, controlCoord) {
                        return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
                    };
                var clonePoint = function(point, newX, newY) {
                        var p = DX.utils.clone(point);
                        p.x = newX;
                        p.y = newY;
                        return p
                    };
                if (pointsCopy.length !== 1)
                    $.each(pointsCopy, function(i, curPoint) {
                        var leftControlX,
                            leftControlY,
                            rightControlX,
                            rightControlY,
                            prevPoint,
                            nextPoint,
                            xCur,
                            yCur,
                            x1,
                            x2,
                            y1,
                            y2,
                            delta,
                            lambda = 0.5,
                            curIsExtremum,
                            leftPoint,
                            rightPoint,
                            a,
                            b,
                            c,
                            xc,
                            yc,
                            shift;
                        if (!i) {
                            bezierPoints.push(curPoint);
                            bezierPoints.push(curPoint);
                            return
                        }
                        prevPoint = pointsCopy[i - 1];
                        if (i < pointsCopy.length - 1) {
                            nextPoint = pointsCopy[i + 1];
                            xCur = curPoint.x;
                            yCur = curPoint.y;
                            x1 = prevPoint.x;
                            x2 = nextPoint.x;
                            y1 = prevPoint.y;
                            y2 = nextPoint.y;
                            curIsExtremum = !!(!self.options.rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || self.options.rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
                            if (curIsExtremum)
                                if (!self.options.rotated) {
                                    rightControlY = leftControlY = yCur;
                                    rightControlX = (xCur + nextPoint.x) / 2;
                                    leftControlX = (xCur + prevPoint.x) / 2
                                }
                                else {
                                    rightControlX = leftControlX = xCur;
                                    rightControlY = (yCur + nextPoint.y) / 2;
                                    leftControlY = (yCur + prevPoint.y) / 2
                                }
                            else {
                                a = y2 - y1;
                                b = x1 - x2;
                                c = y1 * x2 - x1 * y2;
                                if (!self.options.rotated) {
                                    xc = xCur;
                                    yc = -1 * (a * xc + c) / b;
                                    shift = yc - yCur || 0;
                                    y1 -= shift;
                                    y2 -= shift
                                }
                                else {
                                    yc = yCur;
                                    xc = -1 * (b * yc + c) / a;
                                    shift = xc - xCur || 0;
                                    x1 -= shift;
                                    x2 -= shift
                                }
                                rightControlX = (xCur + lambda * x2) / (1 + lambda);
                                rightControlY = (yCur + lambda * y2) / (1 + lambda);
                                leftControlX = (xCur + lambda * x1) / (1 + lambda);
                                leftControlY = (yCur + lambda * y1) / (1 + lambda)
                            }
                            if (!self.options.rotated) {
                                leftControlY = checkExtr(prevPoint.y, yCur, leftControlY);
                                rightControlY = checkExtr(nextPoint.y, yCur, rightControlY)
                            }
                            else {
                                leftControlX = checkExtr(prevPoint.x, xCur, leftControlX);
                                rightControlX = checkExtr(nextPoint.x, xCur, rightControlX)
                            }
                            leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
                            rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
                            bezierPoints.push(leftPoint, curPoint, rightPoint)
                        }
                        else {
                            bezierPoints.push(curPoint, curPoint);
                            return
                        }
                    });
                else
                    bezierPoints.push(pointsCopy[0]);
                self.preparedSegments[index] = bezierPoints
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file splineAreaSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.SplineAreaSeries = series.SplineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'splinearea';
                this.callBase(renderer, data, options, isRangeSeries);
                this.areas = this.areas || [];
                this.areaSegments = this.areaSegments || []
            },
            dispose: function() {
                var _this = this;
                _this.areas = null;
                _this.areaSegments = null;
                _this.paths = null;
                _this.callBase()
            },
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                if (!this.points.length)
                    return;
                var self = this;
                if (!this.points.length)
                    return;
                this.resetLineColors();
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                this.areas = [];
                $.each(self.preparedSegments, function(index, segment) {
                    self.prepareBezierAreaPoints(index);
                    self.areas.push(self.renderer.createBezierArea(self.areaSegments[index], self.styles.area).append(seriesElementsGroup))
                });
                if (self.styles.attributes.strokeWidth > 0 || self.styles.states.hover.strokeWidth > 0 || self.styles.states.selected.strokeWidth > 0)
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesElementsGroup))
                    });
                self.drawPoints(seriesMarkersGroup, labelsGroup);
                if (self.hoverPattern) {
                    self.styles.area.states.hover.fill = self.hoverPattern.id;
                    self.styles.area.states.selected.fill = self.selectedPattern.id;
                    self.styles.states.hover.fill = 'none';
                    self.styles.states.selected.fill = 'none'
                }
                return self
            },
            resetLineColors: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal;
                attributes.fill = 'none';
                delete attributes.lineWidth;
                normal.fill = 'none';
                delete normal.lineWidth;
                hover.fill = 'none';
                delete hover.lineWidth;
                selected.fill = 'none';
                delete selected.lineWidth
            },
            drawTrackers: function() {
                var self = this;
                if (this._suppressTrackers)
                    return;
                self.drawPointTrackers();
                self.trackerElements = [];
                $.each(this.areaSegments, function(_, segment) {
                    var tracker = self.renderer.createBezierArea(segment, {
                            strokeWidth: 0,
                            fill: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.trackerElements.push(tracker);
                    tracker.data({series: self})
                });
                return series
            },
            prepareBezierAreaPoints: function(index) {
                var segments = this.preparedSegments;
                var fwPoints = $.map(segments[index], function(pt) {
                        return pt.getCoords()
                    });
                var bwPoints = $.map(segments[index].slice().reverse(), function(pt) {
                        return pt.getCoords(true)
                    });
                var lastFwPoint = fwPoints[fwPoints.length - 1];
                var firstBwPoint = bwPoints[0];
                this.areaSegments[index] = fwPoints.concat({
                    x: lastFwPoint.x,
                    y: lastFwPoint.y
                }, {
                    x: firstBwPoint.x,
                    y: firstBwPoint.y
                }, bwPoints)
            },
            applyNormalStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.normal)
                    });
                return this.callBase(mode)
            },
            applyHoverStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.hover)
                    });
                return this.callBase(mode)
            },
            applySelectionStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.selected)
                    });
                return this.callBase(mode)
            },
            animate: function() {
                var self = this;
                this.callBase();
                if (this.preparedSegments && this.preparedSegments.length && this.areas)
                    $.each(this.areas, function(i, area) {
                        var fromPoints = self.getZeroAreaPoints(i);
                        area.applySettings({points: fromPoints});
                        area.animate({points: self.areaSegments[i]})
                    })
            },
            getZeroAreaPoints: function(i) {
                var fwPoints = $.map(this.preparedSegments[i], function(pt) {
                        return pt.getDefaultCoords()
                    });
                var bwPoints = $.map(this.preparedSegments[i].slice().reverse(), function(pt) {
                        return pt.getDefaultCoords()
                    });
                var lastFwPoint = fwPoints[fwPoints.length - 1];
                var firstBwPoint = bwPoints[0];
                return fwPoints.concat({
                        x: lastFwPoint.x,
                        y: lastFwPoint.y
                    }, {
                        x: firstBwPoint.x,
                        y: firstBwPoint.y
                    }, bwPoints)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal,
                    areaNormal = {},
                    areaHover = {},
                    areaSelected = {},
                    opacity;
                opacity = 'opacity' in attributes ? attributes.opacity : 0.5;
                areaNormal = {
                    fill: normal.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaHover = {
                    fill: hover.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaSelected = {
                    fill: selected.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                styles.area = {
                    fill: attributes.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity,
                    states: {
                        normal: areaNormal,
                        hover: areaHover,
                        selected: areaSelected
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file pieSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series,
            HOVERING_SPACING = 20,
            LABEL_SPACING = 80;
        series.PieSeries = series.BaseSeries.inherit({
            ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'pie';
                this.callBase(renderer, data, options);
                this.labelSpace = this.styles.point.label.visible ? LABEL_SPACING : 0;
                this.hoverSpace = 0 && this.styles.point.states.enableHover ? HOVERING_SPACING : 0;
                this.innerRadius = this.type === 'pie' ? 0 : options.innerRadius;
                this.outerRadius = options.radius;
                this.redraw = false
            },
            arrangePoints: function() {
                var series = this,
                    points,
                    pointsLength,
                    correction = 0,
                    translator = this.translator,
                    total = 0,
                    percent,
                    i,
                    isClockWise = series.options.segmentsDirection !== 'anticlockwise';
                series.points = $.map(series.points, function(point) {
                    if (point.value === null || point.value === 0 || point.value < 0)
                        return null;
                    return point
                });
                points = series.points;
                pointsLength = points.length;
                for (i = 0; i < pointsLength; i++)
                    total += points[i].value;
                $.each(isClockWise ? points : points.concat([]).reverse(), function(i, point) {
                    var val = point.value;
                    percent = val / total;
                    point.correctValue(correction, percent);
                    correction = correction + val
                })
            },
            createPatterns: function(){},
            drawSeriesData: function(seriesElementsGroup, seriesMarkersGroup, labelsGroup) {
                var self = this,
                    labelSpace,
                    bbox,
                    paneSpaceHeight,
                    paneSpaceWidth,
                    min;
                $.each(self.points, function(i, point) {
                    if (!point.hoverPatternColor) {
                        point.hoverPatternColor = point.options.states.hover.fill;
                        point.selectedPatternColor = point.options.states.selected.fill
                    }
                    if (!point.hoverPattern) {
                        point.hoverPattern = self.renderer.createPattern(point.hoverPatternColor, point.options.states.hover.hatching).append();
                        point.selectedPattern = self.renderer.createPattern(point.selectedPatternColor, point.options.states.selected.hatching).append()
                    }
                    point.hoverPattern.append();
                    point.selectedPattern.append();
                    point.options.states.hover.fill = point.hoverPattern.id;
                    point.options.states.selected.fill = point.selectedPattern.id
                });
                this.callBase(seriesElementsGroup, seriesMarkersGroup, labelsGroup);
                if (self.styles.point.label.visible) {
                    labelSpace = 0;
                    if (self.styles.point.label.position === 'columns') {
                        $.each(self.points, function(i, point) {
                            point.setLabelEllipsis = true;
                            bbox = point.insideLabelGroup.getBBox();
                            labelSpace = Math.max(bbox.width + point.INDENT_FROM_PIE + point.options.label.radialOffset, labelSpace)
                        });
                        self.redraw = true;
                        paneSpaceHeight = self.canvas.height - self.canvas.top - self.canvas.bottom;
                        paneSpaceWidth = self.canvas.width - self.canvas.left - self.canvas.right;
                        min = paneSpaceWidth < paneSpaceHeight ? paneSpaceWidth : paneSpaceHeight;
                        if (labelSpace > min / 2 - labelSpace)
                            self.labelSpace = min / 2;
                        else
                            self.labelSpace = 2 * labelSpace
                    }
                    else
                        $.each(self.points, function(i, point) {
                            point.setLabelEllipsis = true;
                            point.correctLabel()
                        })
                }
                return this
            },
            correctPosition: function(correction) {
                var debug = DX.utils.debug;
                debug.assert(correction, 'correction was not passed');
                debug.assertParam(correction.centerX, 'correction.centerX was not passed');
                debug.assertParam(correction.centerY, 'correction.centerY was not passed');
                debug.assertParam(correction.radiusInner, 'correction.radiusInner was not passed');
                debug.assertParam(correction.radiusOuter, 'correction.radiusOuter was not passed');
                $.each(this.points, function(_, point) {
                    point.correctPosition(correction)
                })
            },
            getRangeData: function() {
                var range = this.callBase();
                if (!range)
                    return range;
                if (range.minY !== undefined) {
                    range.minY = range.minY > 0 ? 0 : range.minY;
                    range.maxY = range.maxY < 0 ? 0 : range.maxY
                }
                return range
            },
            parseStyleOptions: function(options) {
                if (options.label && options.label.position && options.label.position !== 'outside' && options.label.position !== 'inside' && options.label.position !== 'columns')
                    options.label.position = 'outside';
                if (options.label.position && options.label.position === 'columns')
                    options.label.connector.visible = true;
                this.options.segmentsDirection = options.segmentsDirection || 'clockwise';
                this.styles = this.callBase(options);
                this.adjustOptions();
                return this.styles
            },
            adjustOptions: function() {
                var styles = this.styles,
                    options = this.options,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal,
                    hoverMode = options.hoverMode,
                    selectionMode = options.selectionMode,
                    func = function(mode) {
                        if (!mode)
                            return false;
                        switch (mode.toLowerCase()) {
                            case"none":
                                return true
                        }
                    };
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r;
                styles.point.hoverMode = func(hoverMode) && hoverMode;
                styles.point.selectionMode = func(selectionMode) && selectionMode;
                styles.point.visible = true
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file otherSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        series.RangeAreaSeries = series.AreaSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangearea';
                this.callBase(renderer, data, options, true)
            }});
        series.RangeBarSeries = series.BarSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangebar';
                this.callBase(renderer, data, options, true)
            }});
        series.RangeSplineAreaSeries = series.SplineAreaSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangesplinearea';
                this.callBase(renderer, data, options, true)
            }});
        series.ScatterSeries = series.BaseSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'scatter';
                this.callBase(renderer, data, options)
            }});
        series.StockSeries = series.CandleStickSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'stock';
                this.callBase(renderer, data, options)
            }})
    })(jQuery, DevExpress);
    /*! Module viz, file stepSeries.js */
    (function($, DX) {
        var series = DX.viz.charts.series;
        var prepareSegments = function(index) {
                var self = this,
                    segmentPoint = [];
                self.preparedSegments = self.preparedSegments || [];
                $.each(self.segments[index], function(i, pt) {
                    var stepY;
                    if (!i) {
                        segmentPoint.push(pt);
                        return
                    }
                    stepY = segmentPoint[segmentPoint.length - 1].y;
                    if (stepY !== pt.y) {
                        var point = DX.utils.clone(pt);
                        point.y = stepY;
                        segmentPoint.push(point)
                    }
                    segmentPoint.push(pt)
                });
                self.preparedSegments[index] = segmentPoint
            };
        series.StepLineSeries = series.LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'stepline';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            prepareSegments: prepareSegments
        });
        series.StepAreaSeries = series.AreaSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'steparea';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            prepareSegments: prepareSegments
        })
    })(jQuery, DevExpress);
    /*! Module viz, file seriesFamily.js */
    (function($, DX, undefined) {
        DX.viz.charts.series.SeriesFamily = DX.Class.inherit(function() {
            var ctor = function(options) {
                    var debug = DX.utils.debug;
                    debug.assert(options.type, 'type was not passed or empty');
                    var self = this,
                        stubFunction = $.noop;
                    $.extend(self, options);
                    self.type = self.type.toLowerCase();
                    self.series = [];
                    switch (self.type) {
                        case'bar':
                            self.adjustSeriesDimensions = adjustBarSeriesDimensions;
                            self.adjustSeriesValues = stubFunction;
                            self.updateSeriesValues = updateBarSeriesValues;
                            break;
                        case'rangebar':
                            self.adjustSeriesDimensions = adjustBarSeriesDimensions;
                            self.adjustSeriesValues = stubFunction;
                            self.updateSeriesValues = stubFunction;
                            break;
                        case'fullstackedbar':
                            self.fullStacked = true;
                            self.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                            self.adjustSeriesValues = adjustStackedSeriesValues;
                            self.updateSeriesValues = updateStackedSeriesValues;
                            break;
                        case'stackedbar':
                            self.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                            self.adjustSeriesValues = adjustStackedSeriesValues;
                            self.updateSeriesValues = updateStackedSeriesValues;
                            break;
                        case'fullstackedarea':
                        case'fullstackedline':
                            self.fullStacked = true;
                            self.adjustSeriesDimensions = stubFunction;
                            self.adjustSeriesValues = adjustStackedSeriesValues;
                            self.updateSeriesValues = stubFunction;
                            break;
                        case'stackedarea':
                        case'stackedline':
                            self.adjustSeriesDimensions = stubFunction;
                            self.adjustSeriesValues = adjustStackedSeriesValues;
                            self.updateSeriesValues = stubFunction;
                            break;
                        case'candlestick':
                        case'stock':
                            self.adjustSeriesDimensions = adjuistCandlestickSeriesDimensions;
                            self.adjustSeriesValues = stubFunction;
                            self.updateSeriesValues = stubFunction;
                            break;
                            self.updateSeriesValues = stubFunction;
                        default:
                            self.adjustSeriesDimensions = stubFunction;
                            self.adjustSeriesValues = stubFunction;
                            self.updateSeriesValues = stubFunction;
                            break
                    }
                };
            var dispose = function() {
                    this.series = null;
                    this.translator = null
                };
            var add = function(series) {
                    var self = this,
                        singleSeries,
                        i;
                    if (!$.isArray(series))
                        series = [series];
                    for (i = 0; i < series.length; i++) {
                        singleSeries = series[i];
                        if (singleSeries.type.toLowerCase() === self.type)
                            self.series.push(singleSeries)
                    }
                };
            var adjustBarSeriesDimensionsCore = function(series, interval, stackCount, equalBarWidth, seriesStackIndexCallback) {
                    var spacing,
                        width,
                        maxWidth,
                        middleIndex,
                        stackIndex,
                        i,
                        point,
                        points,
                        seriesOffset,
                        stackName,
                        argumentsKeeper = {},
                        stackKeepers = {},
                        stacksWithArgument,
                        count,
                        round = Math.round;
                    if (equalBarWidth) {
                        width = equalBarWidth.width && equalBarWidth.width < 0 ? 0 : equalBarWidth.width;
                        spacing = equalBarWidth.spacing && equalBarWidth.spacing < 0 ? 0 : equalBarWidth.spacing;
                        if (width && !spacing)
                            if (stackCount > 1) {
                                spacing = round((interval * 0.7 - width * stackCount) / (stackCount - 1));
                                if (spacing < 1)
                                    spacing = 1
                            }
                            else
                                spacing = 0;
                        else if (spacing && !width) {
                            width = round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                            if (width < 2)
                                width = 2
                        }
                        else if (!spacing && !width) {
                            if (stackCount > 1) {
                                spacing = round(interval * 0.7 / stackCount * 0.2);
                                if (spacing < 1)
                                    spacing = 1
                            }
                            else
                                spacing = 0;
                            width = round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                            if (width < 2)
                                width = 2
                        }
                        if (width * stackCount + spacing * (stackCount - 1) > interval) {
                            spacing = round((interval * 0.7 - width * stackCount) / (stackCount - 1));
                            if (spacing < 1) {
                                spacing = 1;
                                maxWidth = round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount)
                            }
                        }
                        middleIndex = stackCount / 2;
                        for (i = 0; i < series.length; i++) {
                            stackIndex = seriesStackIndexCallback(i);
                            points = series[i].getPoints();
                            seriesOffset = (stackIndex - middleIndex + 0.5) * (maxWidth || width) - (middleIndex - stackIndex - 0.5) * spacing;
                            $.each(points, function(_, point) {
                                point.correctCoordinates({
                                    width: width,
                                    offset: seriesOffset
                                })
                            })
                        }
                    }
                    else {
                        $.each(series, function(i, singleSeries) {
                            stackName = singleSeries.getStackName && singleSeries.getStackName();
                            stackName = stackName || i.toString();
                            if (!stackKeepers[stackName])
                                stackKeepers[stackName] = [];
                            stackKeepers[stackName].push(singleSeries)
                        });
                        $.each(series, function(i, singleSeries) {
                            $.each(singleSeries.getPoints(), function(_, point) {
                                var argument = point.argument;
                                if (!argumentsKeeper.hasOwnProperty(argument))
                                    argumentsKeeper[argument] = 1
                            })
                        });
                        for (var argument in argumentsKeeper) {
                            if (!argumentsKeeper.hasOwnProperty(argument))
                                continue;
                            stacksWithArgument = [];
                            $.each(stackKeepers, function(stackName, seriesInStack) {
                                $.each(seriesInStack, function(i, singleSeries) {
                                    point = singleSeries.getPointByArg(argument);
                                    if (point && point.value) {
                                        stacksWithArgument.push(stackName);
                                        return false
                                    }
                                })
                            });
                            count = stacksWithArgument.length;
                            spacing = round(interval * 0.7 / count * 0.2);
                            if (spacing < 1)
                                spacing = 1;
                            width = round((interval * 0.7 - spacing * (count - 1)) / count);
                            if (width < 2)
                                width = 2;
                            middleIndex = count / 2;
                            $.each(stackKeepers, function(stackName, seriesInStack) {
                                stackIndex = $.inArray(stackName, stacksWithArgument);
                                if (stackIndex === -1)
                                    return;
                                seriesOffset = (stackIndex - middleIndex + 0.5) * width - (middleIndex - stackIndex - 0.5) * spacing;
                                $.each(seriesInStack, function(i, singleSeries) {
                                    var point = singleSeries.getPointByArg(argument);
                                    if (point && point.value)
                                        point.correctCoordinates({
                                            width: width,
                                            offset: seriesOffset
                                        })
                                })
                            })
                        }
                    }
                };
            var adjustBarSeriesDimensions = function(translator) {
                    var debug = DX.utils.debug;
                    debug.assert(translator, 'translator was not passed or empty');
                    var self = this,
                        series = self.series,
                        equalBarWidth = self.equalBarWidth,
                        interval;
                    self.translator = translator;
                    interval = setInterval(self);
                    adjustBarSeriesDimensionsCore(series, interval, series.length, equalBarWidth, function(seriesIndex) {
                        return seriesIndex
                    })
                };
            var adjustStackedBarSeriesDimensions = function(translator) {
                    var debug = DX.utils.debug;
                    debug.assert(translator, 'translator was not passed or empty');
                    var self = this,
                        interval,
                        series = self.series,
                        stackIndexes = {},
                        stackCount = 0,
                        equalBarWidth = self.equalBarWidth;
                    $.each(series, function() {
                        var stackName = this.getStackName();
                        if (!stackIndexes.hasOwnProperty(stackName))
                            stackIndexes[stackName] = stackCount++
                    });
                    self.translator = translator;
                    interval = setInterval(self);
                    adjustBarSeriesDimensionsCore(series, interval, stackCount, equalBarWidth, function(seriesIndex) {
                        return stackIndexes[series[seriesIndex].getStackName()]
                    })
                };
            var adjustStackedSeriesValues = function() {
                    var self = this,
                        series = self.series,
                        stackKeepers = {
                            positive: {},
                            negative: {}
                        };
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints();
                        $.each(points, function(index, point) {
                            var value = point.value,
                                argument = point.argument,
                                stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                                valueType = value >= 0 ? 'positive' : 'negative',
                                currentStack;
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            if (currentStack[argument.valueOf()]) {
                                points[index].correctValue(currentStack[argument.valueOf()]);
                                currentStack[argument.valueOf()] += value
                            }
                            else
                                currentStack[argument.valueOf()] = value
                        })
                    });
                    if (self.fullStacked)
                        adjustFullStackedSeriesValues(series, stackKeepers)
                };
            var adjustFullStackedSeriesValues = function(series, stackKeepers) {
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints();
                        $.each(points, function(index, point) {
                            var value = point.value,
                                stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                                valueType = value >= 0 ? 'positive' : 'negative',
                                currentStack;
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            points[index].normalizeValue(currentStack[point.argument.valueOf()])
                        })
                    })
                };
            var getMinShownBusinessValue = function(self, translator, minBarSize) {
                    var rotated = self.rotated,
                        canvas = translator.getCanvasVisibleArea();
                    if (minBarSize && !rotated)
                        return Math.abs(translator.untranslateY(canvas.minY) - translator.untranslateY(canvas.minY + minBarSize));
                    else if (minBarSize && rotated)
                        return Math.abs(translator.untranslateX(canvas.minX) - translator.untranslateX(canvas.minX + minBarSize))
                };
            var updateStackedSeriesValues = function(translator) {
                    var self = this,
                        series = self.series,
                        stackKeepers = {
                            positive: {},
                            negative: {}
                        };
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints(),
                            minBarSize = singleSeries.styles && singleSeries.styles.minBarSize;
                        $.each(points, function(index, point) {
                            var value = point.value,
                                minValue = point.minValue,
                                argument = point.argument,
                                updateValue,
                                pointSize,
                                minShownBusinessValue,
                                stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                                valueType = value >= 0 ? 'positive' : 'negative',
                                currentStack;
                            minShownBusinessValue = getMinShownBusinessValue(self, translator, minBarSize);
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            if (currentStack[argument.valueOf()]) {
                                pointSize = Math.abs(minValue - value);
                                if (minShownBusinessValue && pointSize < minShownBusinessValue && pointSize !== 0)
                                    updateValue = minShownBusinessValue;
                                else
                                    updateValue = Math.abs(value - minValue);
                                points[index].minValue = currentStack[argument.valueOf()];
                                points[index].value = currentStack[argument.valueOf()] + updateValue;
                                currentStack[argument.valueOf()] += updateValue
                            }
                            else {
                                pointSize = value;
                                if (minShownBusinessValue && pointSize < minShownBusinessValue && pointSize !== 0)
                                    updateValue = minShownBusinessValue;
                                else
                                    updateValue = value;
                                points[index].value = updateValue;
                                currentStack[argument.valueOf()] = updateValue
                            }
                        })
                    });
                    if (self.fullStacked)
                        updateFullStackedSeriesValues(series, stackKeepers)
                };
            var updateFullStackedSeriesValues = function(series, stackKeepers) {
                    $.each(series, function(_, singleSeries) {
                        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                            points = singleSeries.getPoints();
                        $.each(points, function(index, point) {
                            var value = point.value,
                                argument = point.argument,
                                valueType = value >= 0 ? 'positive' : 'negative',
                                currentStack;
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            points[index].value = points[index].value / currentStack[argument.valueOf()] || 0;
                            if (DX.utils.isNumber(points[index].minValue))
                                points[index].minValue = points[index].minValue / currentStack[argument.valueOf()] || 0
                        })
                    })
                };
            var updateBarSeriesValues = function(translator) {
                    var self = this,
                        series = self.series,
                        rotated = self.rotated,
                        canvas = translator.getCanvasVisibleArea();
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints(),
                            minBarSize = singleSeries.styles && singleSeries.styles.minBarSize;
                        $.each(points, function(index, point) {
                            var value = point.value,
                                updateValue,
                                pointSize,
                                minShownBusinessValue;
                            minShownBusinessValue = getMinShownBusinessValue(self, translator, minBarSize);
                            pointSize = Math.abs(value);
                            if (minShownBusinessValue && pointSize < minShownBusinessValue && pointSize !== 0)
                                updateValue = value > 0 ? minShownBusinessValue : -minShownBusinessValue;
                            else
                                updateValue = value;
                            points[index].value = updateValue
                        })
                    })
                };
            var adjuistCandlestickSeriesDimensions = function(translator) {
                    var debug = DX.utils.debug;
                    debug.assert(translator, 'translator was not passed or empty');
                    var self = this,
                        series = self.series,
                        interval;
                    self.translator = translator;
                    interval = setInterval(self);
                    adjustBarSeriesDimensionsCore(series, interval, series.length, true, function(seriesIndex) {
                        return seriesIndex
                    })
                };
            var setInterval = function(self) {
                    if (!self.rotated)
                        self.interval = self.translator.getIntervalX();
                    else
                        self.interval = self.translator.getIntervalY();
                    return self.interval
                };
            return {
                    ctor: ctor,
                    dispose: dispose,
                    add: add
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file factory.js */
    (function($, DX) {
        var charts = DX.viz.charts,
            series = charts.series,
            renderers = DX.viz.renderers;
        charts.factory = function() {
            var createSeries = function(seriesType, renderer, data, options) {
                    options = options || {};
                    options.specificType = null;
                    seriesType = (String(seriesType) || '').toLowerCase();
                    switch (seriesType.toLowerCase()) {
                        case'line':
                            return new series.LineSeries(renderer, data, options);
                        case'fullstackedline':
                            options.specificType = 'fullstackedline';
                            return new series.LineSeries(renderer, data, options);
                        case'stackedline':
                            options.specificType = 'stackedline';
                            return new series.LineSeries(renderer, data, options);
                        case'area':
                            return new series.AreaSeries(renderer, data, options);
                        case'fullstackedarea':
                            options.specificType = 'fullstackedarea';
                            return new series.AreaSeries(renderer, data, options);
                        case'stackedarea':
                            options.specificType = 'stackedarea';
                            return new series.AreaSeries(renderer, data, options);
                        case'bar':
                            return new series.BarSeries(renderer, data, options);
                        case'fullstackedbar':
                            options.specificType = 'fullstackedbar';
                            return new series.BarSeries(renderer, data, options);
                        case'stackedbar':
                            options.specificType = 'stackedbar';
                            return new series.BarSeries(renderer, data, options);
                        case'spline':
                            return new series.SplineSeries(renderer, data, options);
                        case'splinearea':
                            return new series.SplineAreaSeries(renderer, data, options);
                        case'scatter':
                            return new series.ScatterSeries(renderer, data, options);
                        case'candlestick':
                            return new series.CandleStickSeries(renderer, data, options);
                        case'stock':
                            return new series.StockSeries(renderer, data, options);
                        case'rangearea':
                            return new series.RangeAreaSeries(renderer, data, options);
                        case'rangebar':
                            return new series.RangeBarSeries(renderer, data, options);
                        case'pie':
                            return new series.PieSeries(renderer, data, options);
                        case'doughnut':
                        case'donut':
                            options.specificType = 'doughnut';
                            return new series.PieSeries(renderer, data, options);
                        case'stepline':
                            return new series.StepLineSeries(renderer, data, options);
                        case'steparea':
                            return new series.StepAreaSeries(renderer, data, options);
                        default:
                            return null
                    }
                };
            var createSeriesFamily = function(options) {
                    return new series.SeriesFamily(options)
                };
            var createAxis = function(renderer, options) {
                    return new charts.Axis(renderer, options)
                };
            var createRenderer = function(options) {
                    return new renderers.Renderer(options)
                };
            var createThemeManager = function(options, groupName) {
                    return new charts.ThemeManager(options, groupName)
                };
            var createLegend = function(options, group, trackerGroup) {
                    return new charts.Legend(options, group, trackerGroup)
                };
            var createTooltip = function(options, group) {
                    return new charts.Tooltip(options, group)
                };
            var createTracker = function(options) {
                    return new charts.Tracker(options)
                };
            var createTitle = function(renderer, canvas, options, group) {
                    return new charts.ChartTitle(renderer, canvas, options, group)
                };
            var createChartLayoutManager = function() {
                    return new charts.LayoutManager
                };
            var getAxisTickProvider = function() {
                    return DX.viz.core.tickProvider
                };
            return {
                    createSeries: createSeries,
                    createSeriesFamily: createSeriesFamily,
                    createAxis: createAxis,
                    getAxisTickProvider: getAxisTickProvider,
                    createRenderer: createRenderer,
                    createThemeManager: createThemeManager,
                    createLegend: createLegend,
                    createTooltip: createTooltip,
                    createTracker: createTracker,
                    createChartLayoutManager: createChartLayoutManager,
                    createTitle: createTitle
                }
        }()
    })(jQuery, DevExpress);
    /*! Module viz, file tracker.js */
    (function($, DX) {
        var charts = DX.viz.charts,
            eventsConsts = charts.series.consts.events,
            utils = DX.utils,
            isFunction = utils.isFunction,
            isDefined = utils.isDefined,
            MULTIPLE_MODE = 'multiple',
            SINGLE_MODE = 'single',
            ALL_ARGUMENTS_POINTS_MODE = 'allargumentpoints',
            ALL_SERIES_POINTS_MODE = 'allseriespoints',
            msPointerEnabled = window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints || null,
            MOUSE_EVENT_LOCK_TIMEOUT = 1000,
            CLICK_EVENT_LOCK_TIMEOUT = 600,
            TOOLTIP_HOLD_TIMEOUT = 400,
            NONE_MODE = 'none';
        charts.Tracker = DX.Class.inherit({
            ctor: function(options) {
                options.events = options.events || {};
                this._reinit(options);
                this.pointSelectionMode = this._prepareMode(options.pointSelectionMode);
                this.seriesSelectionMode = this._prepareMode(options.seriesSelectionMode);
                this.hoverStartDelay = 100;
                this.hoverHoldDelay = 200;
                this.sensitivity = 7;
                if (this.pointSelectionMode === MULTIPLE_MODE) {
                    this._releaseSelectedPoint = this._releaseSelectedPointMultiMode;
                    this.selectedPoint = []
                }
                else
                    this._releaseSelectedPoint = this._releaseSelectedPointSingleMode;
                if (this.seriesSelectionMode === MULTIPLE_MODE) {
                    this._releaseSelectedSeries = this._releaseSelectedSeriesMultiMode;
                    this.selectedSeries = []
                }
                else
                    this._releaseSelectedSeries = this._releaseSelectedSeriesSingleMode;
                this.tooltipEnabled = options.tooltipEnabled;
                this.tooltipShown = options.tooltipShown;
                this.tooltipHidden = options.tooltipHidden;
                this.seriesClick = options.events.seriesClick;
                this.pointClick = options.events.pointClick;
                this.argumentAxisClick = options.events.argumentAxisClick;
                this.seriesHover = options.events.seriesHover;
                this.seriesSelected = options.events.seriesSelected;
                this.pointHover = options.events.pointHover;
                this.pointSelected = options.events.pointSelected;
                this.seriesTrackerGroup = options.seriesTrackerGroup;
                this.markerTrackerGroup = options.markerTrackerGroup;
                this.seriesGroup = options.seriesGroup;
                this.legendGroup = options.legendGroup;
                this.seriesGroup.on(eventsConsts.selectSeries, {tracker: this}, this._selectSeries);
                this.seriesGroup.on(eventsConsts.deselectSeries, {tracker: this}, this._deselectSeries);
                this.seriesGroup.on(eventsConsts.selectPoint, {tracker: this}, this._selectPoint);
                this.seriesGroup.on(eventsConsts.deselectPoint, {tracker: this}, this._deselectPoint);
                this.seriesGroup.on(eventsConsts.showPointTooltip, {tracker: this}, this._showPointTooltip);
                this.seriesGroup.on(eventsConsts.hidePointTooltip, {tracker: this}, this._hidePointTooltip)
            },
            _reinit: function(options) {
                options = options || {};
                this.storedSeries = options.series || [];
                this.argumentAxis = options.argumentAxis || []
            },
            dispose: function() {
                var _this = this;
                clearTimeout(_this.tooltipHoldTimeout);
                clearTimeout(_this.hoverStartTimeOut);
                clearTimeout(_this.hoverHoldTimeOut);
                clearTimeout(_this.unlockMouseTimer);
                clearTimeout(_this.lockClickTimer);
                $.each(_this.argumentAxis, function(_, axis) {
                    axis._axisElementsGroup && axis._axisElementsGroup.off()
                });
                _this.seriesTrackerGroup.off();
                _this.markerTrackerGroup.off();
                _this.legendGroup.off();
                _this.seriesGroup.off();
                _this.argumentAxis = null;
                _this.seriesTrackerGroup = null;
                _this.markerTrackerGroup = null;
                _this.legendGroup = null;
                _this.seriesGroup = null;
                _this.selectedPoint = null;
                _this.selectedSeries = null;
                _this.hoveredSeries = null;
                _this.hoveredPoint = null;
                _this.storedSeries = null;
                _this.argumentAxis = null;
                _this.hoveredObject = null;
                _this.pointAtShownTooltip = null
            },
            _prepareMode: function(mode) {
                mode = (mode || '').toLowerCase();
                return mode = mode !== SINGLE_MODE && mode !== MULTIPLE_MODE ? SINGLE_MODE : mode
            },
            _prepare: function(typeChart) {
                var self = this;
                if (self._prepared)
                    return;
                $.each(self.argumentAxis, function(_, axis) {
                    self._eventHandler(axis._axisElementsGroup, {
                        parser: self._getOptionsAxis,
                        condition: self._axisCondition,
                        execute: self._axisEvent
                    }, {
                        tracker: self,
                        axis: axis
                    })
                });
                self._eventHandler(self.seriesTrackerGroup, {
                    parser: self._getOptionsPointSeries,
                    condition: self._seriesCondition,
                    execute: self._seriesEvent
                }, {tracker: self});
                self._eventHandler(self.markerTrackerGroup, {
                    parser: self._getOptionsPointSeries,
                    condition: self._pointCondition,
                    execute: self._pointEvent
                }, {tracker: self});
                if (typeChart === 'pieChart')
                    self._eventHandler(self.legendGroup, {
                        parser: self._getOptionsPointSeries,
                        condition: self._pointCondition,
                        execute: self._pointEvent
                    }, {tracker: self});
                else
                    self._eventHandler(self.legendGroup, {
                        parser: self._getOptionsPointSeries,
                        condition: self._seriesCondition,
                        execute: self._seriesEvent
                    }, {tracker: self});
                self._prepared = true
            },
            _eventHandler: function(group, handlers, data) {
                var prepareHandlers = this._designerHandlers(handlers);
                group.on(prepareHandlers, data)
            },
            _designerHandlers: function(handler) {
                var handlers = {},
                    parser = handler.parser,
                    condition = handler.condition,
                    execute = handler.execute,
                    designerHandle = function(eventType, func) {
                        if (condition && condition[eventType] === null)
                            return;
                        handlers[eventType] = function(event) {
                            var options = parser ? parser(event) : event;
                            if (!options)
                                return;
                            if (condition && condition[eventType] && condition[eventType].call)
                                condition[eventType].apply(null, options.concat([func]));
                            else
                                func.apply(null, options)
                        }
                    };
                $.each(execute, designerHandle);
                return handlers
            },
            _getOptionsPointSeries: function(event) {
                var object = $(event.target).data('point') || $(event.target).data('series'),
                    self = event.data.tracker,
                    mode = object && ($(event.target).data('mode') || object.options.hoverMode);
                if (event.type === 'mousemove')
                    return [self, event.pageX, event.pageY];
                if (!object)
                    return null;
                return [self, object, mode]
            },
            _getOptionsAxis: function(event) {
                var self = event.data.tracker,
                    axis = event.data.axis,
                    mode = axis.options.hoverMode,
                    argument;
                if (event.target.tagName === "tspan")
                    argument = $(event.target).parent().data('argument');
                else
                    argument = $(event.target).data('argument');
                if (event.type === 'mousemove')
                    return [self, event.pageX, event.pageY];
                if (!axis)
                    return null;
                return [self, axis, mode, argument]
            },
            _pointEvent: {
                mouseover: function(self, point, mode) {
                    if (self.mouseLocked)
                        return;
                    self._setHoveredPoint(point, mode);
                    if (self.tooltipEnabled)
                        self._showTooltip(self.tooltip, point);
                    $(point).trigger('testmousehoverpoint')
                },
                mouseout: function(self, point, mode) {
                    if (self.mouseLocked)
                        return;
                    self._clearHover(self);
                    $(point).trigger('testmouseoutpoint')
                },
                mousemove: function(self, pageX, pageY) {
                    self._getCurCoords(self, pageX, pageY)
                },
                touchstart: function(self, point, mode) {
                    self.showHoldTooltip = false;
                    self._mouseLock(self);
                    if (self.tooltipEnabled)
                        self.tooltipHoldTimeout = setTimeout(function() {
                            self.showHoldTooltip = true;
                            self._showTooltip(self.tooltip, point);
                            $(point).trigger('testHoldTooltip')
                        }, TOOLTIP_HOLD_TIMEOUT)
                },
                touchend: function(self, point, mode) {
                    if (!self.showHoldTooltip)
                        self._pointClick(self, point, true);
                    clearTimeout(self.tooltipHoldTimeout);
                    self._clickLock(self);
                    self._clearHover(self)
                },
                click: function(self, point) {
                    self._pointClick(self, point, false)
                },
                mousedown: function(self, point, mode) {
                    self._pointEvent.touchstart(self, point, mode)
                },
                mouseup: function(self, point, mode) {
                    self._pointEvent.touchend(self, point, mode)
                }
            },
            _pointCondition: {
                mouseover: function(self, point, mode, func) {
                    if (mode === ALL_ARGUMENTS_POINTS_MODE && self.hoveredPoint && self.hoveredPoint.argument === point.argument) {
                        self.hoverHoldTimeOut = clearTimeout(self.hoverHoldTimeOut);
                        self.hoveredObject = point;
                        func(self, point, mode);
                        $(point).trigger('testHoverHoldTimeOutCleared');
                        return
                    }
                    self._setHover(self, point, mode, func)
                },
                mouseout: function(self, point, mode, func) {
                    self._releaseHover(self, point, mode, func)
                },
                touchstart: !msPointerEnabled,
                touchend: !msPointerEnabled,
                mousedown: msPointerEnabled,
                mouseup: msPointerEnabled
            },
            _seriesEvent: {
                mouseover: function(self, series, mode) {
                    if (self.mouseLocked)
                        return;
                    self._setHoveredSeries(series, mode);
                    $(series).trigger('testmousehoverseries')
                },
                mouseout: function(self, series, mode) {
                    self._clearHover(self);
                    $(series).trigger('testmouseoutseries')
                },
                mousemove: function(self, pageX, pageY) {
                    self._getCurCoords(self, pageX, pageY)
                },
                touchstart: function(self) {
                    self._mouseLock(self)
                },
                touchend: function(self, series) {
                    self._seriesClick(self, series, true);
                    self._clickLock(self)
                },
                click: function(self, series) {
                    self._seriesClick(self, series, false)
                },
                mousedown: function(self, point, mode) {
                    self._seriesEvent.touchstart(self, point, mode)
                },
                mouseup: function(self, point, mode) {
                    self._seriesEvent.touchend(self, point, mode)
                }
            },
            _seriesCondition: {
                mouseover: function(self, series, mode, func) {
                    self._setHover(self, series, mode, func)
                },
                mouseout: function(self, series, mode, func) {
                    self._releaseHover(self, series, mode, func)
                },
                touchstart: !msPointerEnabled,
                touchend: !msPointerEnabled,
                mousedown: msPointerEnabled,
                mouseup: msPointerEnabled
            },
            _axisEvent: {
                mouseover: function(self, axis, argument) {
                    if (self.mouseLocked || isDefined(self.hoveredArgument) && self.hoveredArgument === argument)
                        return;
                    self._clearHover(self);
                    if (isDefined(self.hoveredArgument))
                        self._toAllArgumentPoints(self.hoveredArgument, 'releasePointHoverState');
                    self._toAllArgumentPoints(argument, 'setPointHoverState');
                    self.hoveredArgument = argument;
                    $(axis).trigger('testmousehoveraxis')
                },
                mouseout: function(self, axis) {
                    if (self.mouseLocked || !isDefined(self.hoveredArgument))
                        return;
                    self._toAllArgumentPoints(self.hoveredArgument, 'releasePointHoverState');
                    self.hoveredArgument = null;
                    $(axis).trigger('testmouseoutaxis')
                },
                mousemove: function(self, pageX, pageY) {
                    self._getCurCoords(self, pageX, pageY)
                },
                touchstart: function(self) {
                    self._mouseLock(self)
                },
                touchend: function(self, axis, mode, argument) {
                    self._argumentAxisClick(self, axis, argument, true);
                    self._clearHover(self);
                    self._clickLock(self)
                },
                click: function(self, axis, mode, argument) {
                    self._clearHover(self);
                    self._argumentAxisClick(self, axis, argument, false);
                    self._clickLock(self)
                },
                mousedown: function(self) {
                    self._axisEvent.touchstart(self, point, mode)
                },
                mouseup: function(self, axis, mode, argument) {
                    self._axisEvent.touchend(self, axis, mode, argument)
                }
            },
            _axisCondition: {
                mouseover: function(self, axis, mode, argument, func) {
                    if (mode === ALL_ARGUMENTS_POINTS_MODE)
                        self._setHover(self, axis, argument, func)
                },
                mouseout: function(self, axis, mode, argument, func) {
                    self._releaseHover(self, axis, argument, func)
                },
                touchstart: !msPointerEnabled,
                touchend: !msPointerEnabled,
                mousedown: msPointerEnabled,
                mouseup: msPointerEnabled
            },
            _setHover: function(self, object, mode, func) {
                if (object === self.hoveredObject) {
                    self.hoverHoldTimeOut = clearTimeout(self.hoverHoldTimeOut);
                    if (mode === object.lastHoverMode)
                        return
                }
                if (self.mouseLocked)
                    return;
                self.hoverStartTimeOut = setTimeout(function() {
                    self._compareCoords(object, self, mode, func)
                }, self.hoverStartDelay)
            },
            _releaseHover: function(self, object, mode, func) {
                if (self.mouseLocked)
                    return;
                self.hoverStartTimeOut = clearTimeout(self.hoverStartTimeOut);
                if (object === self.hoveredObject)
                    self.hoverHoldTimeOut = setTimeout(function() {
                        self.hoveredObject = null;
                        func(self, object, mode)
                    }, self.hoverHoldDelay)
            },
            _compareCoords: function(point, self, mode, func) {
                clearTimeout(self.hoverStartTimeOut);
                if (Math.abs(self.pX - self.cX) + Math.abs(self.pY - self.cY) < self.sensitivity) {
                    if (self.mouseLocked)
                        return;
                    clearTimeout(self.hoverHoldTimeOut);
                    self.hoveredObject = point;
                    func(self, point, mode)
                }
                else {
                    self.pX = self.cX;
                    self.pY = self.cY;
                    self.hoverStartTimeOut = setTimeout(function() {
                        self._compareCoords(point, self, mode, func)
                    }, self.hoverStartDelay)
                }
            },
            _seriesClick: function(self, series, touchEvent) {
                if (self.lockClick && !touchEvent)
                    return;
                self.seriesClick && self.seriesClick.call && self.seriesClick.call(series, series)
            },
            _pointClick: function(self, point, touchEvent) {
                var series = point.series;
                if (self.lockClick && !touchEvent)
                    return;
                if (self.pointClick && self.pointClick.call && self.pointClick != $.noop) {
                    self.pointClick.call(point, point);
                    return
                }
                self.seriesClick && self.seriesClick.call && self.seriesClick.call(series, series);
                return
            },
            _argumentAxisClick: function(self, axis, argument, touchEvent) {
                if (self.lockClick && !touchEvent)
                    return;
                self.argumentAxisClick && self.argumentAxisClick.call && self.argumentAxisClick.call(axis, axis, argument)
            },
            _selectSeries: function(event, mode) {
                event.data.tracker._setSelectedSeries(event.target, mode)
            },
            _deselectSeries: function(event, mode) {
                event.data.tracker._releaseSelectedSeries(event.target, mode)
            },
            _selectPoint: function(event, point) {
                event.data.tracker._setSelectedPoint(point)
            },
            _deselectPoint: function(event, point) {
                event.data.tracker._releaseSelectedPoint(point)
            },
            _showPointTooltip: function(event, point) {
                var self = event.data.tracker;
                self._showTooltip(self.tooltip, point)
            },
            _hidePointTooltip: function(event, point) {
                event.data.tracker._hideTooltip(point)
            },
            _hideTooltip: function(point) {
                var tooltip = this && this.tooltip;
                if (!tooltip || point && this.pointAtShownTooltip !== point)
                    return;
                point = point || this.pointAtShownTooltip;
                tooltip.hide();
                this.pointAtShownTooltip && isFunction(this.tooltipHidden) && this.tooltipHidden.call(point, point);
                this.pointAtShownTooltip = null
            },
            _showTooltip: function(tooltip, point) {
                var tooltipFormatObject = point.getTooltipFormatObject(tooltip);
                if (!isDefined(tooltipFormatObject.valueText))
                    return;
                this.pointAtShownTooltip && this._hideTooltip(this.pointAtShownTooltip);
                var tooltipCoords = point.getTooltipCoords();
                var tooltipText = tooltip.formatTooltip.call(tooltipFormatObject, tooltip.options);
                if (!isDefined(tooltipText) || !isDefined(tooltipCoords.x) || !isDefined(tooltipCoords.y) || !tooltip)
                    return;
                tooltip.show();
                tooltip.move(~~tooltipCoords.x, ~~tooltipCoords.y, tooltipCoords.offset, tooltipText, point.getColor(), point.getClassName());
                !this.pointAtShownTooltip && isFunction(this.tooltipShown) && this.tooltipShown.call(point, point);
                this.pointAtShownTooltip = point
            },
            _setHoveredSeries: function(series, mode) {
                var self = this;
                if (mode !== NONE_MODE && self.hoveredSeries !== series || series.lastHoverMode !== mode) {
                    self._clearHover(self);
                    self.hoveredSeries = series;
                    series.setHoverState(mode);
                    self.seriesHover && self.seriesHover.call && self.seriesHover.call(series, series)
                }
                if (mode === NONE_MODE)
                    $(series).trigger('NoneMode')
            },
            _setSelectedSeries: function(series, mode) {
                var self = this,
                    seriesContain = false;
                if (this.seriesSelectionMode === MULTIPLE_MODE)
                    $.each(self.selectedSeries, function(_, sr) {
                        if (sr == series) {
                            seriesContain = true;
                            return false
                        }
                    });
                else if (self.selectedSeries == series)
                    seriesContain = true;
                if (!seriesContain || series.lastSelectionMode !== mode) {
                    if (self.seriesSelectionMode === SINGLE_MODE) {
                        this._releaseSelectedSeries();
                        self.selectedSeries = series
                    }
                    else
                        self.selectedSeries.push(series);
                    series.setSelectedState(mode);
                    self.seriesSelected && self.seriesSelected.call && self.seriesSelected.call(series, series)
                }
            },
            _setHoveredPoint: function(point, mode) {
                var self = this;
                var debug = DX.utils.debug;
                debug.assert(point.series, 'series was not assigned to point or empty');
                if (self.hoveredPoint === point && !point.series)
                    return;
                self._clearHover(self);
                self.hoveredPoint = point;
                self._setHoverStylePointWithMode(point, 'setPointHoverState', mode || point.options.hoverMode);
                self.pointHover && self.pointHover.call && self.pointHover.call(point, point)
            },
            _toAllArgumentPoints: function(argument, func) {
                $.each(this.storedSeries, function(_, series) {
                    var neighborPoint = series.getPointByArg(argument);
                    if (neighborPoint)
                        series[func](neighborPoint)
                })
            },
            _setHoverStylePointWithMode: function(point, func, mode) {
                switch (mode) {
                    case ALL_ARGUMENTS_POINTS_MODE:
                        this._toAllArgumentPoints(point.argument, func);
                        break;
                    case ALL_SERIES_POINTS_MODE:
                        $.each(point.series.points, function(_, point) {
                            point.series[func](point)
                        });
                        break;
                    case NONE_MODE:
                        break;
                    default:
                        point.series[func](point)
                }
            },
            _setSelectedPoint: function(point) {
                var self = this,
                    pointContain = false;
                if (this.pointSelectionMode === MULTIPLE_MODE) {
                    $.each(self.selectedPoint, function(_, pt) {
                        if (pt == point) {
                            pointContain = true;
                            return false
                        }
                    });
                    !pointContain && self.selectedPoint.push(point)
                }
                else if (self.selectedPoint !== point) {
                    this._releaseSelectedPoint();
                    self.selectedPoint = point
                }
                else
                    pointContain = true;
                if (!pointContain) {
                    self._setHoverStylePointWithMode(point, 'setPointSelectedState', point.options.selectionMode);
                    self.pointSelected && self.pointSelected.call && self.pointSelected.call(point, point)
                }
            },
            _releaseHoveredSeries: function() {
                if (!this.hoveredSeries)
                    return;
                this.hoveredSeries.releaseHoverState();
                this.hoveredSeries = null
            },
            _releaseSelectedSeriesMultiMode: function(series) {
                if (!this.selectedSeries)
                    return;
                series.releaseSelectedState();
                this.selectedSeries = $.map(this.selectedSeries, function(sr) {
                    if (sr !== series)
                        return sr
                })
            },
            _releaseSelectedSeriesSingleMode: function() {
                if (!this.selectedSeries)
                    return;
                this.selectedSeries.releaseSelectedState();
                this.selectedSeries = null
            },
            _releaseHoveredPoint: function() {
                var self = this,
                    point = self.hoveredPoint;
                if (self.tooltipEnabled && !self.showHoldTooltip)
                    self._hideTooltip(point);
                if (!point)
                    return;
                if (point.options.hoverMode === ALL_SERIES_POINTS_MODE)
                    $.each(point.series.points, function(_, point) {
                        point.series.releasePointHoverState(point)
                    });
                else if (point.options.hoverMode === ALL_ARGUMENTS_POINTS_MODE)
                    self._toAllArgumentPoints(point.argument, 'releasePointHoverState');
                else
                    point.releaseHoverState();
                self.hoveredPoint = null
            },
            _releaseSelectedPointMultiMode: function(point) {
                var self = this,
                    points = self.selectedPoint;
                if (!points)
                    return;
                self._setHoverStylePointWithMode(point, 'releasePointSelectedState', point.options.selectionMode);
                this.selectedPoint = $.map(this.selectedPoint, function(pt) {
                    if (pt !== point)
                        return pt
                })
            },
            _releaseSelectedPointSingleMode: function() {
                var self = this,
                    point = self.selectedPoint;
                if (!point)
                    return;
                self._setHoverStylePointWithMode(point, 'releasePointSelectedState', point.options.selectionMode);
                this.selectedPoint = null
            },
            clearSelection: function() {
                var self = this;
                if (this.pointSelectionMode === SINGLE_MODE)
                    this._releaseSelectedPoint();
                else
                    $.each(this.selectedPoint, function(_, point) {
                        self._releaseSelectedPoint(point)
                    });
                if (this.seriesSelectionMode === SINGLE_MODE)
                    this._releaseSelectedSeries();
                else
                    $.each(this.selectedSeries, function(_, series) {
                        self._releaseSelectedSeries(series)
                    })
            },
            _mouseLock: function(tracker) {
                if (tracker.unlockMouseTimer)
                    clearTimeout(tracker.unlockMouseTimer);
                tracker.mouseLocked = true;
                tracker.unlockMouseTimer = setTimeout(function() {
                    tracker.mouseLocked = false
                }, MOUSE_EVENT_LOCK_TIMEOUT)
            },
            _clickLock: function(tracker) {
                tracker.lockClick = true;
                if (tracker.lockClickTimer)
                    clearTimeout(tracker.lockClickTimer);
                tracker.lockClickTimer = setTimeout(function() {
                    tracker.lockClick = false
                }, CLICK_EVENT_LOCK_TIMEOUT)
            },
            _getCurCoords: function(self, pageX, pageY) {
                self.cX = pageX;
                self.cY = pageY
            },
            _clearHover: function(self) {
                self._releaseHoveredSeries();
                self._releaseHoveredPoint()
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file namespaces.js */
    (function(DX) {
        DX.viz.gauges = {__internals: {
                circularNeedles: {},
                circularMarkers: {},
                linearNeedles: {},
                linearMarkers: {}
            }};
        DX.viz.gauges.__tests = {}
    })(DevExpress);
    /*! Module viz, file factory.js */
    (function(DX, undefined) {
        var gauges = DX.viz.gauges,
            renderers = DX.viz.renderers,
            internals = gauges.__internals,
            circularNeedles = internals.circularNeedles,
            circularMarkers = internals.circularMarkers,
            linearNeedles = internals.linearNeedles,
            linearMarkers = internals.linearMarkers;
        var isString = DX.utils.isString;
        gauges.__factory = {
            createTranslator: function(fromAngle, toAngle, fromValue, toValue) {
                return new DX.viz.core.Translator1D(fromValue, toValue, fromAngle, toAngle)
            },
            createRenderer: function(options) {
                return new renderers.Renderer(options)
            },
            createCircularNeedle: function(type) {
                if (isString(type))
                    switch (type.toLowerCase()) {
                        case'rectangle':
                            return new circularNeedles.RectangleNeedle;
                        case'twocolorrectangle':
                            return new circularNeedles.TwoColorRectangleNeedle;
                        case'triangle':
                            return new circularNeedles.TriangleNeedle
                    }
                return undefined
            },
            createLinearNeedle: function(type) {
                if (isString(type))
                    switch (type.toLowerCase()) {
                        case'rectangle':
                            return new linearNeedles.RectangleNeedle;
                        case'rhombus':
                            return new linearNeedles.RhombusNeedle;
                        case'circle':
                            return new linearNeedles.CircleNeedle
                    }
                return undefined
            },
            createCircularMarker: function(type) {
                if (isString(type))
                    switch (type.toLowerCase()) {
                        case'triangle':
                            return new circularMarkers.TriangleMarker;
                        case'textcloud':
                            return new circularMarkers.TextCloudMarker
                    }
                return undefined
            },
            createLinearMarker: function(type) {
                if (isString(type))
                    switch (type.toLowerCase()) {
                        case'triangle':
                            return new linearMarkers.TriangleMarker;
                        case'textcloud':
                            return new linearMarkers.TextCloudMarker
                    }
                return undefined
            },
            createCircularRangeBar: function() {
                return new internals.CircularRangeBar
            },
            createLinearRangeBar: function() {
                return new internals.LinearRangeBar
            },
            createCircularScale: function() {
                return new internals.CircularScale
            },
            createLinearScale: function() {
                return new internals.LinearScale
            },
            createCircularRangeContainer: function() {
                return new internals.CircularRangeContainer
            },
            createLinearRangeContainer: function() {
                return new internals.LinearRangeContainer
            },
            createCircularSpindle: function() {
                return new internals.CircularSpindle
            },
            createTitle: function() {
                return new internals.Title
            },
            createIndicator: function() {
                return internals.Indicator && new internals.Indicator || null
            },
            createTooltip: function() {
                return new internals.Tooltip
            },
            createLayoutManager: function() {
                return new internals.LayoutManager
            },
            createThemeManager: function(theme) {
                return new internals.ThemeManager(theme)
            },
            createPresetManager: function() {
                return new internals.PresetManager
            },
            createTracker: function() {
                return new internals.Tracker
            }
        }
    })(DevExpress);
    /*! Module viz, file baseGaugeItem.js */
    (function(DX, $, undefined) {
        var $extend = $.extend;
        DX.viz.gauges.__internals.BaseGaugeItem = DX.Class.inherit({
            ctor: function() {
                this._options = {}
            },
            _getDefaultOptions: function() {
                return {}
            },
            create: function(options) {
                var self = this;
                self._renderer = options.renderer;
                self._rootElement = self._renderer.createGroup().append(options.ownerElement);
                $extend(true, self._options, self._getDefaultOptions(), options);
                self._create(options);
                return self
            },
            update: function(options) {
                var self = this;
                $extend(true, self._options, options);
                self._update(options);
                return self
            },
            showTooltip: function(element, coord, text) {
                if (element && element.$element)
                    element.$element.trigger('showToolTip', [coord, text])
            },
            hideTooltip: function(element) {
                if (element && element.$element)
                    element.$element.trigger('hideToolTip')
            },
            destroy: function() {
                this._rootElement.remove();
                return this
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file scale.js */
    (function(DX, $, undefined) {
        var formatHelper = DX.formatHelper;
        var getCosAndSin = DX.utils.getCosAndSin,
            normalizeAngle = DX.utils.normalizeAngle,
            convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            isDefined = DX.utils.isDefined,
            isString = DX.utils.isString,
            isFunction = DX.utils.isFunction,
            isArray = DX.utils.isArray,
            isNaN = window.isNaN,
            Number = window.Number,
            String = window.String,
            max = Math.max,
            min = Math.min,
            abs = Math.abs,
            atan = Math.atan,
            acos = Math.acos,
            ceil = Math.ceil,
            $extend = $.extend,
            $map = $.map;
        var PI = Math.PI;
        var tickProvider = DX.viz.core.tickProvider;
        function binarySearch(x, list) {
            var a = 0,
                b = list.length - 1,
                flag = list[a] - list[b] < 0,
                c,
                k = -1;
            if (list[a] === x)
                k = a;
            if (list[b] === x)
                k = b;
            while (k < 0 && a <= b) {
                c = ~~((a + b) / 2);
                if (list[c] === x)
                    k = c;
                else if (list[c] - x < 0 === flag)
                    a = c + 1;
                else
                    b = c - 1
            }
            return k
        }
        DX.viz.gauges.__internals.BaseScale = DX.Class.inherit({
            setup: function(parameters) {
                var self = this;
                DX.utils.debug.assertParam(parameters.renderer, '"renderer" was not passed');
                DX.utils.debug.assertParam(parameters.owner, '"owner" was not passed');
                DX.utils.debug.assertParam(parameters.incidentOccured, '"incidentOccured" was not passed');
                self._renderer = parameters.renderer;
                self._owner = parameters.owner;
                self._incidentOccured = parameters.incidentOccured;
                return self
            },
            init: function(options) {
                var self = this;
                self._options = $extend(true, self._options || {}, options);
                self._options.majorTick || (self._options.majorTick = {});
                self._options.minorTick || (self._options.minorTick = {});
                if (options && options.majorTick && isDefined(options.majorTick.customTickValues))
                    self._options.majorTick.customTickValues = isArray(options.majorTick.customTickValues) ? options.majorTick.customTickValues.slice(0) : null;
                if (options && options.minorTick && isDefined(options.minorTick.customTickValues))
                    self._options.minorTick.customTickValues = isArray(options.minorTick.customTickValues) ? options.minorTick.customTickValues.slice(0) : null;
                delete self._processed;
                return self
            },
            _getCustomValues: function(values, compare) {
                var translator = this._options.translator,
                    result = [];
                if (isArray(values)) {
                    result = $map(values, function(x) {
                        return !isNaN(translator.translate(x)) ? Number(x) : null
                    }).sort(compare);
                    result = $map(result, function(x, i) {
                        return x !== result[i - 1] ? x : null
                    })
                }
                return result
            },
            _getTicks: function() {
                var self = this,
                    options = self._options,
                    translator = options.translator,
                    startValue = translator.getDomainStart(),
                    endValue = translator.getDomainEnd(),
                    compare = startValue < endValue ? function(x, y) {
                        return x - y
                    } : function(x, y) {
                        return y - x
                    },
                    gridSpacingFactor = self._getGridSpacingFactor(),
                    info,
                    majorValues,
                    minorValues,
                    customMajorValues,
                    customMinorValues,
                    list,
                    ticks = {};
                info = tickProvider.getFullTicks(startValue, endValue, self._getScreenDelta(), {
                    tickInterval: options.majorTick.tickInterval > 0 ? Number(options.majorTick.tickInterval) : undefined,
                    gridSpacingFactor: gridSpacingFactor.majorTicks,
                    numberMultipliers: [1, 2, 5]
                }, {
                    tickInterval: options.minorTick.tickInterval > 0 ? Number(options.minorTick.tickInterval) : undefined,
                    gridSpacingFactor: gridSpacingFactor.minorTicks,
                    numberMultipliers: [1, 2, 5]
                });
                if (options.majorTick.showCalculatedTicks) {
                    majorValues = info.majorTicks;
                    if (options.majorTick.useTicksAutoArrangement)
                        majorValues = self._cutTicks(majorValues)
                }
                else
                    majorValues = [];
                customMajorValues = self._getCustomValues(options.majorTick.customTickValues, compare);
                customMajorValues = $map(customMajorValues, function(value) {
                    return binarySearch(value, majorValues) === -1 ? value : null
                });
                if (options.minorTick.showCalculatedTicks)
                    minorValues = info.minorTicks;
                else
                    minorValues = [];
                minorValues = $map(minorValues, function(value) {
                    return binarySearch(value, customMajorValues) === -1 ? value : null
                });
                customMinorValues = self._getCustomValues(options.minorTick.customTickValues, compare);
                list = majorValues.concat(minorValues, customMajorValues).sort(compare);
                customMinorValues = $map(customMinorValues, function(value) {
                    return binarySearch(value, list) === -1 ? value : null
                });
                ticks.major = $map(majorValues.concat(customMajorValues), function(value) {
                    return {
                            value: value,
                            position: translator.translate(value)
                        }
                });
                ticks.minor = $map(minorValues.concat(customMinorValues), function(value) {
                    return {
                            value: value,
                            position: translator.translate(value)
                        }
                });
                return ticks
            },
            _cutTicks: function(values) {
                var self = this,
                    factor = self._getCuttingFactor(values.length, {
                        width: self._textWidth,
                        height: self._textHeight
                    }),
                    cutValues = [],
                    i = 0,
                    ii = values.length;
                for (; i < ii; i += factor)
                    cutValues.push(values[i]);
                return cutValues
            },
            _renderContent: function(ticks) {
                var self = this,
                    options = self._options,
                    i,
                    ii,
                    item,
                    points,
                    element,
                    majorTickColor,
                    minorTickColor,
                    textPosition,
                    textValue;
                if (self._majorTickLength && self._majorTickWidth) {
                    majorTickColor = isString(options.majorTick.color) ? options.majorTick.color : 'none';
                    points = self._getTickPoints(self._majorTickLength, self._majorTickWidth);
                    i = 0;
                    ii = ticks.major.length;
                    options.hideFirstTick === true && ++i;
                    options.hideLastTick === true && --ii;
                    for (; i < ii; ++i) {
                        item = ticks.major[i];
                        element = self._renderer.createArea(points, {
                            'class': 'dx-major-tick',
                            fill: majorTickColor,
                            stroke: 'none',
                            strokeWidth: 0
                        });
                        self._moveTick(element, item);
                        element.append(self._majorTicks)
                    }
                }
                if (self._minorTickLength && self._minorTickWidth) {
                    minorTickColor = isString(options.minorTick.color) ? options.minorTick.color : 'none';
                    points = self._getTickPoints(self._minorTickLength, self._minorTickWidth);
                    for (i = 0, ii = ticks.minor.length; i < ii; ++i) {
                        item = ticks.minor[i];
                        element = self._renderer.createArea(points, {
                            'class': 'dx-minor-tick',
                            fill: minorTickColor,
                            stroke: 'none',
                            strokeWidth: 0
                        });
                        self._moveTick(element, item);
                        element.append(self._minorTicks)
                    }
                }
                if (self._textIndent) {
                    textPosition = self._getLabelPosition(self._majorTickLength || 0, self._textIndent);
                    i = 0;
                    ii = ticks.major.length;
                    options.hideFirstLabel === true && ++i;
                    options.hideLastLabel === true && --ii;
                    for (; i < ii; ++i) {
                        item = ticks.major[i];
                        textValue = self._formatValue(item.value);
                        points = self._getLabelOptions(textValue, textPosition, self._textIndent, item);
                        self._renderer.createText(textValue, points.x, points.y + self._textVerticalOffset, {
                            'class': 'dx-gauge-scale-label',
                            align: points.align,
                            font: options.label.font
                        }).append(self._labels)
                    }
                }
            },
            _processOptions: function() {
                var self = this,
                    options = self._options;
                if (self._processed)
                    return;
                self._processed = true;
                self._setupOrientation();
                if (options.majorTick.visible) {
                    if (options.majorTick.length > 0)
                        self._majorTickLength = Number(options.majorTick.length);
                    else
                        self._incidentOccured('Major ticks are not rendered because the value of "majorTick.length" option is not valid');
                    if (options.majorTick.width > 0)
                        self._majorTickWidth = Number(options.majorTick.width);
                    else
                        self._incidentOccured('Major ticks are not rendered because the value of "majorTick.width" option is not valid')
                }
                if (options.minorTick.visible) {
                    if (options.minorTick.length > 0)
                        self._minorTickLength = Number(options.minorTick.length);
                    else
                        self._incidentOccured('Minor ticks are not rendered because the value of "minorTick.length" option is not valid');
                    if (options.minorTick.width > 0)
                        self._minorTickWidth = Number(options.minorTick.width);
                    else
                        self._incidentOccured('Minor ticks are not rendered because the value of "minorTick.width" option is not valid')
                }
                if (options.label.visible)
                    if (Number(options.label.indentFromTick) !== 0) {
                        self._textIndent = Number(options.label.indentFromTick);
                        self._measureText()
                    }
                    else
                        self._incidentOccured('Labels are not rendered because the value of the "label.indentFromTick" option is not valid')
            },
            render: function() {
                var self = this,
                    ticks;
                if (!self._rootElement) {
                    self._rootElement = self._renderer.createGroup({'class': 'scale'});
                    self._majorTicks = self._renderer.createGroup({'class': 'dx-major-ticks'}).append(self._rootElement);
                    self._minorTicks = self._renderer.createGroup({'class': 'dx-minor-ticks'}).append(self._rootElement);
                    self._labels = self._renderer.createGroup({'class': 'labels'}).append(self._rootElement)
                }
                self._rootElement.append(self._owner);
                self._majorTicks.clear();
                self._minorTicks.clear();
                self._labels.clear();
                self._processOptions();
                if (self._isVisible()) {
                    ticks = self._getTicks();
                    self._renderContent(ticks)
                }
                else if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    delete self._majorTicks;
                    delete self._minorTicks;
                    delete self._labels
                }
                return self
            },
            _formatValue: function(value) {
                var labelOptions = this._options.label,
                    result = formatHelper.format(value, labelOptions.format, labelOptions.precision);
                if (isFunction(labelOptions.customizeText)) {
                    result = {
                        value: value,
                        valueText: result
                    };
                    result = String(labelOptions.customizeText.call(result, result))
                }
                return result
            },
            _getSampleText: function() {
                var self = this,
                    start = self._options.translator.getDomainStart(),
                    end = self._options.translator.getDomainEnd(),
                    texts = [],
                    i,
                    ii,
                    text,
                    maxLength = 0,
                    maxText;
                texts.push(self._formatValue(start));
                for (i = 1, ii = 8; i < ii; ++i)
                    texts.push(self._formatValue(((ii - i) * start + i * end) / ii));
                texts.push(self._formatValue(end));
                for (i = 0, ii = texts.length; i < ii; ++i) {
                    text = texts[i];
                    text.length > maxLength && (maxText = text) && (maxLength = text.length)
                }
                return maxText
            },
            _measureText: function() {
                var self = this,
                    root = self._renderer.createGroup({'class': 'scale'}).append(self._rootElement),
                    labels = self._renderer.createGroup({'class': 'labels'}).append(root),
                    value = self._getSampleText(),
                    text = self._renderer.createText(value, 0, 0, {
                        'class': 'dx-gauge-scale-label',
                        align: 'center',
                        font: self._options.label.font
                    }).append(labels),
                    bbox = text.getBBox();
                root.remove();
                self._textVerticalOffset = -bbox.y - bbox.height / 2;
                self._textWidth = bbox.width;
                self._textHeight = bbox.height;
                self._textLength = value.length
            }
        });
        function getBasedAngle(startAngle, endAngle) {
            var startDelta,
                endDelta,
                tmp;
            if (startAngle > endAngle) {
                tmp = endAngle;
                endAngle = startAngle;
                startAngle = tmp
            }
            startDelta = 0 <= startAngle && startAngle <= 180 ? abs(90 - startAngle) : abs(270 - startAngle);
            startDelta = startAngle < 90 && 90 < endAngle || startAngle < 270 && 270 < endAngle ? 0 : startDelta;
            endDelta = 0 < endAngle && endAngle < 180 ? abs(90 - endAngle) : abs(270 - endAngle);
            return startDelta < endDelta ? startDelta : endDelta
        }
        DX.viz.gauges.__internals.CircularScale = DX.viz.gauges.__internals.BaseScale.inherit({
            _getGridSpacingFactor: function() {
                return {
                        majorTicks: 17,
                        minorTicks: 5
                    }
            },
            _getScreenDelta: function() {
                var options = this._options;
                return (options.translator.getCodomainStart() - options.translator.getCodomainEnd()) * options.radius * PI / 180
            },
            _getCuttingFactor: function(ticksCount, maxLabelSize) {
                var self = this,
                    options = self._options,
                    startAngle = options.translator.getCodomainStart(),
                    endAngle = options.translator.getCodomainEnd(),
                    radius = self._getLabelPosition(self._majorTickLength || 0, self._textIndent),
                    baseAngle = getBasedAngle(normalizeAngle(startAngle), normalizeAngle(endAngle)),
                    baseAngleCosSin = getCosAndSin(baseAngle),
                    degreesPerTick = (startAngle - endAngle) / ticksCount,
                    minAngleBetweenTicks,
                    widthBasedAngle,
                    tanOfWidthBasedAngle,
                    heightBasedAngle,
                    cosOfHeightBasedAngle,
                    cuttingBackFactor = 1;
                tanOfWidthBasedAngle = (baseAngleCosSin.sin * radius + maxLabelSize.width) / (baseAngleCosSin.cos * radius);
                widthBasedAngle = abs(baseAngle - atan(tanOfWidthBasedAngle) * 180 / PI);
                cosOfHeightBasedAngle = baseAngleCosSin.cos - maxLabelSize.height / radius;
                heightBasedAngle = -1 > cosOfHeightBasedAngle || cosOfHeightBasedAngle > 1 ? 90 : abs(baseAngle - acos(cosOfHeightBasedAngle) * 180 / PI);
                minAngleBetweenTicks = widthBasedAngle < heightBasedAngle ? widthBasedAngle : heightBasedAngle;
                if (degreesPerTick < minAngleBetweenTicks)
                    cuttingBackFactor = ceil(minAngleBetweenTicks / degreesPerTick);
                return max(1, cuttingBackFactor)
            },
            _setupOrientation: function() {
                var self = this,
                    inner = 0,
                    outer = 0;
                switch (self._options.orientation) {
                    case'inside':
                        inner = 1;
                        break;
                    case'center':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._options.orientation !== 'outside' && self._incidentOccured('The value of the "orientation" option is not valid');
                        outer = 1;
                        break
                }
                self._inner = inner;
                self._outer = outer
            },
            _getTickPoints: function(length, width) {
                var options = this._options,
                    x1 = options.x - width / 2,
                    x2 = options.x + width / 2,
                    y1 = options.y - options.radius - length * this._outer,
                    y2 = options.y - options.radius + length * this._inner;
                return [x1, y1, x2, y1, x2, y2, x1, y2]
            },
            _moveTick: function(element, tick) {
                element.rotate(convertAngleToRendererSpace(tick.position), this._options.x, this._options.y)
            },
            _getLabelPosition: function(tickLength, textIndent) {
                return this._options.radius + tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent
            },
            _getLabelOptions: function(textValue, textPosition, textIndent, tick) {
                var self = this,
                    options = self._options,
                    cossin = getCosAndSin(tick.position),
                    x = options.x + cossin.cos * textPosition,
                    y = options.y - cossin.sin * textPosition,
                    dx = cossin.cos * (textValue.length / self._textLength) * self._textWidth / 2,
                    dy = cossin.sin * self._textHeight / 2;
                if (textIndent > 0) {
                    x += dx;
                    y -= dy
                }
                else {
                    x -= dx;
                    y += dy
                }
                return {
                        x: x,
                        y: y,
                        align: 'center'
                    }
            },
            _isVisible: function() {
                var self = this,
                    length = self._majorTickLength || 0,
                    r = self._options.radius,
                    inner = r - self._inner * length,
                    outer = r + self._outer * length;
                return inner > 0 && outer > inner
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    result = {
                        min: options.radius,
                        max: options.radius
                    };
                self._processOptions();
                if (self._majorTickLength) {
                    result.min -= self._inner * self._majorTickLength;
                    result.max += self._outer * self._majorTickLength
                }
                if (self._textIndent) {
                    if (self._textIndent >= 0) {
                        result.horizontalOffset = self._textIndent + self._textWidth;
                        result.verticalOffset = self._textIndent + self._textHeight
                    }
                    else {
                        result.horizontalOffset = 0;
                        result.verticalOffset = 0;
                        result.min += self._textIndent - max(self._textWidth, self._textHeight)
                    }
                    result.inverseHorizontalOffset = self._textWidth / 2;
                    result.inverseVerticalOffset = self._textHeight / 2
                }
                return result
            }
        });
        DX.viz.gauges.__internals.LinearScale = DX.viz.gauges.__internals.BaseScale.inherit({
            _getGridSpacingFactor: function() {
                return {
                        majorTicks: 25,
                        minorTicks: 5
                    }
            },
            _getScreenDelta: function() {
                return abs(this._options.translator.getCodomainEnd() - this._options.translator.getCodomainStart())
            },
            _getCuttingFactor: function(ticksCount, maxLabelSize) {
                var options = this._options,
                    labelSize = this._vertical ? maxLabelSize.height : maxLabelSize.width,
                    screenSize = abs(options.translator.getCodomainEnd() - options.translator.getCodomainStart());
                return max(1, ceil(ticksCount * labelSize / (screenSize + labelSize)))
            },
            _setupOrientation: function() {
                var self = this,
                    inner = 0,
                    outer = 0;
                self._vertical = self._options.orientation === 'vertical';
                if (self._vertical)
                    switch (self._options.horizontalOrientation) {
                        case'left':
                            inner = 1;
                            break;
                        case'center':
                            inner = outer = 0.5;
                            break;
                        default:
                            self._options.horizontalOrientation !== 'right' && self._incidentOccured('The value of the "horizontalOrientation" option is not valid');
                            outer = 1;
                            break
                    }
                else
                    switch (self._options.verticalOrientation) {
                        case'top':
                            inner = 1;
                            break;
                        case'middle':
                            inner = outer = 0.5;
                            break;
                        default:
                            self._options.verticalOrientation !== 'bottom' && self._incidentOccured('The value of the "verticalOrientation" option is not valid');
                            outer = 1;
                            break
                    }
                self._inner = inner;
                self._outer = outer
            },
            _getTickPoints: function(length, width) {
                var options = this._options,
                    x1,
                    x2,
                    y1,
                    y2;
                if (this._vertical) {
                    x1 = options.x - length * this._inner;
                    x2 = options.x + length * this._outer;
                    y1 = -width / 2;
                    y2 = width / 2
                }
                else {
                    x1 = -width / 2;
                    x2 = width / 2;
                    y1 = options.y - length * this._inner;
                    y2 = options.y + length * this._outer
                }
                return [x1, y1, x2, y1, x2, y2, x1, y2]
            },
            _moveTick: function(element, tick) {
                var options = this._options,
                    x = 0,
                    y = 0;
                if (this._vertical)
                    y = tick.position;
                else
                    x = tick.position;
                element.move(x, y)
            },
            _getLabelPosition: function(tickLength, textIndent) {
                var options = this._options,
                    position = tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent;
                if (this._vertical)
                    position += options.x;
                else
                    position += options.y + (textIndent >= 0 ? 1 : -1) * this._textVerticalOffset;
                return position
            },
            _getLabelOptions: function(textValue, textPosition, textIndent, tick) {
                var x,
                    y,
                    align;
                if (this._vertical) {
                    x = textPosition;
                    y = tick.position;
                    align = textIndent > 0 ? 'left' : 'right'
                }
                else {
                    x = tick.position;
                    y = textPosition;
                    align = 'center'
                }
                return {
                        x: x,
                        y: y,
                        align: align
                    }
            },
            _isVisible: function() {
                return true
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    result;
                self._processOptions();
                if (self._vertical) {
                    result = {
                        min: options.x,
                        max: options.x
                    };
                    if (self._majorTickLength) {
                        result.min -= self._inner * self._majorTickLength;
                        result.max += self._outer * self._majorTickLength
                    }
                    if (self._textIndent) {
                        if (self._textIndent >= 0)
                            result.max += self._textIndent + self._textWidth;
                        else
                            result.min += self._textIndent - self._textWidth;
                        result.indent = self._textHeight / 2
                    }
                }
                else {
                    result = {
                        min: options.y,
                        max: options.y
                    };
                    if (self._majorTickLength) {
                        result.min -= self._inner * self._majorTickLength;
                        result.max += self._outer * self._majorTickLength
                    }
                    if (self._textIndent) {
                        if (self._textIndent >= 0)
                            result.max += self._textIndent + self._textHeight;
                        else
                            result.min += self._textIndent - self._textHeight;
                        result.indent = self._textWidth / 2
                    }
                }
                return result
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file baseIndicator.js */
    (function(DX, $, undefined) {
        var formatHelper = DX.formatHelper;
        var isFunction = DX.utils.isFunction,
            isFinite = window.isFinite,
            Number = window.Number,
            String = window.String,
            $extend = $.extend;
        DX.viz.gauges.__internals.BaseIndicator = DX.viz.gauges.__internals.BaseGaugeItem.inherit({
            setup: function(parameters) {
                var self = this;
                self._renderer = parameters.renderer;
                self._owner = parameters.owner;
                self._trackerOwner = parameters.tracker;
                self._options = {};
                return self
            },
            init: function(options) {
                $extend(true, this._options, options || {});
                return this
            },
            render: function() {
                var self = this;
                self._actualValue = self._currentValue = self._options.translator.adjust(self._options.currentValue);
                self._isCurrentValueLocked = false;
                delete self._setCurrentValueNext;
                delete self._setCurrentValueHas;
                self._animateStep = self._animateStep || function(_, fx) {
                    var target = self;
                    target._updateActualValue(target._animateStart + target._animateDelta * fx.pos)
                };
                self._animateComplete = self._animateComplete || function() {
                    var target = self;
                    if (target._setCurrentValueHas) {
                        target._runAnimation(target._actualValue, target._setCurrentValueNext);
                        target._setCurrentValueHas = false
                    }
                    else {
                        target._isCurrentValueLocked = false;
                        delete target._animateStart;
                        delete target._animateDelta
                    }
                    target._setCurrentValueNext = undefined
                };
                return self
            },
            _formatValue: function(value) {
                var options = this._options.text,
                    valueText = formatHelper.format(value, options.format, options.precision),
                    obj = {
                        value: value,
                        valueText: valueText
                    };
                return isFunction(options.customizeText) ? String(options.customizeText.call(obj, obj)) : valueText
            },
            _getActualPosition: function() {
                return this._options.translator.translate(this._actualValue)
            },
            _getSampleText: function() {
                var self = this,
                    options = self._options,
                    text1,
                    text2,
                    text;
                if (options.text) {
                    text1 = self._formatValue(options.translator.getDomainStart());
                    text2 = self._formatValue(options.translator.getDomainEnd());
                    text = text1.length >= text2.length ? text1 : text2
                }
                return text
            },
            _updateActualValue: function(value) {
                this._actualValue = value;
                this._updateActiveElements()
            },
            _runAnimation: function(fromValue, toValue) {
                var self = this;
                self._isCurrentValueLocked = true;
                self._animateStart = fromValue;
                self._animateDelta = toValue - fromValue;
                self._rootElement.animate({fake: true}, {
                    duration: self._options.animationDuration,
                    step: self._animateStep,
                    complete: self._animateComplete
                })
            },
            getCurrentValue: function() {
                return this._currentValue
            },
            setCurrentValue: function(value) {
                var self = this,
                    newValue = self._options.translator.adjust(value);
                if (self._currentValue !== newValue && isFinite(newValue)) {
                    self._currentValue = newValue;
                    if (self._rootElement)
                        if (self._options.animationEnabled)
                            if (!self._isCurrentValueLocked)
                                self._runAnimation(self._actualValue, newValue);
                            else {
                                self._setCurrentValueNext = newValue;
                                self._setCurrentValueHas = true
                            }
                        else
                            self._updateActualValue(newValue)
                }
                return self._currentValue
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file baseMarker.js */
    (function(DX, $, undefined) {
        var $extend = $.extend;
        var TextCloud = DX.viz.core.TextCloud;
        DX.viz.gauges.__internals.BaseTextCloudMarker = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _updateActiveElements: function() {
                var self = this,
                    bbox,
                    info = new TextCloud,
                    textCloudOptions = self._getTextCloudOptions();
                self._text.applySettings({text: self._formatValue(self._actualValue)});
                bbox = self._text.getBBox();
                info.setup({
                    x: textCloudOptions.x,
                    y: textCloudOptions.y,
                    textWidth: bbox.width,
                    textHeight: bbox.height,
                    horMargin: self._options.horizontalOffset,
                    verMargin: self._options.verticalOffset,
                    tailLength: self._options.arrowLength,
                    type: textCloudOptions.type
                });
                self._text.applySettings({
                    x: info.cx(),
                    y: info.cy() + self._textVerticalOffset
                });
                self._cloud.applySettings({points: info.points()});
                self._tracker.applySettings({points: info.points()})
            },
            _measureText: function() {
                var self = this,
                    bbox;
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'marker'});
                self._rootElement.append(self._owner);
                self._cloud = self._cloud || self._renderer.createArea().append(self._rootElement);
                self._text = self._text || self._renderer.createText().append(self._rootElement);
                self._text.applySettings({
                    x: 0,
                    y: 0,
                    align: 'center',
                    font: self._options.text.font,
                    text: self._getSampleText()
                });
                bbox = self._text.getBBox();
                self._textVerticalOffset = -bbox.y - bbox.height / 2;
                self._textWidth = bbox.width;
                self._textHeight = bbox.height;
                self._textFullWidth = self._textWidth + 2 * self._options.horizontalOffset;
                self._textFullHeight = self._textHeight + 2 * self._options.verticalOffset
            },
            render: function() {
                var self = this;
                self.callBase();
                if (self._isVisible()) {
                    self._measureText();
                    self._tracker = self._tracker || self._renderer.createArea([], {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.0001
                    }).append(self._trackerOwner);
                    self._cloud.applySettings({
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: self._options.color
                    });
                    self._updateActiveElements()
                }
                else
                    self.clear();
                return self
            },
            clear: function() {
                var self = this;
                if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    delete self._cloud;
                    delete self._text;
                    delete self._tracker
                }
            },
            getTrackingElement: function() {
                return this._tracker
            },
            getTooltipParameters: function() {
                var position = this._getTextCloudOptions();
                return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color
                    }
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file baseRangeBar.js */
    (function(DX, $, undefined) {
        var $extend = $.extend;
        DX.viz.gauges.__internals.BaseRangeBar = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _prepare: function() {
                var self = this,
                    bbox;
                self._hasText = self._isTextVisible();
                if (self._hasText) {
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'rangebar'}).append(self._owner);
                    self._text = self._text || self._renderer.createText().append(self._rootElement);
                    self._text.applySettings({
                        x: 0,
                        y: 0,
                        align: self._getTextAlign(),
                        font: self._getFontOptions(),
                        text: self._getSampleText()
                    });
                    bbox = self._text.getBBox();
                    self._textVerticalOffset = -bbox.y - bbox.height / 2;
                    self._textWidth = bbox.width;
                    self._textHeight = bbox.height
                }
            },
            _updateActiveElements: function() {
                var self = this;
                self._updateBarItemsPositions();
                if (self._hasText) {
                    self._text.applySettings({text: self._formatValue(self._actualValue)});
                    self._updateTextPosition();
                    self._updateLinePosition()
                }
            },
            _updateBarItems: function() {
                var self = this,
                    options = self._options,
                    backgroundColor,
                    spaceColor;
                self._setBarSides();
                self._startPosition = options.translator.translate(options.translator.getDomainStart());
                self._endPosition = options.translator.translate(options.translator.getDomainEnd());
                self._basePosition = options.translator.translate(options.baseValue);
                self._space = self._getSpace();
                backgroundColor = options.backgroundColor || 'none';
                if (backgroundColor !== 'none' && self._space > 0)
                    spaceColor = options.containerBackgroundColor || 'none';
                else {
                    self._space = 0;
                    spaceColor = 'none'
                }
                self._backItem1.applySettings({
                    fill: backgroundColor,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._backItem2.applySettings({
                    fill: backgroundColor,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._spaceItem1.applySettings({
                    fill: spaceColor,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._spaceItem2.applySettings({
                    fill: spaceColor,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._mainItem.applySettings({
                    fill: options.color,
                    stroke: 'none',
                    strokeWidth: 0
                })
            },
            _getSpace: function() {
                return 0
            },
            _updateTextItems: function() {
                var self = this,
                    options = self._options;
                if (self._isTextVisible()) {
                    self._hasText = true;
                    self._createTextItems();
                    self._updateText();
                    self._updateLine();
                    self._setTextItemsSides()
                }
                else {
                    delete self._hasText;
                    self._destroyTextItems()
                }
            },
            _isTextVisible: function() {
                return false
            },
            _createTextItems: function() {
                var self = this;
                self._line || (self._line = self._renderer.createPath().append(self._rootElement));
                self._text || (self._text = self._renderer.createText().append(self._rootElement))
            },
            _destroyTextItems: function() {
                var self = this;
                self._line && self._line.remove() && delete self._line;
                self._text && self._text.remove() && delete self._text
            },
            _updateText: function() {
                var self = this,
                    bbox;
                self._text.applySettings({
                    x: 0,
                    y: 0,
                    align: self._getTextAlign(),
                    font: self._getFontOptions(),
                    text: self._getSampleText()
                });
                bbox = self._text.getBBox();
                self._textVerticalOffset = -bbox.y - bbox.height / 2;
                self._textWidth = bbox.width;
                self._textHeight = bbox.height
            },
            _getTextAlign: function() {
                return undefined
            },
            _getFontOptions: function() {
                var options = this._options,
                    font = options.text.font;
                if (!font || !font.color)
                    font = $extend({}, font, {color: options.color});
                return font
            },
            _updateLine: function() {
                var self = this;
                self._line.applySettings({
                    fill: self._options.color,
                    stroke: 'none',
                    strokeWidth: 0
                })
            },
            _updateBarItemsPositions: function() {
                var self = this,
                    positions = self._getPositions();
                self._backItem1.applySettings(self._buildItemSettings(positions.start, positions.back1));
                self._backItem2.applySettings(self._buildItemSettings(positions.back2, positions.end));
                self._spaceItem1.applySettings(self._buildItemSettings(positions.back1, positions.main1));
                self._spaceItem2.applySettings(self._buildItemSettings(positions.main2, positions.back2));
                self._mainItem.applySettings(self._buildItemSettings(positions.main1, positions.main2));
                self._tracker.applySettings(self._buildItemSettings(positions.main1, positions.main2))
            },
            render: function() {
                var self = this;
                self.callBase();
                if (self._isVisible()) {
                    self._prepare();
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'rangebar'});
                    self._rootElement.append(self._owner);
                    self._backItem1 = self._backItem1 || self._createBarItem();
                    self._backItem2 = self._backItem2 || self._createBarItem();
                    self._spaceItem1 = self._spaceItem1 || self._createBarItem();
                    self._spaceItem2 = self._spaceItem2 || self._createBarItem();
                    self._mainItem = self._mainItem || self._createBarItem();
                    self._tracker = self._tracker || self._createTracker().append(self._trackerOwner);
                    self._updateBarItems();
                    self._updateTextItems();
                    self._updateActiveElements()
                }
                else
                    self.clear();
                return self
            },
            clear: function() {
                var self = this;
                if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    delete self._backItem1;
                    delete self._backItem2;
                    delete self._spaceItem1;
                    delete self._spaceItem2;
                    delete self._mainItem;
                    delete self._tracker;
                    delete self._hasText;
                    self._destroyTextItems()
                }
            },
            getTrackingElement: function() {
                return this._tracker
            },
            getTooltipParameters: function() {
                var position = this._getTooltipPosition();
                return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color
                    }
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file circularNeedle.js */
    (function(DX, $, undefined) {
        var circularNeedles = DX.viz.gauges.__internals.circularNeedles;
        var convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            $extend = $.extend;
        circularNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _updateActiveElements: function() {
                var self = this,
                    options = self._options,
                    actualAngle = self._getActualPosition(),
                    angle = convertAngleToRendererSpace(actualAngle);
                self._rootElement.rotate(angle, options.x, options.y);
                self._tracker.rotate(angle, options.x, options.y)
            },
            _isVisible: function() {
                var options = this._options;
                return options.width > 0 && options.indentFromCenter >= 0 && options.radius - options.indentFromCenter > 0
            },
            _getClassName: function() {
                return 'needle'
            },
            _getTrackerPoints: function() {
                var options = this._options,
                    y2 = options.y - options.radius,
                    y1 = options.y - options.indentFromCenter || options.y,
                    x1 = options.x - options.width / 2 || options.x,
                    x2 = x1 + options.width || options.x;
                return [x1, y1, x1, y2, x2, y2, x2, y1]
            },
            _destroy: function() {
                delete this._element
            },
            render: function() {
                var self = this;
                self.callBase();
                if (self._isVisible()) {
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': self._getClassName()});
                    self._rootElement.append(self._owner);
                    self._create();
                    self._tracker = self._tracker || self._renderer.createArea().append(self._trackerOwner);
                    self._tracker.applySettings({
                        points: self._getTrackerPoints(),
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.0001
                    });
                    self._updateActiveElements()
                }
                else if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    self._destroy();
                    delete self._tracker
                }
                return self
            },
            measure: function() {
                var options = this._options,
                    result = {max: options.radius};
                if (options.indentFromCenter < 0)
                    result.inverseHorizontalOffset = result.inverseVerticalOffset = -options.indentFromCenter;
                return result
            },
            getTrackingElement: function() {
                return this._tracker
            },
            getTooltipParameters: function() {
                var options = this._options,
                    cossin = DX.utils.getCosAndSin(this._getActualPosition()),
                    r = (options.radius + options.indentFromCenter) / 2;
                return {
                        x: options.x + cossin.cos * r,
                        y: options.y - cossin.sin * r,
                        value: this._currentValue,
                        color: options.color,
                        offset: options.width / 2
                    }
            }
        });
        circularNeedles.RectangleNeedle = circularNeedles.SimpleIndicator.inherit({_create: function() {
                var self = this,
                    options = self._options,
                    y2 = options.y - options.radius,
                    y1 = options.y - options.indentFromCenter || options.y,
                    x1 = options.x - options.width / 2 || options.x,
                    x2 = x1 + options.width || options.x;
                self._element = self._element || self._renderer.createArea().append(self._rootElement);
                self._element.applySettings({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1],
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                })
            }});
        circularNeedles.TriangleNeedle = circularNeedles.SimpleIndicator.inherit({_create: function() {
                var self = this,
                    options = self._options,
                    y2 = options.y - options.radius,
                    y1 = options.y - options.indentFromCenter || options.y,
                    x1 = options.x - options.width / 2 || options.x,
                    x2 = options.x + options.width / 2 || options.x;
                self._element = self._element || self._renderer.createArea().append(self._rootElement);
                self._element.applySettings({
                    points: [x1, y1, options.x, y2, x2, y1],
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                })
            }});
        circularNeedles.TwoColorRectangleNeedle = circularNeedles.SimpleIndicator.inherit({
            _create: function() {
                var self = this,
                    options = self._options,
                    x1 = options.x - options.width / 2 || options.x,
                    x2 = options.x + options.width / 2 || options.x,
                    y4 = options.y - options.radius,
                    y1 = options.y - options.indentFromCenter || options.y,
                    y3 = y4 + (y1 - y4) * options.secondFraction || y4,
                    y2 = y3 + options.space || y3;
                self._firstElement = self._firstElement || self._renderer.createArea().append(self._rootElement);
                self._spaceElement = self._spaceElement || self._renderer.createArea().append(self._rootElement);
                self._secondElement = self._secondElement || self._renderer.createArea().append(self._rootElement);
                self._firstElement.applySettings({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1],
                    'class': 'dx-needle-part1',
                    fill: options.color,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._spaceElement.applySettings({
                    points: [x1, y2, x1, y3, x2, y3, x2, y2],
                    'class': 'dx-needle-hole',
                    fill: options.containerBackgroundColor,
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._secondElement.applySettings({
                    points: [x1, y3, x1, y4, x2, y4, x2, y3],
                    'class': 'dx-needle-part2',
                    fill: options.secondColor,
                    stroke: 'none',
                    strokeWidth: 0
                })
            },
            _destroy: function() {
                delete this._firstElement;
                delete this._secondElement;
                delete this._spaceElement
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file linearNeedle.js */
    (function(DX, $, undefined) {
        var linearNeedles = DX.viz.gauges.__internals.linearNeedles;
        var $extend = $.extend;
        linearNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _updateActiveElements: function() {
                var self = this,
                    delta = self._getActualPosition() - self._zeroPosition;
                self._rootElement.move(self._vertical ? 0 : delta, self._vertical ? delta : 0);
                self._tracker.move(self._vertical ? 0 : delta, self._vertical ? delta : 0)
            },
            _isVisible: function() {
                var options = this._options;
                return options.length > 0 && options.width > 0
            },
            _getClassName: function() {
                return 'needle'
            },
            _getTrackerPoints: function() {
                var options = this._options,
                    x1,
                    x2,
                    y1,
                    y2,
                    p = this._zeroPosition;
                if (this._vertical) {
                    x1 = options.x - options.length / 2 || options.x;
                    x2 = options.x + options.length / 2 || options.x;
                    y1 = p + options.width / 2 || p;
                    y2 = p - options.width / 2 || p
                }
                else {
                    x1 = p - options.width / 2 || p;
                    x2 = p + options.width / 2 || p;
                    y1 = options.y + options.length / 2 || options.y;
                    y2 = options.y - options.length / 2 || options.y
                }
                return [x1, y1, x1, y2, x2, y2, x2, y1]
            },
            _destroy: function() {
                delete this._element
            },
            init: function(options) {
                var self = this;
                self.callBase(options);
                self._vertical = self._options.orientation === 'vertical';
                return self
            },
            render: function() {
                var self = this;
                self.callBase();
                if (self._isVisible()) {
                    self._zeroPosition = self._options.translator.getCodomainStart();
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': self._getClassName()});
                    self._rootElement.append(self._owner);
                    self._create();
                    self._tracker = self._tracker || self._renderer.createArea().append(self._trackerOwner);
                    self._tracker.applySettings({
                        points: self._getTrackerPoints(),
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.0001
                    });
                    self._updateActiveElements()
                }
                else if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    self._destroy();
                    delete self._tracker
                }
                return self
            },
            measure: function() {
                var options = this._options,
                    p = this._vertical ? options.x : options.y;
                return {
                        min: p - options.length / 2,
                        max: p + options.length / 2
                    }
            },
            getTrackingElement: function() {
                return this._tracker
            },
            getTooltipParameters: function() {
                var self = this,
                    options = self._options,
                    p = self._getActualPosition(),
                    parameters = {
                        x: p,
                        y: p,
                        value: self._currentValue,
                        color: options.color,
                        offset: options.width / 2
                    };
                self._vertical ? parameters.x = options.x : parameters.y = options.y;
                return parameters
            }
        });
        linearNeedles.RectangleNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
                var self = this,
                    options = self._options,
                    p = self._zeroPosition,
                    x1,
                    x2,
                    y1,
                    y2;
                if (self._vertical) {
                    x1 = options.x - options.length / 2 || options.x;
                    x2 = options.x + options.length / 2 || options.x;
                    y1 = p + options.width / 2 || p;
                    y2 = p - options.width / 2 || p
                }
                else {
                    x1 = p - options.width / 2 || p;
                    x2 = p + options.width / 2 || p;
                    y1 = options.y + options.length / 2 || options.y;
                    y2 = options.y - options.length / 2 || options.y
                }
                self._element = self._element || self._renderer.createArea().append(self._rootElement);
                self._element.applySettings({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1],
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                })
            }});
        linearNeedles.RhombusNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
                var self = this,
                    options = self._options,
                    x,
                    y,
                    dx,
                    dy;
                if (self._vertical) {
                    x = options.x;
                    y = self._zeroPosition;
                    dx = options.length / 2 || 0;
                    dy = options.width / 2 || 0
                }
                else {
                    x = self._zeroPosition;
                    y = options.y;
                    dx = options.width / 2 || 0;
                    dy = options.length / 2 || 0
                }
                self._element = self._element || self._renderer.createArea().append(self._rootElement);
                self._element.applySettings({
                    points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy],
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                })
            }});
        linearNeedles.CircleNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
                var self = this,
                    options = self._options,
                    x,
                    y,
                    r;
                if (self._vertical) {
                    x = options.x;
                    y = self._zeroPosition
                }
                else {
                    x = self._zeroPosition;
                    y = options.y
                }
                r = options.length / 2 || 0;
                self._element = self._element || self._renderer.createCircle().append(self._rootElement);
                self._element.applySettings({
                    cx: x,
                    cy: y,
                    r: r,
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                })
            }})
    })(DevExpress, jQuery);
    /*! Module viz, file circularMarker.js */
    (function(DX, undefined) {
        var circularMarkers = DX.viz.gauges.__internals.circularMarkers;
        var normalizeAngle = DX.utils.normalizeAngle,
            convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            getCosAndSin = DX.utils.getCosAndSin,
            min = Math.min;
        circularMarkers.TriangleMarker = DX.viz.gauges.__internals.circularNeedles.SimpleIndicator.inherit({
            _isVisible: function() {
                var options = this._options;
                return options.length > 0 && options.width > 0 && options.radius > 0
            },
            _getClassName: function() {
                return 'marker'
            },
            _create: function() {
                var self = this,
                    options = self._options,
                    x = options.x,
                    y1 = options.y - options.radius,
                    dx = options.width / 2 || 0,
                    y2 = y1 - options.length || y1,
                    settings;
                self._element = self._element || self._renderer.createArea([], {'class': 'dx-marker-element'}).append(self._rootElement);
                settings = {
                    points: [x, y1, x - dx, y2, x + dx, y2],
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                };
                if (options.space > 0) {
                    settings.strokeWidth = min(options.space, options.width / 4) || 0;
                    settings.stroke = settings.strokeWidth > 0 ? options.containerBackgroundColor || 'none' : 'none'
                }
                self._element.applySettings(settings)
            },
            _getTrackerPoints: function() {
                var options = this._options,
                    x1 = options.x - options.width / 2,
                    x2 = options.x + options.width / 2,
                    y1 = options.y - options.radius,
                    y2 = y1 - options.length || y1;
                return [x1, y1, x1, y2, x2, y2, x2, y1]
            },
            measure: function() {
                var options = this._options;
                return {
                        min: options.radius,
                        max: options.radius + options.length || options.radius
                    }
            },
            getTooltipParameters: function() {
                var options = this._options,
                    cossin = DX.utils.getCosAndSin(this._getActualPosition()),
                    r = options.radius + options.length / 2,
                    parameters = this.callBase();
                parameters.x = options.x + cossin.cos * r;
                parameters.y = options.y - cossin.sin * r;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        circularMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
            _isVisible: function() {
                return this._options.radius > 0
            },
            _getTextCloudOptions: function() {
                var self = this,
                    angle = self._getActualPosition(),
                    cossin = getCosAndSin(angle),
                    nangle = normalizeAngle(angle);
                return {
                        x: self._options.x + cossin.cos * self._options.radius,
                        y: self._options.y - cossin.sin * self._options.radius,
                        type: nangle > 270 ? 'left-top' : nangle > 180 ? 'top-right' : nangle > 90 ? 'right-bottom' : 'bottom-left'
                    }
            },
            measure: function() {
                var self = this;
                self._measureText();
                return {
                        min: self._options.radius,
                        max: self._options.radius,
                        horizontalOffset: self._textFullWidth + self._options.arrowLength,
                        verticalOffset: self._textFullHeight + self._options.arrowLength
                    }
            }
        })
    })(DevExpress);
    /*! Module viz, file linearMarker.js */
    (function(DX, $, undefined) {
        var linearMarkers = DX.viz.gauges.__internals.linearMarkers;
        var min = Math.min,
            $extend = $.extend;
        linearMarkers.TriangleMarker = DX.viz.gauges.__internals.linearNeedles.SimpleIndicator.inherit({
            _getClassName: function() {
                return 'marker'
            },
            _create: function() {
                var self = this,
                    options = self._options,
                    x1,
                    x2,
                    y1,
                    y2,
                    settings = {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: options.color
                    };
                if (self._vertical) {
                    x1 = options.x;
                    y1 = self._zeroPosition;
                    x2 = x1 + (self._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2]
                }
                else {
                    y1 = options.y;
                    x1 = self._zeroPosition;
                    y2 = y1 + (self._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2]
                }
                if (options.space > 0) {
                    settings.strokeWidth = min(options.space, options.width / 4) || 0;
                    settings.stroke = settings.strokeWidth > 0 ? options.containerBackgroundColor || 'none' : 'none'
                }
                self._element = self._element || self._renderer.createArea().append(self._rootElement);
                self._element.applySettings(settings)
            },
            _getTrackerPoints: function() {
                var self = this,
                    options = self._options,
                    l = Number(options.length) || 0,
                    w = options.width / 2 || 0,
                    x1,
                    x2,
                    y1,
                    y2,
                    result;
                if (self._vertical) {
                    x1 = x2 = options.x;
                    x2 = x1 + (self._inverted ? options.length : -options.length);
                    y1 = self._zeroPosition + options.width / 2;
                    y2 = self._zeroPosition - options.width / 2;
                    result = [x1, y1, x2, y1, x2, y2, x1, y2]
                }
                else {
                    y1 = options.y;
                    y2 = y1 + (self._inverted ? options.length : -options.length);
                    x1 = self._zeroPosition - options.width / 2;
                    x2 = self._zeroPosition + options.width / 2;
                    result = [x1, y1, x1, y2, x2, y2, x2, y1]
                }
                return result
            },
            init: function(options) {
                var self = this;
                self.callBase(options);
                self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom';
                return self
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    minbound,
                    maxbound,
                    indent = options.width / 2 || 0;
                if (self._vertical) {
                    minbound = maxbound = options.x;
                    if (self._inverted)
                        maxbound = minbound + options.length || minbound;
                    else
                        minbound = maxbound - options.length || maxbound
                }
                else {
                    minbound = maxbound = options.y;
                    if (self._inverted)
                        maxbound = minbound + options.length || minbound;
                    else
                        minbound = maxbound - options.length || maxbound
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
            },
            getTooltipParameters: function() {
                var self = this,
                    options = self._options,
                    s = (self._inverted ? options.length : -options.length) / 2,
                    parameters = self.callBase();
                self._vertical ? parameters.x += s : parameters.y += s;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        linearMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
            _isVisible: function() {
                return true
            },
            _getTextCloudOptions: function() {
                var self = this,
                    position = self._getActualPosition(),
                    x = position,
                    y = position,
                    type;
                if (self._vertical) {
                    x = self._options.x;
                    type = self._inverted ? 'top-left' : 'top-right'
                }
                else {
                    y = self._options.y;
                    type = self._inverted ? 'right-top' : 'right-bottom'
                }
                return {
                        x: x,
                        y: y,
                        type: type
                    }
            },
            init: function(options) {
                var self = this;
                self.callBase(options);
                self._vertical = self._options.orientation === 'vertical';
                self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom';
                return self
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    minbound,
                    maxbound,
                    indent;
                self._measureText();
                if (self._vertical) {
                    indent = self._textFullHeight;
                    if (self._inverted) {
                        minbound = options.x;
                        maxbound = options.x + options.arrowLength + self._textFullWidth
                    }
                    else {
                        minbound = options.x - options.arrowLength - self._textFullWidth;
                        maxbound = options.x
                    }
                }
                else {
                    indent = self._textFullWidth;
                    if (self._inverted) {
                        minbound = options.y;
                        maxbound = options.y + options.arrowLength + self._textFullHeight
                    }
                    else {
                        minbound = options.y - options.arrowLength - self._textFullHeight;
                        maxbound = options.y
                    }
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file circularRangeBar.js */
    (function(DX, undefined) {
        var getCosAndSin = DX.utils.getCosAndSin,
            convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            max = Math.max,
            min = Math.min;
        DX.viz.gauges.__internals.CircularRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
            _isVisible: function() {
                var options = this._options;
                return options.size > 0 && options.radius - options.size > 0
            },
            _createBarItem: function() {
                return this._renderer.createArc().append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.createArc(0, 0, 0, 0, 0, 0, {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.0001
                    })
            },
            _setBarSides: function() {
                var self = this,
                    options = self._options;
                self._minSide = options.radius - options.size;
                self._maxSide = options.radius
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0
            },
            _isTextVisible: function() {
                var options = this._options.text || {};
                return options.indent > 0
            },
            _getTextAlign: function() {
                return 'center'
            },
            _setTextItemsSides: function() {
                var self = this,
                    options = self._options;
                self._lineFrom = options.y - options.radius;
                self._lineTo = self._lineFrom - options.text.indent;
                self._textRadius = options.radius + options.text.indent
            },
            _getPositions: function() {
                var self = this,
                    basePosition = self._basePosition,
                    actualPosition = self._getActualPosition(),
                    mainPosition1,
                    mainPosition2,
                    space = self._space;
                if (basePosition >= actualPosition) {
                    mainPosition1 = basePosition;
                    mainPosition2 = actualPosition
                }
                else {
                    mainPosition1 = actualPosition;
                    mainPosition2 = basePosition
                }
                return {
                        start: self._startPosition,
                        end: self._endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: min(mainPosition1 + space, self._startPosition),
                        back2: max(mainPosition2 - space, self._endPosition)
                    }
            },
            _buildItemSettings: function(from, to) {
                var self = this;
                return {
                        x: self._options.x,
                        y: self._options.y,
                        innerRadius: self._minSide,
                        outerRadius: self._maxSide,
                        startAngle: to,
                        endAngle: from
                    }
            },
            _updateTextPosition: function() {
                var self = this,
                    cossin = getCosAndSin(self._getActualPosition()),
                    x = self._options.x + self._textRadius * cossin.cos,
                    y = self._options.y - self._textRadius * cossin.sin;
                x += cossin.cos * self._textWidth / 2;
                y -= cossin.sin * self._textHeight / 2;
                self._text.applySettings({
                    x: x,
                    y: y + self._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var self = this,
                    angle = convertAngleToRendererSpace(self._getActualPosition()),
                    actualPosition = self._getActualPosition(),
                    x = self._options.x,
                    x1,
                    x2;
                if (self._basePosition > actualPosition) {
                    x1 = x - 2;
                    x2 = x
                }
                else if (self._basePosition < actualPosition) {
                    x1 = x;
                    x2 = x + 2
                }
                else {
                    x1 = x - 1;
                    x2 = x + 1
                }
                self._line.applySettings({points: [x1, self._lineFrom, x1, self._lineTo, x2, self._lineTo, x2, self._lineFrom]});
                self._line.rotate(angle, x, self._options.y)
            },
            _getTooltipPosition: function() {
                var self = this,
                    cossin = getCosAndSin((self._basePosition + self._getActualPosition()) / 2),
                    r = (self._minSide + self._maxSide) / 2;
                return {
                        x: self._options.x + cossin.cos * r,
                        y: self._options.y - cossin.sin * r
                    }
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    result = {
                        min: options.radius - options.size || options.radius,
                        max: options.radius
                    };
                self._prepare();
                if (self._hasText) {
                    result.max += options.text.indent;
                    result.horizontalOffset = self._textWidth;
                    result.verticalOffset = self._textHeight
                }
                return result
            }
        })
    })(DevExpress);
    /*! Module viz, file linearRangeBar.js */
    (function(DX, undefined) {
        DX.viz.gauges.__internals.LinearRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
            _isVisible: function() {
                var options = this._options;
                return options.size > 0
            },
            _prepare: function() {
                var self = this;
                self.callBase();
                self._vertical = self._options.orientation === 'vertical';
                self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom'
            },
            _createBarItem: function() {
                return this._renderer.createArea().append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.createArea([], {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.0001
                    })
            },
            _setBarSides: function() {
                var self = this,
                    options = self._options,
                    minSide,
                    maxSide;
                if (self._vertical)
                    if (self._inverted) {
                        minSide = options.x;
                        maxSide = options.x + options.size
                    }
                    else {
                        minSide = options.x - options.size;
                        maxSide = options.x
                    }
                else if (self._inverted) {
                    minSide = options.y;
                    maxSide = options.y + options.size
                }
                else {
                    minSide = options.y - options.size;
                    maxSide = options.y
                }
                self._minSide = minSide;
                self._maxSide = maxSide;
                self._minBound = minSide;
                self._maxBound = maxSide
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? Number(options.space) : 0
            },
            _isTextVisible: function() {
                var textOptions = this._options.text || {};
                return textOptions.indent > 0 || textOptions.indent < 0
            },
            _getTextAlign: function() {
                return this._vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center'
            },
            _setTextItemsSides: function() {
                var self = this,
                    indent = Number(self._options.text.indent);
                if (indent > 0) {
                    self._lineStart = self._maxSide;
                    self._lineEnd = self._maxSide + indent;
                    self._textPosition = self._lineEnd + (self._vertical ? 2 : self._textHeight / 2);
                    self._maxBound = self._textPosition + (self._vertical ? self._textWidth : self._textHeight / 2)
                }
                else if (indent < 0) {
                    self._lineStart = self._minSide;
                    self._lineEnd = self._minSide + indent;
                    self._textPosition = self._lineEnd - (self._vertical ? 2 : self._textHeight / 2);
                    self._minBound = self._textPosition - (self._vertical ? self._textWidth : self._textHeight / 2)
                }
            },
            _getPositions: function() {
                var self = this,
                    options = self._options,
                    startPosition = self._startPosition,
                    endPosition = self._endPosition,
                    space = self._space,
                    basePosition = self._basePosition,
                    actualPosition = self._getActualPosition(),
                    mainPosition1,
                    mainPosition2,
                    backPosition1,
                    backPosition2;
                if (startPosition < endPosition) {
                    if (basePosition < actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    }
                    else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 - space;
                    backPosition2 = mainPosition2 + space
                }
                else {
                    if (basePosition > actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    }
                    else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 + space;
                    backPosition2 = mainPosition2 - space
                }
                return {
                        start: startPosition,
                        end: endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: backPosition1,
                        back2: backPosition2
                    }
            },
            _buildItemSettings: function(from, to) {
                var self = this,
                    side1 = self._minSide,
                    side2 = self._maxSide;
                var points = self._vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
                return {points: points}
            },
            _updateTextPosition: function() {
                var self = this,
                    options = self._options,
                    position = self._getActualPosition();
                self._text.applySettings(self._vertical ? {
                    x: self._textPosition,
                    y: position + self._textVerticalOffset
                } : {
                    x: position,
                    y: self._textPosition + self._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var self = this,
                    actualPosition = self._getActualPosition(),
                    side1,
                    side2,
                    points;
                if (self._vertical) {
                    if (self._basePosition >= actualPosition) {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    }
                    else {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    }
                    points = [self._lineStart, side1, self._lineStart, side2, self._lineEnd, side2, self._lineEnd, side1]
                }
                else {
                    if (self._basePosition <= actualPosition) {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    }
                    else {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    }
                    points = [side1, self._lineStart, side1, self._lineEnd, side2, self._lineEnd, side2, self._lineStart]
                }
                self._line.applySettings({points: points})
            },
            _getTooltipPosition: function() {
                var self = this,
                    crossCenter = (self._minSide + self._maxSide) / 2,
                    alongCenter = (self._basePosition + self._getActualPosition()) / 2,
                    position = {};
                if (self._vertical)
                    position = {
                        x: crossCenter,
                        y: alongCenter
                    };
                else
                    position = {
                        x: alongCenter,
                        y: crossCenter
                    };
                return position
            },
            measure: function() {
                var self = this,
                    options = self._options,
                    minbound,
                    maxbound,
                    indent;
                self._prepare();
                if (self._vertical) {
                    minbound = maxbound = options.x;
                    if (self._inverted)
                        maxbound = maxbound + options.size || maxbound;
                    else
                        minbound = minbound - options.size || minbound;
                    if (self._hasText) {
                        indent = self._textHeight / 2;
                        if (options.text.indent > 0)
                            maxbound += options.text.indent + self._textWidth;
                        if (options.text.indent < 0)
                            minbound += options.text.indent - self._textWidth
                    }
                }
                else {
                    minbound = maxbound = options.y;
                    if (self._inverted)
                        maxbound = maxbound + options.size || maxbound;
                    else
                        minbound = minbound - options.size || minbound;
                    if (self._hasText) {
                        indent = self._textWidth / 2;
                        if (options.text.indent > 0)
                            maxbound += options.text.indent + self._textHeight;
                        if (options.text.indent < 0)
                            minbound += options.text.indent - self._textHeight
                    }
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
            }
        })
    })(DevExpress);
    /*! Module viz, file circularSpindle.js */
    (function(DX, $, undefined) {
        var min = Math.min,
            $extend = $.extend;
        DX.viz.gauges.__internals.CircularSpindle = DX.Class.inherit({
            setup: function(parameters) {
                this._renderer = parameters.renderer;
                this._owner = parameters.owner;
                return this
            },
            init: function(options) {
                this._options = $extend(true, this._options || {}, options);
                return this
            },
            render: function() {
                var self = this,
                    options = self._options;
                if (options.visible !== false && options.size > 0) {
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'spindle'});
                    self._rootElement.append(self._owner);
                    self._element = self._element || self._renderer.createCircle().append(self._rootElement);
                    self._element.applySettings({
                        'class': 'dx-spindle-border',
                        cx: options.x,
                        cy: options.y,
                        r: options.size / 2,
                        fill: options.color || 'none',
                        stroke: 'none',
                        strokeWidth: 0
                    });
                    if (options.gapSize > 0) {
                        self._gapElement = self._gapElement || self._renderer.createCircle().append(self._rootElement);
                        self._gapElement.applySettings({
                            cx: options.x,
                            cy: options.y,
                            r: min(options.size, options.gapSize) / 2,
                            'class': 'dx-spindle-hole',
                            fill: options.containerBackgroundColor || 'none',
                            stroke: 'none',
                            strokeWidth: 0
                        })
                    }
                    else {
                        self._gapElement && self._gapElement.remove();
                        delete self._gapElement
                    }
                }
                else {
                    self._rootElement && self._rootElement.remove();
                    delete self._rootElement;
                    self._element && self._element.remove();
                    delete self._element;
                    self._gapElement && self._gapElement.remove();
                    delete self._gapElement
                }
                return self
            },
            measure: function() {
                var r = this._options.size / 2 || 0;
                return {
                        inverseHorizontalOffset: r,
                        inverseVerticalOffset: r
                    }
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file rangeContainer.js */
    (function(DX, $, undefined) {
        var isDefined = DX.utils.isDefined,
            isString = DX.utils.isString,
            isArray = DX.utils.isArray,
            Number = window.Number,
            isFinite = window.isFinite,
            max = Math.max,
            abs = Math.abs,
            $each = $.each,
            $map = $.map,
            $extend = $.extend;
        function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart > segmentStart && otherEnd < segmentEnd)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }];
            else if (otherStart >= segmentEnd || otherEnd <= segmentStart)
                result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }];
            else if (otherStart <= segmentStart && otherEnd >= segmentEnd)
                result = [];
            else if (otherStart > segmentStart)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }];
            else if (otherEnd < segmentEnd)
                result = [{
                        start: otherEnd,
                        end: segmentEnd
                    }];
            return result
        }
        function subtractSegmentDes(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart < segmentStart && otherEnd > segmentEnd)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }];
            else if (otherStart <= segmentEnd || otherEnd >= segmentStart)
                result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }];
            else if (otherStart >= segmentStart && otherEnd <= segmentEnd)
                result = [];
            else if (otherStart < segmentStart)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }];
            else if (otherEnd > segmentEnd)
                result = [{
                        start: otherEnd,
                        end: segmentEnd
                    }];
            return result
        }
        function isNotEmptySegmentAsc(start, end, threshold) {
            return end - start >= threshold
        }
        function isNotEmptySegmentDes(start, end, threshold) {
            return start - end >= threshold
        }
        DX.viz.gauges.__internals.BaseRangeContainer = DX.Class.inherit({
            setup: function(parameters) {
                var self = this;
                DX.utils.debug.assertParam(parameters.renderer, '"renderer" was not passed');
                DX.utils.debug.assertParam(parameters.owner, '"owner" was not passed');
                DX.utils.debug.assertParam(parameters.incidentOccured, '"incidentOccured" was not passed');
                self._renderer = parameters.renderer;
                self._owner = parameters.owner;
                self._incidentOccured = parameters.incidentOccured;
                return self
            },
            init: function(options) {
                var self = this;
                self._options = $extend(true, self._options || {}, options);
                if (options && isDefined(options.ranges))
                    self._options.ranges = isArray(options.ranges) ? options.ranges.slice(0) : null;
                return self
            },
            _getRanges: function() {
                var options = this._options,
                    translator = options.translator,
                    totalStart = translator.getDomainStart(),
                    totalEnd = translator.getDomainEnd(),
                    totalDelta = totalEnd - totalStart,
                    isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDes,
                    subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDes,
                    list = [],
                    ranges = [],
                    backgroundRanges = [{
                            start: totalStart,
                            end: totalEnd
                        }],
                    threshold = abs(totalDelta) / 1E4,
                    palette = isArray(options.palette) ? options.palette : [],
                    paletteOffset,
                    backgroundColor = isString(options.backgroundColor) ? options.backgroundColor : 'none',
                    width = options.width || {},
                    startWidth = Number(width > 0 ? width : width.start),
                    endWidth = Number(width > 0 ? width : width.end),
                    deltaWidth = endWidth - startWidth;
                if (!options.ranges) {
                    this._incidentOccured('The range container is not rendered because the value of the "ranges" option is not valid');
                    return null
                }
                if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
                    this._incidentOccured('The range container is not rendered because the value of the "width" option is not valid');
                    return null
                }
                list = $map(options.ranges, function(rangeOptions) {
                    rangeOptions = rangeOptions || {};
                    var start = translator.adjust(rangeOptions.startValue),
                        end = translator.adjust(rangeOptions.endValue);
                    return isFinite(start) && isFinite(end) && isNotEmptySegment(start, end, threshold) ? {
                            start: start,
                            end: end,
                            color: rangeOptions.color
                        } : null
                });
                paletteOffset = max(0, palette.length - list.length);
                $each(list, function(i, item) {
                    var color = item.color;
                    isString(color) || (color = palette[i + paletteOffset]);
                    isString(color) || (color = 'none');
                    item.color = color
                });
                $each(list, function(_, item) {
                    var i,
                        ii,
                        sub,
                        subs,
                        range,
                        newRanges = [],
                        newBackgroundRanges = [];
                    for (i = 0, ii = ranges.length; i < ii; ++i) {
                        range = ranges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && (sub.color = range.color) && newRanges.push(sub);
                        (sub = subs[1]) && (sub.color = range.color) && newRanges.push(sub)
                    }
                    newRanges.push(item);
                    ranges = newRanges;
                    for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
                        range = backgroundRanges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && newBackgroundRanges.push(sub);
                        (sub = subs[1]) && newBackgroundRanges.push(sub)
                    }
                    backgroundRanges = newBackgroundRanges
                });
                $each(backgroundRanges, function(_, range) {
                    range.color = backgroundColor;
                    range['class'] = 'dx-background-range';
                    ranges.push(range)
                });
                $each(ranges, function(_, range) {
                    range.startPosition = translator.translate(range.start);
                    range.endPosition = translator.translate(range.end);
                    range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
                    range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth
                });
                return ranges
            },
            render: function() {
                var self = this,
                    ranges;
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'range-container'});
                self._rootElement.append(self._owner).clear();
                ranges = self._getRanges();
                if (!ranges || !self._renderRanges(ranges)) {
                    self._rootElement.remove();
                    delete self._rootElement
                }
                return self
            }
        });
        DX.viz.gauges.__internals.CircularRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
            _renderRanges: function(ranges) {
                var self = this,
                    options = self._options,
                    x = options.x,
                    y = options.y,
                    r = options.radius,
                    renderer = self._renderer,
                    root = self._rootElement,
                    inner = 0,
                    outer = 0,
                    width = options.width > 0 ? options.width : max(options.width.start, options.width.end);
                switch (options.orientation) {
                    case'inside':
                        inner = 1;
                        break;
                    case'outside':
                        outer = 1;
                        break;
                    case'center':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._incidentOccured('The range container is not rendered because the value of the "orientation" option is not valid');
                        break
                }
                if ((inner || outer) && r + outer * width > 0 && r - inner * width > 0) {
                    $each(ranges, function(_, range) {
                        var width = (range.startWidth + range.endWidth) / 2;
                        var element = renderer.createArc(x, y, r + outer * width, r - inner * width, range.endPosition, range.startPosition, {
                                stroke: 'none',
                                strokeWidth: 0,
                                fill: range.color
                            }).append(root);
                        'class' in range && element.applySettings({'class': range['class']})
                    });
                    return true
                }
                return false
            },
            measure: function() {
                var options = this._options,
                    radius = options.radius,
                    size = options.width || {},
                    result = null;
                size = Number(size) || max(size.start, size.end, 0) || 0;
                switch (options.orientation) {
                    case'inside':
                        result = {
                            min: radius - size,
                            max: radius
                        };
                        break;
                    case'outside':
                        result = {
                            min: radius,
                            max: radius + size
                        };
                        break;
                    case'center':
                        result = {
                            min: radius - size / 2,
                            max: radius + size / 2
                        };
                        break
                }
                return result
            }
        });
        DX.viz.gauges.__internals.LinearRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
            _renderRanges: function(ranges) {
                var self = this,
                    options = self._options,
                    renderer = self._renderer,
                    root = self._rootElement,
                    inner = 0,
                    outer = 0,
                    position;
                if (options.orientation === 'vertical') {
                    position = options.x;
                    switch (options.horizontalOrientation) {
                        case'left':
                            inner = 1;
                            break;
                        case'right':
                            outer = 1;
                            break;
                        case'center':
                            inner = outer = 0.5;
                            break;
                        default:
                            self._incidentOccured('The range container is not rendered because the value of the "horizontalOrientation" option is not valid');
                            break
                    }
                    if (inner || outer) {
                        $each(ranges, function(_, range) {
                            var element = renderer.createArea([position - range.startWidth * inner, range.startPosition, position - range.endWidth * inner, range.endPosition, position + range.endWidth * outer, range.endPosition, position + range.startWidth * outer, range.startPosition], {
                                    stroke: 'none',
                                    strokeWidth: 0,
                                    fill: range.color
                                }).append(root);
                            'class' in range && element.applySettings({'class': range['class']})
                        });
                        return true
                    }
                }
                else {
                    position = options.y;
                    switch (options.verticalOrientation) {
                        case'top':
                            inner = 1;
                            break;
                        case'bottom':
                            outer = 1;
                            break;
                        case'middle':
                            inner = outer = 0.5;
                            break;
                        default:
                            self._incidentOccured('The range container is not rendered because the value of the "verticalOrientation" option is not valid');
                            break
                    }
                    if (inner || outer) {
                        $each(ranges, function(_, range) {
                            var element = renderer.createArea([range.startPosition, position + range.startWidth * outer, range.startPosition, position - range.startWidth * inner, range.endPosition, position - range.endWidth * inner, range.endPosition, position + range.endWidth * outer], {
                                    stroke: 'none',
                                    strokeWidth: 0,
                                    fill: range.color
                                }).append(root);
                            'class' in range && element.applySettings({'class': range['class']})
                        });
                        return true
                    }
                }
                return false
            },
            measure: function() {
                var options = this._options,
                    size = options.width || {},
                    result = null;
                size = Number(size) || max(size.start, size.end, 0) || 0;
                if (options.orientation === 'vertical') {
                    result = {
                        min: options.x,
                        max: options.x
                    };
                    switch (options.horizontalOrientation) {
                        case'left':
                            result.min -= size;
                            break;
                        case'right':
                            result.max += size;
                            break;
                        case'center':
                            result.min -= size / 2;
                            result.max += size / 2;
                            break
                    }
                }
                else {
                    result = {
                        min: options.y,
                        max: options.y
                    };
                    switch (options.verticalOrientation) {
                        case'top':
                            result.min -= size;
                            break;
                        case'bottom':
                            result.max += size;
                            break;
                        case'middle':
                            result.min -= size / 2;
                            result.max += size / 2;
                            break
                    }
                }
                return result
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file title.js */
    (function(DX, $, undefined) {
        var Rectangle = DX.viz.core.Rectangle;
        var isString = DX.utils.isString,
            isDefined = DX.utils.isDefined,
            min = Math.min,
            max = Math.max,
            floor = Math.floor,
            ceil = Math.ceil,
            $extend = $.extend;
        DX.viz.gauges.__internals.Title = DX.Class.inherit({
            ctor: function() {
                this._options = {
                    title: {},
                    subtitle: {}
                }
            },
            _measureTexts: function() {
                var self = this,
                    mainBox = self._mainText ? self._mainText.getBBox() : null,
                    subBox = self._subText ? self._subText.getBBox() : null,
                    dy;
                self._location = {
                    x: 0,
                    y: 0
                };
                if (mainBox && subBox) {
                    self._subText.applySettings({y: ceil(-subBox.y)});
                    self._rect = new Rectangle({
                        left: floor(min(mainBox.x, subBox.x)),
                        right: ceil(max(mainBox.x + mainBox.width, subBox.x + subBox.width)),
                        top: floor(mainBox.y),
                        bottom: ceil(subBox.height)
                    })
                }
                else if (mainBox || subBox) {
                    mainBox = mainBox || subBox;
                    self._rect = new Rectangle({
                        left: floor(mainBox.x),
                        right: ceil(mainBox.x + mainBox.width),
                        top: floor(mainBox.y),
                        bottom: ceil(mainBox.y + mainBox.height)
                    })
                }
            },
            render: function(options) {
                var self = this;
                $extend(true, self._options, options);
                self._root = self._root || self._renderer.createGroup().applySettings({'class': 'dx-gauge-title'}).append(self._owner);
                if (isString(self._options.title.text)) {
                    self._mainText = self._mainText || self._renderer.createText().append(self._root);
                    self._mainText.applySettings({
                        x: 0,
                        y: 0,
                        align: 'center',
                        font: self._options.title.font,
                        text: self._options.title.text
                    })
                }
                else {
                    self._mainText && self._mainText.remove();
                    delete self._mainText
                }
                if (isString(self._options.subtitle.text)) {
                    self._subText = self._subText || self._renderer.createText().append(self._root);
                    self._subText.applySettings({
                        x: 0,
                        y: 0,
                        align: 'center',
                        font: self._options.subtitle.font,
                        text: self._options.subtitle.text
                    })
                }
                else {
                    self._subText && self._subText.remove();
                    delete self._subText
                }
                if (self._mainText || self._subText)
                    self._measureTexts();
                else {
                    self._root && self._root.remove();
                    delete self._root
                }
                return self
            },
            processTitleOptions: function(options) {
                if (isString(options))
                    return {text: options};
                else if (!isDefined(options))
                    return {text: null};
                else {
                    options = $extend({}, options);
                    options.layout = $extend({}, options.layout, {position: options.position});
                    return options
                }
            },
            processSubtitleOptions: function(options) {
                if (isString(options))
                    return {text: options};
                else if (!isDefined(options))
                    return {text: null};
                else
                    return $extend({}, options)
            },
            isVisible: function() {
                return !!(this._mainText || this._subText)
            },
            getBoundingRect: function() {
                return this._rect.clone()
            },
            getLayoutOptions: function() {
                return this._options.title.layout || {}
            },
            move: function(dx, dy) {
                var self = this;
                self._root.move(self._location.x += dx, self._location.y += dy);
                self._rect = self._rect.move(dx, dy);
                return self
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file layoutManager.js */
    (function(DX, undefined) {
        var min = Math.min,
            max = Math.max,
            isString = DX.utils.isString;
        var Rectangle = DX.viz.core.Rectangle;
        function parseLayoutOptions(options) {
            options = options || {};
            var parts = (isString(options) ? options : options.position || '').split('-');
            return {
                    primary: isString(parts[0]) ? parts[0].toLowerCase() : '',
                    secondary: isString(parts[1]) ? parts[1].toLowerCase() : '',
                    overlay: options.overlay > 0 ? Number(options.overlay) : 0
                }
        }
        DX.viz.gauges.__internals.LayoutManager = DX.Class.inherit({
            setRect: function(rect) {
                this._rect = rect.clone();
                return this
            },
            getRect: function() {
                return this._rect.clone()
            },
            applyLayout: function(rect, options) {
                var dx = 0,
                    dy = 0,
                    availableRect = this._rect,
                    resultRect = rect.clone(),
                    options_ = parseLayoutOptions(options),
                    delta = resultRect.height() - options_.overlay;
                switch (options_.primary) {
                    case'top':
                        if (delta >= 0) {
                            dy = availableRect.top - resultRect.top;
                            availableRect.top = min(availableRect.top + delta, availableRect.bottom)
                        }
                        else
                            dy = availableRect.top - resultRect.top - delta;
                        break;
                    case'bottom':
                        if (delta >= 0) {
                            dy = availableRect.bottom - resultRect.bottom;
                            availableRect.bottom = max(availableRect.bottom - delta, availableRect.top)
                        }
                        else
                            dy = availableRect.bottom - resultRect.bottom + delta;
                        break
                }
                switch (options_.secondary) {
                    case'':
                    case'center':
                        dx = availableRect.horizontalMiddle() - resultRect.horizontalMiddle();
                        break;
                    case'left':
                        dx = availableRect.left - resultRect.left;
                        break;
                    case'right':
                        dx = availableRect.right - resultRect.right;
                        break
                }
                resultRect = resultRect.move(dx, dy);
                return {
                        rect: resultRect,
                        dx: dx,
                        dy: dy
                    }
            },
            dock: function(rect, options) {
                var dx = 0,
                    dy = 0,
                    mainRect = this._rect,
                    resultRect = rect.clone(),
                    options_ = parseLayoutOptions(options);
                switch (options_.primary) {
                    case'top':
                        dy = mainRect.top - resultRect.bottom + options_.overlay;
                        break;
                    case'bottom':
                        dy = mainRect.bottom - resultRect.top - options_.overlay;
                        break
                }
                resultRect = resultRect.move(dx, dy);
                return {
                        rect: resultRect,
                        dx: dx,
                        dy: dy
                    }
            },
            selectRectByAspectRatio: function(aspectRatio, margins) {
                var rect = this._rect.clone(),
                    selfAspectRatio,
                    width = 0,
                    height = 0;
                margins = margins || {};
                if (aspectRatio > 0) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (rect.width() > 0 && rect.height() > 0) {
                        selfAspectRatio = rect.height() / rect.width();
                        if (selfAspectRatio > 1)
                            aspectRatio < selfAspectRatio ? width = rect.width() : height = rect.height();
                        else
                            aspectRatio > selfAspectRatio ? height = rect.height() : width = rect.width();
                        width > 0 || (width = height / aspectRatio);
                        height > 0 || (height = width * aspectRatio);
                        width = (rect.width() - width) / 2;
                        height = (rect.height() - height) / 2;
                        rect.left += width;
                        rect.right -= width;
                        rect.top += height;
                        rect.bottom -= height
                    }
                    else {
                        rect.left = rect.right = rect.horizontalMiddle();
                        rect.top = rect.bottom = rect.verticalMiddle()
                    }
                }
                return rect
            },
            selectRectBySizes: function(sizes, margins) {
                var rect = this._rect.clone(),
                    step;
                margins = margins || {};
                if (sizes) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (sizes.width > 0) {
                        step = (rect.width() - sizes.width) / 2;
                        if (step > 0) {
                            rect.left += step;
                            rect.right -= step
                        }
                    }
                    if (sizes.height > 0) {
                        step = (rect.height() - sizes.height) / 2;
                        if (step > 0) {
                            rect.top += step;
                            rect.bottom -= step
                        }
                    }
                }
                return rect
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file themeManager.js */
    (function($, DX, undefined) {
        var defaultFormatText = function(text) {
                if (isString(text))
                    return text;
                if (isNumber(text))
                    return text.toString();
                return 'N/A'
            };
        DX.viz.gauges.__internals.ThemeManager = DX.viz.core.BaseThemeManager.inherit(function() {
            var ctor = function(userTheme) {
                    this.callBase(userTheme, 'gauge');
                    this.theme.area.defaultFormatText = defaultFormatText
                };
            var getRangeTheme = function() {
                    return this.theme.range || {}
                };
            var getScaleTheme = function() {
                    return this.theme.scale || {}
                };
            var getNeedleTheme = function() {
                    return this.theme.needle || {}
                };
            var getMarkerTheme = function() {
                    return this.theme.marker || {}
                };
            return {
                    ctor: ctor,
                    getRangeTheme: getRangeTheme,
                    getScaleTheme: getScaleTheme,
                    getNeedleTheme: getNeedleTheme,
                    getMarkerTheme: getMarkerTheme
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file presetManager.js */
    (function(DX, $, undefined) {
        var internals = DX.viz.gauges.__internals;
        var circularPresets = {
                preset1: {
                    commonNeedleSettings: {type: 'rectangle'},
                    commonMarkerSettings: {type: 'textcloud'}
                },
                preset2: {
                    commonNeedleSettings: {type: 'twocolorrectangle'},
                    commonMarkerSettings: {
                        offset: 6,
                        type: 'triangle'
                    }
                },
                preset3: {
                    commonMarkerSettings: {
                        offset: 6,
                        type: 'triangle'
                    },
                    commonRangeBarSettings: {text: {indent: 70}}
                }
            };
        var linearPresets = {
                preset1: {
                    commonNeedleSettings: {type: 'rhombus'},
                    commonMarkerSettings: {type: 'textcloud'}
                },
                preset2: {
                    commonNeedleSettings: {type: 'circle'},
                    commonMarkerSettings: {type: 'triangle'}
                }
            };
        DX.viz.gauges.__internals.PresetManager = DX.Class.inherit({
            setup: function(gaugeType, presetName) {
                var self = this;
                self._activePreset = {};
                self._setPresetsCollection(self._selectPresets(gaugeType), 'preset1');
                return self._setActivePreset(presetName)
            },
            _selectPresets: function(gaugeType) {
                var presets = {};
                switch (gaugeType) {
                    case'circular':
                        presets = circularPresets;
                        break;
                    case'linear':
                        presets = linearPresets;
                        break
                }
                return presets
            },
            _setActivePreset: function(preset) {
                var currentPreset = {},
                    argIsString = !preset || typeof preset === 'string';
                this._presetName = argIsString ? preset : preset.name;
                if (this._presetName !== 'none') {
                    if (!argIsString)
                        this._updatePreset(preset);
                    this._activePreset = this._getCollectionElement(this._presetName)
                }
                else
                    this._activePreset = argIsString ? currentPreset : preset;
                return this._activePreset
            },
            getNeedlePreset: function() {
                return this._activePreset.commonNeedleSettings || {}
            },
            getMarkerPreset: function() {
                return this._activePreset.commonMarkerSettings || {}
            },
            getRangeBarPreset: function() {
                return this._activePreset.commonRangeBarSettings || {}
            },
            getScalePreset: function() {
                return this._activePreset.commonScaleSettings || {}
            },
            getRangePreset: function() {
                return this._activePreset.commonRangeSettings || {}
            },
            getTitlePreset: function() {
                return this._activePreset.title || {}
            },
            getSubtitlePreset: function() {
                return this._activePreset.subtitle || {}
            },
            getIndicatorPreset: function() {
                return this._activePreset.indicator || {}
            },
            getSpindlePreset: function() {
                return this._activePreset.spindle || {}
            },
            _updatePreset: function(preset) {
                if (this._presetsCollection.hasOwnProperty(preset.name))
                    $.extend(true, this._presetsCollection[preset.name], preset);
                else
                    $.extend(true, this._presetsCollection.defaultPreset, preset)
            },
            _getCollectionElement: function(elementName) {
                var element = {};
                if (this._presetsCollection.hasOwnProperty(elementName))
                    element = this._presetsCollection[elementName];
                else
                    element = this._presetsCollection.defaultPreset;
                return element
            },
            _setPresetsCollection: function(presetsCollection, defaultPresetName) {
                this._presetsCollection = $.extend(true, {}, presetsCollection || {});
                if (defaultPresetName && this._presetsCollection.hasOwnProperty(defaultPresetName))
                    this._presetsCollection.defaultPreset = $.extend({}, this._presetsCollection[defaultPresetName]);
                else
                    this._presetsCollection.defaultPreset = {}
            }
        });
        $.extend(DX.viz.gauges.__tests, {
            circularPresets: circularPresets,
            linearPresets: linearPresets
        })
    })(DevExpress, jQuery);
    /*! Module viz, file gauge.js */
    (function(DX, $, undefined) {
        var factory = DX.viz.gauges.__factory;
        var Rectangle = DX.viz.core.Rectangle;
        var isNumber = DX.utils.isNumber,
            isString = DX.utils.isString,
            isFunction = DX.utils.isFunction,
            isFinite = window.isFinite,
            setTimeout = window.setTimeout,
            windowResizeCallbacks = DX.utils.windowResizeCallbacks,
            $extend = $.extend,
            $each = $.each;
        var REDRAW_DELAY = 500;
        var DEFAULT_GAUGE_OPTIONS = {
                size: {
                    width: undefined,
                    height: undefined
                },
                margin: {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                },
                geometry: {},
                preset: 'preset1',
                containerBackgroundColor: '#FFFFFF',
                animationEnabled: true,
                animationDuration: 1000,
                redrawOnResize: true,
                incidentOccured: $.noop,
                scale: {
                    startValue: 0,
                    endValue: 100,
                    majorTick: {
                        visible: true,
                        type: 'rectangle',
                        tickInterval: undefined,
                        customTickValues: [],
                        length: 5,
                        width: 2,
                        showCalculatedTicks: true,
                        useTicksAutoArrangement: true,
                        color: '#FFFFFF'
                    },
                    minorTick: {
                        visible: false,
                        type: 'rectangle',
                        tickInterval: undefined,
                        customTickValues: [],
                        length: 3,
                        width: 1,
                        showCalculatedTicks: true,
                        color: '#FFFFFF'
                    },
                    label: {
                        visible: true,
                        format: '',
                        precision: 2,
                        customizeText: undefined,
                        font: {
                            color: '#7F7F7F',
                            size: 12,
                            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                            weight: 400
                        }
                    }
                },
                rangeContainer: {
                    offset: 0,
                    width: 5,
                    backgroundColor: '#808080',
                    palette: ['#AD79CE', '#639EC6', '#A5C763', '#FFB65A', '#E78E94'],
                    ranges: []
                },
                commonNeedleSettings: {
                    __info: 'needle',
                    color: '#C2C2C2'
                },
                commonMarkerSettings: {
                    __info: 'marker',
                    color: '#679EC5',
                    space: 2,
                    length: 14,
                    width: 13,
                    arrowLength: 5,
                    horizontalOffset: 6,
                    verticalOffset: 3,
                    text: {
                        customizeText: undefined,
                        font: {
                            color: '#FFFFFF',
                            size: 18,
                            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                            weight: 400
                        }
                    }
                },
                commonRangeBarSettings: {
                    baseValue: undefined,
                    color: '#AD79CE',
                    backgroundColor: 'none',
                    space: 2,
                    size: 10,
                    text: {
                        indent: 0,
                        customizeText: undefined,
                        font: {
                            size: 14,
                            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                            weight: 400
                        }
                    }
                },
                title: {
                    layout: {
                        position: 'top-center',
                        overlay: 0
                    },
                    font: {
                        size: 18,
                        color: '#232323',
                        family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200
                    }
                },
                subtitle: {font: {
                        size: 14,
                        color: '#232323',
                        family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200
                    }},
                indicator: {
                    hasPositiveMeaning: true,
                    text: {
                        format: 'fixedPoint',
                        precision: 0,
                        customizeText: $.none,
                        useDefaultColor: false,
                        font: {
                            color: '#7F7F7F',
                            size: 18,
                            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                            weight: 400
                        }
                    },
                    layout: {
                        position: 'bottom-center',
                        overlay: 0
                    }
                },
                tooltip: {
                    enabled: false,
                    format: undefined,
                    precision: undefined,
                    customizeText: undefined,
                    font: {
                        color: '#FFFFFF',
                        size: 26,
                        family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200
                    },
                    horizontalPadding: 22,
                    verticalPadding: 6,
                    arrowLength: 10
                },
                tracker: {tooltipDelay: 500}
            };
        DX.viz.gauges.Gauge = DX.ui.Component.inherit({
            _defaultOptions: function() {
                return $extend(true, {}, DEFAULT_GAUGE_OPTIONS)
            },
            _initOptions: function(options) {
                var self = this,
                    preset;
                self._presetManager = factory.createPresetManager();
                preset = self._presetManager.setup(self._gaugeType(), options ? options.preset : {});
                self.option(preset);
                self.callBase(options)
            },
            _getPresetName: function(options) {
                return options && isString(options.preset) ? options.preset : this.option('preset')
            },
            _init: function() {
                var self = this;
                self._initRenderer();
                self._tracker = factory.createTracker();
                self._tracker.setup(self);
                self._layoutManager = factory.createLayoutManager();
                self._defaultOpts = self._defaultOptions();
                self._creationOptions = self._getCreationOptions();
                self._mainElements = [];
                self._externalElements = [];
                self._needles = [];
                self._markers = [];
                self._rangeBars = [];
                self._initResizeHandler()
            },
            _dispose: function() {
                var self = this;
                self._disposeRenderer();
                delete self._tracker;
                delete self._layoutManager;
                delete self._defaultOpts;
                delete self._creationOptions;
                delete self._mainElements;
                delete self._externalElements;
                delete self._needles;
                delete self._markers;
                delete self._rangeBars;
                self._disposeResizeHandler();
                self.callBase()
            },
            _initRenderer: function() {
                var self = this;
                self._canvas = {
                    width: 1,
                    height: 1,
                    marginLeft: 0,
                    marginRight: 0,
                    marginTop: 0,
                    marginBottom: 0
                };
                self._renderer = factory.createRenderer({
                    width: 1,
                    height: 1
                });
                self._rootElement = self._renderer.getRoot();
                self._trackerGroup = self._renderer.createGroup({'class': 'tracker'}).append(self._rootElement)
            },
            _disposeRenderer: function() {
                var self = this;
                delete self._canvas;
                delete self._renderer;
                delete self._rootElement;
                delete self._trackerGroup
            },
            _initResizeHandler: function() {
                var self = this;
                self._resizeHandler = DX.utils.createResizeHandler(function() {
                    self._renderCore()
                });
                self._resizeHandler.dispose = function() {
                    self = null;
                    return this
                }
            },
            _disposeResizeHandler: function() {
                windowResizeCallbacks.remove(this._resizeHandler.stop().dispose());
                delete this._resizeHandler
            },
            _trackWindowResize: function() {
                var self = this;
                if (self.option('redrawOnResize') === true)
                    windowResizeCallbacks.has(self._resizeHandler) || windowResizeCallbacks.add(self._resizeHandler);
                else
                    windowResizeCallbacks.remove(self._resizeHandler)
            },
            _getIncidentOccured: function() {
                var incidentOccured = this.option('incidentOccured');
                isFunction(incidentOccured) || (incidentOccured = this._defaultOpts.incidentOccured);
                return function() {
                        incidentOccured.apply(null, arguments)
                    }
            },
            _getCreationOptions: function() {
                return {
                        renderer: this._renderer,
                        ownerElement: this._rootElement,
                        owner: this._rootElement
                    }
            },
            _getCommonOptions: function() {
                var self = this,
                    formatOptions = self._getDefaultFormatOptions();
                return {
                        translator: self._area.translator,
                        animationEnabled: self.option('animationEnabled'),
                        animationDuration: self.option('animationDuration'),
                        containerBackgroundColor: self.option('containerBackgroundColor'),
                        defaultTextFormat: formatOptions.format,
                        defaultTextPrecision: formatOptions.precision
                    }
            },
            _getDefaultFormatOptions: function() {
                var area = this._area;
                return DX.utils.getAppropriateFormat(area.startValue, area.endValue, this._getApproximateScreenRange())
            },
            _getCommonNeedleSettings: function() {
                var self = this;
                return $extend(true, {}, self._defaultOpts.commonNeedleSettings, self._presetManager.getNeedlePreset(), self.option('commonNeedleSettings'))
            },
            _getCommonMarkerSettings: function() {
                var self = this;
                return $extend(true, {}, self._defaultOpts.commonMarkerSettings, self._presetManager.getMarkerPreset(), self.option('commonMarkerSettings'))
            },
            _getCommonRangeBarSettings: function() {
                var self = this;
                return $extend(true, self._defaultOpts.commonRangeBarSettings, self._presetManager.getRangeBarPreset(), self.option('commonRangeBarSettings'))
            },
            _hide: function() {
                !this._isHidden && (this._isHidden = true) && this._renderer.getRoot().hide()
            },
            _show: function() {
                this._isHidden && delete this._isHidden && this._renderer.getRoot().show()
            },
            _getCanvas: function() {
                var self = this,
                    size = self.option('size') || {},
                    margin = self.option('margin') || {},
                    container = self._element(),
                    defaultSize = self._getDefaultContainerSize(),
                    width = size.width >= 0 ? Number(size.width) : container.width(),
                    height = size.height >= 0 ? Number(size.height) : container.height();
                if (!width && Number(size.width) !== 0)
                    width = defaultSize.width;
                if (!height && Number(size.height) !== 0)
                    height = defaultSize.height;
                return {
                        width: width,
                        height: height,
                        marginLeft: margin.left > 0 ? Number(margin.left) : 0,
                        marginTop: margin.top > 0 ? Number(margin.top) : 0,
                        marginRight: margin.right > 0 ? Number(margin.right) : 0,
                        marginBottom: margin.bottom > 0 ? Number(margin.bottom) : 0
                    }
            },
            _updateVisibility: function(canvas) {
                var self = this;
                if (canvas.width - canvas.marginLeft - canvas.marginRight >= 2 && canvas.height - canvas.marginTop - canvas.marginBottom >= 2 && self._element().is(':visible')) {
                    self._show();
                    return true
                }
                else {
                    self._hide();
                    self._incidentOccured('Gauge cannot be rendered since container is too small or not visible');
                    return false
                }
            },
            _getArea: function() {
                var self = this,
                    scale = self.option('scale') || {},
                    area = {};
                area.startValue = isNumber(scale.startValue) ? Number(scale.startValue) : 0;
                area.endValue = isNumber(scale.endValue) ? Number(scale.endValue) : 100;
                area.baseValue = Math.min(area.startValue, area.endValue);
                self._setupArea(area);
                area.translator = factory.createTranslator(area.startCoord, area.endCoord, area.startValue, area.endValue);
                return area
            },
            _renderTitle: function() {
                var self = this,
                    titleOptions = self.option('title'),
                    subtitleOptions = self.option('subtitle');
                if (!self._title) {
                    self._title = factory.createTitle();
                    self._title._renderer = self._renderer;
                    self._title._owner = self._rootElement
                }
                titleOptions = $extend(true, {}, self._defaultOpts.title, self._presetManager.getTitlePreset(), self._title.processTitleOptions(titleOptions));
                subtitleOptions = $extend(true, {}, self._defaultOpts.subtitle, self._presetManager.getSubtitlePreset(), self._title.processSubtitleOptions(subtitleOptions));
                self._title.render({
                    title: titleOptions,
                    subtitle: subtitleOptions
                });
                self._title.isVisible() && self._externalElements.push(self._title)
            },
            _renderDeltaIndicator: function() {
                var self = this,
                    options = self.option('indicator');
                if (!self._indicator) {
                    self._indicator = factory.createIndicator();
                    if (self._indicator) {
                        self._indicator._renderer = self._renderer;
                        self._indicator._owner = self._rootElement
                    }
                }
                if (self._indicator) {
                    options = $extend(true, {}, self._defaultOpts.indicator, self._presetManager.getIndicatorPreset(), options);
                    self._indicator.render(options);
                    self._indicator.isVisible() && self._externalElements.push(self._indicator)
                }
            },
            _renderTooltip: function() {
                var self = this,
                    options = $extend({}, self._defaultOpts.tooltip, self.option('tooltip'));
                if (!self._tooltip) {
                    self._tooltip = factory.createTooltip();
                    self._tooltip.setup(self)
                }
                self._tooltip.init($extend(true, {}, self._defaultOpts.tooltip, self.option('tooltip')));
                self._tooltip.render()
            },
            _renderDebugInfo: function() {
                var self = this,
                    group = self._debugGroup || self._renderer.createGroup({'class': 'debug-info'}).append(),
                    rect;
                group.clear();
                rect = self._rootRect;
                self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                    stroke: '#000000',
                    strokeWidth: 1,
                    fill: 'none'
                }).append(group);
                rect = self._mainRect;
                self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                    stroke: '#0000FF',
                    strokeWidth: 1,
                    fill: 'none'
                }).append(group);
                rect = self._layoutManager.getRect();
                rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                    stroke: '#FF0000',
                    strokeWidth: 1,
                    fill: 'none'
                }).append(group);
                rect = self._title && self._title.isVisible() ? self._title.getBoundingRect() : null;
                rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                    stroke: '#00FF00',
                    strokeWidth: 1,
                    fill: 'none'
                }).append(group);
                rect = self._indicator && self._indicator.isVisible() ? self._indicator.getBoundingRect() : null;
                rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                    stroke: '#00FF00',
                    strokeWidth: 1,
                    fill: 'none'
                }).append(group)
            },
            _renderCore: function(force) {
                var self = this,
                    currentCanvas = self._canvas,
                    canvas = self._getCanvas();
                if (!self._updateVisibility(canvas))
                    return;
                if (canvas.width === currentCanvas.width && canvas.height === currentCanvas.height && !force)
                    return;
                self._renderer.container || self._renderer.draw(self._element().get(0));
                self._renderer.resize(canvas.width, canvas.height);
                self._canvas = canvas;
                self._rootRect = new Rectangle({
                    left: canvas.marginLeft,
                    top: canvas.marginTop,
                    right: canvas.width - canvas.marginRight,
                    bottom: canvas.height - canvas.marginBottom
                });
                self._layoutManager.setRect(self._rootRect);
                self._mainRect = self._rootRect.clone();
                self._area = self._getArea();
                self._commonOptions = self._getCommonOptions();
                self._mainElements.length = 0;
                self._externalElements.length = 0;
                self._renderTitle();
                self._renderDeltaIndicator();
                $each(self._externalElements, function(_, item) {
                    var layout = self._layoutManager.applyLayout(item.getBoundingRect(), item.getLayoutOptions());
                    item.move(layout.dx, layout.dy)
                });
                self._mainRect = self._layoutManager.getRect();
                self._prepareMainElements();
                self._applyMainLayout(self._measureMainElements());
                self._renderMainElements();
                $each(self._externalElements, function(_, item) {
                    var layout = self._layoutManager.dock(item.getBoundingRect(), item.getLayoutOptions());
                    item.move(layout.dx, layout.dy)
                });
                self._renderTooltip();
                self._tracker.init(self.option('tracker')).activate()
            },
            _render: function() {
                var self = this;
                self._incidentOccured = self._getIncidentOccured();
                self._renderCore(true);
                self._updateActiveElements();
                self._trackWindowResize();
                self.option('debugMode') === true && self._renderDebugInfo()
            },
            _prepareMainElements: function() {
                var self = this;
                self._renderRangeContainer();
                self._renderScale();
                var rangeBarsOption = self.option('rangeBars'),
                    needlesOption = self.option('needles'),
                    markersOption = self.option('markers');
                if (rangeBarsOption === undefined && needlesOption === undefined && markersOption === undefined)
                    needlesOption = [{value: self._area.baseValue}];
                self._renderIndicators('_rangeBars', rangeBarsOption || [], self._getCommonRangeBarSettings(), self._createRangeBar);
                self._renderIndicators('_needles', needlesOption || [], self._getCommonNeedleSettings(), self._createNeedle);
                self._renderIndicators('_markers', markersOption || [], self._getCommonMarkerSettings(), self._createMarker)
            },
            _updateActiveElements: function() {
                var self = this;
                $each(self._mainElements, function(_, item) {
                    item.setCurrentValue && item.setCurrentValue(item._options.value)
                })
            },
            _renderScale: function() {
                var self = this,
                    scale = self._scale,
                    userOptions = self.option('scale'),
                    options;
                if (!scale) {
                    scale = self._scale = self._createScale();
                    scale.setup({
                        renderer: self._renderer,
                        owner: self._rootElement,
                        incidentOccured: self._incidentOccured
                    })
                }
                options = self._combineOptions(self._commonOptions, self._defaultOpts.commonScaleSettings, self._presetManager.getScalePreset(), userOptions, {offset: 0});
                options.majorTick.customTickValues = options.majorTick.customTickValues || [];
                options.minorTick.customTickValues = options.minorTick.customTickValues || [];
                scale.init(options);
                self._mainElements.push(scale)
            },
            _renderRangeContainer: function() {
                var self = this,
                    rangeContainer = self._rangeContainer,
                    userOptions = self.option('rangeContainer'),
                    options;
                if (!rangeContainer) {
                    rangeContainer = self._rangeContainer = self._createRangeContainer();
                    rangeContainer.setup({
                        renderer: self._renderer,
                        owner: self._rootElement,
                        incidentOccured: self._incidentOccured
                    })
                }
                options = self._combineOptions(self._commonOptions, self._defaultOpts.commonRangeSettings, self._presetManager.getRangePreset(), userOptions);
                options.ranges = options.ranges || [];
                rangeContainer.init(options);
                self._mainElements.push(rangeContainer)
            },
            _renderIndicators: function(fieldName, userOptions, commonSettings, createHandler) {
                var self = this,
                    list = self[fieldName],
                    newList = [],
                    currentUserOptions,
                    i,
                    count,
                    item,
                    newItem;
                for (i = 0, count = list.length; i < count; ++i) {
                    item = list[i];
                    currentUserOptions = userOptions[i];
                    if (currentUserOptions) {
                        newItem = self._renderIndicator(item, commonSettings, currentUserOptions, createHandler);
                        item !== newItem && item.destroy();
                        newItem && newList.push(newItem)
                    }
                    else
                        item.destroy()
                }
                for (i = count, count = userOptions.length; i < count; ++i) {
                    currentUserOptions = userOptions[i];
                    if (currentUserOptions) {
                        newItem = self._renderIndicator(undefined, commonSettings, currentUserOptions, createHandler);
                        newItem && newList.push(newItem)
                    }
                }
                self[fieldName] = newList
            },
            _renderIndicator: function(indicator, commonSettings, userOptions, createHandler) {
                var self = this,
                    options = self._combineOptions(self._commonOptions, commonSettings, userOptions),
                    item = indicator;
                self._updateIndicatorOptions(item, options);
                if (options.value !== undefined) {
                    if (!item || item._options.type !== options.type) {
                        item = createHandler.call(self, options.type);
                        if (item)
                            item.setup({
                                renderer: self._renderer,
                                owner: self._rootElement,
                                tracker: self._trackerGroup
                            });
                        else
                            self._incidentOccured('Cannot create ' + options.__info + ': type "' + options.type + '" is unknown')
                    }
                    if (item) {
                        item.init(options);
                        self._mainElements.push(item)
                    }
                }
                else
                    item = undefined;
                return item
            },
            _updateIndicatorOptions: function(indicator, options) {
                options.baseValue = isFinite(options.translator.translate(options.baseValue)) ? options.baseValue : this._area.baseValue;
                indicator && (options.currentValue = indicator.getCurrentValue());
                isFinite(options.currentValue) || (options.currentValue = options.baseValue);
                options.value = options.translator.adjust(options.value);
                if (options.text && !options.text.format && !options.text.precision) {
                    options.text.format = this._commonOptions.defaultTextFormat;
                    options.text.precision = this._commonOptions.defaultTextPrecision
                }
            },
            _getTrackedElements: function() {
                var list = [];
                $each(this._rangeBars, function(i, item) {
                    list.push({
                        target: item,
                        info: {
                            type: 'rangebar',
                            index: i
                        }
                    })
                });
                $each(this._needles, function(i, item) {
                    list.push({
                        target: item,
                        info: {
                            type: 'needle',
                            index: i
                        }
                    })
                });
                $each(this._markers, function(i, item) {
                    list.push({
                        target: item,
                        info: {
                            type: 'marker',
                            index: i
                        }
                    })
                });
                return list
            },
            _accessIndicatorValue: function(indicator, value) {
                if (value === undefined)
                    return indicator ? indicator.getCurrentValue() : undefined;
                else {
                    indicator && indicator.setCurrentValue(value);
                    return this
                }
            },
            needleValue: function(name, value) {
                return this._accessIndicatorValue(this._needles[name], value)
            },
            markerValue: function(name, value) {
                return this._accessIndicatorValue(this._markers[name], value)
            },
            rangeBarValue: function(name, value) {
                return this._accessIndicatorValue(this._rangeBars[name], value)
            },
            indicatorValue: function(value) {
                var self = this;
                if (value !== undefined)
                    self._indicator && self._indicator.update(value)
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                if (name === 'rangeContainer')
                    oldValue && newValue && newValue.ranges && (oldValue.ranges = null);
                if (name === 'scale') {
                    oldValue && oldValue.majorTick && newValue.majorTick && newValue.majorTick.customTickValues && (oldValue.majorTick.customTickValues = null);
                    oldValue && oldValue.minorTick && newValue.minorTick && newValue.minorTick.customTickValues && (oldValue.minorTick.customTickValues = null)
                }
                return this.callBase.apply(this, arguments)
            }
        });
        DX.viz.gauges.__tests.DEFAULT_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
    })(DevExpress, jQuery);
    /*! Module viz, file circularGauge.js */
    (function(DX, $, undefined) {
        var factory = DX.viz.gauges.__factory;
        var isNumber = DX.utils.isNumber,
            Number = window.Number,
            normalizeAngle = DX.utils.normalizeAngle,
            getCosAndSin = DX.utils.getCosAndSin,
            max = Math.max,
            min = Math.min,
            round = Math.round,
            slice = Array.prototype.slice,
            $extend = $.extend,
            $each = $.each;
        var PI = Math.PI;
        var DEFAULT_GAUGE_OPTIONS = {
                geometry: {
                    startAngle: 225,
                    endAngle: 315,
                    totalRadius: undefined
                },
                scale: {
                    orientation: 'outside',
                    label: {indentFromTick: 10}
                },
                rangeContainer: {orientation: 'outside'},
                spindle: {
                    visible: true,
                    size: 14,
                    gapSize: 10,
                    color: '#C2C2C2'
                },
                commonNeedleSettings: {
                    offset: 20,
                    type: 'rectangle',
                    indentFromCenter: 0,
                    width: 2,
                    space: 2,
                    secondColor: '#E18E92',
                    secondFraction: 0.4
                },
                commonMarkerSettings: {
                    offset: -6,
                    type: 'textcloud'
                },
                commonRangeBarSettings: {offset: 30}
            };
        function getSides(startAngle, endAngle) {
            var startCosSin = getCosAndSin(startAngle),
                endCosSin = getCosAndSin(endAngle),
                startCos = startCosSin.cos,
                startSin = startCosSin.sin,
                endCos = endCosSin.cos,
                endSin = endCosSin.sin;
            return {
                    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : min(startCos, endCos, 0),
                    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : max(startCos, endCos, 0),
                    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -max(startSin, endSin, 0),
                    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -min(startSin, endSin, 0)
                }
        }
        DX.viz.gauges.CircularGauge = DX.viz.gauges.Gauge.inherit({
            _gaugeType: function() {
                return 'circular'
            },
            _defaultOptions: function() {
                return $extend(true, {}, this.callBase(), DEFAULT_GAUGE_OPTIONS)
            },
            _setupArea: function(area) {
                var self = this,
                    geometry = self.option('geometry'),
                    startAngle = geometry.startAngle,
                    endAngle = geometry.endAngle;
                startAngle = isNumber(startAngle) ? normalizeAngle(startAngle) : self._defaultOpts.geometry.startAngle;
                endAngle = isNumber(endAngle) ? normalizeAngle(endAngle) : self._defaultOpts.geometry.endAngle;
                if (startAngle <= endAngle)
                    endAngle -= 360;
                area.x = 0;
                area.y = 0;
                area.radius = 100;
                area.startCoord = startAngle;
                area.endCoord = endAngle;
                area.totalRadius = geometry.totalRadius > 0 ? Number(geometry.totalRadius) : self._defaultOpts.geometry.totalRadius;
                area.sides = getSides(startAngle, endAngle)
            },
            _getCreationOptions: function() {
                var result = this.callBase();
                result.type = 'circular';
                return result
            },
            _getCommonOptions: function() {
                var area = this._area;
                return $extend(true, this.callBase(), {
                        x: area.x,
                        y: area.y,
                        areaRadius: area.radius,
                        type: 'circular'
                    })
            },
            _combineOptions: function() {
                var args = [true, {}].concat(slice.apply(arguments)),
                    options = $extend.apply($, args);
                options.radius = round(options.areaRadius - Number(options.offset) || options.areaRadius);
                return options
            },
            _measureMainElements: function() {
                var self = this,
                    maxRadius = 0,
                    minRadius = Infinity,
                    maxHorizontalOffset = 0,
                    maxVerticalOffset = 0,
                    maxInverseHorizontalOffset = 0,
                    maxInverseVerticalOffset = 0;
                $each(self._mainElements, function(_, x) {
                    var bounds = x.measure();
                    bounds.min > 0 && (minRadius = min(minRadius, bounds.min));
                    bounds.max > 0 && (maxRadius = max(maxRadius, bounds.max));
                    bounds.horizontalOffset > 0 && (maxHorizontalOffset = max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
                    bounds.verticalOffset > 0 && (maxVerticalOffset = max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
                    bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
                    bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = max(maxInverseVerticalOffset, bounds.inverseVerticalOffset))
                });
                maxHorizontalOffset = max(maxHorizontalOffset - maxRadius, 0);
                maxVerticalOffset = max(maxVerticalOffset - maxRadius, 0);
                return {
                        minRadius: minRadius,
                        maxRadius: maxRadius,
                        horizontalMargin: maxHorizontalOffset,
                        verticalMargin: maxVerticalOffset,
                        inverseHorizontalMargin: maxInverseHorizontalOffset,
                        inverseVerticalMargin: maxInverseVerticalOffset
                    }
            },
            _applyMainLayout: function(measurements) {
                var self = this,
                    area = self._area,
                    sides = area.sides,
                    margins = {
                        left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                        right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                        top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
                        bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
                    },
                    rect = self._layoutManager.selectRectByAspectRatio((sides.down - sides.up) / (sides.right - sides.left), margins),
                    radius = min(rect.width() / (sides.right - sides.left), rect.height() / (sides.down - sides.up)),
                    x,
                    y;
                if (radius > area.totalRadius) {
                    rect = rect.scale(area.totalRadius / radius);
                    radius = area.totalRadius
                }
                radius = radius - measurements.maxRadius + area.radius;
                x = rect.left - rect.width() * sides.left / (sides.right - sides.left);
                y = rect.top - rect.height() * sides.up / (sides.down - sides.up);
                area.x = round(x);
                area.y = round(y);
                area.radius = radius;
                rect.left -= margins.left;
                rect.right += margins.right;
                rect.top -= margins.top;
                rect.bottom += margins.bottom;
                self._layoutManager.setRect(rect)
            },
            _renderMainElements: function() {
                var self = this,
                    x = self._area.x,
                    y = self._area.y,
                    r = self._area.radius;
                $each(self._mainElements, function(_, item) {
                    item.init({
                        x: x,
                        y: y,
                        radius: round(r - Number(item._options.offset) || r)
                    }).render()
                })
            },
            _createScale: function() {
                return factory.createCircularScale()
            },
            _createRangeContainer: function() {
                return factory.createCircularRangeContainer()
            },
            _createNeedle: function(type) {
                return factory.createCircularNeedle(type)
            },
            _createMarker: function(type) {
                return factory.createCircularMarker(type)
            },
            _createRangeBar: function() {
                return factory.createCircularRangeBar()
            },
            _createSpindle: function() {
                return factory.createCircularSpindle()
            },
            _prepareMainElements: function() {
                this.callBase();
                this._renderSpindle()
            },
            _renderSpindle: function() {
                var self = this;
                if (!self._spindle) {
                    self._spindle = self._createSpindle();
                    self._spindle.setup({
                        renderer: self._renderer,
                        owner: self._rootElement
                    })
                }
                self._spindle.init(self._combineOptions(self._commonOptions, self._defaultOpts.spindle, self._presetManager.getSpindlePreset(), self.option('spindle')));
                self._mainElements.push(self._spindle)
            },
            _getApproximateScreenRange: function() {
                var self = this,
                    area = self._area,
                    r = min(self._mainRect.width() / (area.sides.right - area.sides.left), self._mainRect.height() / (area.sides.down - area.sides.up));
                r > area.totalRadius && (r = area.totalRadius);
                r = 0.8 * r;
                return -area.translator.getCodomainRange() * r * PI / 180
            },
            _getDefaultContainerSize: function() {
                return {
                        width: 300,
                        height: 300
                    }
            }
        });
        DX.viz.gauges.__tests.getSides = getSides;
        DX.viz.gauges.__tests.DEFAULT_CIRCULAR_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
    })(DevExpress, jQuery);
    /*! Module viz, file linearGauge.js */
    (function(DX, $, undefined) {
        var factory = DX.viz.gauges.__factory;
        var max = Math.max,
            min = Math.min,
            round = Math.round,
            slice = Array.prototype.slice,
            $extend = $.extend,
            $each = $.each;
        var DEFAULT_GAUGE_OPTIONS = {
                geometry: {
                    orientation: 'horizontal',
                    totalSize: undefined
                },
                scale: {
                    horizontalOrientation: 'right',
                    verticalOrientation: 'bottom',
                    label: {indentFromTick: -10}
                },
                rangeContainer: {
                    horizontalOrientation: 'right',
                    verticalOrientation: 'bottom'
                },
                commonNeedleSettings: {
                    offset: 2.5,
                    type: 'rhombus',
                    length: 15,
                    width: 15
                },
                commonMarkerSettings: {
                    offset: -1,
                    type: 'textcloud',
                    horizontalOrientation: 'left',
                    verticalOrientation: 'top'
                },
                commonRangeBarSettings: {
                    offset: 10,
                    horizontalOrientation: 'right',
                    verticalOrientation: 'bottom'
                }
            };
        DX.viz.gauges.LinearGauge = DX.viz.gauges.Gauge.inherit({
            _gaugeType: function() {
                return 'linear'
            },
            _defaultOptions: function() {
                return $extend(true, this.callBase(), DEFAULT_GAUGE_OPTIONS)
            },
            _setupArea: function(area) {
                var geometry = this.option('geometry');
                area.vertical = geometry.orientation === 'vertical';
                area.x = 0;
                area.y = 0;
                area.startCoord = -100;
                area.endCoord = 100;
                area.totalSize = geometry.totalSize > 0 ? Number(geometry.totalSize) : undefined
            },
            _getCreationOptions: function() {
                var result = this.callBase();
                result.type = 'linear';
                return result
            },
            _getCommonOptions: function() {
                var area = this._area;
                return $extend(true, this.callBase(), {
                        baseX: area.x,
                        baseY: area.y,
                        orientation: area.vertical ? 'vertical' : 'horizontal'
                    })
            },
            _combineOptions: function() {
                var args = [true, {}].concat(slice.apply(arguments)),
                    options = $extend.apply($, args);
                options.x = round(options.baseX + Number(options.offset) || options.baseX);
                options.y = round(options.baseY + Number(options.offset) || options.baseY);
                return options
            },
            _measureMainElements: function() {
                var self = this,
                    minBound = 1000,
                    maxBound = 0,
                    indent = 0;
                $each(self._mainElements, function(_, item) {
                    var bounds = item.measure();
                    maxBound = max(maxBound, bounds.max);
                    minBound = min(minBound, bounds.min);
                    if (bounds.indent > 0)
                        indent = max(indent, bounds.indent)
                });
                return {
                        minBound: minBound,
                        maxBound: maxBound,
                        indent: indent
                    }
            },
            _applyMainLayout: function(measurements) {
                var self = this,
                    area = self._area,
                    rect,
                    offset;
                if (area.vertical) {
                    rect = self._layoutManager.selectRectBySizes({
                        width: measurements.maxBound - measurements.minBound,
                        height: area.totalSize
                    });
                    offset = rect.horizontalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.bottom - measurements.indent;
                    area.endCoord = rect.top + measurements.indent;
                    area.x = round(area.x + offset)
                }
                else {
                    rect = self._layoutManager.selectRectBySizes({
                        height: measurements.maxBound - measurements.minBound,
                        width: area.totalSize
                    });
                    offset = rect.verticalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.left + measurements.indent;
                    area.endCoord = rect.right - measurements.indent;
                    area.y = round(area.y + offset)
                }
                area.translator = factory.createTranslator(area.startCoord, area.endCoord, area.startValue, area.endValue);
                self._layoutManager.setRect(rect)
            },
            _renderMainElements: function() {
                var self = this,
                    x = self._area.x,
                    y = self._area.y,
                    translator = self._area.translator;
                $each(self._mainElements, function(_, item) {
                    item.init({
                        x: round(x + Number(item._options.offset) || x),
                        y: round(y + Number(item._options.offset) || y),
                        translator: translator
                    }).render()
                })
            },
            _createScale: function() {
                return factory.createLinearScale()
            },
            _createRangeContainer: function() {
                return factory.createLinearRangeContainer()
            },
            _createNeedle: function(type) {
                return factory.createLinearNeedle(type)
            },
            _createMarker: function(type) {
                return factory.createLinearMarker(type)
            },
            _createRangeBar: function() {
                return factory.createLinearRangeBar()
            },
            _getApproximateScreenRange: function() {
                var self = this,
                    area = self._area,
                    s = area.vertical ? self._mainRect.height() : self._mainRect.width();
                s > area.totalSize && (s = area.totalSize);
                s = s * 0.8;
                return s
            },
            _getDefaultContainerSize: function() {
                var geometry = this.option('geometry');
                if (geometry.orientation === 'vertical')
                    return {
                            width: 100,
                            height: 300
                        };
                else
                    return {
                            width: 300,
                            height: 100
                        }
            }
        });
        DX.viz.gauges.__tests.DEFAULT_LINEAR_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
    })(DevExpress, jQuery);
    /*! Module viz, file tooltip.js */
    (function(DX, $, undefined) {
        var formatHelper = DX.formatHelper;
        var Number = window.Number,
            String = window.String,
            isFunction = DX.utils.isFunction,
            round = Math.round,
            $extend = $.extend;
        var SHADOW_OFFSET = 4;
        var MASKS = {
                up: [-0.5, -1, -1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1],
                down: [0.5, 1, 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1],
                left: [-1, 0.5, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1, 1, 0],
                right: [1, -0.5, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0]
            };
        DX.viz.gauges.__internals.Tooltip = DX.Class.inherit({
            setup: function(gauge) {
                var self = this;
                DX.utils.debug.assertParam(gauge, '"gauge" parameter');
                self._gauge = gauge;
                self._renderer = gauge._renderer;
                self._options = {};
                return self
            },
            init: function(options) {
                var self = this;
                $extend(true, self._options, options);
                return self
            },
            render: function() {
                var self = this;
                if (self._options.enabled) {
                    self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'tooltip'});
                    self._rootElement.append(self._gauge._rootElement);
                    self._shadow = self._shadow || self._renderer.createArea().append(self._rootElement);
                    self._cloud = self._cloud || self._renderer.createArea().append(self._rootElement);
                    self._text = self._text || self._renderer.createText().append(self._rootElement);
                    self._shadow.applySettings({
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: '#000000',
                        opacity: 0.1
                    });
                    self._cloud.applySettings({
                        stroke: 'none',
                        strokeWidth: 0
                    });
                    self._text.applySettings({
                        align: 'center',
                        font: self._options.font
                    });
                    self._rootElement.applySettings({visibility: 'hidden'});
                    self._visible = false
                }
                else
                    self.clear();
                return self
            },
            clear: function() {
                var self = this;
                if (self._rootElement) {
                    self._rootElement.remove();
                    delete self._rootElement;
                    delete self._shadow;
                    delete self._cloud;
                    delete self._text
                }
                return self
            },
            _formatValue: function(value, context) {
                var options = this._options,
                    text = formatHelper.format(value, options.format, options.precision);
                if (isFunction(options.customizeText)) {
                    var target = $extend(true, context || {}, {
                            value: value,
                            valueText: text
                        });
                    return String(options.customizeText.call(target, target))
                }
                return text
            },
            _selectMask: function(x, y, width, height, arrowLength) {
                var rect = this._gauge._rootRect,
                    mask;
                if (x + width / 2 > rect.right)
                    mask = MASKS.left;
                else if (x - width / 2 < rect.left)
                    mask = MASKS.right;
                else if (y - arrowLength - height < rect.top)
                    mask = MASKS.down;
                else
                    mask = MASKS.up;
                return mask
            },
            _getSettings: function(x, y, textWidth, textHeight, offset) {
                var options = this._options,
                    cloudWidth = textWidth + 2 * Number(options.horizontalPadding),
                    cloudHeight = textHeight + 2 * Number(options.verticalPadding),
                    arrowLength = Number(options.arrowLength),
                    mask = this._selectMask(x, y, cloudWidth, cloudHeight, arrowLength),
                    i,
                    cloudPoints,
                    shadowPoints,
                    cx,
                    cy;
                cloudPoints = [cx = round(x - mask[12] * offset), cy = round(y - mask[13] * offset), cx += round(mask[0] * arrowLength), cy += round(mask[1] * arrowLength), cx += round(mask[2] * (cloudWidth - arrowLength) / 2), cy += round(mask[3] * (cloudHeight - arrowLength) / 2), cx += round(mask[4] * cloudWidth), cy += round(mask[5] * cloudHeight), cx += round(mask[6] * cloudWidth), cy += round(mask[7] * cloudHeight), cx += round(mask[8] * cloudWidth), cy += round(mask[9] * cloudHeight), cx += round(mask[10] * (cloudWidth - arrowLength) / 2), cy += round(mask[11] * (cloudHeight - arrowLength) / 2)];
                shadowPoints = cloudPoints.slice(0);
                cx = round(mask[12] * SHADOW_OFFSET);
                cy = round(mask[13] * SHADOW_OFFSET);
                for (i = 0; i < 14; i += 2) {
                    shadowPoints[i] += cx;
                    shadowPoints[i + 1] += cy
                }
                cx = round(x - mask[12] * (arrowLength + cloudWidth / 2 + offset));
                cy = round(y - mask[13] * (arrowLength + cloudHeight / 2 + offset)) - 2;
                return {
                        x: cx,
                        y: cy,
                        cloudPoints: cloudPoints,
                        shadowPoints: shadowPoints
                    }
            },
            show: function(parameters) {
                parameters = parameters || {};
                var self = this,
                    text = self._formatValue(parameters.value, parameters.context),
                    box,
                    settings;
                self._text.applySettings({
                    text: text,
                    x: 0,
                    y: 0
                });
                box = self._text.getBBox();
                settings = self._getSettings(parameters.x, parameters.y, box.width, box.height, parameters.offset || 0);
                self._shadow.applySettings({points: settings.shadowPoints});
                self._cloud.applySettings({
                    points: settings.cloudPoints,
                    fill: parameters.color
                });
                self._text.applySettings({
                    x: settings.x,
                    y: round(settings.y - box.y - box.height / 2 + 2)
                });
                !self._visible && self._rootElement.applySettings({visibility: 'visible'}) && (self._visible = true);
                return self
            },
            hide: function() {
                var self = this;
                self._visible && self._rootElement.applySettings({visibility: 'hidden'}) && (self._visible = false);
                return self
            },
            enabled: function() {
                return !!this._rootElement
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file tracker.js */
    (function(DX, $, undefined) {
        var setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            Number = window.Number,
            $extend = $.extend,
            $each = $.each,
            abs = Math.abs;
        function handleMouseOver(event) {
            var tracker = event.data.tracker;
            if (tracker._context !== null)
                tracker._processLeave();
            tracker._context = event.data;
            tracker._processEnter(event)
        }
        function handleMouseOut(event) {
            var tracker = event.data.tracker;
            if (tracker._context !== null) {
                tracker._processLeave();
                tracker._context = null
            }
        }
        function handleMouseMove(event) {
            event.data.tracker._processMove(event)
        }
        var HOVER_DELAY = 200;
        var HOVER_SENSITIVITY = 3;
        var mouseOverOutEvents = {
                mouseover: handleMouseOver,
                mouseout: handleMouseOut
            };
        var mouseMoveEvents = {mousemove: handleMouseMove};
        DX.viz.gauges.__internals.Tracker = DX.Class.inherit({
            setup: function(gauge) {
                var self = this;
                DX.utils.debug.assertParam(gauge, '"gauge" parameter');
                self._gauge = gauge;
                self._listeners = [];
                self._context = null;
                self._options = {};
                self._waitHoverCallback = function() {
                    self._context.element.off(mouseMoveEvents);
                    self._context.hover = true;
                    self._processHoverOn()
                };
                return self
            },
            init: function(options) {
                $extend(true, this._options, options);
                return this
            },
            activate: function() {
                var self = this;
                self._detachListeners();
                if (self._gauge._tooltip.enabled())
                    self._attachListeners();
                self._gauge._trackerGroup.toForeground();
                self._tooltipDelay = self._options.tooltipDelay >= 0 ? Number(self._options.tooltipDelay) : 0;
                return self
            },
            _attachListeners: function() {
                var self = this;
                $each(self._gauge._getTrackedElements(), function(_, item) {
                    var element;
                    if (item.target.getTrackingElement) {
                        element = item.target.getTrackingElement();
                        if (element) {
                            self._listeners.push(element);
                            element.on(mouseOverOutEvents, {
                                tracker: self,
                                element: element,
                                target: item.target,
                                info: item.info
                            })
                        }
                    }
                })
            },
            _detachListeners: function() {
                var self = this;
                $each(self._listeners, function(_, item) {
                    item.off()
                });
                self._listeners.length = 0
            },
            _processEnter: function(event) {
                var self = this,
                    context = self._context;
                context.x = event.pageX;
                context.y = event.pageY;
                context.element.on(mouseMoveEvents, context);
                context.hoverTimeout = setTimeout(self._waitHoverCallback, HOVER_DELAY)
            },
            _processLeave: function() {
                var self = this;
                self._context.element.off(mouseMoveEvents);
                clearTimeout(self._context.hoverTimeout);
                self._context.hover && self._processHoverOff();
                delete self._context.hover
            },
            _processMove: function(event) {
                var self = this,
                    context = self._context;
                if (abs(event.pageX - context.x) > HOVER_SENSITIVITY || abs(event.pageY - context.y) > HOVER_SENSITIVITY) {
                    context.x = event.pageX;
                    context.y = event.pageY;
                    clearTimeout(context.hoverTimeout);
                    context.hoverTimeout = setTimeout(self._waitHoverCallback, HOVER_DELAY)
                }
            },
            _processHoverOn: function() {
                this._gauge._tooltip.show($extend(true, this._context.target.getTooltipParameters(), {context: this._context.info}));
                this._debug_hoverOn && this._debug_hoverOn(this._context)
            },
            _processHoverOff: function() {
                this._gauge._tooltip.hide();
                this._debug_hoverOff && this._debug_hoverOff(this._context)
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.rangeSelector = {utils: {}}
    })(DevExpress);
    /*! Module viz, file baseVisualElement.js */
    (function(DX) {
        DevExpress.viz.rangeSelector.BaseVisualElement = DX.Class.inherit({
            ctor: function(renderer) {
                this._renderer = renderer;
                this._isDrawn = false
            },
            applyOptions: function(options) {
                this._options = options || {};
                this._applyOptions(this._options)
            },
            _applyOptions: function(options){},
            redraw: function(group) {
                var self = this;
                if (!self._isDrawn) {
                    self._isDrawn = !(self._draw(group || self._group) === false);
                    if (group)
                        self._group = group
                }
                else
                    self._update(group || self._group)
            },
            isDrawn: function() {
                return !!this._isDrawn
            },
            isInitialized: function() {
                return !!this._options
            },
            _draw: function(group){},
            _update: function(group) {
                group.clear();
                this._draw(group)
            }
        })
    })(DevExpress);
    /*! Module viz, file rangeSelector.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            core = DX.viz.core,
            utils = DX.utils,
            dataUtils = DX.data.utils,
            rangeSelectorUtils = rangeSelector.utils,
            ParseUtils = DX.viz.core.ParseUtils,
            formatHelper = DX.formatHelper;
        var REDRAW_DELAY = 100;
        rangeSelector.consts = {
            fontHeightRatio: 0.55,
            emptySliderMarkerText: '. . .'
        };
        rangeSelector.formatValue = function(value, formatOptions) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, formatOptions.format, formatOptions.precision)
                };
            return String(formatOptions.customizeText ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText)
        };
        rangeSelector.RangeSelector = DX.ui.Component.inherit(function() {
            var SCALE_TEXT_SPACING = 5;
            var defaultRangeSelectorOptions = {
                    size: undefined,
                    margin: {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    },
                    scale: {
                        showCustomBoundaryTicks: true,
                        showMinorTicks: true,
                        startValue: undefined,
                        endValue: undefined,
                        minorTickCount: undefined,
                        minorTickInterval: undefined,
                        majorTickInterval: undefined,
                        useTicksAutoArrangement: true,
                        setTicksAtUnitBeginning: true,
                        minRange: undefined,
                        maxRange: undefined,
                        placeholderHeight: undefined,
                        valueType: undefined,
                        label: {
                            visible: true,
                            format: undefined,
                            precision: undefined,
                            customizeText: undefined
                        },
                        marker: {
                            visible: true,
                            label: {
                                format: undefined,
                                precision: undefined,
                                customizeText: undefined
                            }
                        }
                    },
                    selectedRange: undefined,
                    sliderMarker: {
                        visible: true,
                        format: undefined,
                        precision: undefined,
                        customizeText: undefined,
                        placeholderSize: undefined
                    },
                    behavior: {
                        snapToTicks: true,
                        animationEnabled: true,
                        moveSelectedRangeByClick: true,
                        manualRangeSelectionEnabled: true,
                        allowSlidersSwap: true,
                        callSelectedRangeChanged: "onMovingComplete"
                    },
                    background: {
                        color: "#C0BAE1",
                        visible: true,
                        image: {
                            url: undefined,
                            location: 'full'
                        }
                    },
                    chart: {
                        commonSeriesSettings: {
                            type: 'area',
                            label: {visible: false},
                            hoverMode: 'none'
                        },
                        equalBarWidth: true,
                        topIndent: 0.1,
                        bottomIndent: 0,
                        valueAxis: {
                            min: undefined,
                            max: undefined,
                            inverted: false
                        },
                        series: undefined
                    },
                    dataSource: undefined,
                    dataSourceField: 'arg',
                    redrawOnResize: true,
                    theme: undefined,
                    selectedRangeChanged: null,
                    incidentOccured: $.noop
                };
            var calculateMarkerSize = function(renderer, value, sliderMarkerOptions) {
                    var formattedText = value === undefined ? rangeSelector.consts.emptySliderMarkerText : rangeSelector.formatValue(value, sliderMarkerOptions),
                        textBBox = rangeSelectorUtils.getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
                    return {
                            width: Math.ceil(textBBox.width) + 2 * sliderMarkerOptions.padding,
                            height: Math.ceil(textBBox.height * rangeSelector.consts.fontHeightRatio) + 2 * sliderMarkerOptions.padding + sliderMarkerOptions.pointerSize
                        }
                };
            var calculateScaleLabelHalfWidth = function(renderer, value, scaleOptions) {
                    var formattedText = rangeSelector.formatValue(value, scaleOptions.label),
                        textBBox = rangeSelectorUtils.getTextBBox(renderer, formattedText, scaleOptions.label.font);
                    return Math.ceil(textBBox.width / 2)
                };
            var calculateRangeContainerCanvas = function(size, margin, sliderMarkerSpacing) {
                    var canvas = {
                            left: margin.left + sliderMarkerSpacing.left,
                            top: margin.top + sliderMarkerSpacing.top,
                            width: size.width - margin.left - margin.right - sliderMarkerSpacing.left - sliderMarkerSpacing.right,
                            height: size.height - margin.top - margin.bottom - sliderMarkerSpacing.top - sliderMarkerSpacing.bottom
                        };
                    if (canvas.width <= 0)
                        canvas.width = 1;
                    return canvas
                };
            var parseSliderMarkersPlaceholderSize = function(placeholderSize) {
                    var placeholderWidthLeft,
                        placeholderWidthRight,
                        placeholderHeight;
                    if (utils.isNumber(placeholderSize))
                        placeholderWidthLeft = placeholderWidthRight = placeholderHeight = placeholderSize;
                    else if (placeholderSize) {
                        if (utils.isNumber(placeholderSize.height))
                            placeholderHeight = placeholderSize.height;
                        if (utils.isNumber(placeholderSize.width))
                            placeholderWidthLeft = placeholderWidthRight = placeholderSize.width;
                        else if (placeholderSize.width) {
                            if (utils.isNumber(placeholderSize.width.left))
                                placeholderWidthLeft = placeholderSize.width.left;
                            if (utils.isNumber(placeholderSize.width.right))
                                placeholderWidthRight = placeholderSize.width.right
                        }
                    }
                    return {
                            widthLeft: placeholderWidthLeft,
                            widthRight: placeholderWidthRight,
                            height: placeholderHeight
                        }
                };
            var calculateSliderMarkersSpacing = function(renderer, size, scale, sliderMarkerOptions) {
                    var leftMarkerSize,
                        leftScaleLabelWidth,
                        rightScaleLabelWidth,
                        rightMarkerSize,
                        canvas,
                        placeholderWidthLeft = 0,
                        placeholderWidthRight = 0,
                        placeholderHeight = 0,
                        parsedPlaceholderSize;
                    parsedPlaceholderSize = parseSliderMarkersPlaceholderSize(sliderMarkerOptions.placeholderSize);
                    placeholderWidthLeft = parsedPlaceholderSize.widthLeft || 0;
                    placeholderWidthRight = parsedPlaceholderSize.widthRight || 0;
                    placeholderHeight = parsedPlaceholderSize.height || 0;
                    if (sliderMarkerOptions.visible) {
                        leftMarkerSize = calculateMarkerSize(renderer, scale.startValue, sliderMarkerOptions);
                        if (!placeholderWidthLeft)
                            placeholderWidthLeft = leftMarkerSize.width;
                        rightMarkerSize = calculateMarkerSize(renderer, scale.endValue, sliderMarkerOptions);
                        if (!placeholderWidthRight)
                            placeholderWidthRight = rightMarkerSize.width;
                        if (!placeholderHeight)
                            placeholderHeight = Math.max(leftMarkerSize.height, rightMarkerSize.height)
                    }
                    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.startValue, scale);
                    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.endValue, scale);
                    placeholderWidthLeft = Math.max(placeholderWidthLeft, leftScaleLabelWidth);
                    placeholderWidthRight = Math.max(placeholderWidthRight, rightScaleLabelWidth);
                    return {
                            left: placeholderWidthLeft,
                            right: placeholderWidthRight,
                            top: placeholderHeight,
                            bottom: 0
                        }
                };
            var clearContainer = function(container) {
                    if (container)
                        container.empty()
                };
            var getContainer = function(self) {
                    return self._element()
                };
            var createRangeContainer = function(rangeContainerOptions) {
                    return rangeSelector.rangeSelectorFactory.createRangeContainer(rangeContainerOptions)
                };
            var createTranslator = function(range, canvas) {
                    return rangeSelector.rangeSelectorFactory.createTranslator(range, canvas)
                };
            var createTranslatorCanvas = function(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight) {
                    return {
                            left: rangeContainerCanvas.left,
                            top: rangeContainerCanvas.top,
                            right: sizeOptions.width - rangeContainerCanvas.width - rangeContainerCanvas.left,
                            bottom: sizeOptions.height - rangeContainerCanvas.height - rangeContainerCanvas.top + scaleLabelsAreaHeight,
                            width: sizeOptions.width,
                            height: sizeOptions.height
                        }
                };
            var createRenderer = function(self) {
                    var renderer = self.option('renderer');
                    if (renderer)
                        return renderer;
                    renderer = rangeSelector.rangeSelectorFactory.createRenderer();
                    return renderer
                };
            var createThemeManager = function(theme) {
                    return rangeSelector.rangeSelectorFactory.createThemeManager(theme)
                };
            var calculateValueType = function(firstValue, secondValue) {
                    var types = [$.type(firstValue), $.type(secondValue)];
                    $.inArray();
                    return $.inArray('date', types) != -1 ? 'datetime' : $.inArray('number', types) != -1 ? 'numeric' : ''
                };
            var createSeriesDataSource = function(self) {
                    var seriesDataSource,
                        dataSource = self._dataSource && self._dataSource.items(),
                        scaleOptions = self.option('scale'),
                        valueType = scaleOptions.valueType;
                    if (!valueType)
                        valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
                    if (dataSource || self.option('chart').series)
                        seriesDataSource = new rangeSelector.SeriesDataSource({
                            renderer: self.renderer,
                            dataSource: dataSource,
                            valueType: (valueType || '').toLowerCase(),
                            chart: self.option('chart'),
                            dataSourceField: self.option('dataSourceField'),
                            backgroundColor: self._userBackgroundColor,
                            incidentOccured: self.option('incidentOccured')
                        });
                    return seriesDataSource
                };
            var calculateTranslatorRange = function(self, seriesDataSource, scaleOptions) {
                    var translatorRange,
                        minValue,
                        maxValue,
                        inverted = false;
                    if (utils.isDefined(scaleOptions.startValue) && utils.isDefined(scaleOptions.endValue)) {
                        inverted = scaleOptions.inverted = scaleOptions.startValue > scaleOptions.endValue;
                        minValue = inverted ? scaleOptions.endValue : scaleOptions.startValue;
                        maxValue = inverted ? scaleOptions.startValue : scaleOptions.endValue
                    }
                    else if (utils.isDefined(scaleOptions.startValue) || utils.isDefined(scaleOptions.endValue)) {
                        minValue = scaleOptions.startValue;
                        maxValue = scaleOptions.endValue
                    }
                    translatorRange = seriesDataSource ? seriesDataSource.getBoundRange() : new DX.viz.charts.Range;
                    if (minValue !== maxValue) {
                        translatorRange.invertX = inverted;
                        translatorRange.getBoundRange({
                            minX: minValue,
                            maxX: maxValue,
                            minVisibleX: minValue,
                            maxVisibleX: maxValue
                        })
                    }
                    if (!translatorRange.isDefinedX())
                        translatorRange.setStubDataX(scaleOptions.valueType);
                    return translatorRange
                };
            var calculateScaleAreaHeight = function(renderer, scaleOptions, visibleMarkers) {
                    var textBBox,
                        visibleLabels = scaleOptions.label.visible;
                    if (scaleOptions.placeholderHeight)
                        return scaleOptions.placeholderHeight;
                    else {
                        textBBox = rangeSelectorUtils.getTextBBox(renderer, '0', scaleOptions.label.font);
                        return (visibleLabels ? scaleOptions.label.topIndent + textBBox.height : 0) + (visibleMarkers ? scaleOptions.marker.topIndent + scaleOptions.marker.separatorHeight : 0)
                    }
                };
            var getTicksInfo = function(self, scaleOptions, translator, screenDelta) {
                    var isEmpty = scaleOptions.isEmpty,
                        tickProvider = rangeSelector.rangeSelectorFactory.getTickProvider(),
                        minorTicksOptions,
                        majorTicksOptions,
                        startValue,
                        endValue,
                        businessRange = translator.getBusinessRange();
                    minorTicksOptions = {
                        tickInterval: isEmpty ? 0 : self.option('scale').minorTickInterval,
                        showCustomBoundaryTicks: scaleOptions.showCustomBoundaryTicks,
                        minorTickCount: scaleOptions.minorTickCount
                    };
                    majorTicksOptions = {
                        textOptions: {
                            align: 'center',
                            font: scaleOptions.label.font
                        },
                        renderer: self.renderer,
                        getText: function(value) {
                            return rangeSelector.formatValue(value, scaleOptions.label)
                        },
                        translator: translator,
                        isStartTickGenerated: !utils.isDefined(self.option('scale').majorTickInterval),
                        tickInterval: scaleOptions.majorTickInterval,
                        textSpacing: SCALE_TEXT_SPACING,
                        setTicksAtUnitBeginning: scaleOptions.setTicksAtUnitBeginning,
                        useTicksAutoArrangement: scaleOptions.useTicksAutoArrangement,
                        hideLabels: isEmpty
                    };
                    startValue = isEmpty ? businessRange.minX : scaleOptions.startValue;
                    endValue = isEmpty ? businessRange.maxX : scaleOptions.endValue;
                    return tickProvider.getFullTicks(startValue, endValue, screenDelta, majorTicksOptions, minorTicksOptions)
                };
            var updateTickIntervals = function(scaleOptions, screenDelta, incidentOccured) {
                    var tickProvider = rangeSelector.rangeSelectorFactory.getTickProvider(),
                        tickIntervals = tickProvider.getTickIntervals(scaleOptions.startValue, scaleOptions.endValue, screenDelta, {
                            tickInterval: scaleOptions.majorTickInterval,
                            incidentOccured: incidentOccured
                        }, {
                            tickInterval: scaleOptions.minorTickInterval,
                            incidentOccured: incidentOccured
                        });
                    scaleOptions.minorTickInterval = tickIntervals.minorTickInterval;
                    scaleOptions.majorTickInterval = tickIntervals.majorTickInterval
                };
            var updateScaleOptions = function(self, seriesDataSource, translatorRange, screenDelta, scaleOptions) {
                    var minVisibleX = utils.isDefined(translatorRange.minVisibleX) ? translatorRange.minVisibleX : translatorRange.minX,
                        maxVisibleX = utils.isDefined(translatorRange.maxVisibleX) ? translatorRange.maxVisibleX : translatorRange.maxX;
                    if (seriesDataSource && !seriesDataSource.isEmpty()) {
                        scaleOptions.startValue = scaleOptions.inverted ? maxVisibleX : minVisibleX;
                        scaleOptions.endValue = scaleOptions.inverted ? minVisibleX : maxVisibleX
                    }
                    scaleOptions.isEmpty = !utils.isDefined(scaleOptions.startValue) || !utils.isDefined(scaleOptions.endValue) || scaleOptions.startValue === scaleOptions.endValue || scaleOptions.valueType === 'string';
                    if (scaleOptions.isEmpty)
                        scaleOptions.startValue = scaleOptions.endValue = undefined;
                    else {
                        updateTickIntervals(scaleOptions, screenDelta, self.option('incidentOccured'));
                        if (scaleOptions.valueType === 'datetime' && !utils.isDefined(scaleOptions.label.format))
                            if (!scaleOptions.marker.visible)
                                scaleOptions.label.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.majorTickInterval);
                            else
                                scaleOptions.label.format = utils.getDateUnitInterval(scaleOptions.majorTickInterval)
                    }
                };
            var prepareSliderMarkersOptions = function(self, scaleOptions, screenDelta) {
                    var sliderMarkerOptions = $.extend(true, {}, self.option('sliderMarker')),
                        businessInterval;
                    if (!sliderMarkerOptions.format) {
                        if (!self.option('behavior').snapToTicks && utils.isNumber(scaleOptions.startValue)) {
                            businessInterval = Math.abs(scaleOptions.endValue - scaleOptions.startValue);
                            sliderMarkerOptions.format = 'fixedPoint';
                            sliderMarkerOptions.precision = utils.getSignificantDigitPosition(businessInterval / screenDelta)
                        }
                        if (scaleOptions.valueType === 'datetime')
                            if (!scaleOptions.marker.visible)
                                sliderMarkerOptions.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval);
                            else
                                sliderMarkerOptions.format = utils.getDateUnitInterval(utils.isDefined(scaleOptions.minorTickInterval) && scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval)
                    }
                    return sliderMarkerOptions
                };
            var showScaleMarkers = function(scaleOptions) {
                    return scaleOptions.valueType == 'datetime' && scaleOptions.marker.visible
                };
            var updateTranslatorRangeInterval = function(translatorRange, scaleOptions) {
                    var intervalX = scaleOptions.minorTickInterval || scaleOptions.majorTickInterval;
                    translatorRange = translatorRange.getBoundRange({intervalX: intervalX})
                };
            var prepareScaleOptions = function(self, seriesDataSource) {
                    var scaleOptions = $.extend(true, {}, self.option('scale')),
                        incidentOccured = self.option('incidentOccured'),
                        parsedValue = 0,
                        parseUtils = new ParseUtils({incidentOccured: incidentOccured}),
                        valueType = parseUtils.correctValueType((scaleOptions.valueType || '').toLowerCase());
                    if (seriesDataSource)
                        valueType = seriesDataSource.getCalculatedValueType() || valueType;
                    if (!valueType)
                        valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue) || 'numeric';
                    scaleOptions.valueType = valueType;
                    if (scaleOptions.valueType === 'string') {
                        incidentOccured('The type of the argument values specified in the data source is unsupported.');
                        return scaleOptions
                    }
                    var parser = parseUtils.getParser(valueType, 'scale');
                    if (utils.isDefined(scaleOptions.startValue)) {
                        parsedValue = parser(scaleOptions.startValue);
                        if (utils.isDefined(parsedValue))
                            scaleOptions.startValue = parsedValue;
                        else {
                            scaleOptions.startValue = undefined;
                            incidentOccured.call(null, "Cannot parse the value specified as the startValue property of the scale configuration object.")
                        }
                    }
                    if (utils.isDefined(scaleOptions.endValue)) {
                        parsedValue = parser(scaleOptions.endValue);
                        if (utils.isDefined(parsedValue))
                            scaleOptions.endValue = parsedValue;
                        else {
                            scaleOptions.endValue = undefined;
                            incidentOccured.call(null, "Cannot parse the value specified as the endValue property of the scale configuration object.")
                        }
                    }
                    scaleOptions.parser = parser;
                    return scaleOptions
                };
            var correctSizeOptions = function(self, sizeOptions, scaleOptions) {
                    var size = self.option('size') || {};
                    if (!sizeOptions.height && size.height !== 0)
                        if (scaleOptions.valueType === 'datetime' && scaleOptions.marker.visible !== false)
                            sizeOptions.height = 160;
                        else
                            sizeOptions.height = 120;
                    if (!sizeOptions.width && size.width !== 0)
                        sizeOptions.width = 400
                };
            var applyOptions = function(self) {
                    var rangeContainerCanvas,
                        seriesDataSource,
                        translatorRange,
                        scaleLabelsAreaHeight,
                        sizeOptions,
                        sliderMarkerSpacing,
                        sliderMarkerOptions,
                        selectedRange,
                        $container = self.container,
                        isEmpty;
                    self._isUpdating = true;
                    sizeOptions = calculateSize(self);
                    self._actualSize = sizeOptions;
                    seriesDataSource = createSeriesDataSource(self);
                    self._scaleOptions = prepareScaleOptions(self, seriesDataSource);
                    correctSizeOptions(self, sizeOptions, self._scaleOptions);
                    if (!sizeOptions.width || !sizeOptions.height || !$container.is(':visible')) {
                        self.stopRedraw = true;
                        self.option('incidentOccured')('RangeSelector can not be drawn as container is not visible');
                        return
                    }
                    else
                        self.stopRedraw = false;
                    updateRendererSize(self, sizeOptions);
                    translatorRange = calculateTranslatorRange(self, seriesDataSource, self._scaleOptions);
                    updateScaleOptions(self, seriesDataSource, translatorRange, sizeOptions.width, self._scaleOptions);
                    updateTranslatorRangeInterval(translatorRange, self._scaleOptions);
                    sliderMarkerOptions = prepareSliderMarkersOptions(self, self._scaleOptions, sizeOptions.width);
                    selectedRange = initSelection(self, self._scaleOptions);
                    sliderMarkerSpacing = calculateSliderMarkersSpacing(self.renderer, sizeOptions, self._scaleOptions, sliderMarkerOptions);
                    rangeContainerCanvas = calculateRangeContainerCanvas(sizeOptions, self.option('margin'), sliderMarkerSpacing);
                    scaleLabelsAreaHeight = calculateScaleAreaHeight(self.renderer, self._scaleOptions, showScaleMarkers(self._scaleOptions));
                    self.translator = createTranslator(translatorRange, createTranslatorCanvas(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight));
                    self._scaleOptions.ticksInfo = getTicksInfo(self, self._scaleOptions, self.translator, rangeContainerCanvas.width);
                    self._testTicksInfo = self._scaleOptions.ticksInfo;
                    self._selectedRange = selectedRange;
                    if (seriesDataSource)
                        seriesDataSource.adjustSeriesDimensions(self.translator);
                    self.rangeContainer.applyOptions({
                        canvas: rangeContainerCanvas,
                        scaleLabelsAreaHeight: scaleLabelsAreaHeight,
                        sliderMarkerSpacing: sliderMarkerSpacing,
                        translator: self.translator,
                        selectedRange: selectedRange,
                        scale: self._scaleOptions,
                        behavior: self.option('behavior'),
                        background: self.option('background'),
                        chart: self.option('chart'),
                        seriesDataSource: seriesDataSource,
                        sliderMarker: sliderMarkerOptions,
                        sliderHandles: self.option('sliderHandles'),
                        shutter: self.option('shutter'),
                        selectedRangeChanged: createSelectedRangeChangedFunction(self),
                        setSelectedRange: function(selectedRange) {
                            self.setSelectedRange(selectedRange)
                        }
                    });
                    self._isUpdating = false
                };
            var createSelectedRangeChangedFunction = function(self) {
                    return function(selectedRange, blockSelectedRangeChanged) {
                            var selectedRangeChanged = self.option('selectedRangeChanged');
                            self.option('selectedRange', selectedRange);
                            if (selectedRangeChanged && !blockSelectedRangeChanged)
                                selectedRangeChanged(selectedRange)
                        }
                };
            var calculateSize = function(self) {
                    var $container = self.container,
                        size = self.option('size') || {},
                        result = {
                            width: size.width,
                            height: size.height
                        };
                    if ($container) {
                        if (!result.width)
                            result.width = $container.width();
                        if (!result.height)
                            result.height = $container.height()
                    }
                    return result
                };
            var updateRendererSize = function(self, size) {
                    var renderer = self.renderer;
                    if (renderer.isInitialized())
                        renderer.getRoot().applySettings({
                            width: size.width,
                            height: size.height
                        });
                    else {
                        renderer.recreateCanvas(size.width, size.height);
                        renderer.draw(self.container[0])
                    }
                };
            var prepareChartThemeOptions = function(self, options) {
                    var chartTheme;
                    if (!self.option('chart').theme && options && options.theme) {
                        chartTheme = options.theme;
                        if (chartTheme) {
                            if (typeof chartTheme === 'object') {
                                chartTheme = chartTheme.chart || {};
                                chartTheme.name = options.theme.name
                            }
                            self.option('chart').theme = chartTheme
                        }
                    }
                };
            var initSelection = function(self, scaleOptions) {
                    var selectedRangeOptions = self.option('selectedRange'),
                        parser = scaleOptions.parser || function() {
                            return null
                        },
                        parseValue = function(value, entity) {
                            var parsedValue,
                                result = scaleOptions[entity];
                            if (utils.isDefined(value))
                                parsedValue = parser(value);
                            if (!utils.isDefined(parsedValue))
                                self.option('incidentOccured').call(null, "Cannot parse the value specified as the " + entity + " property of the selectedRange configuration object.");
                            else
                                result = parsedValue;
                            return result
                        };
                    if (!selectedRangeOptions)
                        return {
                                startValue: scaleOptions.startValue,
                                endValue: scaleOptions.endValue
                            };
                    else
                        return {
                                startValue: parseValue(selectedRangeOptions.startValue, 'startValue'),
                                endValue: parseValue(selectedRangeOptions.endValue, 'endValue')
                            }
                };
            var _isSizeChanged = function(self) {
                    var actualSize = self._actualSize,
                        newSize = calculateSize(self);
                    return actualSize && (actualSize.width !== newSize.width || actualSize.height !== newSize.height)
                };
            var _resizeHandler = function(self) {
                    return DX.utils.createResizeHandler(function() {
                            if (_isSizeChanged(self))
                                self._render(true)
                        })
                };
            return {
                    isSizeChanged: function() {
                        return _isSizeChanged(this)
                    },
                    _defaultOptions: function() {
                        return defaultRangeSelectorOptions
                    },
                    _dataSourceOptions: function() {
                        return {
                                paginate: false,
                                _preferSync: true
                            }
                    },
                    _init: function() {
                        var self = this;
                        self.container = getContainer(self);
                        clearContainer(self.container);
                        self.renderer = createRenderer(self);
                        self.rangeContainer = createRangeContainer(self.renderer);
                        if (self.option('redrawOnResize') === true)
                            utils.windowResizeCallbacks.add(_resizeHandler(self));
                        if (!$.isFunction(self.option('incidentOccured'))) {
                            utils.debug.assert(false, 'Function should be passed as "info" callback');
                            self.option('incidentOccured', $.noop)
                        }
                        if (self.option('incidentOccured') === $.noop)
                            self.option('incidentOccured', utils.logger.warn);
                        self._reinitDataSource()
                    },
                    _reinitDataSource: function() {
                        this._initDataSource();
                        this._loadDataSource()
                    },
                    _initOptions: function(options) {
                        var self = this,
                            themeManager;
                        this._optionsInitializing = true;
                        options = options || {};
                        self._userOptions = $.extend(true, {}, options);
                        themeManager = createThemeManager(options.theme);
                        themeManager.setBackgroundColor(options.containerBackgroundColor);
                        self.option(themeManager.applyRangeSelectorTheme(options));
                        prepareChartThemeOptions(self, options);
                        if (options.background)
                            self._userBackgroundColor = options.background.color
                    },
                    _render: function(isResizing) {
                        this._optionsInitializing = false;
                        var self = this,
                            currentAnimationEnabled,
                            behaviorOptions;
                        applyOptions(self);
                        if (!self.stopRedraw)
                            if (isResizing) {
                                behaviorOptions = self.option('behavior');
                                currentAnimationEnabled = behaviorOptions.animationEnabled;
                                behaviorOptions.animationEnabled = false;
                                self.rangeContainer.redraw();
                                behaviorOptions.animationEnabled = currentAnimationEnabled
                            }
                            else
                                self.rangeContainer.redraw()
                    },
                    _optionChanged: function(name, value, prevValue) {
                        var self = this;
                        if (!this._optionsInitializing)
                            dataUtils.compileSetter(name)(self._userOptions, value, {
                                functionsAsIs: true,
                                merge: true
                            });
                        if (name === "dataSource") {
                            self._reinitDataSource();
                            self._invalidate()
                        }
                        else if (name === "selectedRange")
                            self.setSelectedRange(self.option('selectedRange'));
                        else if (name === "selectedRangeChanged")
                            self.rangeContainer.slidersContainer.selectedRangeChanged = createSelectedRangeChangedFunction(self);
                        else if (name === 'containerBackgroundColor' || name === 'theme') {
                            this._initOptions(self._userOptions);
                            self._invalidate()
                        }
                        else
                            self._invalidate()
                    },
                    _handleDataSourceChanged: function() {
                        var self = this;
                        if (self.renderer.isInitialized())
                            self._render()
                    },
                    getSelectedRange: function() {
                        var self = this;
                        var selectedRange = self.rangeContainer.slidersContainer.getSelectedRange();
                        return {
                                startValue: selectedRange.startValue,
                                endValue: selectedRange.endValue
                            }
                    },
                    setSelectedRange: function(selectedRange) {
                        var self = this;
                        if (self._isUpdating || !selectedRange)
                            return;
                        var oldSelectedRange = self.rangeContainer.slidersContainer.getSelectedRange();
                        if (oldSelectedRange && oldSelectedRange.startValue === selectedRange.startValue && oldSelectedRange.endValue === selectedRange.endValue)
                            return;
                        self.rangeContainer.slidersContainer.setSelectedRange(selectedRange)
                    },
                    resetSelectedRange: function(blockSelectedRangeChanged) {
                        var self = this;
                        self.setSelectedRange({
                            startValue: self._scaleOptions.startValue,
                            endValue: self._scaleOptions.endValue,
                            blockSelectedRangeChanged: blockSelectedRangeChanged
                        })
                    }
                }
        }()).include(DX.ui.DataHelperMixin)
    })(jQuery, DevExpress);
    /*! Module viz, file rangeContainer.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector;
        rangeSelector.RangeContainer = rangeSelector.BaseVisualElement.inherit(function() {
            var ctor = function(renderer) {
                    this.callBase(renderer);
                    this.slidersContainer = createSlidersContainer(renderer);
                    this.rangeView = createRangeView(renderer);
                    this.scale = createScale(renderer)
                };
            var _applyOptions = function(options) {
                    var self = this,
                        isEmpty = options.scale.isEmpty,
                        viewCanvas = {
                            left: options.canvas.left,
                            top: options.canvas.top,
                            width: options.canvas.width,
                            height: options.canvas.height >= options.scaleLabelsAreaHeight ? options.canvas.height - options.scaleLabelsAreaHeight : 0
                        };
                    self._viewCanvas = viewCanvas;
                    self.slidersContainer.applyOptions({
                        canvas: viewCanvas,
                        translator: options.translator,
                        scale: options.scale,
                        selectedRange: options.selectedRange,
                        sliderMarker: options.sliderMarker,
                        sliderHandles: options.sliderHandles,
                        shutter: options.shutter,
                        behavior: options.behavior,
                        selectedRangeChanged: options.selectedRangeChanged,
                        isEmpty: isEmpty
                    });
                    self.rangeView.applyOptions({
                        canvas: viewCanvas,
                        translator: options.translator,
                        background: options.background,
                        chart: options.chart,
                        seriesDataSource: options.seriesDataSource,
                        behavior: options.behavior,
                        isEmpty: isEmpty
                    });
                    self.scale.applyOptions({
                        canvas: options.canvas,
                        translator: options.translator,
                        scale: options.scale,
                        hideLabels: isEmpty,
                        scaleLabelsAreaHeight: options.scaleLabelsAreaHeight,
                        setSelectedRange: options.setSelectedRange
                    })
                };
            var createSlidersContainer = function(options) {
                    return rangeSelector.rangeSelectorFactory.createSlidersContainer(options)
                };
            var createScale = function(options) {
                    return rangeSelector.rangeSelectorFactory.createScale(options)
                };
            var createRangeView = function(options) {
                    return rangeSelector.rangeSelectorFactory.createRangeView(options)
                };
            var _createClipRectCanvas = function(canvas, sliderMarkerSpacing) {
                    return {
                            left: canvas.left - sliderMarkerSpacing.left,
                            top: canvas.top - sliderMarkerSpacing.top,
                            width: canvas.width + sliderMarkerSpacing.right + sliderMarkerSpacing.left,
                            height: canvas.height + sliderMarkerSpacing.bottom + sliderMarkerSpacing.top
                        }
                };
            var _draw = function() {
                    var self = this,
                        containerGroup,
                        rangeViewGroup,
                        slidersContainerGroup,
                        scaleGroup,
                        trackersGroup,
                        size = self._options.size,
                        clipRectCanvas = _createClipRectCanvas(self._options.canvas, self._options.sliderMarkerSpacing),
                        viewCanvas = self._viewCanvas;
                    self._clipRect = self._renderer.createClipRect(clipRectCanvas.left, clipRectCanvas.top, clipRectCanvas.width, clipRectCanvas.height).append();
                    containerGroup = self._renderer.createGroup({
                        'class': 'rangeContainer',
                        clipId: self._clipRect.id
                    }).append();
                    self._viewClipRect = self._renderer.createClipRect(viewCanvas.left, viewCanvas.top, viewCanvas.width, viewCanvas.height).append();
                    rangeViewGroup = self._renderer.createGroup({
                        'class': 'view',
                        clipId: self._viewClipRect.id
                    });
                    rangeViewGroup.append(containerGroup);
                    self.rangeView.redraw(rangeViewGroup);
                    slidersContainerGroup = self._renderer.createGroup({'class': 'slidersContainer'});
                    slidersContainerGroup.append(containerGroup);
                    self.slidersContainer.redraw(slidersContainerGroup);
                    scaleGroup = self._renderer.createGroup({'class': 'scale'});
                    scaleGroup.append(containerGroup);
                    self.scale.redraw(scaleGroup);
                    trackersGroup = self._renderer.createGroup({'class': 'trackers'});
                    trackersGroup.append(containerGroup);
                    self._trackersGroup = trackersGroup;
                    self.slidersContainer.appendTrackers(trackersGroup)
                };
            var _update = function() {
                    var self = this,
                        clipRectCanvas = _createClipRectCanvas(self._options.canvas, self._options.sliderMarkerSpacing),
                        viewCanvas = self._viewCanvas;
                    self._clipRect.updateRectangle({
                        x: clipRectCanvas.left,
                        y: clipRectCanvas.top,
                        width: clipRectCanvas.width,
                        height: clipRectCanvas.height
                    });
                    self._viewClipRect.updateRectangle({
                        x: viewCanvas.left,
                        y: viewCanvas.top,
                        width: viewCanvas.width,
                        height: viewCanvas.height
                    });
                    self.rangeView.redraw();
                    self.slidersContainer.redraw();
                    self.slidersContainer.appendTrackers(self._trackersGroup);
                    self.scale.redraw()
                };
            var prototypeObject = {
                    createSlidersContainer: createSlidersContainer,
                    createScale: createScale,
                    ctor: ctor,
                    _applyOptions: _applyOptions,
                    _draw: _draw,
                    _update: _update
                };
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file scale.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            formatHelper = DX.formatHelper,
            utils = DX.utils;
        var SCALE_TEXT_SPACING = 5;
        rangeSelector.Scale = rangeSelector.BaseVisualElement.inherit({
            _setupDateTickInterval: function(majorTickInterval) {
                this.dateUnitInterval = utils.getDateUnitInterval(majorTickInterval);
                this._prepareTickIntervalObject(majorTickInterval, this.dateUnitInterval)
            },
            _prepareTickIntervalObject: function(tickInterval, dateUnitInterval) {
                if (utils.isObject(tickInterval) && utils.isString(dateUnitInterval))
                    for (var key in tickInterval) {
                        if (key === dateUnitInterval + 's')
                            continue;
                        delete tickInterval[key]
                    }
            },
            _prepareDatesDifferences: function(datesDifferences, tickInterval) {
                var deleteDifferent = tickInterval;
                if (deleteDifferent === 'week')
                    deleteDifferent = 'day';
                if (deleteDifferent === 'quarter')
                    deleteDifferent = 'month';
                if (datesDifferences[deleteDifferent]) {
                    datesDifferences[deleteDifferent] = false;
                    datesDifferences.count--
                }
            },
            _getMarkerDate: function(date, tickInterval) {
                var markerDate = new Date(date.getTime()),
                    month = 0;
                switch (tickInterval) {
                    case'quarter':
                        month = formatHelper.getFirstQuarterMonth(date.getMonth());
                    case'month':
                        markerDate.setMonth(month);
                    case'week':
                    case'day':
                        markerDate.setDate(1);
                    case'hour':
                        markerDate.setHours(0, 0, 0, 0);
                        break;
                    case'millisecond':
                        markerDate.setMilliseconds(0);
                        break;
                    case'second':
                        markerDate.setSeconds(0, 0);
                        break;
                    case'minute':
                        markerDate.setMinutes(0, 0, 0);
                        break
                }
                return markerDate
            },
            _drawDateMarker: function(date, options) {
                var labelPosX,
                    labelPosY,
                    dateFormated,
                    scaleOptions,
                    textElement;
                if (options.x === null)
                    return;
                scaleOptions = this._options.scale;
                this.lineOptions['class'] = 'dx-range-selector-date-marker';
                this._renderer.createLine(options.x, options.y, options.x, options.y + scaleOptions.marker.separatorHeight, this.lineOptions).append(options.group);
                dateFormated = this._getLabel(date, options.label);
                labelPosX = options.x + scaleOptions.tick.width + scaleOptions.marker.textLeftIndent;
                labelPosY = options.y + scaleOptions.marker.textTopIndent + scaleOptions.label.font.size;
                this.textOptions.align = 'left';
                textElement = this._renderer.createText(dateFormated, labelPosX, labelPosY, this.textOptions).append(options.group);
                return labelPosX + textElement.getBBox().width
            },
            _drawDateMarkers: function(dates, group) {
                var dateMarker,
                    i,
                    datesDifferences,
                    markerDate,
                    posX,
                    prevMarkerRightX = -1;
                if (this._options.scale.valueType !== 'datetime' || !this.visibleMarkers)
                    return;
                var markerDatePositions = [];
                if (dates.length > 1) {
                    for (i = 1; i < dates.length; i++) {
                        datesDifferences = utils.getDatesDifferences(dates[i - 1], dates[i]);
                        this._prepareDatesDifferences(datesDifferences, this.dateUnitInterval);
                        if (datesDifferences.count > 0) {
                            markerDate = this._getMarkerDate(dates[i], this.dateUnitInterval);
                            this.markerDates = this.markerDates || [];
                            this.markerDates.push(markerDate);
                            posX = this.translator.translateX(markerDate);
                            if (posX > prevMarkerRightX) {
                                posX !== null && markerDatePositions.push({
                                    date: markerDate,
                                    posX: posX
                                });
                                prevMarkerRightX = this._drawDateMarker(markerDate, {
                                    group: group,
                                    y: this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                                    x: posX,
                                    label: this._getLabelFormatOptions(formatHelper.getDateFormatByDifferences(datesDifferences))
                                })
                            }
                        }
                    }
                    this._initializeMarkersEvents(markerDatePositions, group)
                }
            },
            _getLabelFormatOptions: function(formatString) {
                if (!utils.isDefined(this._options.scale.marker.label.format))
                    return $.extend({}, this._options.scale.marker.label, {format: formatString});
                return this._options.scale.marker.label
            },
            _calculateRangeByMarkerPosition: function(posX, markerDatePositions, scaleOptions) {
                var selectedRange = {},
                    index,
                    position;
                for (index in markerDatePositions) {
                    position = markerDatePositions[index];
                    if (!scaleOptions.inverted) {
                        if (posX >= position.posX)
                            selectedRange.startValue = position.date;
                        else if (!selectedRange.endValue)
                            selectedRange.endValue = position.date
                    }
                    else if (posX < position.posX)
                        selectedRange.endValue = position.date;
                    else if (!selectedRange.startValue)
                        selectedRange.startValue = position.date
                }
                selectedRange.startValue = selectedRange.startValue || scaleOptions.startValue;
                selectedRange.endValue = selectedRange.endValue || scaleOptions.endValue;
                return selectedRange
            },
            _initializeMarkersEvents: function(markerDatePositions, group) {
                var self = this,
                    markersAreaTop = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                    markersTracker,
                    svgOffsetLeft,
                    index,
                    posX,
                    selectedRange;
                if (markerDatePositions.length > 0) {
                    markersTracker = self._renderer.createRect(self._options.canvas.left, markersAreaTop, self._options.canvas.width, self._options.scale.marker.separatorHeight, 0, {
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001
                    });
                    markersTracker.append(group);
                    markersTracker.on(rangeSelector.events.start, function(e) {
                        svgOffsetLeft = rangeSelector.utils.getRootOffsetLeft(self._renderer);
                        posX = rangeSelector.utils.getEventPageX(e) - svgOffsetLeft;
                        selectedRange = self._calculateRangeByMarkerPosition(posX, markerDatePositions, self._options.scale);
                        self._options.setSelectedRange(selectedRange)
                    });
                    self._markersTracker = markersTracker
                }
            },
            _getLabel: function(value, options) {
                var formatObject = {
                        value: value,
                        valueText: formatHelper.format(value, options.format, options.precision)
                    };
                return String(options.customizeText ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText)
            },
            _drawLabel: function(value, group) {
                var textY = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight,
                    textElement = this._renderer.createText(this._getLabel(value, this._options.scale.label), this.translator.translateX(value), textY, this.textOptions);
                textElement.append(group);
                this.textElements = this.textElements || [];
                this.textElements.push(textElement)
            },
            _drawTick: function(value, group) {
                this.lineOptions['class'] = 'dx-range-selector-tick';
                var secondY = this._options.canvas.top + this._options.canvas.height - this.scaleLabelsAreaHeight,
                    posX = this.translator.translateX(value),
                    tickElement = this._renderer.createLine(posX, this._options.canvas.top, posX, secondY, this.lineOptions).append(group);
                this.tickElements = this.tickElements || [];
                this.tickElements.push(tickElement)
            },
            _redraw: function(group, isOptimize) {
                var self = this,
                    scaleOptions = self._options.scale,
                    ticksGroup = self._renderer.createGroup(),
                    labelsGroup = self._renderer.createGroup().append(group),
                    majorTicks = scaleOptions.ticksInfo.majorTicks,
                    minorTicks = scaleOptions.ticksInfo.minorTicks,
                    customBoundaryTicks = scaleOptions.ticksInfo.customBoundaryTicks,
                    hideLabels = self._options.hideLabels || majorTicks.hideLabels || !scaleOptions.label.visible,
                    i;
                for (i = 0; i < majorTicks.length; i++) {
                    if (!hideLabels)
                        self._drawLabel(majorTicks[i], labelsGroup);
                    self._drawTick(majorTicks[i], ticksGroup)
                }
                if (scaleOptions.showMinorTicks)
                    for (i = 0; i < minorTicks.length; i++)
                        self._drawTick(minorTicks[i], ticksGroup);
                for (i = 0; i < customBoundaryTicks.length; i++)
                    self._drawTick(customBoundaryTicks[i], ticksGroup);
                ticksGroup.append(group);
                self._drawDateMarkers(majorTicks, labelsGroup)
            },
            _applyOptions: function(options) {
                var scaleOptions = options.scale,
                    labelsAreaHeight;
                this.textOptions = {
                    align: 'center',
                    'class': 'dx-range-selector-scale',
                    font: scaleOptions.label.font,
                    style: {'-webkit-user-select': 'none'}
                };
                this.lineOptions = {
                    strokeWidth: scaleOptions.tick.width,
                    stroke: scaleOptions.tick.color,
                    strokeOpacity: scaleOptions.tick.opacity
                };
                this._setupDateTickInterval(scaleOptions.ticksInfo.majorTickInterval);
                this.visibleMarkers = scaleOptions.marker.visible === undefined ? true : scaleOptions.marker.visible;
                labelsAreaHeight = scaleOptions.label.visible ? scaleOptions.label.topIndent + scaleOptions.label.font.size : 0;
                this.scaleLabelsAreaHeight = options.scaleLabelsAreaHeight;
                this.markersAreaHeight = this.scaleLabelsAreaHeight - labelsAreaHeight;
                this.translator = options.translator
            },
            _draw: function(group) {
                this._redraw(group, false)
            },
            _update: function(group) {
                var callBase = this.callBase;
                if (this._markersTracker)
                    this._markersTracker.off(rangeSelector.events.start, '**');
                this.callBase = callBase;
                this.callBase(group)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file rangeFactory.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            renderers = DX.viz.renderers;
        rangeSelector.rangeSelectorFactory = function() {
            return {
                    createRenderer: function(options) {
                        return new renderers.Renderer(options)
                    },
                    createTranslator: function(range, canvas) {
                        return new DX.viz.core.LinearTranslator(range, canvas)
                    },
                    getTickProvider: function() {
                        return DX.viz.core.tickProvider
                    },
                    createRangeContainer: function(rangeContainerOptions) {
                        return new rangeSelector.RangeContainer(rangeContainerOptions)
                    },
                    createSlidersContainer: function(options) {
                        return new rangeSelector.SlidersContainer(options)
                    },
                    createScale: function(options) {
                        return new rangeSelector.Scale(options)
                    },
                    createSliderMarker: function(options) {
                        return new rangeSelector.SliderMarker(options)
                    },
                    createRangeView: function(options) {
                        return new rangeSelector.RangeView(options)
                    },
                    createThemeManager: function(options) {
                        return new rangeSelector.ThemeManager(options)
                    },
                    createSlider: function(renderer, sliderIndex) {
                        return new rangeSelector.Slider(renderer, sliderIndex)
                    },
                    createSlidersEventsManager: function(renderer, slidersController, processSelectionChanged) {
                        return new rangeSelector.SlidersEventsManager(renderer, slidersController, processSelectionChanged)
                    },
                    createSlidersController: function(sliders) {
                        return new rangeSelector.SlidersController(sliders)
                    }
                }
        }()
    })(jQuery, DevExpress);
    /*! Module viz, file slidersContainer.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils;
        var msPointerEnabled = window.navigator.msPointerEnabled;
        var isNumber = DX.utils.isNumber;
        var isDate = DX.utils.isDate;
        var START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1;
        rangeSelector.SlidersContainer = rangeSelector.BaseVisualElement.inherit(function() {
            var prototypeObject = {
                    getController: function() {
                        return this._controller
                    },
                    _drawAreaTracker: function(group) {
                        var self = this,
                            areaTracker,
                            selectedAreaTracker;
                        areaTracker = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0, {
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001
                        });
                        areaTracker.append(group);
                        selectedAreaTracker = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0, {
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001,
                            style: {cursor: 'pointer'}
                        });
                        selectedAreaTracker.append(group);
                        self._controller.setAreaTrackers(areaTracker, selectedAreaTracker)
                    },
                    _processSelectionChanged: function(moving, blockSelectedRangeChanged) {
                        var self = this,
                            equalLastSelectedRange = function(selectedRange) {
                                return selectedRange && self._lastSelectedRange.startValue === selectedRange.startValue && self._lastSelectedRange.endValue === selectedRange.endValue
                            },
                            selectedRange = self.getSelectedRange();
                        if ((!moving || (self._options.behavior.callSelectedRangeChanged || '').toLowerCase() === "onmoving") && self._options.selectedRangeChanged && !equalLastSelectedRange(selectedRange)) {
                            self._updateLastSelectedRange(selectedRange);
                            if (typeof self._options.selectedRangeChanged === 'function')
                                self._options.selectedRangeChanged.call(null, selectedRange, blockSelectedRangeChanged);
                            if (!moving && !equalLastSelectedRange(selectedRange))
                                self.setSelectedRange(selectedRange)
                        }
                    },
                    _updateLastSelectedRange: function(selectedRange) {
                        selectedRange = selectedRange || this._options.selectedRange;
                        this._lastSelectedRange = {
                            startValue: selectedRange.startValue,
                            endValue: selectedRange.endValue
                        }
                    },
                    _createSlider: function(sliderIndex) {
                        return rangeSelector.rangeSelectorFactory.createSlider(this._renderer, sliderIndex)
                    },
                    _createSlidersController: function(sliders) {
                        return rangeSelector.rangeSelectorFactory.createSlidersController(sliders)
                    },
                    _createSlidersEventsManager: function(controller) {
                        var self = this;
                        return rangeSelector.rangeSelectorFactory.createSlidersEventsManager(self._renderer, controller, function(moving) {
                                self._processSelectionChanged(moving)
                            })
                    },
                    ctor: function(renderer) {
                        var self = this,
                            sliders;
                        self.callBase(renderer);
                        sliders = [self._createSlider(START_VALUE_INDEX), self._createSlider(END_VALUE_INDEX)];
                        self._controller = self._createSlidersController(sliders);
                        self._eventsManager = self._createSlidersEventsManager(self._controller);
                        self._lastSelectedRange = {}
                    },
                    getSelectedRange: function() {
                        return this._controller.getSelectedRange()
                    },
                    setSelectedRange: function(selectedRange) {
                        var self = this,
                            scale = self._options.scale,
                            startValue,
                            endValue,
                            currentSelectedRange = self._options.selectedRange;
                        if (selectedRange) {
                            startValue = selectedRange.startValue;
                            endValue = selectedRange.endValue
                        }
                        if (isNumber(scale.startValue) && isNumber(startValue) || isDate(scale.startValue) && isDate(startValue))
                            currentSelectedRange.startValue = startValue;
                        if (isNumber(scale.endValue) && isNumber(endValue) || isDate(scale.endValue) && isDate(endValue))
                            currentSelectedRange.endValue = endValue;
                        self._controller.applySelectedRange(currentSelectedRange);
                        self._controller.applyPosition();
                        self._processSelectionChanged(false, selectedRange && selectedRange.blockSelectedRangeChanged)
                    },
                    appendTrackers: function(group) {
                        this._controller.appendTrackers(group)
                    },
                    _applyOptions: function(options) {
                        var self = this;
                        self._controller.applyOptions({
                            translator: options.translator,
                            canvas: options.canvas,
                            sliderMarker: options.sliderMarker,
                            sliderHandles: options.sliderHandles,
                            shutter: options.shutter,
                            scale: options.scale,
                            behavior: options.behavior
                        });
                        self._eventsManager.applyOptions({behavior: options.behavior})
                    },
                    _draw: function(group) {
                        var self = this,
                            rootElement;
                        if (msPointerEnabled) {
                            rootElement = self._renderer.getRoot();
                            rootElement && (rootElement.element.style.msTouchAction = "none")
                        }
                        self._controller.redraw(group);
                        self._drawAreaTracker(group);
                        self._eventsManager.initialize();
                        self._update()
                    },
                    _update: function() {
                        var self = this,
                            isEmpty = self._options.isEmpty;
                        self._eventsManager.setEnabled(!isEmpty);
                        self._controller.applySelectedRange(isEmpty ? {} : self._options.selectedRange);
                        self._controller.applyPosition(self.isDrawn());
                        self._updateLastSelectedRange();
                        self._controller.redraw()
                    }
                };
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file slidersController.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils;
        var START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1;
        rangeSelector.SlidersController = DX.Class.inherit(function() {
            return {
                    ctor: function(sliders) {
                        this._sliders = sliders;
                        sliders[START_VALUE_INDEX].setAnotherSlider(sliders[END_VALUE_INDEX]);
                        sliders[END_VALUE_INDEX].setAnotherSlider(sliders[START_VALUE_INDEX])
                    },
                    setAreaTrackers: function(areaTracker, selectedAreaTracker) {
                        this._areaTracker = areaTracker;
                        this._selectedAreaTracker = selectedAreaTracker
                    },
                    applyOptions: function(options) {
                        var self = this,
                            values = null;
                        self._options = options;
                        self.getSlider(START_VALUE_INDEX).applyOptions(options);
                        self.getSlider(END_VALUE_INDEX).applyOptions(options);
                        if (options.behavior.snapToTicks) {
                            values = options.scale.ticksInfo.fullTicks;
                            if (values.length > 1 && values[0] > values[values.length - 1])
                                values = values.reverse()
                        }
                        self.getSlider(START_VALUE_INDEX).setAvailableValues(values);
                        self.getSlider(END_VALUE_INDEX).setAvailableValues(values)
                    },
                    processDocking: function(sliderIndex) {
                        var self = this;
                        if (sliderIndex !== undefined)
                            self.getSlider(sliderIndex).processDocking();
                        else {
                            self.getSlider(START_VALUE_INDEX).processDocking();
                            self.getSlider(END_VALUE_INDEX).processDocking()
                        }
                        self.setTrackersCursorStyle('default');
                        self.applyAreaTrackersPosition()
                    },
                    getSelectedRangeInterval: function() {
                        var self = this;
                        return rangeSelector.utils.getInterval(self.getSlider(START_VALUE_INDEX).getValue(), self.getSlider(END_VALUE_INDEX).getValue())
                    },
                    moveSliders: function(postitionDelta, selectedRangeInterval) {
                        var self = this;
                        self.getSlider(START_VALUE_INDEX).setPosition(self.getSlider(START_VALUE_INDEX).getPosition() + postitionDelta, false, selectedRangeInterval);
                        self.applyPosition(true)
                    },
                    moveSlider: function(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, startOffsetPositionChangedCallback) {
                        var self = this,
                            slider = self.getSlider(sliderIndex),
                            anotherSlider = slider.getAnotherSlider(),
                            anotherSliderIndex = anotherSlider.getIndex(),
                            doSwap;
                        if (slider.canSwap())
                            if (sliderIndex === START_VALUE_INDEX ? position > anotherSlider.getPosition() : position < anotherSlider.getPosition()) {
                                doSwap = fastSwap;
                                if (!fastSwap)
                                    if (Math.abs(offsetPosition) >= Math.abs(startOffsetPosition) && offsetPosition * startOffsetPosition < 0) {
                                        doSwap = true;
                                        position += 2 * startOffsetPosition;
                                        startOffsetPositionChangedCallback(-startOffsetPosition)
                                    }
                                if (doSwap) {
                                    self.swapSliders();
                                    anotherSlider.applyPosition(true)
                                }
                            }
                        slider.setPosition(position, true);
                        slider.applyPosition(true);
                        self.applyAreaTrackersPosition();
                        self.setTrackersCursorStyle('w-resize')
                    },
                    applySelectedAreaCenterPosition: function(pos) {
                        var self = this,
                            slidersContainerHalfWidth = (self.getSlider(END_VALUE_INDEX).getPosition() - self.getSlider(START_VALUE_INDEX).getPosition()) / 2,
                            selectedRangeInterval = self.getSelectedRangeInterval();
                        self.getSlider(START_VALUE_INDEX).setPosition(pos - slidersContainerHalfWidth, false, selectedRangeInterval);
                        self.applyPosition();
                        self.processDocking()
                    },
                    processManualSelection: function(startPosition, endPosition, eventArgs) {
                        var self = this,
                            animateSliderIndex,
                            movingSliderIndex,
                            positionRange = [Math.min(startPosition, endPosition), Math.max(startPosition, endPosition)];
                        animateSliderIndex = startPosition < endPosition ? START_VALUE_INDEX : END_VALUE_INDEX;
                        movingSliderIndex = startPosition < endPosition ? END_VALUE_INDEX : START_VALUE_INDEX;
                        self.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex]);
                        self.getSlider(animateSliderIndex).setPosition(positionRange[animateSliderIndex]);
                        self.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex], true);
                        self.getSlider(movingSliderIndex).startEventHandler(eventArgs);
                        self.getSlider(animateSliderIndex).processDocking();
                        self.getSlider(movingSliderIndex).applyPosition(true)
                    },
                    applySelectedRange: function(selectedRange) {
                        var self = this,
                            inverted = self._options.scale.inverted;
                        utils.debug.assertParam(selectedRange, 'selectedRange not passed');
                        if (!inverted && selectedRange.startValue > selectedRange.endValue || inverted && selectedRange.startValue < selectedRange.endValue) {
                            self.getSlider(START_VALUE_INDEX).setValue(selectedRange.endValue);
                            self.getSlider(END_VALUE_INDEX).setValue(selectedRange.startValue)
                        }
                        else {
                            self.getSlider(START_VALUE_INDEX).setValue(selectedRange.startValue);
                            self.getSlider(END_VALUE_INDEX).setValue(selectedRange.endValue)
                        }
                    },
                    getSelectedRange: function() {
                        var self = this;
                        return {
                                startValue: self.getSlider(START_VALUE_INDEX).getValue(),
                                endValue: self.getSlider(END_VALUE_INDEX).getValue()
                            }
                    },
                    swapSliders: function() {
                        var self = this;
                        self._sliders.reverse();
                        self.getSlider(START_VALUE_INDEX).changeLocation();
                        self.getSlider(END_VALUE_INDEX).changeLocation()
                    },
                    applyAreaTrackersPosition: function() {
                        var self = this,
                            selectedRange = self.getSelectedRange(),
                            scaleOptions = self._options.scale,
                            width = self.getSlider(END_VALUE_INDEX).getPosition() - self.getSlider(START_VALUE_INDEX).getPosition(),
                            options = {
                                x: self.getSlider(START_VALUE_INDEX).getPosition(),
                                width: width < 0 ? 0 : width,
                                y: self._options.canvas.top,
                                height: self._options.canvas.height,
                                style: {cursor: scaleOptions.endValue - scaleOptions.startValue === selectedRange.endValue - selectedRange.startValue ? 'default' : 'pointer'}
                            };
                        self._selectedAreaTracker.applySettings(options);
                        self._areaTracker.applySettings({
                            x: self._options.canvas.left,
                            width: self._options.canvas.width,
                            y: self._options.canvas.top,
                            height: self._options.canvas.height
                        })
                    },
                    applyPosition: function(disableAnimation) {
                        var self = this;
                        self.getSlider(START_VALUE_INDEX).applyPosition(disableAnimation);
                        self.getSlider(END_VALUE_INDEX).applyPosition(disableAnimation);
                        self.applyAreaTrackersPosition()
                    },
                    redraw: function(group) {
                        var self = this;
                        self.getSlider(START_VALUE_INDEX).redraw(group);
                        self.getSlider(END_VALUE_INDEX).redraw(group)
                    },
                    appendTrackers: function(group) {
                        var self = this;
                        if (self._areaTracker && self._selectedAreaTracker) {
                            self._areaTracker.append(group);
                            self._selectedAreaTracker.append(group)
                        }
                        self.getSlider(START_VALUE_INDEX).appendTrackers(group);
                        self.getSlider(END_VALUE_INDEX).appendTrackers(group)
                    },
                    getSlider: function(sliderIndex) {
                        return this._sliders[sliderIndex]
                    },
                    getAreaTracker: function() {
                        return this._areaTracker
                    },
                    getSelectedAreaTracker: function() {
                        return this._selectedAreaTracker
                    },
                    setTrackersCursorStyle: function(style) {
                        var self = this;
                        self._selectedAreaTracker.applySettings({style: {cursor: style}});
                        self._areaTracker.applySettings({style: {cursor: style}})
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file slidersEventsManager.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils;
        var touchSupport = "ontouchstart" in window;
        var msPointerEnabled = window.navigator.msPointerEnabled;
        rangeSelector.events = {
            start: msPointerEnabled ? "MSPointerDown" : touchSupport ? "touchstart mousedown" : "mousedown",
            move: msPointerEnabled ? "MSPointerMove" : touchSupport ? "touchmove mousemove" : "mousemove",
            end: msPointerEnabled ? "MSPointerUp MSPointerCancel" : touchSupport ? "touchend mouseup" : "mouseup"
        };
        var MIN_MANUAL_SELECTING_WIDTH = 10,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1;
        rangeSelector.SlidersEventsManager = DX.Class.inherit(function() {
            var getRootOffsetLeft = function(self) {
                    return rangeSelector.utils.getRootOffsetLeft(self._renderer)
                };
            var getEventPageX = function(eventArgs) {
                    return rangeSelector.utils.getEventPageX(eventArgs)
                };
            var isLeftButtonPressed = function(event) {
                    var e = event || window.event,
                        originalEvent = e.originalEvent,
                        touches = e.touches,
                        pointerType = originalEvent ? originalEvent.pointerType : false,
                        eventTouches = originalEvent ? originalEvent.touches : false,
                        isIE8LeftClick = e.which === undefined && e.button === 1,
                        isMSPointerLeftClick = originalEvent && pointerType !== undefined && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || 'touch') || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || 'mouse') && originalEvent.buttons === 1),
                        isLeftClick = isIE8LeftClick || e.which === 1,
                        isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
                    return isLeftClick || isMSPointerLeftClick || isTouches
                };
            var isTouchEventArgs = function(e) {
                    return e && e.type && e.type.indexOf('touch') === 0
                };
            var initializeSliderEvents = function(self, sliderIndex) {
                    var renderer = self._renderer,
                        isTouchEvent,
                        slidersController = self._slidersController,
                        processSelectionChanged = self._processSelectionChanged,
                        slider = slidersController.getSlider(sliderIndex),
                        anotherSlider = slider.getAnotherSlider(),
                        fastSwap,
                        startOffsetPosition,
                        splitterMoving;
                    slider.startEventHandler = function(e) {
                        if (!self._enabled || !isLeftButtonPressed(e) || splitterMoving)
                            return;
                        fastSwap = this === slider.getSliderTracker().element;
                        splitterMoving = true;
                        isTouchEvent = isTouchEventArgs(e);
                        startOffsetPosition = getEventPageX(e) - slider.getPosition() - getRootOffsetLeft(self);
                        e.stopPropagation();
                        e.preventDefault()
                    };
                    slider.on(rangeSelector.events.start, slider.startEventHandler);
                    utils.subscribeEventToDocument(rangeSelector.events.end, function(e) {
                        if (splitterMoving) {
                            splitterMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                    });
                    utils.subscribeEventToDocument(rangeSelector.events.move, slider.__moveEventHandler = function(e) {
                        var doSwap,
                            pageX,
                            offsetPosition,
                            svgOffsetLeft = getRootOffsetLeft(self),
                            position,
                            sliderIndex = slider.getIndex();
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (!isLeftButtonPressed(e, true) && splitterMoving) {
                            splitterMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                        else if (splitterMoving) {
                            e.preventDefault();
                            pageX = getEventPageX(e);
                            position = pageX - startOffsetPosition - svgOffsetLeft;
                            offsetPosition = pageX - slider.getPosition() - svgOffsetLeft;
                            slidersController.moveSlider(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, function(newStartOffsetPosition) {
                                startOffsetPosition = newStartOffsetPosition
                            });
                            processSelectionChanged(true)
                        }
                    })
                };
            var initializeSelectedAreaEvents = function(self) {
                    var renderer = self._renderer,
                        isTouchEvent,
                        slidersController = self._slidersController,
                        processSelectionChanged = self._processSelectionChanged,
                        selectedAreaTracker = slidersController.getSelectedAreaTracker(),
                        selectedAreaMoving = false,
                        offsetStartPosition,
                        selectedRangeInterval;
                    selectedAreaTracker.on(rangeSelector.events.start, function(e) {
                        if (!self._enabled || !isLeftButtonPressed(e) || selectedAreaMoving)
                            return;
                        selectedAreaMoving = true;
                        isTouchEvent = isTouchEventArgs(e);
                        offsetStartPosition = getEventPageX(e) - slidersController.getSlider(START_VALUE_INDEX).getPosition();
                        selectedRangeInterval = slidersController.getSelectedRangeInterval();
                        e.stopPropagation();
                        e.preventDefault()
                    });
                    utils.subscribeEventToDocument(rangeSelector.events.end, function(e) {
                        if (selectedAreaMoving) {
                            selectedAreaMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                    });
                    utils.subscribeEventToDocument(rangeSelector.events.move, self.__selectedAreaMoveEventHandler = function(e) {
                        var positionDelta,
                            pageX;
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (selectedAreaMoving && !isLeftButtonPressed(e)) {
                            selectedAreaMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                        if (selectedAreaMoving) {
                            e.preventDefault();
                            pageX = getEventPageX(e);
                            positionDelta = pageX - slidersController.getSlider(START_VALUE_INDEX).getPosition() - offsetStartPosition;
                            slidersController.moveSliders(positionDelta, selectedRangeInterval);
                            processSelectionChanged(true)
                        }
                    })
                };
            var initializeAreaEvents = function(self) {
                    var renderer = self._renderer,
                        isTouchEvent,
                        slidersController = self._slidersController,
                        processSelectionChanged = self._processSelectionChanged,
                        areaTracker = slidersController.getAreaTracker(),
                        unselectedAreaProcessing = false,
                        splitterMoving = false,
                        startPageX;
                    areaTracker.on(rangeSelector.events.start, function(e) {
                        if (!self._enabled || !isLeftButtonPressed(e) || unselectedAreaProcessing)
                            return;
                        unselectedAreaProcessing = true;
                        isTouchEvent = isTouchEventArgs(e);
                        startPageX = getEventPageX(e)
                    });
                    utils.subscribeEventToDocument(rangeSelector.events.end, function(e) {
                        var pageX;
                        if (unselectedAreaProcessing) {
                            pageX = getEventPageX(e);
                            if (self._options.behavior.moveSelectedRangeByClick && Math.abs(startPageX - pageX) < MIN_MANUAL_SELECTING_WIDTH)
                                slidersController.applySelectedAreaCenterPosition(pageX - getRootOffsetLeft(self));
                            unselectedAreaProcessing = false;
                            processSelectionChanged(false)
                        }
                    });
                    utils.subscribeEventToDocument(rangeSelector.events.move, self.__areaMoveEventHandler = function(e) {
                        var pageX,
                            startPosition,
                            endPosition,
                            svgOffsetLeft = getRootOffsetLeft(self);
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (unselectedAreaProcessing && !isLeftButtonPressed(e)) {
                            unselectedAreaProcessing = false;
                            processSelectionChanged(false)
                        }
                        if (unselectedAreaProcessing) {
                            pageX = getEventPageX(e);
                            if (self._options.behavior.manualRangeSelectionEnabled && Math.abs(startPageX - pageX) >= MIN_MANUAL_SELECTING_WIDTH) {
                                startPosition = startPageX - svgOffsetLeft;
                                endPosition = pageX - svgOffsetLeft;
                                slidersController.processManualSelection(startPosition, endPosition, e);
                                unselectedAreaProcessing = false;
                                processSelectionChanged(true)
                            }
                        }
                    })
                };
            rangeSelector.getRootOffsetLeft = getRootOffsetLeft;
            return {
                    ctor: function(renderer, slidersController, processSelectionChanged) {
                        this._renderer = renderer;
                        this._slidersController = slidersController;
                        this._processSelectionChanged = processSelectionChanged;
                        this._enabled = true
                    },
                    applyOptions: function(options) {
                        this._options = options
                    },
                    initialize: function() {
                        var self = this;
                        if (!self._renderer.isInitialized())
                            return;
                        initializeSelectedAreaEvents(self);
                        initializeAreaEvents(self);
                        initializeSliderEvents(self, START_VALUE_INDEX);
                        initializeSliderEvents(self, END_VALUE_INDEX)
                    },
                    setEnabled: function(enabled) {
                        this._enabled = enabled
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file slider.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils;
        var touchSupport = "ontouchstart" in window;
        var msPointerEnabled = window.navigator.msPointerEnabled;
        var animationOptions = {duration: 250};
        var SPLITTER_WIDTH = 8,
            TOUCH_SPLITTER_WIDTH = 20,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1;
        rangeSelector.Slider = rangeSelector.BaseVisualElement.inherit(function() {
            return {
                    getText: function() {
                        if (this._marker)
                            return this._marker.getText()
                    },
                    getAvailableValues: function() {
                        return this._values
                    },
                    getShutter: function() {
                        return this._shutter
                    },
                    getMarker: function() {
                        return this._marker
                    },
                    _createSlider: function() {
                        var self = this,
                            sliderHandle,
                            sliderGroup;
                        sliderGroup = self._renderer.createGroup({'class': 'slider'});
                        sliderGroup.applySettings({
                            translateX: self._options.canvas.left,
                            translateY: self._options.canvas.top
                        });
                        sliderHandle = self._renderer.createLine(0, 0, 0, self._options.canvas.height, {
                            'class': 'dx-range-selector-slider',
                            strokeWidth: self._options.sliderHandles.width,
                            stroke: self._options.sliderHandles.color,
                            strokeOpacity: self._options.sliderHandles.opacity
                        });
                        sliderHandle.append(sliderGroup);
                        sliderGroup.setValid = function(correct) {
                            sliderHandle.applySettings({stroke: correct ? self._options.sliderHandles.color : self._options.sliderMarker.invalidRangeColor})
                        };
                        sliderGroup.updateHeight = function() {
                            sliderHandle.applySettings({points: [0, 0, 0, self._options.canvas.height]})
                        };
                        sliderGroup.applyOptions = function(options) {
                            sliderHandle.applySettings(options)
                        };
                        sliderGroup.__line = sliderHandle;
                        return sliderGroup
                    },
                    _createSliderTracker: function() {
                        var self = this,
                            sliderWidth = touchSupport || msPointerEnabled ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH,
                            sliderTracker,
                            sliderTrackerGroup;
                        sliderTracker = self._renderer.createRect(-sliderWidth / 2, 0, sliderWidth, self._options.canvas.height, 0, {
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001,
                            style: {cursor: 'w-resize'}
                        });
                        sliderTrackerGroup = self._renderer.createGroup({'class': 'sliderTracker'});
                        sliderTrackerGroup.applySettings({
                            translateX: 0,
                            translateY: self._options.canvas.top
                        });
                        sliderTracker.append(sliderTrackerGroup);
                        sliderTrackerGroup.updateHeight = function() {
                            sliderTracker.applySettings({height: self._options.canvas.height})
                        };
                        sliderTrackerGroup.__rect = sliderTracker;
                        return sliderTrackerGroup
                    },
                    _drawSliderTracker: function(group) {
                        var self = this,
                            sliderTracker = self._createSliderTracker();
                        if (sliderTracker) {
                            sliderTracker.append(group);
                            self._sliderTracker = sliderTracker
                        }
                    },
                    _createSliderMarker: function(options) {
                        return rangeSelector.rangeSelectorFactory.createSliderMarker(options)
                    },
                    _setPosition: function(position, correctByMinMaxRange) {
                        var self = this,
                            correctedPosition = self._correctPosition(position),
                            value = self._options.translator.untranslateX(correctedPosition);
                        self.setValue(value, correctByMinMaxRange);
                        self._position = correctedPosition
                    },
                    _setPositionForBothSliders: function(startPosition, interval) {
                        var self = this,
                            anotherSlider,
                            startValue,
                            endValue,
                            endPosition,
                            inverted = self._options.scale.inverted;
                        anotherSlider = self.getAnotherSlider();
                        startPosition = self._correctBounds(startPosition);
                        startValue = self._options.translator.untranslateX(startPosition);
                        endValue = utils.addInterval(startValue, interval);
                        if (!inverted && endValue > self._options.scale.endValue || inverted && endValue < self._options.scale.endValue) {
                            endValue = self._options.scale.endValue;
                            endPosition = self._options.canvas.left + self._options.canvas.width;
                            startValue = utils.addInterval(endValue, interval, true);
                            startPosition = self._options.translator.translateX(startValue)
                        }
                        else
                            endPosition = self._options.translator.translateX(endValue);
                        if (self._values)
                            if (!inverted ? startValue < self._values[0] : startValue > self._values[self._values.length - 1]) {
                                startValue = self._correctBusinessValueByAvailableValues(startValue);
                                endValue = utils.addInterval(startValue, interval)
                            }
                            else {
                                endValue = self._correctBusinessValueByAvailableValues(endValue);
                                startValue = utils.addInterval(endValue, interval, true)
                            }
                        anotherSlider.setValue(endValue);
                        self.setValue(startValue);
                        self._position = startPosition;
                        anotherSlider._position = endPosition
                    },
                    _correctPosition: function(position) {
                        var self = this,
                            correctedPosition = self._correctInversion(position);
                        correctedPosition = self._correctBounds(correctedPosition);
                        return correctedPosition
                    },
                    _correctInversion: function(position) {
                        var self = this,
                            correctedPosition = position,
                            anotherSliderPosition = self.getAnotherSlider().getPosition(),
                            slidersInverted = self.getIndex() === START_VALUE_INDEX ? position > anotherSliderPosition : position < anotherSliderPosition;
                        if (slidersInverted)
                            correctedPosition = anotherSliderPosition;
                        return correctedPosition
                    },
                    _correctBounds: function(position) {
                        var self = this,
                            correctedPosition = position,
                            canvas = self._options.canvas;
                        if (position < canvas.left)
                            correctedPosition = canvas.left;
                        if (position > canvas.left + canvas.width)
                            correctedPosition = canvas.left + canvas.width;
                        return correctedPosition
                    },
                    _correctBusinessValue: function(businessValue, correctByMinMaxRange) {
                        var self = this,
                            result = self._correctBusinessValueByAvailableValues(businessValue);
                        if (correctByMinMaxRange)
                            result = self._correctBusinessValueByMinMaxRangeFromAnotherSlider(result);
                        result = self._correctBusinessValueByMinRangeFromStartEndValues(result);
                        return result
                    },
                    _correctBusinessValueByAvailableValues: function(businessValue) {
                        var values = this._values;
                        if (values)
                            return rangeSelector.utils.findNearValue(values, businessValue);
                        return businessValue
                    },
                    _correctBusinessValueByMinMaxRangeFromAnotherSlider: function(businessValue) {
                        var self = this,
                            result = businessValue,
                            scale = self._options.scale,
                            values = self._values,
                            sliderIndex = self.getIndex(),
                            anotherBusinessValue = self.getAnotherSlider().getValue(),
                            isValid = true,
                            minValue,
                            maxValue;
                        if (!scale.inverted && sliderIndex === START_VALUE_INDEX || scale.inverted && sliderIndex === END_VALUE_INDEX) {
                            if (scale.maxRange)
                                minValue = utils.addInterval(anotherBusinessValue, scale.maxRange, true);
                            if (scale.minRange)
                                maxValue = utils.addInterval(anotherBusinessValue, scale.minRange, true)
                        }
                        else {
                            if (scale.maxRange)
                                maxValue = utils.addInterval(anotherBusinessValue, scale.maxRange);
                            if (scale.minRange)
                                minValue = utils.addInterval(anotherBusinessValue, scale.minRange)
                        }
                        if (maxValue !== undefined && result > maxValue) {
                            result = values ? rangeSelector.utils.findLessOrEqualValue(values, maxValue) : maxValue;
                            isValid = false
                        }
                        else if (minValue !== undefined && result < minValue) {
                            result = values ? rangeSelector.utils.findGreaterOrEqualValue(values, minValue) : minValue;
                            isValid = false
                        }
                        self._setValid(isValid);
                        return result
                    },
                    _correctBusinessValueByMinRangeFromStartEndValues: function(businessValue) {
                        var self = this,
                            values = self._values,
                            startValue,
                            endValue,
                            isValid = true,
                            scale = self._options.scale,
                            result = businessValue;
                        if (scale.minRange)
                            if (self.getIndex() === END_VALUE_INDEX) {
                                startValue = utils.addInterval(scale.startValue, scale.minRange, scale.inverted);
                                if (!scale.inverted && result < startValue || scale.inverted && result > startValue)
                                    result = startValue
                            }
                            else if (self.getIndex() === START_VALUE_INDEX) {
                                endValue = utils.addInterval(scale.endValue, scale.minRange, !scale.inverted);
                                if (!scale.inverted && result > endValue || scale.inverted && result < endValue)
                                    result = endValue
                            }
                        return result
                    },
                    _applySliderPosition: function(position, disableAnimation) {
                        var self = this,
                            isAnimation = self._options.behavior.animationEnabled && !disableAnimation,
                            top = self._options.canvas.top,
                            slider = self._slider;
                        if (isAnimation || slider.inAnimation) {
                            slider.inAnimation = true;
                            slider.animate({translate: {
                                    x: position,
                                    y: top
                                }}, isAnimation ? animationOptions : {duration: 0}, function() {
                                slider.inAnimation = false
                            });
                            self._sliderTracker.animate({translate: {
                                    x: position,
                                    y: top
                                }}, isAnimation ? animationOptions : {duration: 0})
                        }
                        else {
                            self._slider.applySettings({
                                translateX: position,
                                translateY: top
                            });
                            self._sliderTracker.applySettings({
                                translateX: position,
                                translateY: top
                            })
                        }
                        self._sliderTracker.updateHeight();
                        self._slider.updateHeight()
                    },
                    _applyShutterPosition: function(position, disableAnimation) {
                        var self = this,
                            shutterSettings,
                            shutter = self._shutter,
                            isAnimation = self._options.behavior.animationEnabled && !disableAnimation,
                            sliderIndex = self.getIndex();
                        if (sliderIndex == START_VALUE_INDEX)
                            shutterSettings = {
                                x: self._options.canvas.left,
                                y: self._options.canvas.top,
                                width: position - self._options.canvas.left,
                                height: self._options.canvas.height
                            };
                        else if (sliderIndex == END_VALUE_INDEX)
                            shutterSettings = {
                                x: position + 1,
                                y: self._options.canvas.top,
                                width: self._options.canvas.left + self._options.canvas.width - position,
                                height: self._options.canvas.height
                            };
                        if (shutterSettings)
                            if (isAnimation || shutter.inAnimation) {
                                shutter.inAnimation = true;
                                shutter.animate(shutterSettings, isAnimation ? animationOptions : {duration: 0}, function() {
                                    shutter.inAnimation = false
                                })
                            }
                            else
                                shutter.applySettings(shutterSettings)
                    },
                    _setValid: function(isValid) {
                        var self = this;
                        if (self._marker)
                            self._marker.setValid(isValid);
                        self._slider.setValid(isValid)
                    },
                    _setText: function(text) {
                        var self = this;
                        if (self._marker)
                            self._marker.setText(text)
                    },
                    ctor: function(renderer, index) {
                        var self = this;
                        self.callBase(renderer);
                        self._index = index
                    },
                    getIndex: function() {
                        return this._index
                    },
                    setAvailableValues: function(values) {
                        this._values = values
                    },
                    setAnotherSlider: function(slider) {
                        this._anotherSlider = slider
                    },
                    getAnotherSlider: function(slider) {
                        return this._anotherSlider
                    },
                    appendTrackers: function(group) {
                        var self = this;
                        if (self._sliderTracker)
                            self._sliderTracker.append(group)
                    },
                    getSliderTracker: function() {
                        return this._sliderTracker
                    },
                    changeLocation: function() {
                        var self = this;
                        if (self._marker)
                            self._marker.changeLocation();
                        self._index = this._index === START_VALUE_INDEX ? END_VALUE_INDEX : START_VALUE_INDEX;
                        self._lastPosition = null
                    },
                    setPosition: function(position, correctByMinMaxRange, selectedRangeInterval) {
                        var self = this,
                            slider;
                        if (selectedRangeInterval !== undefined) {
                            slider = self.getIndex() === START_VALUE_INDEX ? self : self.getAnotherSlider();
                            slider._setPositionForBothSliders(position, selectedRangeInterval)
                        }
                        else
                            self._setPosition(position, correctByMinMaxRange)
                    },
                    getPosition: function() {
                        return this._position
                    },
                    _applyOptions: function(options) {
                        this._lastPosition = null
                    },
                    setValue: function(value, correctByMinMaxRange) {
                        var self = this;
                        if (value === undefined) {
                            self._value = undefined;
                            self._valuePosition = self._position = self.getIndex() === START_VALUE_INDEX ? self._options.canvas.left : self._options.canvas.left + self._options.canvas.width;
                            self._setText(rangeSelector.consts.emptySliderMarkerText)
                        }
                        else {
                            self._value = self._correctBusinessValue(value, correctByMinMaxRange);
                            self._valuePosition = self._position = self._options.translator.translateX(self._value);
                            self._setText(rangeSelector.formatValue(self._value, self._options.sliderMarker))
                        }
                    },
                    getValue: function() {
                        return this._value
                    },
                    canSwap: function() {
                        var self = this,
                            scale = self._options.scale,
                            startValue,
                            endValue,
                            anotherSliderValue;
                        if (self._options.behavior.allowSlidersSwap) {
                            if (scale.minRange) {
                                anotherSliderValue = self.getAnotherSlider().getValue();
                                if (self.getIndex() === START_VALUE_INDEX) {
                                    endValue = utils.addInterval(scale.endValue, scale.minRange, !scale.inverted);
                                    if (!scale.inverted && anotherSliderValue > endValue || scale.inverted && anotherSliderValue < endValue)
                                        return false
                                }
                                else {
                                    startValue = utils.addInterval(scale.startValue, scale.minRange, scale.inverted);
                                    if (!scale.inverted && anotherSliderValue < startValue || scale.inverted && anotherSliderValue > startValue)
                                        return false
                                }
                            }
                            return true
                        }
                        return false
                    },
                    processDocking: function() {
                        var self = this;
                        self._position = self._valuePosition;
                        self.applyPosition(false);
                        self._setValid(true)
                    },
                    applyPosition: function(disableAnimation) {
                        var self = this,
                            position = self.getPosition();
                        if (self._lastPosition !== position) {
                            self._applySliderPosition(position, disableAnimation);
                            self._applyShutterPosition(position, disableAnimation);
                            self._lastPosition = position
                        }
                    },
                    on: function(event, handler) {
                        var self = this;
                        self._sliderTracker.on(event, handler);
                        if (self._marker)
                            self._marker.getTracker().on(event, handler)
                    },
                    _update: function() {
                        var self = this;
                        self._marker && self._marker.applyOptions(self._options.sliderMarker);
                        self._shutter && self._shutter.applySettings({
                            fill: self._options.shutter.color,
                            fillOpacity: self._options.shutter.opacity
                        });
                        self._slider && self._slider.applyOptions({
                            strokeWidth: self._options.sliderHandles.width,
                            stroke: self._options.sliderHandles.color,
                            strokeOpacity: self._options.sliderHandles.opacity
                        })
                    },
                    _draw: function(group) {
                        var self = this,
                            slider,
                            marker,
                            sliderAreaGroup,
                            shutter,
                            startPos,
                            startWidth,
                            index = self.getIndex();
                        sliderAreaGroup = self._renderer.createGroup({'class': 'sliderArea'});
                        sliderAreaGroup.append(group);
                        if (index === START_VALUE_INDEX)
                            shutter = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, 0, self._options.canvas.height, 0);
                        else if (index === END_VALUE_INDEX)
                            shutter = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0);
                        if (shutter) {
                            shutter.append(sliderAreaGroup);
                            slider = self._createSlider();
                            if (slider)
                                slider.append(sliderAreaGroup);
                            if (self._options.sliderMarker.visible) {
                                marker = self._createSliderMarker({
                                    renderer: self._renderer,
                                    isLeftPointer: index === END_VALUE_INDEX,
                                    sliderMarkerOptions: self._options.sliderMarker
                                });
                                marker.draw(slider)
                            }
                            self._shutter = shutter;
                            self._slider = slider;
                            self._marker = marker
                        }
                        self._drawSliderTracker(group)
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file sliderMarker.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector;
        rangeSelector.SliderMarker = DX.Class.inherit(function() {
            var ctor = function(options) {
                    this._renderer = options.renderer;
                    this._text = options.text;
                    this._isLeftPointer = options.isLeftPointer;
                    this._options = options.sliderMarkerOptions;
                    this._isValid = true;
                    initializeAreaPoints(this, {
                        width: 10,
                        height: 10
                    })
                };
            var applyOptions = function(options) {
                    this._options = options;
                    this.update()
                };
            var getRectSize = function(self, textSize) {
                    return {
                            width: Math.round(2 * self._options.padding + textSize.width),
                            height: Math.round(2 * self._options.padding + textSize.height * rangeSelector.consts.fontHeightRatio)
                        }
                };
            var initializeAreaPoints = function(self, textSize) {
                    var rectSize = getRectSize(self, textSize);
                    self._points = [];
                    if (self._isLeftPointer) {
                        self._points.push({
                            x: 0,
                            y: 0
                        });
                        self._points.push({
                            x: rectSize.width,
                            y: 0
                        });
                        self._points.push({
                            x: rectSize.width,
                            y: rectSize.height
                        });
                        self._points.push({
                            x: self._options.pointerSize,
                            y: rectSize.height
                        });
                        self._points.push({
                            x: 0,
                            y: rectSize.height + self._options.pointerSize
                        })
                    }
                    else {
                        self._points.push({
                            x: 0,
                            y: 0
                        });
                        self._points.push({
                            x: rectSize.width,
                            y: 0
                        });
                        self._points.push({
                            x: rectSize.width,
                            y: rectSize.height + self._options.pointerSize
                        });
                        self._points.push({
                            x: rectSize.width - self._options.pointerSize,
                            y: rectSize.height
                        });
                        self._points.push({
                            x: 0,
                            y: rectSize.height
                        })
                    }
                };
            var getPointerPosition = function(self, textSize) {
                    var rectSize = getRectSize(self, textSize);
                    if (self._isLeftPointer)
                        return {
                                x: 0,
                                y: rectSize.height + self._options.pointerSize
                            };
                    else
                        return {
                                x: rectSize.width - 1,
                                y: rectSize.height + self._options.pointerSize
                            }
                };
            var draw = function(group) {
                    var self = this;
                    var padding = self._options.padding;
                    self._sliderMarkerGroup = self._renderer.createGroup({'class': 'sliderMarker'});
                    self._sliderMarkerGroup.append(group);
                    self._area = self._renderer.createArea(self.points, {fill: self._options.color});
                    self._area.append(self._sliderMarkerGroup);
                    self._label = self._renderer.createText(self._text, padding, padding, {
                        font: self._options.font,
                        style: {'-webkit-user-select': 'none'}
                    });
                    self._label.append(self._sliderMarkerGroup);
                    self._tracker = self._renderer.createRect(0, 0, 2 * padding, 2 * padding + self._options.pointerSize, 0, {
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001,
                        style: {cursor: 'pointer'}
                    });
                    self._tracker.append(self._sliderMarkerGroup);
                    self._drawn = true;
                    self.update()
                };
            var getTextSize = function(self) {
                    var textSize = self._label.getBBox();
                    if (!self._textHeight && isFinite(textSize.height))
                        self._textHeight = textSize.height;
                    return {
                            width: textSize.width,
                            height: self._textHeight
                        }
                };
            var update = function(stop) {
                    var self = this,
                        textSize,
                        rectSize,
                        pointerPosition;
                    self._interval && clearInterval(self._interval);
                    delete self._interval;
                    if (!self._drawn)
                        return;
                    self._label.updateText(self._text);
                    textSize = getTextSize(self);
                    if (!stop) {
                        self._textSize = self._textSize || textSize;
                        self._textSize = textSize.width > self._textSize.width || textSize.height > self._textSize.height ? textSize : self._textSize;
                        textSize = self._textSize;
                        self._interval = setInterval(function() {
                            update.call(self, [true])
                        }, 75)
                    }
                    else {
                        delete self._textSize;
                        self._textSize = textSize
                    }
                    rectSize = getRectSize(self, textSize);
                    pointerPosition = getPointerPosition(self, textSize);
                    self._sliderMarkerGroup.applySettings({
                        translateX: -pointerPosition.x,
                        translateY: -pointerPosition.y
                    });
                    initializeAreaPoints(self, textSize);
                    self._area.applySettings({
                        points: self._points,
                        fill: self._isValid ? self._options.color : self._options.invalidRangeColor
                    });
                    self._tracker.applySettings({
                        width: rectSize.width,
                        height: rectSize.height + self._options.pointerSize
                    });
                    self._label.applySettings({
                        x: self._options.padding,
                        y: rectSize.height - self._options.padding
                    })
                };
            var getText = function() {
                    var self = this;
                    return self._text
                };
            var setText = function(value) {
                    var self = this;
                    if (self._text !== value) {
                        self._text = value;
                        self.update()
                    }
                };
            var setValid = function(isValid) {
                    var self = this;
                    self._isValid = isValid;
                    self.update()
                };
            var changeLocation = function() {
                    var self = this;
                    self._isLeftPointer = !self._isLeftPointer;
                    self.update()
                };
            var getTracker = function() {
                    var self = this;
                    return self._tracker
                };
            return {
                    ctor: ctor,
                    draw: draw,
                    update: update,
                    getText: getText,
                    setText: setText,
                    changeLocation: changeLocation,
                    applyOptions: applyOptions,
                    getTracker: getTracker,
                    setValid: setValid
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file rangeView.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector;
        rangeSelector.RangeView = rangeSelector.BaseVisualElement.inherit(function() {
            var createThemeManager = function(self) {
                    return DX.viz.charts.factory.createThemeManager(self.chart.theme)
                };
            return {_draw: function(group) {
                        var self = this,
                            viewRect,
                            viewImage,
                            backgroundColor,
                            series,
                            i,
                            showChart,
                            canvas,
                            isEmpty = self._options.isEmpty;
                        showChart = self._options.seriesDataSource && self._options.seriesDataSource.isShowChart() && !isEmpty;
                        canvas = self._options.canvas;
                        if (showChart)
                            backgroundColor = self._options.seriesDataSource.getBackgroundColor();
                        else if (!isEmpty && self._options.background.visible)
                            backgroundColor = self._options.background.color;
                        if (self._options.background.visible && backgroundColor) {
                            viewRect = self._renderer.createRect(canvas.left, canvas.top, canvas.width + 1, canvas.height, 0, {
                                fill: backgroundColor,
                                'class': 'dx-range-selector-background'
                            });
                            viewRect.append(group)
                        }
                        if (self._options.background.visible && self._options.background.image && self._options.background.image.url) {
                            viewImage = self._renderer.createImage(canvas.left, canvas.top, canvas.width + 1, canvas.height, self._options.background.image.url, {location: self._options.background.image.location});
                            viewImage.append(group)
                        }
                        if (showChart) {
                            series = self._options.seriesDataSource.getSeries();
                            for (i = 0; i < series.length; i++) {
                                series[i].options.seriesGroup = group;
                                series[i].options.seriesLabelsGroup = group;
                                series[i].options.trackerGroup = group;
                                series[i].draw(self._options.translator);
                                if (self._options.behavior && self._options.behavior.animationEnabled)
                                    series[i].animate()
                            }
                        }
                    }}
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file seriesDataSource.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            charts = DX.viz.charts;
        rangeSelector.SeriesDataSource = DX.Class.inherit(function() {
            var createThemeManager = function(chartOptions) {
                    return charts.factory.createThemeManager(chartOptions, 'rangeSelector.chart')
                };
            var isArrayOfSimpleTypes = function(data) {
                    return $.isArray(data) && data.length > 0 && (DX.utils.isNumber(data[0]) || DX.utils.isDate(data[0]))
                };
            var convertToArrayOfObjects = function(data) {
                    return $.map(data, function(item, i) {
                            return {
                                    arg: item,
                                    val: i
                                }
                        })
                };
            var calculateSeries = function(self, options) {
                    var series = [],
                        particularSeriesOptions,
                        seriesTheme,
                        data,
                        chartThemeManager = createThemeManager(options.chart),
                        allSeriesOptions = options.chart.series,
                        seriesValueType = options.chart.valueAxis && options.chart.valueAxis.valueType,
                        dataSourceField,
                        chartOptions,
                        i;
                    if (options.dataSource && !allSeriesOptions) {
                        if (isArrayOfSimpleTypes(options.dataSource))
                            options.dataSource = convertToArrayOfObjects(options.dataSource);
                        dataSourceField = options.dataSourceField || 'arg';
                        allSeriesOptions = {
                            argumentField: dataSourceField,
                            valueField: dataSourceField
                        };
                        self._hideChart = true
                    }
                    allSeriesOptions = $.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
                    chartOptions = chartThemeManager.applyTheme(chartThemeManager.getTheme(), options.chart);
                    $.extend(chartOptions.commonSeriesSettings, {
                        argumentType: options.valueType,
                        valueType: dataSourceField ? options.valueType : seriesValueType,
                        incidentOccured: options.incidentOccured
                    });
                    self._backgroundColor = options.backgroundColor !== undefined ? options.backgroundColor : chartOptions.backgroundColor;
                    for (i = 0; i < allSeriesOptions.length; i++) {
                        particularSeriesOptions = allSeriesOptions[i];
                        particularSeriesOptions.rotated = false;
                        data = particularSeriesOptions.data || options.dataSource;
                        seriesTheme = chartThemeManager.applyNextSeriesTheme(particularSeriesOptions, chartOptions.commonSeriesSettings);
                        if (data && data.length > 0) {
                            var newSeries = charts.factory.createSeries(particularSeriesOptions.type || chartOptions.commonSeriesSettings.type, options.renderer, data, seriesTheme);
                            newSeries._suppressTrackers = true;
                            series.push(newSeries)
                        }
                    }
                    return series
                };
            var processSeriesFamilies = function(series, equalBarWidth) {
                    var families = [],
                        types = [];
                    $.each(series, function(i, item) {
                        if ($.inArray(item.type, types) === -1)
                            types.push(item.type)
                    });
                    $.each(types, function(_, type) {
                        var family = new charts.factory.createSeriesFamily({
                                type: type,
                                equalBarWidth: equalBarWidth
                            });
                        family.add(series);
                        family.adjustSeriesValues();
                        families.push(family)
                    });
                    return families
                };
            var prototypeObject = {
                    ctor: function(options) {
                        var self = this;
                        self._indent = {
                            top: options.chart.topIndent >= 0 && options.chart.topIndent < 1 ? options.chart.topIndent : 0,
                            bottom: options.chart.bottomIndent >= 0 && options.chart.bottomIndent < 1 ? options.chart.bottomIndent : 0
                        };
                        self._valueAxis = options.chart.valueAxis || {};
                        self._hideChart = false;
                        self._series = calculateSeries(self, options);
                        self._seriesFamilies = processSeriesFamilies(self._series, options.chart.equalBarWidth)
                    },
                    adjustSeriesDimensions: function(translator) {
                        var self = this;
                        $.each(self._seriesFamilies, function() {
                            this.adjustSeriesDimensions(translator)
                        })
                    },
                    getBoundRange: function() {
                        var self = this,
                            seriesElement,
                            rangeData,
                            range = new DX.viz.charts.Range({
                                minY: self._valueAxis.min,
                                minVisibleY: self._valueAxis.min,
                                maxY: self._valueAxis.max,
                                maxVisibleY: self._valueAxis.max
                            }),
                            rangeYSize,
                            rangeVisibleSizeY,
                            i,
                            minIndent,
                            maxIndent;
                        for (i = 0; i < self._series.length; i++) {
                            rangeData = self._series[i].getRangeData();
                            range = range.getBoundRange(rangeData)
                        }
                        if (range.isDefined()) {
                            minIndent = self._valueAxis.inverted ? self._indent.top : self._indent.bottom;
                            maxIndent = self._valueAxis.inverted ? self._indent.bottom : self._indent.top;
                            rangeYSize = range.maxY - range.minY;
                            rangeVisibleSizeY = ($.isNumeric(range.maxVisibleY) ? range.maxVisibleY : range.maxY) - ($.isNumeric(range.minVisibleY) ? range.minVisibleY : range.minY);
                            range.minY -= rangeYSize * minIndent;
                            range.maxY += rangeYSize * maxIndent;
                            if ($.isNumeric(rangeVisibleSizeY)) {
                                range.maxVisibleY = range.maxVisibleY ? range.maxVisibleY + rangeVisibleSizeY * maxIndent : undefined;
                                range.minVisibleY = range.minVisibleY ? range.minVisibleY - rangeVisibleSizeY * minIndent : undefined
                            }
                            range.invertY = self._valueAxis.inverted
                        }
                        return range
                    },
                    getSeries: function() {
                        var self = this;
                        return self._series
                    },
                    getBackgroundColor: function() {
                        var self = this;
                        return self._backgroundColor
                    },
                    isEmpty: function() {
                        var self = this;
                        return self.getSeries().length === 0
                    },
                    isShowChart: function() {
                        var self = this;
                        return !self.isEmpty() && !self._hideChart
                    },
                    getCalculatedValueType: function() {
                        var self = this,
                            result;
                        if (self._series.length)
                            result = self._series[0].options.argumentType;
                        return result
                    }
                };
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz, file utils.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = rangeSelector.utils,
            dxUtils = DX.utils;
        var INVISIBLE_POS = -1000;
        var findLessOrEqualValueIndex = function(values, value) {
                if (!values || values.length === 0)
                    return -1;
                var minIndex = 0,
                    maxIndex = values.length - 1,
                    index = 0;
                while (maxIndex - minIndex > 1) {
                    var index = minIndex + maxIndex >> 1;
                    if (values[index] > value)
                        maxIndex = index;
                    else
                        minIndex = index
                }
                return values[maxIndex] <= value ? maxIndex : minIndex
            };
        var findLessOrEqualValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length)
                    return values[index];
                return value
            };
        var findNearValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length) {
                    if (index + 1 < values.length)
                        if (dxUtils.isDate(value)) {
                            if (values[index + 1].getTime() - value.getTime() < value.getTime() - values[index].getTime())
                                index++
                        }
                        else if (values[index + 1] - value < value - values[index])
                            index++;
                    return values[index]
                }
                return value
            };
        var findGreaterOrEqualValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length) {
                    if (values[index] < value && index + 1 < values.length)
                        index++;
                    return values[index]
                }
                return value
            };
        var getInterval = function(valueMin, valueMax, delta) {
                var result,
                    minDateDaysCount,
                    maxDateDaysCount,
                    daysCount,
                    prevMaxDaysCount;
                if (dxUtils.isDate(valueMin)) {
                    if (delta === 'year' || delta === 'quarter' || delta === 'month')
                        return {months: valueMax.getFullYear() * 12 + valueMax.getMonth() - valueMin.getFullYear() * 12 - valueMin.getMonth()};
                    else
                        return {milliseconds: valueMax.valueOf() - valueMin.valueOf()};
                    return result
                }
                else
                    return valueMax - valueMin
            };
        var getRootOffsetLeft = function(renderer) {
                var node,
                    result = 0,
                    root = renderer.getRoot();
                if (root) {
                    node = root.element;
                    if (node.getScreenCTM)
                        result = node.createSVGPoint().matrixTransform(node.getScreenCTM()).x;
                    else
                        while (node) {
                            result += node.offsetLeft || 0;
                            node = node.offsetParent
                        }
                }
                return result
            };
        var getEventPageX = function(eventArgs) {
                var result = 0;
                if (eventArgs.pageX)
                    result = eventArgs.pageX;
                else if (eventArgs.originalEvent && eventArgs.originalEvent.pageX)
                    result = eventArgs.originalEvent.pageX;
                if (eventArgs.originalEvent && eventArgs.originalEvent.touches)
                    if (eventArgs.originalEvent.touches.length > 0)
                        result = eventArgs.originalEvent.touches[0].pageX;
                    else if (eventArgs.originalEvent.changedTouches.length > 0)
                        result = eventArgs.originalEvent.changedTouches[0].pageX;
                return result
            };
        var getTextBBox = function(renderer, text, fontOptions) {
                var textElement = renderer.createText(text, INVISIBLE_POS, INVISIBLE_POS, {font: fontOptions}).append();
                var textBBox = textElement.getBBox();
                textElement.remove();
                return textBBox
            };
        utils.findLessOrEqualValue = findLessOrEqualValue;
        utils.findNearValue = findNearValue;
        utils.findGreaterOrEqualValue = findGreaterOrEqualValue;
        utils.getInterval = getInterval;
        utils.getRootOffsetLeft = getRootOffsetLeft;
        utils.getEventPageX = getEventPageX;
        utils.getTextBBox = getTextBBox
    })(jQuery, DevExpress);
    /*! Module viz, file themeManager.js */
    (function($, DX, undefined) {
        DX.viz.rangeSelector = DX.viz.rangeSelector;
        DX.viz.rangeSelector.ThemeManager = DX.viz.core.BaseThemeManager.inherit({
            ctor: function(userTheme) {
                var self = this;
                self.callBase(userTheme, 'rangeSelector');
                self.initializeFont(self.theme.scale.label.font);
                self.initializeFont(self.theme.sliderMarker.font)
            },
            applyRangeSelectorTheme: function(userOptions) {
                var self = this,
                    refs = {dataSource: userOptions.dataSource},
                    result;
                delete userOptions.dataSource;
                result = self.applyTheme(self.theme, userOptions);
                result.dataSource = refs.dataSource;
                return result
            },
            setBackgroundColor: function(containerBackgroundColor) {
                var theme = this.theme;
                if (containerBackgroundColor)
                    theme.containerBackgroundColor = containerBackgroundColor;
                theme.shutter.color = theme.shutter.color || theme.containerBackgroundColor
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz, file viz.js */
    (function(DevExpress) {
        var viz = DevExpress.viz;
        viz.Chart = viz.charts.Chart;
        viz.PieChart = viz.charts.PieChart;
        viz.RangeSelector = viz.rangeSelector.RangeSelector;
        viz.CircularGauge = viz.gauges.CircularGauge;
        viz.LinearGauge = viz.gauges.LinearGauge
    })(DevExpress);
    /*! Module viz, file dxChart.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            viz = DX.viz;
        ui.registerComponent("dxChart", viz.Chart)
    })(jQuery, DevExpress);
    /*! Module viz, file dxPieChart.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            viz = DX.viz;
        ui.registerComponent("dxPieChart", viz.PieChart)
    })(jQuery, DevExpress);
    /*! Module viz, file dxCircularGauge.js */
    (function(DX, undefined) {
        DX.ui.registerComponent("dxCircularGauge", DX.viz.CircularGauge)
    })(DevExpress);
    /*! Module viz, file dxLinearGauge.js */
    (function(DX, undefined) {
        DX.ui.registerComponent("dxLinearGauge", DX.viz.LinearGauge)
    })(DevExpress);
    /*! Module viz, file dxRangeSelector.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            viz = DX.viz;
        ui.registerComponent("dxRangeSelector", viz.RangeSelector)
    })(jQuery, DevExpress);
    DevExpress.MOD_VIZ = true
}
;
/*! 
* DevExpress ChartJS
* Version: 13.1.7
* Build date: Sep 17, 2013
*
* Copyright (c) 2012 - 2013 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: http://chartjs.devexpress.com/EULA
*/

"use strict";window.DevExpress||(function(n,t,i){(function(n){if(n=n.split("."),n[0]<1||n[0]===1&&n[1]<8)throw Error("Your version of jQuery is too old. Please upgrade jQuery to 1.8.0 or later.");})(n.fn.jquery);var r=function(){var i=function(n,t,i){return function(){var r=this.callBase;this.callBase=n[t];try{return i.apply(this,arguments)}finally{this.callBase=r}}},r=function(n){var t=function(){};return t.prototype=n.prototype,new t},t=function(){},u=function(t){var r=this,u;return t?(u=n.map(t,function(n,t){return t}),n.each(["toString","toLocaleString","valueOf"],function(){t[this]&&u.push(this)}),n.each(u,function(){var u=n.isFunction(r.prototype[this])&&n.isFunction(t[this]);r.prototype[this]=u?i(r.parent.prototype,this,t[this]):t[this]}),r):r},f=function(){var t=this;return n.each(arguments,function(){this.ctor&&t._includedCtors.push(this.ctor);for(var n in this)if(n!=="ctor"){if(n in t.prototype)throw Error("Member name collision: "+n);t.prototype[n]=this[n]}}),t},e=function(n){return this.parent===n?!0:!this.parent||!this.parent.subclassOf?!1:this.parent.subclassOf(n)};return t.inherit=function(t){var i=function(){if(!this||this.constructor!==i)throw Error("A class must be instantiated using the 'new' keyword");var t=this,r=t.ctor;r&&r.apply(t,arguments),n.each(t.constructor._includedCtors,function(){this.call(t)})};return i.prototype=r(this),i.inherit=this.inherit,i.redefine=u,i.include=f,i.subclassOf=e,i.parent=this,i._includedCtors=this._includedCtors?this._includedCtors.slice(0):[],i.prototype.constructor=i,i.redefine(t),i},t}(),u=function(){var t=[],r=!1,u=function(){while(t.length){var e=t.shift(),f=e();if(f!==i){if(f.then){r=!0,n.when(f).always(u);return}throw Error();}}r=!1};return function(n){t.push(n),r||u()}}(),f=function(){var t=document.createElement("a"),i=["protocol","hostname","port","pathname","search","hash"],r=function(n){return n.charAt(0)!=="/"&&(n="/"+n),n};return function(u){t.href=u;var f={};return n.each(i,function(){f[this]=t[this]}),f.pathname=r(f.pathname),f}}();t.DevExpress=t.DevExpress||{};var e=function(t){var i=n.Deferred();return setTimeout(function(){i.resolve(t())},60),i},o=function(){var t=[];return{add:function(n){t.push(n)},remove:function(i){var r=n.inArray(i,t);r!==-1&&t.splice(r,1)},fire:function(){var n=t.pop(),i=!!n;return i&&n(),i}}}(),s=function(){var n=null;return function(t){return arguments.length&&(n=t),n}}();n.extend(t.DevExpress,{abstract:function(){throw Error("Not implemented");},Class:r,enqueue:u,enqueueAsync:e,parseUrl:f,backButtonCallback:o,overlayTargetContainer:s})}(jQuery,this),function(n,t,i){var e=function(n){return n===i||n===null?"":String(n)},r=function(n){return e(n).charAt(0).toUpperCase()+n.substr(1)},u=function(n){return e(n).replace(/([a-z\d])([A-Z])/g,"$1 $2").split(/[\s_-]+/)},f=function(t){return n.map(u(t),function(n){return n.toLowerCase()}).join("-")},o=function(n){return f(n).replace(/-/g,"_")},s=function(t,i){return n.map(u(t),function(n,t){return n=n.toLowerCase(),(i||t>0)&&(n=r(n)),n}).join("")},h=function(n){return r(f(n).replace(/-/g," "))},c=function(t){return n.map(u(t),function(n){return r(n.toLowerCase())}).join(" ")};t.inflector={dasherize:f,camelize:s,humanize:h,titleize:c,underscore:o}}(jQuery,DevExpress),function(n,t,i){var f=["","Webkit","Moz","O","ms"],e=document.createElement("dx").style,o={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",msTransition:"MsTransitionEnd",transition:"transitionend"},u=function(n){var i,u,r;for(n=t.inflector.camelize(n,!0),i=0,u=f.length;i<u;i++)if(r=f[i]+n,r in e)return r},r=function(n){return!!u(n)};t.support={touch:"ontouchstart"in i,transform3d:r("perspective"),transition:r("transition"),transitionEndEventName:o[u("transition")],animation:r("animation"),winJS:"WinJS"in i,styleProp:u,supportProp:r}}(jQuery,DevExpress,this),function(n,t){var f=/(webkit)[ \/]([\w.]+)/,e=/(opera)(?:.*version)?[ \/]([\w.]+)/,o=/(msie) ([\w.]+)/,s=/(mozilla)(?:.*? rv:([\w.]+))?/,u=navigator.userAgent.toLowerCase(),h=function(){var n={},t=f.exec(u)||e.exec(u)||o.exec(u)||u.indexOf("compatible")<0&&s.exec(u)||[],i=t[1],r=t[2];return i&&(n[i]=!0,n.version=r),n}();t.browser=h}(jQuery,DevExpress,this),function(n,t,i){var a=/left|right/,v=/top|bottom/,o=/fit|flip/,f=function(n){switch(typeof n){case"string":return n.split(/\s+/,2);case"object":return[n.x||n.h,n.y||n.v];case"number":return[n];default:return n}},s=function(t){var i={h:"center",v:"center"},r=f(t);return r&&n.each(r,function(){var n=String(this).toLowerCase();a.test(n)?i.h=n:v.test(n)&&(i.v=n)}),i},y=function(n){var t=f(n),i=parseInt(t&&t[0],10),r=parseInt(t&&t[1],10);return isFinite(i)||(i=0),isFinite(r)||(r=i),{h:i,v:r}},p=function(n){var t=f(n),i=String(t&&t[0]).toLowerCase(),r=String(t&&t[1]).toLowerCase();return o.test(i)||(i="none"),o.test(r)||(r=i),{h:i,v:r}},h=function(n){switch(n){case"center":return.5;case"right":case"bottom":return 1;default:return 0}},c=function(n){switch(n){case"left":return"right";case"right":return"left";case"top":return"bottom";case"bottom":return"top";default:return n}},e=function(n){n.myLocation=n.atLocation+h(n.atAlign)*n.atSize-h(n.myAlign)*n.mySize+n.offset},r={fit:function(n,t){n.myLocation>t.max&&(n.myLocation=t.max),n.myLocation<t.min&&(n.myLocation=t.min)},flip:function(t,i){if((t.myAlign!=="center"||t.atAlign!=="center")&&(t.myLocation<i.min||t.myLocation>i.max)){var r=n.extend({},t,{myAlign:c(t.myAlign),atAlign:c(t.atAlign),offset:-t.offset});e(r),(r.myLocation>=i.min&&r.myLocation<=i.max||r.myLocation>t.myLocation)&&(t.myLocation=r.myLocation)}}},u,w=function(f,o){var v=n(f),w,b;if(!o)return v.offset();var k=s(o.my),d=s(o.at),h=o.of||window,g=y(o.offset),nt=p(o.collision),c={mySize:v.outerWidth(),myAlign:k.h,atAlign:d.h,offset:g.h,collision:nt.h},a={mySize:v.outerHeight(),myAlign:k.v,atAlign:d.v,offset:g.v,collision:nt.v};h.preventDefault?(c.atLocation=h.pageX,a.atLocation=h.pageY,c.atSize=0,a.atSize=0):(h=n(h),n.isWindow(h[0])?(c.atLocation=h.scrollLeft(),a.atLocation=h.scrollTop(),c.atSize=h.width(),a.atSize=h.height()):h[0].nodeType===9?(c.atLocation=0,a.atLocation=0,c.atSize=h.width(),a.atSize=h.height()):(w=h.offset(),c.atLocation=w.left,a.atLocation=w.top,c.atSize=h.outerWidth(),a.atSize=h.outerHeight())),e(c),e(a),b=function(){var r=n(window),f=r.scrollLeft(),e=r.scrollTop();u===i&&(u=l());var o=document.width>document.documentElement.clientWidth,s=document.height>document.documentElement.clientHeight,h=t.support.touch?document.documentElement.clientWidth/(s?window.innerWidth-u:window.innerWidth):1,v=t.support.touch?document.documentElement.clientHeight/(o?window.innerHeight-u:window.innerHeight):1;return{h:{min:f,max:f+r.width()/h-c.mySize},v:{min:e,max:e+r.height()/v-a.mySize}}}(),r[c.collision]&&r[c.collision](c,b.h),r[a.collision]&&r[a.collision](a,b.v),v.offset({left:Math.round(c.myLocation),top:Math.round(a.myLocation)})},l;t.position=w,l=function(){var t=n("<div>").css({width:100,height:100,overflow:"scroll",position:"absolute",top:-9999}).appendTo(n("body")),i=t.get(0).offsetWidth-t.get(0).clientWidth;return t.remove(),i}}(jQuery,DevExpress),function(n,t){var r={},u=function(t,i){if(n.isPlainObject(t)){n.each(t,u);return}r[t]=i},e=function(){var i=n.makeArray(arguments);n.each(i,function(){delete r[this]})},f;u({func:{execute:function(t){n.isFunction(t.action)&&(t.result=t.action.apply(t.context,t.args),t.handled=!0)}},url:{execute:function(n){typeof n.action=="string"&&n.action.charAt(0)!=="#"&&(document.location=n.action)}},hash:{execute:function(n){typeof n.action=="string"&&n.action.charAt(0)==="#"&&(document.location.hash=n.action)}}}),f=t.Class.inherit({ctor:function(t,i){i=i||{},this._action=t||n.noop,this._context=i.context||window,this._beforeExecute=i.beforeExecute||n.noop,this._afterExecute=i.afterExecute||n.noop,this._component=i.component,this._allowedForGesture=!!i.allowedForGesture},execute:function(){var n={action:this._action,args:Array.prototype.slice.call(arguments),context:this._context,component:this._component,canceled:!1,handled:!1,allowedForGesture:this._allowedForGesture},t;if(this._validateAction(n))return(this._beforeExecute.call(this._context,n),n.canceled)?void 0:(t=this._executeAction(n),this._afterExecute.call(this._context,n),t)},_validateAction:function(t){return n.each(r,function(n,i){return i.validate&&i.validate(t),t.canceled?!1:void 0}),!t.canceled},_executeAction:function(t){var i;return n.each(r,function(n,r){return r.execute&&r.execute(t),t.handled?(i=t.result,!1):void 0}),i}}),n.extend(t,{registerActionExecutor:u,unregisterActionExecutor:e,Action:f})}(jQuery,DevExpress),function(n,t,i){function it(){}var rt=Math.PI,ut=Math.LN10,ft=Math.cos,et=Math.sin,c=Math.abs,ot=Math.log,st=Math.floor,ht=Math.ceil,ct=Math.max,nr=Math.min,l=window.isNaN,p=window.Number,lt=window.NaN,f=["millisecond","second","minute","hour","day","week","month","quarter","year"],at=function(n){return n!==null&&n!==i},e=function(t){return n.type(t)==="string"},o=function(t){return n.isNumeric(t)},a=function(t){return n.type(t)==="object"},vt=function(t){return n.type(t)==="array"},w=function(t){return n.type(t)==="date"},yt=function(t){return n.type(t)==="function"},r=function(n){switch(n){case"millisecond":return 1;case"second":return r("millisecond")*1e3;case"minute":return r("second")*60;case"hour":return r("minute")*60;case"day":return r("hour")*24;case"week":return r("day")*7;case"month":return r("day")*30;case"quarter":return r("month")*3;case"year":return r("day")*365;default:return 0}},s=function(n,t){return r(n)*t},pt=function(n){for(var t,i,f=["millisecond","second","minute","hour","day","month","year"],e={},u=f.length-1;u>=0;u--)i=f[u],t=Math.floor(n/r(i)),t>0&&(e[i+"s"]=t,n-=s(i,t));return e},wt=function(t){var i=0;return a(t)&&n.each(t,function(n,t){i+=s(n.substr(0,n.length-1),t)}),e(t)&&(i=s(t,1)),i},bt=function(t,i){var r,u=0;return r={year:t.getFullYear()!==i.getFullYear(),month:t.getMonth()!==i.getMonth(),day:t.getDate()!==i.getDate(),hour:t.getHours()!==i.getHours(),minute:t.getMinutes()!==i.getMinutes(),second:t.getSeconds()!==i.getSeconds()},n.each(r,function(n,t){t&&u++}),r.count=u,r},v=function(n){var t,i;return o(n)?(t=n.toFixed(20),i=t.indexOf("."),t.substr(i+1,t.length-i+1)):""},kt=function(n){var i=v(n),t;if(i)for(t=0;t<i.length;t++)if(i.charAt(t)!=="0")return t+1;return 0},u=function(n,t,i){return n+(i?-1:1)*t},b=function(n){return o(n)&&n.toString().indexOf("e")!==-1},dt=function(n,t,i){var r=null,f;return w(n)?(f=e(t)?g(t.toLowerCase()):t,r=new Date(n.getTime()),f.years&&r.setFullYear(u(r.getFullYear(),f.years,i)),f.quarters&&r.setMonth(u(r.getMonth(),3*f.quarters,i)),f.months&&r.setMonth(u(r.getMonth(),f.months,i)),f.weeks&&r.setDate(u(r.getDate(),7*f.weeks,i)),f.days&&r.setDate(u(r.getDate(),f.days,i)),f.hours&&r.setHours(u(r.getHours(),f.hours,i)),f.minutes&&r.setMinutes(u(r.getMinutes(),f.minutes,i)),f.seconds&&r.setSeconds(u(r.getSeconds(),f.seconds,i)),f.milliseconds&&r.setMilliseconds(u(n.getMilliseconds(),f.milliseconds,i))):r=u(n,t,i),r},k=function(t){var r=-1,i;return e(t)?t:a(t)?(n.each(t,function(n,t){for(i=0;i<f.length;i++)t&&(n===f[i]+"s"||n===f[i])&&r<i&&(r=i)}),f[r]):""},gt=function(n,i){var r,u,f=k(i);switch(f){case"second":n.setMilliseconds(0);break;case"minute":n.setSeconds(0,0);break;case"hour":n.setMinutes(0,0,0);break;case"year":n.setMonth(0);case"month":n.setDate(1);case"day":n.setHours(0,0,0,0);break;case"week":r=n.getDate(),n.getDay()!==0&&(r+=7-n.getDay()),n.setDate(r),n.setHours(0,0,0,0);break;case"quarter":u=t.formatHelper.getFirstQuarterMonth(n.getMonth()),n.getMonth()!==u&&n.setMonth(u),n.setDate(1),n.setHours(0,0,0,0)}},y=function(n,t){if(o(n))return b(n)?p(n.toExponential(t)):p(n.toFixed(t))},d=function(n){var t,i=n.toString(),r=i.indexOf(".");return r!==-1?(t=i.substring(r+1),t.length):0},ni=function(n,t,i){var r=d(n),u=d(t);return y(i,r<u?u:r)},ti=function(n){var i=v(n),r,t;if(i)for(t=1;t<=i.length;t++)if(r=y(n,t),r!==0&&i[t-2]&&i[t-1]&&i[t-2]===i[t-1])return r;return n},g=function(n){var t={};switch(n){case"year":t.years=1;break;case"month":t.months=1;break;case"quarter":t.months=3;break;case"week":t.days=7;break;case"day":t.days=1;break;case"hour":t.hours=1;break;case"minute":t.minutes=1;break;case"second":t.seconds=1;break;case"millisecond":t.milliseconds=1}return t},ii=function(n){return(n%360+360)%360},ri=function(n){return 90-n},nt=function(n){return rt*n/180},ui=function(n){var t=nt(n);return{cos:ft(t),sin:et(t)}},fi=1e-14,h=function(n){var t=c(n),i;return l(t)?lt:t>0?(t=ot(t)/ut,i=ht(t),i-t<fi?i:st(t)):0},ei=function(n,t,i){var u=ct(h(n),h(t)),r=-h(c(t-n)/i),f;return!l(u)&&!l(r)?(c(u)<=4?(f="fixedPoint",r<0&&(r=0),r>4&&(r=4)):(f="exponential",r+=u-1,r>3&&(r=3)),{format:f,precision:r}):null},oi=function(t){var i=n(window),r,u=function(){var n=i.width(),u=i.height();clearTimeout(r),r=setTimeout(function(){i.width()===n&&i.height()===u&&t()},100)};return u.stop=function(){return clearTimeout(r),this},u},si=function(){var n=function(){window.console&&arguments[0]&&console.info(arguments[0])},t=function(){window.console&&arguments[0]&&console.warn(arguments[0])},i=function(){window.console&&arguments[0]&&console.error(arguments[0])};return{info:n,warn:t,error:i}}(),hi=function(){function n(n,t){if(!n)throw new Error(t);}function t(t,r){n(t!==null&&t!==i,r)}return{assert:n,assertParam:t}}(),ci=function(){var t,r=n.Callbacks(),i=n(window),u=function(){return[i.width(),i.height()].join()},f=function(){var n=u();n!==t&&(t=n,r.fire())};i.on("resize",f);return t=u(),r}(),li=function(t){var i=n("<div />");return window.WinJS?WinJS.Utilities.setInnerHTMLUnsafe(i.get(0),t):i.append(t),i.contents()},ai=1,vi=1,yi=function(){return"DevExpress_"+ai++},pi=function(){return"DevExpressPattern_"+vi++},wi=function(n,i,r){var u,e,h;n=n||{};var o={},s="data-dx-",f=i.get(0).attributes;for(u=0;u<f.length;u++)e=f[u].name,e.indexOf(s)===0&&(h=t.inflector.camelize(e.substr(s.length)),o[h]=f[u].value);return tt(n,o,r)},tt=function(n,t,i){var r,u;n=n||{};for(r in t)t.hasOwnProperty(r)&&(u=t[r],r in n&&!i||(n[r]=u));return n},bi=function(t,i,r){var u=window;n(document).on(t,r,i)},ki=function(t){var i=window;n(document).off(t)},di=function(n){return it.prototype=n,new it},gi=function(t,i){var r=n.Deferred(),u=i||this;return setTimeout(function(){var i=t.call(u);i&&i.done&&n.isFunction(i.done)?i.done(function(){r.resolveWith(u)}):r.resolveWith(u)},0),r.promise()};t.utils={dateUnitIntervals:f,isDefined:at,isString:e,isNumber:o,isObject:a,isArray:vt,isDate:w,isFunction:yt,normalizeAngle:ii,convertAngleToRendererSpace:ri,degreesToRadians:nt,getCosAndSin:ui,getDecimalOrder:h,getAppropriateFormat:ei,getFraction:v,adjustValue:ti,convertMillisecondsToDateUnits:pt,convertDateTickIntervalToMilliseconds:wt,convertDateUnitToMilliseconds:s,getDateUnitInterval:k,getDatesDifferences:bt,correctDateWithUnitBeginning:gt,roundValue:y,isExponential:b,applyPrecisionByMinDelta:ni,getSignificantDigitPosition:kt,addInterval:dt,getDateIntervalByString:g,logger:si,debug:hi,createResizeHandler:oi,windowResizeCallbacks:ci,createMarkupFromString:li,getNextClipId:yi,getNextPatternId:pi,extendFromDataAttributes:wi,extendFromObject:tt,subscribeEventToDocument:bi,unsubscribeEventFromDocument:ki,clone:di,executeAsync:gi}}(jQuery,DevExpress),function(n,t,i){var u=t.support,e=/matrix(3d)?\((.+?)\)/,o=/translate(?:3d)?\((.+?)\)/,s=function(n){var t,i,f;return u.transform3d?(f=r(n),t={left:f.x,top:f.y}):(i=n.position(),t={left:i.left,top:i.top}),t},h=function(n,t){if(!u.transform3d){n.css(t);return}var e=r(n),o=t.left,s=t.top;o!==i&&(e.x=o),s!==i&&(e.y=s),n.css("transform",f(e))},r=function(n){var i=n.css("transform"),t=i.match(e),r=t&&t[1];return t?(t=t[2].split(","),r==="3d"?t=t.slice(12,15):(t.push(0),t=t.slice(4,7))):t=[0,0,0],{x:parseFloat(t[0]),y:parseFloat(t[1]),z:parseFloat(t[2])}},c=function(n){var t=n.match(o);if(t&&t[1])return t=t[1].split(","),t={x:parseFloat(t[0]),y:parseFloat(t[1]),z:parseFloat(t[2])}},f=function(n){return"translate3d("+(n.x||0)+"px, "+(n.y||0)+"px, "+(n.z||0)+"px)"};t.translator={move:h,locate:s,parseTranslate:c,getTranslate:r,getTranslateCss:f}}(jQuery,DevExpress),function(n,t,i){function l(n){if(n=n||window.navigator.userAgent,/iP(hone|od|ad)/.test(n)){var t=n.match(/OS (\d+)_(\d+)_?(\d+)?/);return[parseInt(t[1],10),parseInt(t[2],10),parseInt(t[3]||0,10)]}}var s={iPhone:"iPhone",iPhone5:"iPhone 5",iPad:"iPad",iPadMini:"iPad Mini",androidPhone:"Android Mobile",androidTablet:"Android",win8:"MSAppHost",win8Phone:"Windows Phone 8",msSurface:"MSIE ARM Tablet PC",desktop:"desktop"},u={phone:!1,tablet:!1,android:!1,ios:!1,win8:!1},h=n.extend(u,{platform:"desktop"}),f=function(t){var e=/ipad/i.test(t),u=/iphone|ipod/i.test(t),i=/android|silk-accelerated/i.test(t),r=/windows phone 8|wpdesktop/i.test(t),o=/msie(.*)arm(.*)tablet\spc/i.test(t),f=/msapphost/i.test(t)||r||o;if(!e&&!u&&!i&&!f&&!r&&!o)return n.extend({},h);var s=u||i&&/mobile/i.test(t)||r,l=!s&&!f&&!r,c=i?"android":f?"win8":"ios";return{phone:s,tablet:l,android:i,ios:e||u,win8:c==="win8",platform:c}},e=function(n){var t;if(n){if(t=s[n],!t)throw Error("Unknown device");}else t=navigator.userAgent;return f(t)},c=function(t){t=t||window.navigator.userAgent;var i=/Android (\d\.\d(?:\.\d)?)/.exec(t);return i&&i.length===2?n.map(i[1].split("."),function(n){return parseInt(n,10)}):[]},r,o=function(){return window.sessionStorage&&(sessionStorage.getItem("dx-force-device")||sessionStorage.getItem("dx-simulator-device"))},a=function(){var n=i;return window.top["dx-force-device"]&&(n=window.top["dx-force-device"]),n},v=function(t){if(t)r=n.isPlainObject(t)?n.extend(u,t):e(t);else{if(!r){var f=i;try{f=a()}catch(s){f=o()}finally{f||(f=o())}r=e(f)}return r}};t.devices={androidVersion:c,iosVersion:l,current:v,fromUA:function(){return f(navigator.userAgent)}}}(jQuery,DevExpress),function(n,t,i){var f=t.translator,e=t.support,o=e.transitionEndEventName+".dxFX",w=/cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,s="dxSimulatedTransitionTimeoutKey",u="dxAnimData",r="transform",b=1e3/60,l={animate:function(t,i){var r=n.Deferred(),u=n.Deferred(),e=n.Deferred();t.one(o,function(){u.reject()});return t.data(s,setTimeout(function(){e.reject()},i.duration+i.delay)),n.when(u,e).fail(n.proxy(function(){this._cleanup(t),r.resolveWith(t,[i,t])},this)),f.getTranslate(t),t.css({transitionProperty:"all",transitionDelay:i.delay+"ms",transitionDuration:i.duration+"ms",transitionTimingFunction:i.easing}),y(t,i.to),i.duration||t.trigger(o),r.promise()},_cleanup:function(n){n.css("transition","none").off(o);var t=n.data(s);clearTimeout(t),n.removeData(s)},stop:function(t,i){var r=t.data(u);r&&(i?t.trigger(o):(n.each(r.to,function(n){t.css(n,t.css(n))}),this._cleanup(t)))}},k=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,b)}}(),h={animate:function(t,e){var h=n.Deferred(),s=t.data(u),o=this;return s?(n.each(e.to,function(n){e.from[n]===i&&(e.from[n]=o._normalizeValue(t.css(n)))}),e.to[r]&&(e.from[r]=o._parseTransform(e.from[r]),e.to[r]=o._parseTransform(e.to[r])),s.frameAnimation={to:e.to,from:e.from,currentValue:e.from,easing:nt(e.easing),duration:e.duration,startTime:(new Date).valueOf(),finish:function(){this.currentValue=this.to,this.draw(),h.resolve()},draw:function(){var i=n.extend({},this.currentValue);i[r]&&(i[r]=n.map(i[r],function(n,t){return t==="translate"?f.getTranslateCss(n):t==="scale"?"scale("+n+")":t.substr(0,t.length-1)==="rotate"?t+"("+n+"deg)":void 0}).join(" ")),t.css(i)}},e.delay?(s.frameAnimation.startTime+=e.delay,s.frameAnimation.delayTimeout=setTimeout(function(){o._animationStep(t)},e.delay)):o._animationStep(t),h.promise()):h.reject().promise()},_parseTransform:function(t){var i={};return n.each(t.match(/(\w|\d)+\([^\)]*\)\s*/g),function(n,t){var e=f.parseTranslate(t),u=t.match(/scale\((.+?)\)/),r=t.match(/(rotate.)\((.+)deg\)/);e&&(i.translate=e),u&&u[1]&&(i.scale=parseFloat(u[1])),r&&r[1]&&(i[r[1]]=parseFloat(r[2]))}),i},stop:function(n,t){var r=n.data(u),i=r&&r.frameAnimation;i&&(clearTimeout(i.delayTimeout),t&&i.finish())},_animationStep:function(t){var f=t.data(u),i=f&&f.frameAnimation,r;if(i){if(r=(new Date).valueOf(),r>=i.startTime+i.duration){i.finish();return}i.currentValue=this._calcStepValue(i,r-i.startTime),i.draw(),k(n.proxy(function(){this._animationStep(t)},this))}},_calcStepValue:function(t,i){var r=function(u,f){var e=n.isArray(f)?[]:{},o=function(r){var e=i/t.duration,o=i,s=1*u[r],h=f[r]-u[r],c=t.duration;return n.easing[t.easing](e,o,s,h,c)};return n.each(f,function(n,t){if(typeof t=="string"&&parseFloat(t,10)===!1)return!0;e[n]=typeof t=="object"?r(u[n],t):o(n)}),e};return r(t.from,t.to)},_normalizeValue:function(n){var t=parseFloat(n,10);return t===!1?n:t}},d={transition:e.transition?l:h,frame:h},c=function(n){return d[n&&n.strategy||"transition"]},g={linear:"cubic-bezier(0, 0, 1, 1)",ease:"cubic-bezier(0.25, 0.1, 0.25, 1)","ease-in":"cubic-bezier(0.42, 0, 1, 1)","ease-out":"cubic-bezier(0, 0, 0.58, 1)","ease-in-out":"cubic-bezier(0.42, 0, 0.58, 1)"},nt=function(t){var i,r,u;return(t=g[t]||t,i=t.match(w),!i)?"linear":(i=i.slice(1,5),n.each(i,function(n,t){i[n]=parseFloat(t)}),r="cubicbezier_"+i.join("_").replace(/\./g,"p"),n.isFunction(n.easing[r])||(u=function(n,t,i,r){var u=3*n,f=3*(i-n)-u,o=1-u-f,e=3*t,s=3*(r-t)-e,h=1-e-s,c=function(n){return n*(u+n*(f+n*o))},l=function(n){return n*(e+n*(s+n*h))},a=function(n){for(var t=n,r=0,i;r<14;){if(i=c(t)-n,Math.abs(i)<.001)break;t=t-i/v(t),r++}return t},v=function(n){return u+n*(2*f+n*3*o)};return function(n){return l(a(n))}},n.easing[r]=function(n,t,r,f,e){return f*u(i[0],i[1],i[2],i[3])(t/e)+r}),r)},a=function(t,i){n.each(["from","to"],function(){if(!n.isPlainObject(t[this]))throw Error("Animation with the '"+i+"' type requires '"+this+"' configuration as an plain object.");})},tt={setup:function(){}},it={validateConfig:function(n){a(n,"slide")},setup:function(n,t){var i=c(t);e.transform3d&&(i===l||i===h)&&(this._setupConfig(n,t.from),this._setupConfig(n,t.to))},_setupConfig:function(n,t){var u=f.getTranslate(n),e=t.left,o=t.top;e!==i&&(u.x=e,delete t.left),o!==i&&(u.y=o,delete t.top),t[r]=f.getTranslateCss(u)}},rt={setup:function(t,i){var r=i.from,u=n.isPlainObject(r)?t.css("opacity"):String(r),f=String(i.to);i.from={opacity:u},i.to={opacity:f}}},ut={validateConfig:function(n){a(n,"pop")},setup:function(n,t){if(e.transform3d){var i=t.from,u=t.to,f="opacity"in i?i.opacity:n.css("opacity"),o="opacity"in u?u.opacity:1,s="scale"in i?i.scale:0,h="scale"in u?u.scale:1;t.from={opacity:f},t.from[r]=this._getCssTransform(s),t.to={opacity:o},t.to[r]=this._getCssTransform(h)}},_getCssTransform:function(n){return"scale("+n+")"}},v={custom:tt,slide:it,fade:rt,pop:ut},ft=function(n){var t=v[n];if(!t)throw Error('Unknown animation type "'+n+'"');return t},et={type:"custom",from:{},to:{},duration:400,complete:n.noop,easing:"ease",delay:0},ot=function(t,i){i=n.extend(!0,{},et,i);var r=n(t),u=ft(i.type);return n.isFunction(u.validateConfig)&&u.validateConfig(i),u.setup(r,i),p(r),y(r,i.from),st(r,i).done(i.complete)},y=function(t,i){n.each(i,function(n,i){t.css(n,i)})},st=function(i,r){var f=n.Deferred();return i.data(u,r),t.fx.off&&(r.duration=0),c(r).animate(i,r).done(function(){i.removeData(u),f.resolveWith(this,[i,r])}),f.promise()},ht=function(n){return!!n.data(u)},p=function(t,i){var r=n(t);c(r.data(u)).stop(r,i),r.removeData(u)};t.fx={off:!1,animationTypes:v,animate:ot,animating:ht,stop:p}}(jQuery,DevExpress),function(n,t){function e(n){return/^(localhost$|127\.)/i.test(n)}var r=window.location,u="dxproxy.devexpress.com:8000",f=r.protocol==="ms-appx:",o=r.host===u,s=e(r.hostname),h=function(){return r.pathname.split("/")[1]},c=function(n){var i=t.parseUrl(n);return e(i.hostname)?"http://"+u+"/"+h()+"_"+i.port+i.pathname+i.search:n},l=t.EndpointSelector=function(n){this.config=n};l.prototype={urlFor:function(n){var t=this.config[n];if(!t)throw Error("Unknown endpoint key");return o?c(t.local):t.production&&(f&&!Debug.debuggerEnabled||!f&&!s)?t.production:t.local}}}(jQuery,DevExpress),function(n,t,i){var r=t.utils,f,u;t.NumericFormat={currency:"C",fixedpoint:"N",exponential:"",percent:"P",decimal:"D"},t.LargeNumberFormatPostfixes={1:"K",2:"M",3:"B",4:"T"},f=4,u=10,t.LargeNumberFormatPowers={largenumber:"auto",thousands:1,millions:2,billions:3,trillions:4},t.DateTimeFormat={longdate:"D",longtime:"T",monthandday:"M",monthandyear:"Y",quarterandyear:"qq",shortdate:"d",shorttime:"t",millisecond:"fff",second:"T",minute:"t",hour:"t",day:"dd",week:"dd",month:"MMMM",quarter:"qq",year:"yyyy",longdatelongtime:"D",shortdateshorttime:"d"},t.formatHelper={romanDigits:["I","II","III","IV"],_addFormatSeparator:function(n,t){var i=" ";return t?n+i+t:n},_getDateTimeFormatPattern:function(n){return Globalize.findClosestCulture().calendar.patterns[t.DateTimeFormat[n.toLowerCase()]]},_isDateFormatContains:function(i){var r=!1;return n.each(t.DateTimeFormat,function(n){return r=n===i.toLowerCase(),!r}),r},getQuarter:function(n){return Math.floor(n/3)},getQuarterString:function(n,t){var i="",r=this.getQuarter(n.getMonth());switch(t){case"q":i=this.romanDigits[r];break;case"qq":i="Q"+this.romanDigits[r];break;case"Q":i=(r+1).toString();break;case"QQ":i="Q"+(r+1).toString()}return i},getFirstQuarterMonth:function(n){return this.getQuarter(n)*3},_formatCustomString:function(n,t){for(var f=/qq|q|QQ|Q/g,i,u="",r=0;r<t.length;)i=f.exec(t),(!i||i.index>r)&&(u+=Globalize.format(n,t.substring(r,i?i.index:t.length))),i?(u+=this.getQuarterString(n,i[0]),r=i.index+i[0].length):r=t.length;return u},_parseNumberFormatString:function(i){var u,r={};if(i&&typeof i=="string")return u=i.toLowerCase().split(" "),n.each(u,function(n,i){i in t.NumericFormat?r.formatType=i:i in t.LargeNumberFormatPowers&&(r.power=t.LargeNumberFormatPowers[i])}),r.power&&!r.formatType&&(r.formatType="fixedpoint"),r.formatType?r:void 0},_calculateNumberPower:function(n,t,r,u){var f=Math.abs(n),e=0;if(f>1)while(f&&f>=t&&(u===i||e<u))e++,f=f/t;else if(f>0&&f<1)while(f<1&&(r===i||e>r))e--,f=f*t;return e},_getNumberByPower:function(n,t,i){for(var r=n;t>0;)r=r/i,t--;while(t<0)r=r*i,t++;return r},_formatNumber:function(n,i,r){var u;return i.power==="auto"&&(i.power=this._calculateNumberPower(n,1e3,0,f)),i.power&&(n=this._getNumberByPower(n,i.power,1e3)),u=t.LargeNumberFormatPostfixes[i.power]||"",this._formatNumberCore(n,i.formatType,r)+u},_formatNumberExponential:function(n,t){var r=this._calculateNumberPower(n,u),f=this._getNumberByPower(n,r,u),e;return t=t===i?1:t,f.toFixed(t||0)>=u&&(r++,f=f/u),e=(r>=0?"+":"")+r.toString(),this._formatNumberCore(f,"fixedpoint",t)+"E"+e},_formatNumberCore:function(n,i,u){return i==="exponential"?this._formatNumberExponential(n,u):Globalize.format(n,t.NumericFormat[i]+(r.isNumber(u)?u:0))},_formatDate:function(n,i){var u=t.DateTimeFormat[i.toLowerCase()];return(i=i.toLowerCase(),i==="quarterandyear"&&(u=this.getQuarterString(n,u)+" yyyy"),i==="quarter")?this.getQuarterString(n,u):i==="longdatelongtime"?this._formatDate(n,"longdate")+" "+this._formatDate(n,"longtime"):i==="shortdateshorttime"?this._formatDate(n,"shortDate")+" "+this._formatDate(n,"shortTime"):Globalize.format(n,u)},format:function(n,t,i){if(t&&t.format){if(t.dateType)return this._formatDateEx(n,t);if(r.isNumber(n)&&isFinite(n))return this._formatNumberEx(n,t)}return this._format(n,t,i)},_format:function(n,t,i){var u;return!r.isString(t)||t===""||!r.isNumber(n)&&!r.isDate(n)?r.isDefined(n)?n.toString():"":(u=this._parseNumberFormatString(t),r.isNumber(n)&&u)?this._formatNumber(n,u,i):r.isDate(n)&&this._isDateFormatContains(t)?this._formatDate(n,t):!u&&!this._isDateFormatContains(t)?this._formatCustomString(n,t):void 0},_formatNumberEx:function(n,i){var a=this,v=t.NumericFormat[i.format.toLowerCase()],f=Globalize.culture().numberFormat,w=i.currencyCulture&&Globalize.cultures[i.currencyCulture]?Globalize.cultures[i.currencyCulture].numberFormat.currency:f.currency,b=f.percent,c=a._getUnitFormatSettings(n,i),k=c.unit,y=c.precision,nt=c.showTrailingZeros,tt=c.includeGroupSeparator,it=f[","],rt=f["."],r,l,o,u,d=/n|\$|-|%/g,e="",s,p,g,h;n=a._applyUnitToValue(n,k),r=Math.abs(n),l=n<0;switch(v){case"D":if(o="n",r=Math[l?"ceil":"floor"](r),y>0){for(s=""+r,p=s.length;p<y;p+=1)s="0"+s;r=s}l&&(r="-"+r);break;case"N":u=f;case"C":u=u||w;case"P":u=u||b,o=l?u.pattern[0]:u.pattern[1]||"n",r=Globalize.format(r*(v==="P"?100:1),"N"+y),nt||(r=a._excludeTrailingZeros(r,rt)),tt||(r=r.replace(new RegExp("\\"+it,"g"),""));break;default:throw"Illegal numeric format: '"+v+"'";}for(;;)if(g=d.lastIndex,h=d.exec(o),e+=o.slice(g,h?h.index:o.length),h)switch(h[0]){case"-":/[1-9]/.test(r)&&(e+=f["-"]);break;case"$":e+=w.symbol;break;case"%":e+=b.symbol;break;case"n":e+=r+k}else break;return(i.plus&&n>0?"+":"")+e},_excludeTrailingZeros:function(n,t){var u=n.indexOf(t),r,i;if(u<0)return n;for(r=n.length,i=r-1;i>=u&&(n[i]==="0"||i===u);i--)r--;return n.substring(0,r)},_getUnitFormatSettings:function(n,t){var e=t.unit||"",u=t.precision||0,h=t.includeGroupSeparator||!1,s=t.showTrailingZeros===i?!0:t.showTrailingZeros,f=t.significantDigits||1,r,o;if(e.toLowerCase()==="auto")if(s=!1,r=Math.abs(n),f<1&&(f=1),r>=1e9?(e="B",r/=1e9):r>=1e6?(e="M",r/=1e6):r>=1e3?(e="K",r/=1e3):e="",r==0)u=0;else if(r<1)for(u=f,o=Math.pow(10,-f);r<o;)o/=10,u++;else u=r>=100?f-3:r>=10?f-2:f-1;return u<0&&(u=0),{unit:e,precision:u,showTrailingZeros:s,includeGroupSeparator:h}},_applyUnitToValue:function(n,t){return t=="B"?n.toFixed(1)/1e9:t=="M"?n/1e6:t=="K"?n/1e3:n},_formatDateEx:function(t,r){var f=this,l="Q",c=r.format,u=r.dateType,h=Globalize.culture().calendars.standard,o=i,s,e;if(c=c.toLowerCase(),u!=="num"||c==="dayofweek")switch(c){case"monthyear":return f._formatDate(t,"monthandyear");case"quarteryear":return f.getQuarterString(t,"QQ")+" "+t.getFullYear();case"daymonthyear":return f._formatDate(t,u+"Date");case"datehour":return o=new Date(t.getTime()),o.setMinutes(0),e=u==="timeOnly"?"":f._formatDate(t,u+"Date"),u==="timeOnly"?f._formatDate(o,"shorttime"):e+" "+f._formatDate(o,"shorttime");case"datehourminute":return e=u==="timeOnly"?"":f._formatDate(t,u+"Date"),u==="timeOnly"?f._formatDate(t,"shorttime"):e+" "+f._formatDate(t,"shorttime");case"datehourminutesecond":return e=u==="timeOnly"?"":f._formatDate(t,u+"Date"),u==="timeOnly"?f._formatDate(t,"longtime"):e+" "+f._formatDate(t,"longtime");case"year":return e=t.toString(),u==="abbr"?e.slice(2,4):e;case"quarter":return l+t.toString();case"month":return s=t-1,u==="abbr"?h.months.namesAbbr[s]:h.months.names[s];case"hour":return u==="long"?(o=new Date,o.setHours(t),o.setMinutes(0),f._formatDate(o,"shorttime")):t.toString();case"dayofweek":return s=n.inArray(t,["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]),u!=="num"?u==="abbr"?h.days.namesAbbr[s]:h.days.names[s]:((s-h.firstDay+1+7)%8).toString();default:return t.toString()}else return t.toString()},getTimeFormat:function(n){return n?this._getDateTimeFormatPattern("longtime"):this._getDateTimeFormatPattern("shorttime")},getDateFormatByDifferences:function(n){var i="";return(n.millisecond&&(i=t.DateTimeFormat.millisecond),(n.hour||n.minute||n.second)&&(i=this._addFormatSeparator(this.getTimeFormat(n.second),i)),n.year&&n.month&&n.day)?this._addFormatSeparator(this._getDateTimeFormatPattern("shortdate"),i):n.year&&n.month?t.DateTimeFormat.monthandyear:n.year?t.DateTimeFormat.year:n.month&&n.day?this._addFormatSeparator(this._getDateTimeFormatPattern("monthandday"),i):n.month?t.DateTimeFormat.month:n.day?this._addFormatSeparator("dddd, dd",i):i},getDateFormatByTicks:function(n){var f,t,u,i,e;if(n.length>1)for(t=r.getDatesDifferences(n[0],n[1]),i=1;i<n.length-1;i++)u=r.getDatesDifferences(n[i],n[i+1]),t.count<u.count&&(t=u);else t={year:!0,month:!0,day:!0,hour:n[0].getHours()>0,minute:n[0].getMinutes()>0,second:n[0].getSeconds()>0};return f=this.getDateFormatByDifferences(t)},getDateFormatByTickInterval:function(n,t,i){var e,u,f,s={quarter:"month",week:"day"},o=function(n,t,i){switch(t){case"year":n.month=i;case"quarter":case"month":n.day=i;case"week":case"day":n.hour=i;case"hour":n.minute=i;case"minute":n.second=i;case"second":n.millisecond=i}},h=function(n,t,i){!i.getMilliseconds()&&i.getSeconds()?i.getSeconds()-t.getSeconds()==1&&(n.millisecond=!0,n.second=!1):!i.getSeconds()&&i.getMinutes()?i.getMinutes()-t.getMinutes()==1&&(n.second=!0,n.minute=!1):!i.getMinutes()&&i.getHours()?i.getHours()-t.getHours()==1&&(n.minute=!0,n.hour=!1):!i.getHours()&&i.getDate()>1?i.getDate()-t.getDate()==1&&(n.hour=!0,n.day=!1):i.getDate()===1&&i.getMonth()?i.getMonth()-t.getMonth()==1&&(n.day=!0,n.month=!1):!i.getMonth()&&i.getFullYear()&&i.getFullYear()-t.getFullYear()==1&&(n.month=!0,n.year=!1)};return i=r.isString(i)?i.toLowerCase():i,u=r.getDatesDifferences(n,t),n!==t&&h(u,n>t?t:n,n>t?n:t),f=r.getDateUnitInterval(u),o(u,f,!0),f=r.getDateUnitInterval(i||"second"),o(u,f,!1),u[s[f]||f]=!0,e=this.getDateFormatByDifferences(u)}}}(jQuery,DevExpress),function(n,t){var r=t.Class;t.Color=r.inherit(function(){var f=function(n){this.baseColor=n,this.decode()},t={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"},i=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,process:function(n){return[parseInt(n[1],10),parseInt(n[2],10),parseInt(n[3],10)]}},{re:/^(\w{2})(\w{2})(\w{2})$/,process:function(n){return[parseInt(n[1],16),parseInt(n[2],16),parseInt(n[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,process:function(n){return[parseInt(n[1]+n[1],16),parseInt(n[2]+n[2],16),parseInt(n[3]+n[3],16)]}}],e=function(){var r=this.baseColor,f,u,s,o,e;r.charAt(0)==="#"&&(r=r.substr(1,6)),r=r.toLowerCase(),r=r.replace(/ /g,"");for(f in t)t.hasOwnProperty(f)&&r===f&&(r=t[f]);for(u=0;u<i.length;u++)if(s=i[u].re,o=s.exec(r),o){e=i[u].process(o),this.r=e[0],this.g=e[1],this.b=e[2],this.ok=!0;break}this.r=n(this.r),this.g=n(this.g),this.b=n(this.b)},n=function(n){return n<0||isNaN(n)?0:n>255?255:n},r=function(n){var t=n.toString(16);return t.length===1?"0"+t:t},u=function(n,t,i){return"#"+r(n)+r(t)+r(i)},o=function(){return u(this.r,this.g,this.b)},s=function(t){return t=t||10,u(n(this.r+t),n(this.g+t),n(this.b+t))},h=function(t){return t=t||10,u(n(this.r-t),n(this.g-t),n(this.b-t))};return{ctor:f,highlight:s,darken:h,decode:e,toHex:o}}())}(jQuery,DevExpress),function(n,t,i){var o=!!window.ko,s=function(n){return n.replace(/\[/g,".").replace(/\]/g,"")},u=function(n){return o?ko.utils.unwrapObservable(n):n},h=function(n){return o&&ko.isObservable(n)},c=function(n,t,i){var r=n[t];h(r)?r(i):n[t]=i},f=function(t){if(arguments.length>1&&(t=n.makeArray(arguments)),!t||t==="this")return function(n){return n};if(n.isFunction(t))return t;if(n.isArray(t))return a(t);t=s(t);var i=t.split(".");return function(t,r){r=r||{};var f=u(t);return n.each(i,function(){if(!f)return!1;var t=u(f[this]);n.isFunction(t)&&!r.functionsAsIs&&(t=t.call(f)),f=t}),f}},a=function(t){var r={};return n.each(t,function(){r[this]=f(this)}),function(t){var u={};return n.each(r,function(n){var o=this(t),f,e,s,r;if(o!==i){for(f=u,e=n.split("."),s=e.length-1,r=0;r<s;r++)f=f[e[r]]={};f[e[r]]=o}}),u}},v=function(t){if(!t||t==="this")throw Error("Cannot assign to self");t=s(t);var e=t.lastIndexOf("."),o=f(t.substr(0,e)),r=t.substr(1+e);return function(t,f,e){e=e||{};var l=o(t,{functionsAsIs:e.functionsAsIs}),s=l[r];e.functionsAsIs||!n.isFunction(s)||h(s)?(s=u(s),e.merge&&n.isPlainObject(f)&&(s===i||n.isPlainObject(s))?(s||c(l,r,{}),n.extend(!0,u(l[r]),f)):c(l,r,f)):l[r](f)}},y=function(n){return[n[0],n.length<3?"=":n[1].toLowerCase(),n.length<2?!0:n[n.length-1]]},p=function(t){return n.isArray(t)||(t=[t]),n.map(t,function(t){return{selector:n.isFunction(t)||typeof t=="string"?t:t.field||t.selector,desc:!!(t.desc||String(t.dir).charAt(0).toLowerCase()==="d")}})},l=t.Class.inherit({ctor:function(n){n&&(n=String(n)),this._value=this._normalize(n||this._generate())},_normalize:function(n){for(n=n.replace(/[^a-f0-9]/ig,"").toLowerCase();n.length<32;)n+="0";return[n.substr(0,8),n.substr(8,4),n.substr(12,4),n.substr(16,4),n.substr(20)].join("-")},_generate:function(){for(var t="",n=0;n<32;n++)t+=Math.round(Math.random()*16).toString(16);return t},toString:function(){return this._value},valueOf:function(){return this._value},toJSON:function(){return this._value}}),r=function(n,t){return n instanceof Date?n.getTime():n instanceof l?n.valueOf():!t&&typeof n=="string"?n.toLowerCase():n},w=function(t,i,u){var e,o,f;if(n.isArray(t)){for(e=n.map(i,function(n,t){return t}),f=0;f<e.length;f++)if(o=e[f],r(i[o],!0)!=r(u[o],!0))return!1;return!0}return r(i,!0)==r(u,!0)},b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",k=function(t){var r,i;for(n.isArray(t)||(t=d(String(t))),r="",i=0;i<t.length;i+=3){var e=t[i],u=t[i+1],f=t[i+2];r+=n.map([e>>2,(e&3)<<4|u>>4,isNaN(u)?64:(u&15)<<2|f>>6,isNaN(f)?64:f&63],function(n){return b.charAt(n)}).join("")}return r},d=function(n){for(var i=[],t,r=0;r<n.length;r++)t=n.charCodeAt(r),t<128?i.push(t):t<2048?i.push(192+(t>>6),128+(t&63)):t<65536?i.push(224+(t>>12),128+(t>>6&63),128+(t&63)):t<2097152&&i.push(240+(t>>18),128+(t>>12&63),128+(t>>6&63),128+(t&63));return i},g=function(){var n={timeout:"Network connection timeout",error:"Unspecified network error",parsererror:"Unexpected server response"},t=function(t){var i=n[t];return i?i:t};return function(n,i){return n.status<400?t(i):n.statusText}}(),e=t.data={utils:{compileGetter:f,compileSetter:v,normalizeBinaryCriterion:y,normalizeSortingInfo:p,toComparable:r,keysEqual:w,errorMessageFromXhr:g},Guid:l,base64_encode:k,queryImpl:{},queryAdapters:{},query:function(){var t=n.isArray(arguments[0])?"array":"remote";return e.queryImpl[t].apply(this,arguments)},errorHandler:null,_handleError:function(n){e.errorHandler&&e.errorHandler(n)}}}(jQuery,DevExpress),function(n,t,i){var a=t.Class,u=t.data,c=u.queryImpl,f=u.utils.compileGetter,r=u.utils.toComparable,e=a.inherit({toArray:function(){var n=[];for(this.reset();this.next();)n.push(this.current());return n},countable:function(){return!1}}),o=e.inherit({ctor:function(n){this.array=n,this.index=-1},next:function(){return this.index+1<this.array.length?(this.index++,!0):!1},current:function(){return this.array[this.index]},reset:function(){this.index=-1},toArray:function(){return this.array.slice(0)},countable:function(){return!0},count:function(){return this.array.length}}),s=e.inherit({ctor:function(n){this.iter=n},next:function(){return this.iter.next()},current:function(){return this.iter.current()},reset:function(){return this.iter.reset()}}),h=e.inherit({ctor:function(n,t,i){this.iter=n,this.rules=[{getter:t,desc:i}]},thenBy:function(n,t){var i=new h(this.sortedIter||this.iter,n,t);return this.sortedIter||(i.rules=this.rules.concat(i.rules)),i},next:function(){return this._ensureSorted(),this.sortedIter.next()},current:function(){return this._ensureSorted(),this.sortedIter.current()},reset:function(){delete this.sortedIter},countable:function(){return this.sortedIter||this.iter.countable()},count:function(){return this.sortedIter?this.sortedIter.count():this.iter.count()},_ensureSorted:function(){this.sortedIter||(n.each(this.rules,function(){this.getter=f(this.getter)}),this.sortedIter=new o(this.iter.toArray().sort(n.proxy(this._compare,this))))},_compare:function(n,t){var i,s;if(n===t)return 0;for(i=0,s=this.rules.length;i<s;i++){var e=this.rules[i],u=r(e.getter(n)),o=r(e.getter(t)),f=e.desc?-1:1;if(u<o)return-f;if(u>o)return f;if(u!==o)return u?f:-f}return 0}}),l=function(){var e=function(t){var u=[],i=["return function(d) { return "],f=0,r=!1;return n.each(t,function(){n.isArray(this)||n.isFunction(this)?(r&&i.push(" && "),u.push(l(this)),i.push("op[",f,"](d)"),f++,r=!0):(i.push(/and|&/i.test(this)?" && ":" || "),r=!1)}),i.push(" }"),new Function("op",i.join(""))(u)},i=function(n){return t.utils.isDefined(n)?n.toString():""},o=function(n){n=u.utils.normalizeBinaryCriterion(n);var e=f(n[0]),o=n[1],t=n[2];t=r(t);switch(o.toLowerCase()){case"=":return function(n){return r(e(n))==t};case"<>":return function(n){return r(e(n))!=t};case">":return function(n){return r(e(n))>t};case"<":return function(n){return r(e(n))<t};case">=":return function(n){return r(e(n))>=t};case"<=":return function(n){return r(e(n))<=t};case"startswith":return function(n){return r(i(e(n))).indexOf(t)===0};case"endswith":return function(n){var u=r(i(e(n)));return u.lastIndexOf(t)===u.length-i(t).length};case"contains":return function(n){return r(i(e(n))).indexOf(t)>-1};case"notcontains":return function(n){return r(i(e(n))).indexOf(t)===-1}}};return function(t){return n.isFunction(t)?t:n.isArray(t[0])?e(t):o(t)}}(),v=s.inherit({ctor:function(n,t){this.callBase(n),this.criteria=l(t)},next:function(){while(this.iter.next())if(this.criteria(this.current()))return!0;return!1}}),y=e.inherit({ctor:function(n,t){this.iter=n,this.getter=t},next:function(){return this._ensureGrouped(),this.groupedIter.next()},current:function(){return this._ensureGrouped(),this.groupedIter.current()},reset:function(){delete this.groupedIter},countable:function(){return!!this.groupedIter},count:function(){return this.groupedIter.count()},_ensureGrouped:function(){var r,t;if(!this.groupedIter){var i={},e=[],u=this.iter,s=f(this.getter);for(u.reset();u.next();)r=u.current(),t=s(r),t in i?i[t].push(r):(i[t]=[r],e.push(t));this.groupedIter=new o(n.map(e,function(n){return{key:n,items:i[n]}}))}}}),p=s.inherit({ctor:function(n,t){this.callBase(n),this.getter=f(t)},current:function(){return this.getter(this.callBase())},countable:function(){return this.iter.countable()},count:function(){return this.iter.count()}}),w=s.inherit({ctor:function(n,t,i){this.callBase(n),this.skip=Math.max(0,t),this.take=Math.max(0,i),this.pos=0},next:function(){if(this.pos>=this.skip+this.take)return!1;while(this.pos<this.skip&&this.iter.next())this.pos++;return this.pos++,this.iter.next()},reset:function(){this.callBase(),this.pos=0},countable:function(){return this.iter.countable()},count:function(){return Math.min(this.iter.count()-this.skip,this.take)}});c.array=function(t,r){r=r||{},t instanceof e||(t=new o(t));var b=function(n){var t=r.errorHandler;t&&t(n),u._handleError(n)},s=function(r,u,f){var o=n.Deferred().fail(b),e;try{for(t.reset(),arguments.length<2&&(u=arguments[0],r=t.next()?t.current():i),e=r;t.next();)e=u(e,t.current());o.resolve(f?f(e):e)}catch(s){o.reject(s)}return o.promise()},k=function(i){return n.isFunction(i)||n.isArray(i)||(i=n.makeArray(arguments)),l(new p(t,i))},a=function(n){return k(f(n))},l=function(n){return c.array(n,r)};return{toArray:function(){return t.toArray()},enumerate:function(){var i=n.Deferred().fail(b);try{i.resolve(t.toArray())}catch(r){i.reject(r)}return i.promise()},sortBy:function(n,i){return l(new h(t,n,i))},thenBy:function(n,i){if(t instanceof h)return l(t.thenBy(n,i));throw Error();},filter:function(i){return n.isArray(i)||(i=n.makeArray(arguments)),l(new v(t,i))},slice:function(n,r){return r===i&&(r=Number.MAX_VALUE),l(new w(t,n,r))},select:k,groupBy:function(n,i){return l(new y(t,n,i))},aggregate:s,count:function(){if(t.countable()){var i=n.Deferred().fail(b);try{i.resolve(t.count())}catch(r){i.reject(r)}return i.promise()}return s(0,function(n){return 1+n})},sum:function(n){return n?a(n).sum():s(0,function(n,t){return n+t})},min:function(n){return n?a(n).min():s(function(n,t){return t<n?t:n})},max:function(n){return n?a(n).max():s(function(n,t){return t>n?t:n})},avg:function(n){if(n)return a(n).avg();var t=0;return s(0,function(n,i){return t++,n+i},function(n){return t?n/t:i})}}}}(jQuery,DevExpress),function(n,t){var r=t.data,u=r.queryImpl;u.remote=function(t,i,f){f=f||[],i=i||{};var o=function(n,t){return{name:n,args:t}},s=function(e){var o=n.Deferred(),h,c,s,l,a=function(n){var t=i.errorHandler;t&&t(n),r._handleError(n),o.reject(n)};try{for(h=i.adapter||"odata",n.isFunction(h)||(h=r.queryAdapters[h]),c=h(i),s=[].concat(f).concat(e);s.length;){if(l=s[0],String(l.name)!=="enumerate"&&(!c[l.name]||c[l.name].apply(c,l.args)===!1))break;s.shift()}c.exec(t).done(function(t){if(s.length){var r=u.array(t,{errorHandler:i.errorHandler});n.each(s,function(){r=r[this.name].apply(r,this.args)}),r.done(n.proxy(o.resolve,o)).fail(n.proxy(o.reject,o))}else o.resolve(t)}).fail(a)}catch(v){a(v)}return o.promise()},e={};return n.each(["sortBy","thenBy","filter","slice","select","groupBy"],function(){var n=this;e[n]=function(){return u.remote(t,i,f.concat(o(n,arguments)))}}),n.each(["count","min","max","sum","avg","aggregate","enumerate"],function(){var n=this;e[n]=function(){return s.call(this,o(n,arguments))}}),e}}(jQuery,DevExpress),function(n,t,i){var f=t.data,o=f.Guid,h="application/json;odata=verbose",l=function(t,i){var u;t=n.extend({method:"get",url:"",params:{},payload:null,headers:{}},t),i=i||{},u=i.beforeSend,u&&u(t);var o=(t.method||"get").toLowerCase(),r=o==="get",f=r&&i.jsonp,s=n.extend({},t.params),c=r?s:JSON.stringify(t.payload),l=!r&&n.param(s),e=t.url,a=!r&&h;return l&&(e+=(e.indexOf("?")>-1?"&":"?")+l),f&&(c.$format="json"),{url:e,data:c,dataType:f?"jsonp":"json",jsonp:f&&"$callback",type:o,timeout:3e4,headers:t.headers,contentType:a,accepts:{json:[h,"text/plain"].join()},xhrFields:{withCredentials:i.withCredentials}}},s=function(t,i){var r=n.Deferred();return n.ajax(l(t,i)).always(function(t,u){var f=y(t,u),e=f.error,o=f.data,h=f.nextUrl;e?r.reject(e):i.countOnly?r.resolve(f.count):h?s({url:h},i).fail(n.proxy(r.reject,r)).done(function(n){r.resolve(o.concat(n))}):r.resolve(o)}),r.promise()},a=function(n){var t,i=n;for(("message"in n)&&(t=n.message.value?n.message.value:n.message);i=i.innererror||i.internalexception;)if(t=i.message,i.internalexception&&t.indexOf("inner exception")===-1)break;return t},v=function(t,i){var o;if(i==="nocontent")return null;var r=200,u="Unknown error",s,e=t;if(i!=="success"){r=t.status,u=f.utils.errorMessageFromXhr(t,i);try{e=n.parseJSON(t.responseText)}catch(h){}}return(o=e&&e.error,o)?(u=a(o)||u,r===200&&(r=500),e.error.code&&(r=Number(e.error.code)),n.extend(Error(u),{httpStatus:r,errorDetails:o})):r!==200?n.extend(Error(u),{httpStatus:r}):void 0},y=function(t,i){var u=v(t,i),r;return u?{error:u}:n.isPlainObject(t)?(r=t.d,!r)?{error:Error("Malformed or unsupported JSON response received")}:(r=r.results||r,c(r),{data:r,nextUrl:t.d.__next,count:t.d.__count}):{data:t}},u=t.Class.inherit({ctor:function(n){this._value=n},valueOf:function(){return this._value}}),p=function(){var n=function(n){return n=String(n),n.length<2&&(n="0"+n),n};return function(t){var i=["datetime'",t.getUTCFullYear(),"-",n(t.getUTCMonth()+1),"-",n(t.getUTCDate())];return(t.getUTCHours()||t.getUTCMinutes()||t.getUTCSeconds()||t.getUTCMilliseconds())&&(i.push("T",n(t.getUTCHours()),":",n(t.getUTCMinutes()),":",n(t.getUTCSeconds())),t.getUTCMilliseconds()&&i.push(".",t.getUTCMilliseconds())),i.push("'"),i.join("")}}(),r=function(n){return n instanceof u?n.valueOf():n.replace(/\./g,"/")},e=function(n){return n instanceof Date?p(n):n instanceof o?"guid'"+n+"'":n instanceof u?n.valueOf():typeof n=="string"?"'"+n.replace(/'/g,"''")+"'":String(n)},w=function(t){if(n.isPlainObject(t)){var i=[];return n.each(t,function(n,t){i.push(r(n)+"="+e(t))}),i.join()}return e(t)},c=function(t){n.each(t,function(n,i){if(i!==null&&typeof i=="object")c(i);else if(typeof i=="string"){var r=i.match(/^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/);r&&(t[n]=new Date(Number(r[1])+r[2]*6e4))}})},b={String:function(n){return n+""},Int32:function(n){return~~n},Int64:function(n){return n instanceof u?n:new u(n+"L")},Guid:function(n){return n instanceof o?n:new o(n)}},k=function(){var t=function(n){return function(t,i,r){r.push(t," ",n," ",i)}},i=function(n,t){return function(i,r,u){t?u.push(n,"(",r,",",i,")"):u.push(n,"(",i,",",r,")")}},o={"=":t("eq"),"<>":t("ne"),">":t("gt"),">=":t("ge"),"<":t("lt"),"<=":t("le"),startswith:i("startswith"),endswith:i("endswith"),contains:i("substringof",!0),notcontains:i("not substringof",!0)},s=function(n,t){n=f.utils.normalizeBinaryCriterion(n),o[n[1]](r(n[0]),e(n[2]),t)},h=function(t,i){var r=!1;n.each(t,function(){n.isArray(this)?(r&&i.push(" and "),i.push("("),u(this,i),i.push(")"),r=!0):(i.push(/and|&/i.test(this)?" and ":" or "),r=!1)})},u=function(t,i){n.isArray(t[0])?h(t,i):s(t,i)};return function(n){var t=[];return u(n,t),t.join("")}}(),d=function(t){var e=[],u=[],f,o,h,c,l=function(){return o||h!==i},a=function(n,t,i){if(l()||typeof n!="string")return!1;i&&(e=[]);var u=r(n);t&&(u+=" desc"),e.push(u)},v=function(){var u={};return t.expand&&n.each(n.makeArray(t.expand),function(){u[r(this)]=1}),f&&n.each(f,function(){var n=this.split(".");n.length<2||(n.pop(),u[r(n.join("."))]=1)}),n.map(u,function(n,t){return t}).join()||i},y=function(){var n={};return c||(e.length&&(n.$orderby=e.join(",")),o&&(n.$skip=o),h!==i&&(n.$top=h),f&&(n.$select=r(f.join())),n.$expand=v()),u.length&&(n.$filter=k(u.length<2?u[0]:u)),c&&(n.$inlinecount="allpages",n.$top=0),n};return{exec:function(i){return s({url:i,params:n.extend(y(),t&&t.params)},{beforeSend:t.beforeSend,jsonp:t.jsonp,withCredentials:t.withCredentials,countOnly:c})},sortBy:function(n,t){return a(n,t,!0)},thenBy:function(n,t){return a(n,t,!1)},slice:function(n,t){if(l())return!1;o=n,h=t},filter:function(t){if(l()||n.isFunction(t))return!1;n.isArray(t)||(t=n.makeArray(arguments)),u.length&&u.push("and"),u.push(t)},select:function(t){if(f||n.isFunction(t))return!1;n.isArray(t)||(t=n.makeArray(arguments)),f=t},count:function(){c=!0}}};n.extend(!0,f,{EdmLiteral:u,utils:{odata:{sendRequest:s,serializePropName:r,serializeValue:e,serializeKey:w,keyConverters:b}},queryAdapters:{odata:d}})}(jQuery,DevExpress),function(n,t){var o=t.Class,r=t.abstract,u=t.data,f=u.utils.normalizeSortingInfo,s=["loading","loaded","modifying","modified","inserting","inserted","updating","updated","removing","removed"],e=function(t,i){return t=t.groupBy(i[0].selector),i.length>1&&(t=t.select(function(t){return n.extend({},t,{items:e(u.query(t.items),i.slice(1)).toArray()})})),t};u.Store=o.inherit({ctor:function(t){var i=this;t=t||{},n.each(s,function(){var r=i[this]=n.Callbacks();this in t&&r.add(t[this])}),this._key=t.key,this._keyGetter=u.utils.compileGetter(this._key),this._errorHandler=t.errorHandler},customLoadOptions:function(){return null},key:function(){return this._key},keyOf:function(n){return this._keyGetter(n)},_requireKey:function(){if(!this._key)throw Error("Key expression is required for this operation");},load:function(n){var t=this;return n=n||{},this.loading.fire(n),this._loadImpl(n).done(function(n){t.loaded.fire(n)})},_loadImpl:function(t){var o=t.filter,u=t.sort,s=t.select,r=t.group,h=t.skip,c=t.take,i=this.createQuery(t);return o&&(i=i.filter(o)),r&&(r=f(r)),u&&(u=f(u),r&&(u=r.concat(u)),n.each(u,function(n){i=i[n?"thenBy":"sortBy"](this.selector,this.desc)})),r&&(i=e(i,r)),(c||h)&&(i=i.slice(h||0,c)),s&&(i=i.select(s)),i.enumerate()},createQuery:r,byKey:function(n,t){return this._addFailHandlers(this._byKeyImpl(n,t))},_byKeyImpl:r,insert:function(n){var t=this;return t.modifying.fire(),t.inserting.fire(n),t._addFailHandlers(t._insertImpl(n).done(function(n,i){t.inserted.fire(n,i),t.modified.fire()}))},_insertImpl:r,update:function(n,t){var i=this;return i.modifying.fire(),i.updating.fire(n,t),i._addFailHandlers(i._updateImpl(n,t).done(function(n,t){i.updated.fire(n,t),i.modified.fire()}))},_updateImpl:r,remove:function(n){var t=this;return t.modifying.fire(),t.removing.fire(n),t._addFailHandlers(t._removeImpl(n).done(function(n){t.removed.fire(n),t.modified.fire()}))},_removeImpl:r,_addFailHandlers:function(n){return n.fail(this._errorHandler,u._handleError)}})}(jQuery,DevExpress),function(n,t,i){var r=t.data,e=r.Guid,u=function(){var i=n.Deferred();return i.resolve.apply(i,arguments).promise()},f=function(){var i=n.Deferred();return i.reject.apply(i,arguments).promise()};r.ArrayStore=r.Store.inherit({ctor:function(t){t=n.isArray(t)?{data:t}:t||{},this.callBase(t),this._array=t.data||[]},createQuery:function(){return r.query(this._array,{errorHandler:this._errorHandler})},_byKeyImpl:function(n){return u(this._array[this._indexByKey(n)])},_insertImpl:function(t){var s=this.key(),r,o={};if(n.extend(o,t),s){if(r=this.keyOf(o),r===i||typeof r=="object"&&n.isEmptyObject(r)){if(n.isArray(s))throw Error("Compound keys cannot be auto-generated");r=o[s]=String(new e)}else if(this._array[this._indexByKey(r)]!==i)return f(Error("Attempt to insert an item with the duplicate key"))}else r=o;return this._array.push(o),u(t,r)},_updateImpl:function(t,i){var r,e;if(this.key()){if(e=this._indexByKey(t),e<0)return f(Error("Data item not found"));r=this._array[e]}else r=t;return n.extend(!0,r,i),u(t,i)},_removeImpl:function(n){var t=this._indexByKey(n);return t>-1&&this._array.splice(t,1),u(n)},_indexByKey:function(n){for(var t=0,i=this._array.length;t<i;t++)if(r.utils.keysEqual(this.key(),this._keyGetter(this._array[t]),n))return t;return-1}})}(jQuery,DevExpress),function(n,t){var f=t.Class,r=t.abstract,u=t.data,e=f.inherit({ctor:function(t,i){var u,f,r;if(this._store=t,this._dirty=!1,u=this._immediate=i.immediate,f=Math.max(100,i.flushInterval||1e4),!u){r=n.proxy(this.save,this),setInterval(r,f);n(window).on("beforeunload",r);window.cordova&&document.addEventListener("pause",r,!1)}},notifyChanged:function(){this._dirty=!0,this._immediate&&this.save()},load:function(){this._store._array=this._loadImpl(),this._dirty=!1},save:function(){this._dirty&&(this._saveImpl(this._store._array),this._dirty=!1)},_loadImpl:r,_saveImpl:r}),o=e.inherit({ctor:function(n,t){this.callBase(n,t);var i=t.name;if(!i)throw Error("Name is required");this._key="dx-data-localStore-"+i},_loadImpl:function(){var n=localStorage.getItem(this._key);return n?JSON.parse(n):[]},_saveImpl:function(n){n.length?localStorage.setItem(this._key,JSON.stringify(n)):localStorage.removeItem(this._key)}}),s={dom:o};u.LocalStore=u.ArrayStore.inherit({ctor:function(n){n=typeof n=="string"?{name:n}:n||{},this.callBase(n),this._backend=new s[n.backend||"dom"](this,n),this._backend.load()},clear:function(){this._array=[],this._backend.notifyChanged()},_insertImpl:function(t){var i=this._backend;return this.callBase(t).done(n.proxy(i.notifyChanged,i))},_updateImpl:function(t,i){var r=this._backend;return this.callBase(t,i).done(n.proxy(r.notifyChanged,r))},_removeImpl:function(t){var i=this._backend;return this.callBase(t).done(n.proxy(i.notifyChanged,i))}})}(jQuery,DevExpress),function(n,t){var h=t.Class,r=t.data,u=r.utils.odata,f=function(t){if(!t)return t;var i={};return n.each(t,function(n,t){i[n]=u.serializeValue(t)}),i},e=function(n,t){var i=u.keyConverters[n];if(!i)throw Error("Unknown key type: "+n);return i(t)},o={_extractServiceOptions:function(n){n=n||{},this._url=String(n.url).replace(/\/+$/,""),this._beforeSend=n.beforeSend,this._jsonp=n.jsonp,this._withCredentials=n.withCredentials},_sendRequest:function(n,t,i,r){return u.sendRequest({url:n,method:t,params:i||{},payload:r},{beforeSend:this._beforeSend,jsonp:this._jsonp,withCredentials:this._withCredentials})}},s=r.Store.inherit({ctor:function(n){this.callBase(n),this._extractServiceOptions(n),this._name=n.name,this._keyType=n.keyType},customLoadOptions:function(){return["expand","customQueryParams"]},_byKeyImpl:function(t,i){var r={};return i&&i.expand&&(r.$expand=n.map(n.makeArray(i.expand),u.serializePropName).join()),this._sendRequest(this._byKeyUrl(t),"GET",r)},createQuery:function(n){return n=n||{},r.query(this._url,{beforeSend:this._beforeSend,errorHandler:this._errorHandler,jsonp:this._jsonp,withCredentials:this._withCredentials,params:f(n.customQueryParams),expand:n.expand})},_insertImpl:function(t){this._requireKey();var r=this,i=n.Deferred();return n.when(this._sendRequest(this._url,"POST",null,t)).done(function(n){i.resolve(t,r._keyGetter(n))}).fail(n.proxy(i.reject,i)),i.promise()},_updateImpl:function(t,i){var r=n.Deferred();return n.when(this._sendRequest(this._byKeyUrl(t),"MERGE",null,i)).done(function(){r.resolve(t,i)}).fail(n.proxy(r.reject,r)),r.promise()},_removeImpl:function(t){var i=n.Deferred();return n.when(this._sendRequest(this._byKeyUrl(t),"DELETE")).done(function(){i.resolve(t)}).fail(n.proxy(i.reject,i)),i.promise()},_byKeyUrl:function(t){var i=this._keyType;return n.isPlainObject(i)?n.each(i,function(n,i){t[n]=e(i,t[n])}):i&&(t=e(i,t)),this._url+"("+encodeURIComponent(u.serializeKey(t))+")"}}).include(o),c=h.inherit({ctor:function(t){var i=this;i._extractServiceOptions(t),i._errorHandler=t.errorHandler,n.each(t.entities||[],function(r,u){i[r]=new s(n.extend({},t,{url:i._url+"/"+encodeURIComponent(u.name||r)},u))})},get:function(n,t){return this.invoke(n,t,"GET")},invoke:function(t,i,u){u=u||"POST";var e=n.Deferred();return n.when(this._sendRequest(this._url+"/"+encodeURIComponent(t),u,f(i))).done(function(n){n&&t in n&&(n=n[t]),e.resolve(n)}).fail([this._errorHandler,r._handleError,n.proxy(e.reject,e)]),e.promise()},objectLink:function(n,t){var i=this[n];if(!i)throw Error("Unknown entity name or alias: "+n);return{__metadata:{uri:i._byKeyUrl(t)}}}}).include(o);n.extend(r,{ODataStore:s,ODataContext:c})}(jQuery,DevExpress),function(n,t){function r(n){return function(t,i){t&&t.getResponseHeader?n.reject(Error(u.utils.errorMessageFromXhr(t,i))):n.reject.apply(n,arguments)}}function f(n){return"_customize"+t.inflector.camelize(n,!0)}function e(n){return"_"+n+"Path"}var u=t.data;u.RestStore=u.Store.inherit({ctor:function(t){var i=this;i.callBase(t),t=t||{},i._url=String(t.url).replace(/\/+$/,""),i._jsonp=t.jsonp,i._withCredentials=t.withCredentials,n.each(["Load","Insert","Update","Remove","ByKey","Operation"],function(){var n=t["customize"+this];n&&(i[f(this)]=n)}),n.each(["load","insert","update","remove","byKey"],function(){var n=t[this+"Path"];n&&(i[e(this)]=n)})},_loadImpl:function(t){var i=n.Deferred(),u={url:this._formatUrlNoKey("load"),type:"GET"};return n.when(this._createAjax(u,"load",t)).done(n.proxy(i.resolve,i)).fail(r(i)),this._addFailHandlers(i.promise())},createQuery:function(){throw Error("Not supported");},_insertImpl:function(t){var i=n.Deferred(),u=this,f={url:this._formatUrlNoKey("insert"),type:"POST",contentType:"application/json",data:JSON.stringify(t)};return n.when(this._createAjax(f,"insert")).done(function(n){i.resolve(t,u.key()&&u._keyGetter(n))}).fail(r(i)),i.promise()},_updateImpl:function(t,i){var u=n.Deferred(),f={url:this._formatUrlWithKey("update",t),type:"PUT",contentType:"application/json",data:JSON.stringify(i)};return n.when(this._createAjax(f,"update")).done(function(){u.resolve(t,i)}).fail(r(u)),u.promise()},_removeImpl:function(t){var i=n.Deferred(),u={url:this._formatUrlWithKey("remove",t),type:"DELETE"};return n.when(this._createAjax(u,"remove")).done(function(){i.resolve(t)}).fail(r(i)),i.promise()},_byKeyImpl:function(t){var i=n.Deferred(),u={url:this._formatUrlWithKey("byKey",t),type:"GET"};return n.when(this._createAjax(u,"byKey")).done(function(n){i.resolve(n)}).fail(r(i)),i.promise()},_createAjax:function(t,i,r){function o(n){return"done"in n&&"fail"in n}var e,u;if(this._jsonp&&t.type==="GET"?t.dataType="jsonp":n.extend(!0,t,{xhrFields:{withCredentials:this._withCredentials}}),e=this[f("operation")],e&&(u=e(t,i,r),u)){if(o(u))return u;t=u}if(e=this[f(i)],e&&(u=e(t,r),u)){if(o(u))return u;t=u}return n.ajax(t)},_formatUrlNoKey:function(t){var r=this._url,i=this[e(t)];return i?n.isFunction(i)?i(r):r+"/"+i:r},_formatUrlWithKey:function(t,i){var u=this._url,r=this[e(t)];return r?n.isFunction(r)?r(u,i):u+"/"+r+"/"+encodeURIComponent(i):u+"/"+encodeURIComponent(i)}})}(jQuery,DevExpress),function(n,t){var r=t.data;r.SimpleStore=r.Store.inherit({ctor:function(n){var t=this;t.callBase(n),n=n||{},t.changed=n.changed,t.userLoadCallback=n.load,t.userLookupCallback=n.lookup},_loadImpl:function(t){var r,i;if(!this.userLoadCallback)throw new Error("Load callback was not defined");return r={refresh:t.refresh},r.searchString=t.searchString,i=this.userLoadCallback(r),i||(i=(new n.Deferred).resolve([])),n.isArray(i)&&(i=(new n.Deferred).resolve(i)),i},lookup:function(t,i,r){if(!this.userLookupCallback)throw new Error("Lookup callback was not defined");var u=this.userLookupCallback(t,i,r);return n.isArray(u)&&(u=u[0]),u||(u=(new n.Deferred).resolve([])),u.done||(u=(new n.Deferred).resolve(u)),u}})}(jQuery,DevExpress),function(n,t,i){var r=t.data,c=t.Class,s="__key__",l=n.Deferred().resolve([]).promise(),f=c.inherit({ctor:function(t){t=t||{};var u=t.store;n.isArray(u)&&(u=new r.ArrayStore(u)),this._store=u,this._storeLoadOptions=this._extractLoadOptions(t),this._mapFunc=t.map,this._postProcessFunc=t.postProcess,this._pageIndex=0,this._pageSize=t.pageSize!==i?t.pageSize:20,this._items=[],this._updateMode=t.updateMode||"item",this._isLoaded=!1,this._preferSync=t._preferSync,this._paginate=t.paginate,this._paginate===i&&(this._paginate=!this._isGrouped()),this._isLastPage=!this._paginate,this.changed=n.Callbacks(),this.loadError=n.Callbacks(),u.updated.add(this._storeUpdatedHandler=n.proxy(this._handleStoreUpdated,this)),u.inserted.add(this._storeInsertedHandler=n.proxy(this._handleStoreInserted,this)),u.removed.add(this._storeRemovedHandler=n.proxy(this._handleStoreRemoved,this)),this._customizeFilters=n.Callbacks()},dispose:function(){this.changed.empty(),this.loadError.empty(),this._store.updated.remove(this._storeUpdatedHandler),delete this._storeUpdatedHandler,this._store.inserted.remove(this._storeInsertedHandler),delete this._storeInsertedHandler,this._store.removed.remove(this._storeRemovedHandler),delete this._storeRemovedHandler,delete this._store,this._disposed=!0},_extractLoadOptions:function(t){var r={},i=["sort","filter","select","group"],u=this._store.customLoadOptions();return u&&(i=i.concat(u)),n.each(i,function(){r[this]=t[this]}),r},loadOptions:function(){return this._storeLoadOptions},_accessStoreLoadOption:function(n,t){var i=this._storeLoadOptions;if(arguments.length<2)return i[n];i[n]=t,this.reload()},filter:function(t){if(!arguments.length)return this._accessStoreLoadOption("filter");t&&!n.isArray(t)&&(t=n.makeArray(arguments)),this._accessStoreLoadOption("filter",t)},clearFilter:function(){this.filter(null)},sortBy:function(n){arguments.length>1&&(n={selector:arguments[0],desc:arguments[1]}),this._accessStoreLoadOption("sort",n)},clearSort:function(){this.sortBy(null)},store:function(){return this._store},key:function(){return this._store&&this._store.key()},_isGrouped:function(){return!!this._storeLoadOptions.group},_assignPageIndex:function(n){this._pageIndex!==n&&(this._pageIndex=n,this.load())},reload:function(n){return this._pageIndex=0,this._isLastPage=!this._paginate,this._loadCore(n)},load:function(n){return this._loadCore(n)},isLoaded:function(){return this._isLoaded},lookup:function(t){var r=new n.Deferred,i=this,f=t.key,u;return t.lookupExpression=t.lookupExpression||i.key(),this._store.lookup?this._store.lookup(f).done(function(n){if(!i._disposed){var t=i._transformLoadedData(n);r.resolve(t[0])}}):t.lookupExpression&&t.lookupExpression===i.key()?this._loadSingleByKey(f).done(function(n){r.resolve(n)}):(u=i._store.toDataSource(),u.load({searchString:f,searchMethod:"=",searchField:t.lookupExpression,silent:!0}).done(function(){if(!i._disposed){var n=u.items(),t=i._transformLoadedData(n);r.resolve(t[0])}}).always(function(){u.dispose()})),r},nextPage:function(t){if(t=t===i?!0:t,this._isLastPage)return l;this._pageIndex++;var r={append:t};return n.extend(r,this._searchCondition),this._loadCore(r)},_loadCore:function(r){var h;r=r||{};var f=this,o=n.Deferred(),c=f.loadError,e=n.extend(!0,{},f._storeLoadOptions),s;return!this.userDataSource&&(r.searchField||e.searchFilter)&&(e.filter&&!n.isArray(e.filter[0])&&(e.filter=[e.filter]),e.filter=e.filter||[],s=r.searchField?[r.searchField,r.searchMethod||"contains",r.searchString]:e.searchFilter,e.filter.push(s),f._storeLoadOptions.searchFilter=s),this._paginate&&f._pageSize&&n.extend(e,{skip:f._pageIndex*f._pageSize,take:f._pageSize}),n.extend(e,{refresh:!f._paginate||f._pageIndex===0,searchString:r.searchString}),h=function(){return f._disposed?i:n.when(f._store.load(e)).done(function(n){var i=function(){if(!f._disposed){var t=f._items;n=f._transformLoadedData(n),r.append||t.splice(0,t.length),t.push.apply(t,n),(!n.length||!f._paginate||f._pageSize&&n.length<f._pageSize)&&(f._isLastPage=!0),f._isLoaded=!0,r.silent||f.changed.fire(),o.resolve(n)}};f._preferSync?i():t.utils.executeAsync(i)}).fail(n.proxy(o.reject,o))},u.locked()?u.addTask(h):h(),o.promise().fail(n.proxy(c.fire,c))},_loadSingleByKey:function(t){var i=this,r=n.Deferred();return i._disposed||n.when(i._store.byKey(t)).done(function(n){if(!i._disposed){var t=i._transformLoadedData(n);r.resolve(t[0])}}),r.promise()},_transformLoadedData:function(t){var i=this,r;return r=n.map(n.makeArray(t),function(t,r){var f=i._store.keyOf(t),u;return u=i._mapFunc?i._mapFunc(t,r):typeof t=="object"?n.extend({},t):t,typeof t=="object"&&(u[s]=f),u}),i._postProcessFunc&&(r=i._postProcessFunc(r)),r},_localIndexByKey:function(n){for(var i=this._items,f=i.length,e=this._store.key(),u,t=0;t<f;t++)if(u=i[t][s],r.utils.keysEqual(e,u,n))return t;return-1},_handleStoreUpdated:function(n){var t=this,i;switch(t._updateMode){case"full":this.reload();break;case"item":if(t._isGrouped())return;if(i=this._localIndexByKey(n),i<0)return;t._loadSingleByKey(n).done(function(n){t._items.splice(i,1,n),t.changed.fire()})}},_handleStoreInserted:function(n,t){var i=this;switch(i._updateMode){case"full":i.reload();break;case"item":if(i._isGrouped())return;i._loadSingleByKey(t).done(function(n){i._items.push(n),i.changed.fire()})}},_handleStoreRemoved:function(n){var t=this,i;switch(t._updateMode){case"full":t.reload();break;case"item":if(t._isGrouped())return;if(i=this._localIndexByKey(n),i<0)return;t._items.splice(i,1),t.changed.fire()}}}),e=f.inherit({items:function(){return this._items},pageIndex:function(n){if(n===i)return this._pageIndex;this._assignPageIndex(n)},isLastPage:function(){return this._isLastPage}}),o=f.inherit({ctor:function(n,t){this.callBase(n,t);var i=ko.observable();this.changed.add(function(){i.notifySubscribers()}),this.items=ko.computed(function(){return i(),this._items},this),this.pageIndex=ko.computed({read:function(){return i(),this._pageIndex},write:function(n){this._assignPageIndex(n)}},this),this.isLastPage=ko.computed(function(){return i(),this._isLastPage},this)},dispose:function(){this.callBase(),this.items.dispose(),this.pageIndex.dispose(),this.isLastPage.dispose()}}),h,u;r.Store.redefine({toDataSource:function(t,i){var r;if(t=n.extend({store:this},t),n.isFunction(i))r=new i(t);else switch(i){case"simple":r=new e(t);break;default:r=new o(t)}return r&&this.changed&&n.isFunction(this.changed.add)&&this.changed.add(function(){r.reload()}),t.userDataSource&&(r.userDataSource=t.userDataSource),r}}),h=function(n){var i=window.ko?o:e;return new t.data.SimpleStore(n).toDataSource({pageSize:null,userDataSource:!0},i)},u=new function(){var r=[],i=0,u=function(){i++},f=function(){i--,i<1&&(n.each(r,function(){t.enqueue(this)}),r=[])};return{obtain:u,release:f,locked:function(){return i>0},addTask:function(n){r.push(n)}}},n.extend(!0,r,{DataSource:f,KoDataSource:o,SimpleDataSource:e,createDataSource:h,utils:{DataSourceLoadLock:u}})}(jQuery,DevExpress),DevExpress.social={},function(n,t,i){var ut=t.social,r=window.location,ft=window.navigator,p=window.encodeURIComponent,et=window.decodeURIComponent,o=ft.standalone,s=!1,y;if(window.cordova)n(document).on("deviceready",function(){s=!0});var w="dx-facebook-access-token",h="dx-facebook-step1",c="dx-facebook-step2",u=null,b=null,k=n.Callbacks(),f,d=function(){return!!u},ot=function(){return{accessToken:u,expiresIn:u?b:0}},l=ut.Facebook={loginRedirectUrl:"FacebookLoginCallback.html",connectionChanged:k,isConnected:d,getAccessTokenObject:ot,jsonp:!1},st=function(n,t){t=t||{},f=s?"https://www.facebook.com/connect/login_success.html":ht();var u=(t.permissions||[]).join(),i="https://www.facebook.com/dialog/oauth?display=popup&client_id="+n+"&redirect_uri="+p(f)+"&scope="+p(u)+"&response_type=token";o&&e(h,r.href),s?lt(i):ct(i)},ht=function(){var n=r.pathname.split(/\//g);return n.pop(),n.push(l.loginRedirectUrl),r.protocol+"//"+r.host+n.join("/")},ct=function(n){var t=512,i=320,r=(screen.width-t)/2,u=(screen.height-i)/2;window.open(n,null,"width="+t+",height="+i+",toolbar=0,scrollbars=0,status=0,resizable=0,menuBar=0,left="+r+",top="+u)},lt=function(n){var t=window.open(n,"_blank");t.addEventListener("exit",function(){f=null}),t.addEventListener("loadstop",function(n){var i=unescape(n.url);i.indexOf(f)===0&&(t.close(),a(i))})},at=function(){var n=window.opener;o?(e(c,r.href),r.href=v(h)):n&&n.DevExpress&&(n.DevExpress.social.Facebook._processLoginRedirectUrl(r.href),window.close())},a=function(n){var t=vt(n);b=t.expires_in,g(t.access_token),f=null},vt=function(t){var r=t.split("#")[1],u,i;return r?(u=r.split(/&/g),i={},n.each(u,function(){var t=this.split("=");i[t[0]]=et(t[1])}),i):{}},yt=function(){g(null)},g=function(n){n!==u&&(u=n,e(w,n),k.fire(!!n))},nt=function(t,r,f){if(!d())throw Error("Not connected");typeof r!="string"&&(f=r,r=i),r=(r||"get").toLowerCase();var e=n.Deferred(),o=arguments;return n.ajax({url:"https://graph.facebook.com/"+t,type:r,data:n.extend({access_token:u},f),dataType:l.jsonp&&r==="get"?"jsonp":"json"}).done(function(n){n=n||tt(),n.error?e.reject(n.error):e.resolve(n)}).fail(function(i){var u,s;try{if(u=n.parseJSON(i.responseText),s=o[3]||0,s++<3&&u.error.code==190&&u.error.error_subcode==466){setTimeout(function(){nt(t,r,f,s).done(function(n){e.resolve(n)}).fail(function(n){e.reject(n)})},500);return}}catch(h){u=tt()}e.reject(u.error)}),e.promise()},tt=function(){return{error:{message:"Unknown error"}}},it=function(){if(!rt())throw Error("HTML5 sessionStorage or jQuery.cookie plugin is required");},rt=function(){return!!(n.cookie||window.sessionStorage)},e=function(t,i){it(),i=JSON.stringify(i),window.sessionStorage?i===null?sess.removeItem(t):sessionStorage.setItem(t,i):n.cookie(t,i)},v=function(t){it();try{return JSON.parse(window.sessionStorage?sessionStorage.getItem(t):n.cookie(t))}catch(i){return null}};rt()&&(u=v(w)),o&&(y=v(c),y&&(a(y),e(h,null),e(c,null))),n.extend(l,{login:st,logout:yt,handleLoginRedirect:at,_processLoginRedirectUrl:a,api:nt})}(jQuery,DevExpress),function(n,t){var r=t.ui={},f=function(i){var e,r,h;i=n.extend({},i);var c=top!=self,o=t.devices.fromUA(),u=i.allowZoom,f=i.allowPan,s="meta[name=viewport]";if(n(s).length||n("<meta />").attr("name","viewport").appendTo("head"),e=["width=device-width"],r=[],u?r.push("pinch-zoom"):e.push("initial-scale=1.0","maximum-scale=1.0"),f&&r.push("pan-x","pan-y"),f||u?n("html").css("-ms-overflow-style","-ms-autohiding-scrollbar"):n("html, body").css("overflow","hidden"),n(s).attr("content",e.join()),n("html").css("-ms-touch-action",r.join(" ")||"none"),t.support.touch)n(document).on("touchmove",function(n){var t=n.originalEvent.touches.length,i=!u&&t>1,r=!f&&t===1&&!n.originalEvent.isScrollingEvent;(i||r)&&n.preventDefault()});if(navigator.userAgent.match(/IEMobile\/10\.0/)&&(n(document.head).append(n("<style/>").text("@-ms-viewport{ width:auto!important; user-zoom: fixed; max-zoom: 1; min-zoom: 1; }")),n(window).bind("load resize",function(){var r=44,u=21,f=72,i="Notify"in window.external,e=i?r:0,o=i?u:f,s=n(window).width()<n(window).height()?Math.round(screen.availHeight*(document.body.clientWidth/screen.availWidth))-o:Math.round(screen.availWidth*(document.body.clientHeight/screen.availHeight))-e;document.body.style.setProperty("min-height",s+"px","important")})),h=function(){var i=60,r=o.phone,u=!navigator.standalone&&/safari/i.test(navigator.userAgent),f=function(){window.scrollTo(0,1)},t=function(n){return n.is(":input")};return function(e){var o,h=n(e.target),s=n(document.activeElement),c=e.type==="touchstart";if(c){if(t(h))return;t(s)&&s.blur()}else if(t(s))return;r&&u&&(o=n(window).height()+i,n(document.body).height()!==o&&n(document.body).height(o)),f()}}(),!c&&o.ios&&t.devices.iosVersion()[0]<7){n(window).on("load resize touchstart",h);n(function(){n(document.body).on("focusout",function(){var n=window.pageYOffset})})}},e=t.Class.inherit({getTemplateClass:function(){return u},supportDefaultTemplate:function(){return!1},getDefaultTemplate:function(){return null}}),u=t.Class.inherit({ctor:function(t){this._template=this._element=n(t)},render:function(n){return n.append(this._template),this._template},dispose:n.noop});t.registerActionExecutor({designMode:{validate:function(n){!t.designMode||n.context instanceof r.dxScrollable||n.context instanceof r.dxScrollView||(n.canceled=!0)}},gesture:{validate:function(t){var f=t.args,i=t.context,e=f.length&&f[0].component,u=r.gestureUtils.recentGestureOwner();!r.gestureUtils.hasRecent()||t.allowedForGesture||n.isFunction(i)&&u instanceof i||u===i||u===e||(t.canceled=!0)}},disabled:{validate:function(n){if(n.args.length){var t=n.args[0].itemElement||n.args[0].element;t&&t.is(".dx-state-disabled, .dx-state-disabled *")&&(n.canceled=!0)}}}}),n.extend(r,{TemplateProvider:e,Template:u,initViewport:f})}(jQuery,DevExpress),function(n,t){var r=t.ui,e={text:"Ok",clickAction:function(){return!0}},u="dx-dialog",o=u+"-root",s=u+"-content",h=u+"-message",c=u+"-buttons",l=u+"-button",a=function(i){function g(){return f.show(),a.promise()}function p(n){f.hide().done(function(){f._element().remove()}),a.resolve(v||n)}var w=this,v,a;if(!r.dxPopup)throw new Error("DevExpress.ui.dxPopup required.");a=n.Deferred(),i=n.extend(r.optionsByDevice(t.devices.current(),"dxDialog"),i);var b=n(".dx-viewport"),k=n("<div/>").addClass(u).appendTo(b),d=n("<div/>").addClass(h).html(String(i.message)),y=n("<div/>").addClass(c),f=k.dxPopup({title:i.title||w.title,height:"auto",width:function(){var r=n(window).height()>n(window).width(),t=(r?"p":"l")+"Width";return i.hasOwnProperty(t)?i[t]:i.width}}).data("dxPopup");return n.each(i.buttons||[e],function(){var i=n("<div/>").addClass(l).appendTo(y),r=new t.Action(this.clickAction,{context:f});i.dxButton(n.extend(this,{clickAction:function(){v=r.execute(arguments),p()}}))}),f._element().addClass(o),f.content().addClass(s).append(d).append(y),{show:g,hide:p}},f=function(t,i){var u,f=n.isPlainObject(t)?t:{title:i,message:t};return u=r.dialog.custom(f),u.show()},v=function(t,i){var u,f=n.isPlainObject(t)?t:{title:i,message:t,buttons:[{text:"Yes",clickAction:function(){return!0}},{text:"No",clickAction:function(){return!1}}]};return u=r.dialog.custom(f),u.show()},y=function(i,u,e){var s,o=n.isPlainObject(i)?i:{message:i};if(!r.dxToast){f(o.message);return}u&&(o.type=u),e&&(o.displayTime=e),s=n("<div/>").appendTo(n(".dx-viewport")).dxToast(o).data("dxToast"),s.option("hiddenAction",function(){this._element().remove(),new t.Action(o.hiddenAction,{context:this}).execute(arguments)}),s.show()};n.extend(r,{notify:y,dialog:{custom:a,alert:f,confirm:v}})}(jQuery,DevExpress),function(n,t,i){var r=window.ko,h,g;if(r){(function(n){if(n=n.split("."),n[0]<2||n[0]==2&&n[1]<2)throw Error("Your version of KnockoutJS is too old. Please upgrade KnockoutJS to 2.2.0 or later.");})(r.version);var e=t.ui,y=t.inflector,o="data-bind",p="unknown",tt="_",c="dxKoLocks",l="M2O",a="O2M",w="dxKoCreation",s=r.bindingProvider.instance,b=r.jsonExpressionRewriting.parseObjectLiteral,v=n("<div><\/div>"),it=function(n){return n in e&&e[n].subclassOf&&e[n].subclassOf(e.Component)},k=function(n){return n.replace(/^['"]|['"]$/g,"")},d=function(t){var i;if(t=n(t),i=t.attr(o),i){var f=b(i),r=[],u=!1;n.each(f,function(){var n=k(this.key),i="data-"+y.underscore(n);it(n)&&!t.attr(i)?(u=!0,t.attr(i,this.value),r.push({key:n,value:"true"})):r.push(this)}),u&&t.attr(o,n.map(r,function(n){return n.key+": "+n.value}).join(", "))}},rt={_original:s,nodeHasBindings:function(n){return s.nodeHasBindings(n)},getBindings:function(n,t){return d(n),s.getBindings(n,t)}},ut=function(){var n={},t=function(t){return n[t]||0};return{obtain:function(i){n[i]=t(i)+1},release:function(i){var r=t(i);r===1?delete n[i]:n[i]=r-1},locked:function(n){return t(n)>0}}},ft=function(t){var i=function(i){var f=n.trim(i.attr("data-"+y.underscore(t))),r,u;return f.charAt(0)==="{"?(r=b(f),u=r[0],u&&p in u&&(r=n.trim(u[p]))):r=f,r===""&&(r=[]),r};r.bindingHandlers[t]={init:function(u){var f=n(u),y=i(f),h={},p={},b=function(n,t){v.attr(o,n+":"+t);try{return s.getBindings(v[0],r.contextFor(u))[n]}finally{v.removeAttr(o)}},d=function(n,i){var e=f.data(t),u=f.data(c),o=r.utils.unwrapObservable(i);if(e){if(u.locked(a))return;u.obtain(l);try{e.option(n,o)}finally{u.release(l)}}else h[n]=o,r.isWriteableObservable(i)&&(p[n]=i)},g=function(n,t){if(n in p){var r=this._$element,i=r.data(c);if(!i.locked(l)){i.obtain(a);try{p[n](t)}finally{i.release(a)}}}};return r.utils.domNodeDisposal.addDisposeCallback(u,function(){n.each(f.data("dxComponents")||[],function(n,t){f.data(t)._dispose()})}),typeof y=="string"?r.computed(function(){var i=f.data(t);i&&i.beginUpdate(),n.each(r.utils.unwrapObservable(b(tt,y)),d),i&&i.endUpdate()},null,{disposeWhenNodeIsRemoved:u}):n.each(y,function(){var t=k(n.trim(this.key)),i=n.trim(this.value);r.computed(function(){var n=b(t,i);d(t,n)},null,{disposeWhenNodeIsRemoved:u})}),h&&(f.data(w,!0),f[t](h),h=null,f.data(c,new ut),f.data(t).optionChanged.add(g)),{controlsDescendantBindings:e[t].subclassOf(e.Widget)}}}};r.bindingProvider.instance=rt,h=e.Template.inherit({ctor:function(t){this.callBase.apply(this,arguments),this._template=n("<div />").append(t),this._cleanTemplateElement(),this._registerKoTemplate()},_cleanTemplateElement:function(){this._element.each(function(){r.cleanNode(this)})},_registerKoTemplate:function(){var n=this._template.get(0);new r.templateSources.anonymousTemplate(n).nodes(n)},render:function(t,u){var e;u=u!==i?u:r.dataFor(t.get(0))||{};var o=r.contextFor(t[0]),s=o?o.createChildContext(u):u,f=n("<div />").appendTo(t);return r.renderTemplate(this._template.get(0),s,null,f.get(0)),e=f.contents(),t.append(e),f.remove(),e},dispose:function(){this._cleanTemplateElement(),this._element.remove(),this._template.remove()}}),g=e.TemplateProvider.inherit({getTemplateClass:function(n){return this._createdWithKo(n)?h:this.callBase(n)},supportDefaultTemplate:function(n){return this._createdWithKo(n)?!0:this.callBase(n)},getDefaultTemplate:function(n){if(this._createdWithKo(n))return nt(n.NAME)},_createdWithKo:function(n){return!!n._element().data(w)}}),r.bindingHandlers.dxAction={update:function(i,u,f,e){var o=n(i),s=r.utils.unwrapObservable(u()),h=new t.Action(s,{context:i});o.off(".dxActionBinding").on("click.dxActionBinding",function(){h.execute({element:o,model:e,evaluate:function(n){var u=e,f;return n.length>0&&n[0]==="$"&&(u=r.contextFor(i)),f=t.data.utils.compileGetter(n),f(u)}})})}};var nt=function(){var i={};return function(r){if(u[r]||(r="base"),!i[r]){var e=u[r](),f=t.utils.createMarkupFromString(e);f.each(function(){d(n(this))}),i[r]=new h(f)}return i[r]}}(),f=function(t,r,u){u=u===i?!0:u;var f=n.map(r,function(n,t){return t+":"+n}).join(",");return"<"+t+' data-bind="'+f+'">'+(u?"<\/"+t+">":"")},et={visible:"$data.visible === undefined || $data.visible",css:"{ 'dx-state-disabled': $data.disabled }"},u={base:function(){var n=[f("div",et,!1)],t=f("div",{html:"html"}),i=f("div",{text:"text"}),r=f("div",{html:"String($data)"});return n.push("<!-- ko if: $data.html -->",t,"<!-- /ko -->","<!-- ko if: !$data.html && $data.text -->",i,"<!-- /ko -->","<!-- ko ifnot: $.isPlainObject($data) -->",r,"<!-- /ko -->","<\/div>"),n.join("")}};u.dxList=function(){var n=u.base(),t=f("div",{html:"key"});return n=[n.substring(0,n.length-6),"<!-- ko if: $data.key -->"+t+"<!-- /ko -->","<\/div>"],n.join("")},u.dxToolbar=function(){var i=u.base();return i=[i.substring(0,i.length-6),"<!-- ko if: $data.widget -->"],n.each(["button","tabs","dropDownMenu"],function(){var r=t.inflector.camelize(["dx","-",this].join("")),n={};n[r]="$data.options",i.push("<!-- ko if: $data.widget === '",this,"' -->",f("div",n),"<!-- /ko -->")}),i.push("<!-- /ko -->"),i.join("")},u.dxGallery=function(){var n=u.base(),t=f("div",{html:"String($data)"}),i=f("img",{attr:"{ src: String($data) }"},!1);return n=n.replace(t,i)},u.dxTabs=function(){var n=u.base(),t=f("div",{text:"text"}),i=f("span",{attr:"{ 'class': 'dx-icon-' + $data.icon }",css:"{ 'dx-icon': true }"}),r=f("img",{attr:"{ src: $data.iconSrc }",css:"{ 'dx-icon': true }"},!1),e="<!-- ko if: $data.icon -->"+i+"<!-- /ko --><!-- ko if: !$data.icon && $data.iconSrc -->"+r+'<!-- /ko --><span class="dx-tab-text" data-bind="text: $data.text"><\/span>';return n=n.replace("<!-- ko if: !$data.html && $data.text -->","<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(t,e)},u.dxActionSheet=function(){return f("div",{dxButton:"{ text: $data.text, clickAction: $data.clickAction, type: $data.type, disabled: !!$data.disabled }"})},u.dxNavBar=u.dxTabs,n.extend(e,{registerComponentKoBinding:ft,TemplateProvider:g,Template:h,defaultTemplate:nt})}}(jQuery,DevExpress),function(n,t,i){var u=t.ui,f=t.support,r=f.touch,e=400,o=function(){var u=null,o=n.Callbacks(),f,s=function(n){f=n||this,clearTimeout(u),u=null,o.fire()},h=function(n){u||n&&f!==n||(u=setTimeout(function(){f=i,u=null},e))},c=function(n){n&&f!==n||(f=i,clearTimeout(u),u=null)},l=function(){return f},a=function(){return!!f},v=/^4\.0/.test(t.devices.androidVersion())&&navigator.userAgent.indexOf("Chrome")===-1,y=function(){r&&(v?p():document.activeElement&&document.activeElement.blur())},p=function(){var t=n("<input>").addClass("dx-hidden-input").appendTo("body");setTimeout(function(){t.focus(),setTimeout(function(){t.hide(),t.remove()},100)},100)},w=function(n){r&&n.preventDefault()},b=function(t){return n(t.target).is("input, textarea, select")};return{gestureStartCallbacks:o,preventHangingCursor:y,preventNativeElastic:w,needSkipEvent:b,notifyStart:s,notifyEnd:h,hasRecent:a,recentGestureOwner:l,forget:c}}();u.gestureUtils=o}(jQuery,DevExpress),function(n,t){var r=t.data,u="_dataSourceOptions",e="_handleDataSourceChanged",f="_handleDataSourceLoadError";t.ui.DataHelperMixin={ctor:function(){this.disposing.add(function(){this._disposeDataSource()})},_initDataSource:function(){var i=this,o=i.option("dataSource"),s,h=u in this?this[u]():{},c=i._dataSourceType?i._dataSourceType():r.SimpleDataSource;if(i._disposeDataSource(),o){if(n.isArray(o))s=new r.ArrayStore(o).toDataSource(h,c);else if(n.isPlainObject(o))if("load"in o)s=r.createDataSource(o);else{if(!o.store&&!t.designMode)throw Error("Please specify 'load' function for the dataSource");s=new c(n.extend(!0,{},h,o))}else if(o instanceof r.DataSource)i._sharedDataSource=!0,s=o;else if(o instanceof r.Store)s=o.toDataSource(h,c);else throw Error("Invalid dataSource option");i._dataSource=s,s.changed.add(i._dataSourceChangedHandler=function(){i._dataSourceLoading=!1,i[e](s.items())}),f in i&&s.loadError.add(i._dataSourceLoadErrorHandler=n.proxy(i[f],i))}},_loadDataSource:function(){var n=this._dataSource;n&&(n.isLoaded()?this._dataSourceChangedHandler():(this._dataSourceLoading=!0,n.load()))},_disposeDataSource:function(){this._dataSource&&(this._sharedDataSource?(delete this._sharedDataSource,this._dataSource.changed.remove(this._dataSourceChangedHandler),this._dataSource.loadError.remove(this._dataSourceLoadErrorHandler)):this._dataSource.dispose(),delete this._dataSource,delete this._dataSourceChangedHandler,delete this._dataSourceLoadErrorHandler)}}}(jQuery,DevExpress),function(n,t){var o=t.ui,s=o.gestureUtils,r=t.Class.inherit({EVENT_SOURCES_REGEX:{mouse:/^mouse/i,touch:/^touch/i,keyboard:/^key/i},EVENTS:{click:"click",start:"touchstart mousedown",move:"touchmove mousemove",end:"touchend mouseup",cancel:"touchcancel",wheel:"mousewheel"},ctor:function(n){this._namespace=n},eventSource:function(t){var i="other";return n.each(this.EVENT_SOURCES_REGEX,function(n){if(this.test(t.type))return i=n,!1}),i},isMouseEvent:function(n){return this.eventSource(n)==="mouse"},isTouchEvent:function(n){return this.eventSource(n)==="touch"},isKeyboardEvent:function(){return this.eventSource(e)==="keyboard"},eventName:function(t){var r=this,i=this.EVENTS[t]||t;return i=i.split(/\s+/g),n.each(i,function(n,t){i[n]=t+"."+r._namespace}),i.join(" ")},eventX:function(n){return this.isMouseEvent(n)?n.pageX:this.isTouchEvent(n)?n.originalEvent.touches[0].pageX:void 0},eventY:function(n){return this.isMouseEvent(n)?n.pageY:this.isTouchEvent(n)?n.originalEvent.touches[0].pageY:void 0},eventData:function(n){if(this.isMouseEvent(n))return{x:n.pageX,y:n.pageY,time:n.timeStamp};if(this.isTouchEvent(n)){var t=(n.changedTouches||n.originalEvent.changedTouches)[0];return{x:t.pageX,y:t.pageY,time:n.timeStamp}}},eventDelta:function(n,t){return{x:t.x-n.x,y:t.y-n.y,time:t.time-n.time||1}},hasTouches:function(n){return this.isMouseEvent(n)?0:this.isTouchEvent(n)?n.originalEvent.touches.length:void 0},needSkipEvent:function(n){return this.isMouseEvent(n)?s.needSkipEvent(n)||n.which>1:this.isTouchEvent(n)?(n.changedTouches||n.originalEvent.changedTouches).length!==1:void 0}}),h=400,u=!1,f=null;t.registerActionExecutor("ignoreMouseAfterTouch",{validate:function(t){var i=t.args[0];(i&&i.jQueryEvent&&(i=i.jQueryEvent),i instanceof n.Event)&&(r.prototype.isTouchEvent(i)?(u=!0,clearTimeout(f),f=setTimeout(function(){u=!1},h)):r.prototype.isMouseEvent(i)&&u&&(t.canceled=!0))}}),t.ui.EventHelper=r}(jQuery,DevExpress),function(n,t){var e="dxSpecialEvents",f=e+"HoldTimer",u=new t.ui.EventHelper(e),s=u.eventName("start"),h=u.eventName("end"),v=u.eventName("cancel"),c=n.event,l=c.special,y=l["dx:hold"]={HOLD_TIMEOUT:750,setup:function(t){var r=this,i=n(r),u=function(u){i.data(f)||i.data(f,setTimeout(function(){i.removeData(f),c.dispatch.call(r,n.Event("dx:hold",{target:u.target}))},t&&"timeout"in t?t.timeout:y.HOLD_TIMEOUT))},e=function(){clearTimeout(i.data(f)),i.removeData(f)};i.on(s+".dxHold",u).on(h+".dxHold",e)},teardown:function(){var t=n(this);clearTimeout(t.data(f)),t.removeData(f).off(".dxHold")}},p=600,o=!1,a=null,r=l["dx:click"]={TOUCH_BOUNDARY:10,_trackingClick:!1,_skipNextClick:!1,_$target:null,_startX:0,_startY:0,_touchWasMoved:function(n){var t=u.eventData(n),i=r.TOUCH_BOUNDARY;return Math.abs(t.x-r._startX)>i||Math.abs(t.y-r._startY)>i},_handleStart:function(t){if(!u.isMouseEvent(t)){var i=t.originalEvent.targetTouches,f=i[0];i.length>1||(r._trackingClick=!0,r._$target=n(t.target),r._startX=f.pageX,r._startY=f.pageY)}},_handleClick:function(t){r._skipNextClick||(t.type="dx:click",n(t.currentTarget).trigger(t)),r._skipNextClick=!1},_handleEnd:function(n){(u.isTouchEvent(n)?(o=!0,clearTimeout(a),a=setTimeout(function(){o=!1},p)):u.isMouseEvent(n)&&o&&(r._skipNextClick=!0),u.isMouseEvent(n))||(r._touchWasMoved(n)&&(r._trackingClick=!1,r._$target=null),r._trackingClick)&&(r._trackingClick=!1,r._$target.trigger("dx:click"))},_handleCancel:function(){r._trackingClick=!1,r._$target=null},setup:function(){n(this).on(["click",e,"dxClick"].join("."),n.proxy(r._handleClick,this)).on(s+".dxClick",n.proxy(r._handleStart,this)).on(h+".dxClick",n.proxy(r._handleEnd,this)).on(v+".dxClick",n.proxy(r._handleCancel,this))},teardown:function(){n(this).off(".dxClick")}}}(jQuery,DevExpress),function(n,t,i){function o(t,i){t.each(function(){var t=this.getElementsByTagName?this.getElementsByTagName("*"):[],r,u;for(i&&(t=jQuery.merge([this],t)),r=0;(u=t[r])!=null;r++)n.each(y(u),function(){this._dispose()}),e&&ko.cleanNode(u)})}var f="dxComponents",e=!!window.ko,r=t.ui,u=t.data.utils,l="dx-state-disabled",a=t.Class.inherit({NAME:null,_defaultOptions:function(){return{disabled:!1}},ctor:function(i,u){this._$element=n(i),this._element().data(this.NAME,this),this._element().data(f)||this._element().data(f,[]),this._element().data(f).push(this.NAME),this._options={},this._updateLockCount=0,this._requireRefresh=!1,this._eventHelper=new r.EventHelper(this.NAME),this.optionChanged=n.Callbacks(),this.disposing=n.Callbacks(),this.beginUpdate();try{var e=t.devices.current(),o=r.optionsByDevice(e,this.NAME)||{},s=n.extend(this._defaultOptions(),o);this.option(s),this._initOptions(u||{})}finally{this.endUpdate()}},_initOptions:function(n){this.option(n)},_optionValuesEqual:function(n,t,i){return(t=u.toComparable(t,!0),i=u.toComparable(i,!0),t===null||typeof t!="object")?t===i:!1},_init:n.noop,_render:function(){this._renderDisabledState()},_clean:n.noop,_invalidate:function(){this._requireRefresh=!0},_refresh:function(){this._clean(),this._render()},_dispose:function(){this._clean(),this.optionChanged.empty(),this.disposing.fireWith(this).empty()},_renderDisabledState:function(){this._element().toggleClass(l,this.option("disabled"))},_createAction:function(i,r){var u=this,f,e,o;return r=n.extend({},r),f=r.element||u._element(),e=u._modelByElement(f),r.context=e||u,r.component=u,o=new t.Action(i,r),function(t){return arguments.length||(t={}),n.isPlainObject(t)||(t={actionValue:t}),o.execute.call(o,n.extend(t,{component:u,element:f,model:e}))}},_createActionByOption:function(n,t){if(typeof n!="string")throw Error("Option name type is unexpected");return this._createAction(this.option(n),t)},_modelByElement:function(n){if(e&&n.length)return ko.dataFor(n.get(0))},_optionChanged:function(n){n==="disabled"?this._renderDisabledState():this._invalidate()},_element:function(){return this._$element},instance:function(){return this},beginUpdate:function(){this._updateLockCount++},endUpdate:function(){if(this._updateLockCount--,!this._updateLockCount)if(this._initializing||this._initialized)this._requireRefresh&&(this._requireRefresh=!1,this._refresh());else{this._initializing=!0;try{this._init()}finally{this._initializing=!1,this._initialized=!0}this._render()}},option:function(t){var i=this,r=t,f=arguments[1];if(arguments.length<2&&n.type(r)!=="object")return u.compileGetter(r)(i._options,{functionsAsIs:!0});typeof r=="string"&&(t={},t[r]=f),i.beginUpdate();try{n.each(t,function(n,t){var r=u.compileGetter(n)(i._options,{functionsAsIs:!0}),f;i._optionValuesEqual(n,r,t)||(u.compileSetter(n)(i._options,t,{functionsAsIs:!0,merge:!0}),f=n.split(/[.\[]/)[0],i._initialized&&(i.optionChanged.fireWith(i,[f,t,r]),i._optionChanged(f,t,r)))})}finally{i.endUpdate()}}}),v=function(t,u){r[t]=u,u.prototype.NAME=t,n.fn[t]=function(r){var s=typeof r=="string",f=this,e,o;return s?(e=r,o=n.makeArray(arguments).slice(1),this.each(function(){var r=n(this).data(t),s,u;if(!r)throw Error("Component "+t+" has not been initialized on this element");return s=r[e],u=s.apply(r,o),u!==i?(f=u,!1):void 0})):this.each(function(){var i=n(this).data(t);i?i.option(r):new u(this,r)}),f},e&&r.registerComponentKoBinding(t)},y=function(t){t=n(t);var i=t.data(f);return i?n.map(i,function(n){return t.data(n)}):[]},p=n.fn.empty,s,h,c;n.fn.empty=function(){return o(this,!1),p.apply(this,arguments)},s=n.fn.remove,n.fn.remove=function(n,t){if(!t){var i=this;n&&(i=i.filter(n)),o(i,!0)}return s.call(this,n,t)},h=n.fn.html,n.fn.html=function(n){return typeof n=="string"&&o(this,!1),h.apply(this,arguments)},c=n.parseHTML,n.parseHTML=function(){return c.apply(this,arguments)||[]},n.extend(r,{registerComponent:v,Component:a})}(jQuery,DevExpress),function(n,t,i){var u=t.ui,l="UIFeedback",f="dx-feedback",h="dx-state-active",a="dx-state-disabled",v="dx-state-invisible",y=30,p=400,r,e=new u.EventHelper(l),o=!1;u.feedback={lock:function(){o=!0},unlock:function(){window.setTimeout(function(){o=!1},0)}},u.Widget=u.Component.inherit({_defaultOptions:function(){return n.extend(this.callBase(),{visible:!0,activeStateEnabled:!0,width:i,height:i,clickAction:null})},_init:function(){this.callBase(),this._feedbackShowTimeout=y},_render:function(){this.callBase(),this._element().addClass("dx-widget"),this._toggleVisibility(this.option("visible")),this._refreshFeedback(),this._renderDimensions(),this._renderClick()},_dispose:function(){this._clearTimers(),r&&r.closest(this._element()).length&&(r=null),this._clickAction=null,this.callBase()},_clean:function(){this.callBase(),this._element().empty()},_clearTimers:function(){clearTimeout(this._feedbackHideTimer),clearTimeout(this._feedbackShowTimer)},_toggleVisibility:function(n){this._element().toggleClass(v,!n)},_renderDimensions:function(){var n=this.option("width"),t=this.option("height");this._element().width(n),this._element().height(t)},_refreshFeedback:function(){this._feedbackDisabled()?(this._feedbackOff(),this._element().removeClass(f)):this._element().addClass(f)},_renderClick:function(){var n=this,t=n._eventHelper.eventName("click");n._clickAction=n._createActionByOption("clickAction");n._element().off(t).on(t,function(t){n._clickAction({jQueryEvent:t})})},_feedbackDisabled:function(){return!this.option("activeStateEnabled")||this.option("disabled")},_feedbackOn:function(t,i){this._feedbackDisabled()||o||(this._clearTimers(),i?this._feedbackShow(t):this._feedbackShowTimer=window.setTimeout(n.proxy(this._feedbackShow,this,t),this._feedbackShowTimeout),this._saveActiveElement())},_feedbackShow:function(t){var i=this._element();this._activeStateUnit&&(i=n(t).closest(this._activeStateUnit)),i.hasClass(a)||i.addClass(h)},_saveActiveElement:function(){r=this._element()},_feedbackOff:function(t,i){this._clearTimers(),i?this._feedbackHide():this._feedbackHideTimer=window.setTimeout(n.proxy(this._feedbackHide,this),p)},_feedbackHide:function(){var n=this._element();this._activeStateUnit&&(n=n.find(this._activeStateUnit)),n.removeClass(h),this._clearActiveElement()},_clearActiveElement:function(){var i=this._element().get(0),t=r&&r.get(0);t&&(t===i||n.contains(i,t))&&(r=null)},_optionChanged:function(n,t){switch(n){case"disabled":this.callBase.apply(this,arguments);case"activeStateEnabled":this._refreshFeedback();break;case"visible":this._toggleVisibility(t);break;case"width":case"height":this._renderDimensions();break;case"clickAction":this._renderClick();break;default:this.callBase.apply(this,arguments)}}});var w=function(t,i){if(!e.needSkipEvent(t)){r&&s(r)._feedbackOff(!1,!0);var o=n(t.target).closest("."+f),u;o.length&&(u=s(o),u._feedbackOn(t.target,i),i&&u._feedbackOff())}},c=function(n){r&&s(r)._feedbackOff(n)},s=function(t){var i;return n.each(t.data("dxComponents"),function(n,r){if(u[r].subclassOf(u.Widget))return i=t.data(r),!1}),i};n(function(){var i=new t.Action(w);n(document).on(e.eventName("start"),function(n){i.execute(n)}).on(e.eventName("end")+" "+e.eventName("cancel"),function(u){var e=r&&n(u.target).closest("."+f).get(0)===r.get(0);!t.ui.gestureUtils.hasRecent()&&e&&i.execute(u,!0),c()});u.gestureUtils.gestureStartCallbacks.add(function(){c(!0)})})}(jQuery,DevExpress),function(n,t){var r=t.ui,u="template",f=function(t){var i=t.data("options");return n.trim(i).charAt(0)!=="{"&&(i="{"+i+"}"),new Function("return "+i)().dxTemplate},e=r.Widget.inherit({_init:function(){this.callBase(),this._templateProvider=new r.TemplateProvider,this._initTemplates()},_clean:n.noop,_initTemplates:function(){var t={},i=this._templateProvider.getTemplateClass(this),r=this._element().children("[data-options]");r.length?r.each(function(r,u){u=n(u);var e=f(u);if(!e.name)throw Error("Template name was not specified");t[e.name]=new i(u.get(0))}):t[u]=new i(this._element().contents()),this._templates=t},_getTemplate:function(n){var t=this._aquireTemplate.apply(this,arguments);if(!t&&this._templateProvider.supportDefaultTemplate(this)&&(t=this._templateProvider.getDefaultTemplate(this),!t))throw Error('Template "'+n+'" was not found and no default template specified!');return t},_aquireTemplate:function(t){return n.isFunction(t)&&(t=t.apply(this,n.makeArray(arguments).slice(1))),this._templates[t]},_cleanTemplates:function(){n.each(this._templates,function(n,t){t.dispose()})},_dispose:function(){this._cleanTemplates(),this.callBase()}});r.ContainerWidget=e}(jQuery,DevExpress),function(n,t,i){var r=t.ui,u=r.ContainerWidget.inherit({_defaultOptions:function(){return n.extend(this.callBase(),{items:[],itemTemplate:"item",itemRender:null,itemClickAction:null,itemRenderedAction:null,noDataText:"No data to display",dataSource:null})},_init:function(){this.callBase(),this._initDataSource(),this._loadDataSource()},_optionChanged:function(n,t,i){switch(n){case"dataSource":this._clean(),this._initDataSource(),this._loadDataSource();return;case"noDataText":this._renderEmptyMessage();return;case"itemRenderedAction":return;default:this.callBase(n,t,i)}},_clean:function(){this._itemContainer().empty()},_handleDataSourceChanged:function(n){this.option("items",n),this._renderEmptyMessage()},_itemContainer:function(){return this._element()},_itemClass:t.abstract,_itemSelector:function(){return"."+this._itemClass()},_itemDataKey:t.abstract,_items:function(){return this._itemContainer().find(this._itemSelector())},_render:function(){this.callBase(),this._attachClickEvent(),this._renderItems()},_renderEmptyMessage:function(){var i=this.option("noDataText"),t=this._element().find(".dx-empty-message"),r=this.option("items"),u=r&&r.length;!i||u||this._dataSourceLoading?t.remove():(t.length||(t=n("<div />").addClass("dx-empty-message").appendTo(this._itemContainer())),t.text(i))},_attachClickEvent:function(){var t=this,i=t._itemSelector();t._itemContainer().off("."+t.NAME,i).on(t._eventHelper.eventName("click"),i,n.proxy(t._handleItemClick,t))},_handleItemClick:function(n){this._handleItemEvent(n,"itemClickAction")},_renderItems:function(){var t=this.option("items")||[];t.length?n.each(t,n.proxy(this._renderItem,this)):this._renderEmptyMessage()},_renderItem:function(n,t,i){i=i||this._itemContainer();var f=this.option("itemRender"),o=this.option("itemTemplate"),e=this._getTemplate(t.template||o,n,t),r,u={index:n,item:t,container:i};return r=f?this._createItemByRenderer(f,u):e?this._createItemByTemplate(e,u):this._createItemByRenderer(this._itemRenderDefault,u),r.addClass(this._itemClass()).data(this._itemDataKey(),t),this._createActionByOption("itemRenderedAction",{element:this._element(),allowedForGesture:!0})({itemElement:r,itemData:t}),r},_createItemByRenderer:function(t,i){var r=n("<div />").appendTo(i.container),u=t.call(this,i.item,i.index,r);return u&&r[0]!==u[0]&&r.append(u),r},_createItemByTemplate:function(n,t){return n.render(t.container,t.item)},_itemRenderDefault:function(t,r,u){n.isPlainObject(t)?(t.visible===i||t.visible||u.hide(),t.disabled&&u.addClass("dx-state-disabled"),t.text&&u.text(t.text),t.html&&u.html(t.html)):u.html(String(t))},_handleItemEvent:function(t,i,r){var u=n(t.target).closest(this._itemSelector()),f=this._createActionByOption(i,{element:this._element()}),e=n.extend({itemElement:u,itemData:u.data(this._itemDataKey()),jQueryEvent:t},r);return f(e)}}).include(r.DataHelperMixin);r.CollectionContainerWidget=u}(jQuery,DevExpress),function(n,t){t.ui.optionsByDevice=function(n,t){var i,r;if(t==="dxScrollView")return(i={},navigator.appName==="Microsoft Internet Explorer"&&(i.animationStrategy="transition"),n.platform==="desktop")?(i.scrollByContent=!1,i.showScrollbar=!1,i):(n.platform==="win8"&&(i.animationStrategy="transition"),i);if(t==="dxScrollable")return(r={},navigator.appName==="Microsoft Internet Explorer"&&(r.animationStrategy="transition"),n.platform==="desktop")?(r.scrollByContent=!1,r.showScrollbar=!1,r):(n.platform==="win8"&&(r.animationStrategy="transition"),r);if(t==="dxList"&&n.platform==="desktop")return{scrollingEnabled:!1,showScrollbar:!1,autoPagingEnabled:!1,showNextButton:!0};if(t==="dxPopup"&&n.platform==="win8"&&!n.phone)return{width:"60%",height:"auto"};if(t==="dxDialog"){if(n.platform==="ios")return{width:276};if(n.platform==="win8"&&!n.phone)return{width:"60%"};if(n.platform==="android")return{lWidth:"60%",pWidth:"80%"}}if(t==="dxLookup"){if(n.platform==="android")return{hideCancelButton:!1};if(n.platform==="win8"&&n.phone)return{hideCancelButton:!0,fullScreen:!0};if(n.platform==="ios"&&n.phone)return{fullScreen:!0}}if(t==="dxLoadIndicator"&&(navigator.appName==="Microsoft Internet Explorer"||navigator.appName==="MSAppHost/1.0"))return{viaImage:!0}}}(jQuery,DevExpress));DevExpress.MOD_VIZ||(function(n){n.viz={}}(DevExpress),function(n){n.viz.core={}}(DevExpress),function(n,t,i){var r=t.utils,u=t.viz.core,f=2e3;u.outOfScreen={x:-1e3,y:-1e3},u.tickIntervalCalculator={_defaultNumberMultipliers:[1,2,3,5],_defaultGridSpacingFactor:30,_getNumericTickInterval:function(n,t){var u,f=0,o,e=!1,i;if(n>1){for(u=1;!e;u*=10)for(i=0;i<t.length;i++)if(f=t[i]*u,n<=f){e=!0;break}}else if(n>0)for(f=1,u=.1;!e;u/=10)for(i=t.length-1;i>=0;i--){if(o=t[i]*u,n>o){e=!0;break}f=o}return r.adjustValue(f)},_getDatetimeTickInterval:function(n,t){var e={millisecond:[1,2,5,10,25,100,250,300,500],second:[1,2,3,5,10,15,20,30],minute:[1,2,3,5,10,15,20,30],hour:[1,2,3,4,6,8,12],day:[1,2,3,5,7,10,14],month:[1,2,3,6]},h={},o,u,f,s,i;if(n<1)return{milliseconds:1};for(u in e)if(e.hasOwnProperty(u))for(f=e[u],i=0;i<f.length;i++)if(n<=r.convertDateUnitToMilliseconds(u,f[i]))return h[u+"s"]=f[i],h;for(o=1;;o*=10)for(i=0;i<t.length;i++)if(s=o*t[i],n<=r.convertDateUnitToMilliseconds("year",s))return{years:s};return null},getTickInterval:function(n,t,i,r,u){var f=this,r=r||f._defaultGridSpacingFactor,u=u||f._defaultNumberMultipliers,e=i>0?r*t/i:0;switch(n){case"numeric":return f._getNumericTickInterval(e,u);case"dateTime":return f._getDatetimeTickInterval(e,u)}return null}},u.minorTickIntervalCalculator={_defaultNumberMultipliers:[2,4,5,8,10],_defaultGridSpacingFactor:15,_getDatetimeTickInterval:function(n,t,i){for(var f,u=i.length-1;u>=0;u--)if(f=Math.floor(n/i[u]),t<=f)return r.convertMillisecondsToDateUnits(f);return 0},_getNumericTickInterval:function(n,t,i){for(var f,u=i.length-1;u>=0;u--)if(f=n/i[u],t<=f)return r.adjustValue(f);return 0},getTickInterval:function(n,t,i,u,f){var e=this,u=r.isDefined(u)?u:e._defaultGridSpacingFactor,f=f||e._defaultNumberMultipliers,o=u*t/i;switch(n){case"numeric":return e._getNumericTickInterval(t,o,f);case"dateTime":return e._getDatetimeTickInterval(t,o,f)}return 0}},u.tickProvider={_areDisplayValuesValid:function(n,t,i){var e=this._getTextFunc(i),o=i.renderer.createText(e(n),u.outOfScreen.x+i.translator.translateX(n),u.outOfScreen.y,i.textOptions).append(),s=i.renderer.createText(e(t),u.outOfScreen.x+i.translator.translateX(t),u.outOfScreen.y,i.textOptions).append(),r=o.getBBox(),f=s.getBBox(),h,c=i.translator.businessRange.invertX;return h=c?f.x+f.width<r.x:r.x+r.width<f.x,o.remove(),s.remove(),h},_removeInvalidDatesWithUnitBegining:function(n,t){n.length<=1||!t.setTicksAtUnitBeginning||!r.isDate(t.min)||this._areDisplayValuesValid(n[0],n[1],t)||n.splice(1,1)},_getMaxDisplayValue:function(n,t){var i=null,f=this._getTextFunc(t),u,r;if(n.length>0)for(i=f(n[0]),r=1;r<n.length;r++)u=f(n[r]),i.length<u.length&&(i=u);return i},_getValueSize:function(n,t){if(n===null)return 0;var i=t.renderer.createText(n,u.outOfScreen.x,u.outOfScreen.y,t.textOptions).append(),r=t.isHorizontal?i.getBBox().width:i.getBBox().height;return i.remove(),Math.ceil(r)},_adjustNumericTickValue:function(n,t,i){return r.isExponential(n)?r.adjustValue(n):r.applyPrecisionByMinDelta(i,t,n)},_generateStartTick:function(n,t){for(var f=this,s=0,o=t.min-t.max<0,i=t.min,e=r.isDate(t.min),u=e?r.convertDateTickIntervalToMilliseconds(n):n,i=Math.floor(t.min/u)*u,i=e?new Date(i):f._adjustNumericTickValue(i,u,t.min);o===i-t.min<0&&i!==t.min;)i=f._nextTick(i,n,t);return i},_nextTick:function(n,t,i){var u=r.addInterval(n,t,i.min>i.max);return r.isNumber(i.min)&&(u=this._adjustNumericTickValue(u,t,i.min)),r.isDate(i.min)&&i.setTicksAtUnitBeginning&&r.correctDateWithUnitBeginning(u,t),u},_addMinorTicks:function(t,i,f,e,o){var w=this,l,a=r.isDate(t)?"dateTime":"numeric",h,s=[],y=0,v=e.minorTickCount+1,p,c;for(e.min=t,e.max=i,r.isDefined(e.tickInterval)||(h=Math.abs(e.max-e.min),r.isDefined(e.minorTickCount)?((!f.majorTicks.autoArrangementStep||f.majorTicks.autoArrangementStep<=1)&&(p=e.minorTickCount+1,y=a==="dateTime"?r.convertDateTickIntervalToMilliseconds(f.majorTickInterval):f.majorTickInterval,v=Math.round(h/y*p)||1),c=a==="dateTime"?r.convertMillisecondsToDateUnits(h/v):h/v,n.isNumeric(c)&&(c=r.adjustValue(c))):r.isDate(t)&&(c=u.minorTickIntervalCalculator.getTickInterval(a,h,h*e.deltaCoef,e.gridSpacingFactor,e.numberMultipliers))),e=n.extend(!0,{},e,{tickInterval:c}),s=w.getTicks(e),o&&s.reverse(),s.length>0&&Math.ceil(Math.abs(i-s[s.length-1])*e.deltaCoef)<2&&s.pop(),l=0;l<s.length;l++)f.minorTicks.push(s[l]),f.fullTicks.push(s[l])},_addLeftBoudedTicks:function(n,t,i){r.isDefined(t)&&n.majorTicks[0].valueOf()!==t.valueOf()&&(i.addMinMax.max=!0,this._addMinorTicks(n.majorTicks[0],t,n,i,!0),i.addMinMax.max=!1,i.showCustomBoundaryTicks&&(n.minorTicks.length>0&&n.minorTicks[0].valueOf()===t.valueOf()&&n.minorTicks.shift(t),n.customBoundaryTicks.push(t),n.fullTicks.unshift(t)))},_addRightBoudedTicks:function(n,t,i){var u=n.majorTicks[n.majorTicks.length-1];n.fullTicks.push(u),r.isDefined(t)&&u.valueOf()!==t.valueOf()&&(i.addMinMax.min=!1,i.addMinMax.max=!0,this._addMinorTicks(u,t,n,i),i.showCustomBoundaryTicks&&(n.minorTicks.length>0&&n.minorTicks[n.minorTicks.length-1].valueOf()===t.valueOf()&&n.minorTicks.pop(t),n.customBoundaryTicks.push(t),n.fullTicks.push(t)))},_correctBoundedTicks:function(t,i,r,u){u=n.extend({},{min:!0,max:!0},u),r.length>0&&(u.min||r[0].valueOf()!==t.valueOf()||r.shift(),u.max&&r[r.length-1].valueOf()===i.valueOf()||r.pop())},_initializeMinorTicksOptions:function(t,f,e,o,s,h){var a=this,c,l=r.isDefined(h.minorTickCount);n.extend(!0,h,{addMinMax:{min:!1,max:!1},deltaCoef:a._getDeltaCoef(o,f,e)},h),h.numberMultipliers=l?[h.minorTickCount+1]:h.numberMultipliers,h.gridSpacingFactor=l?0:h.gridSpacingFactor,!l&&s.majorTicks.length>1&&(c=Math.abs(s.majorTicks[0]-s.majorTicks[1]),a.needTickIntervalCalculation(c,s.minorTickInterval,h.incidentOccured)&&(s.minorTickInterval=u.minorTickIntervalCalculator.getTickInterval(t,c,c*h.deltaCoef,h.gridSpacingFactor,h.numberMultipliers),h.tickInterval=r.isNumber(f)?s.minorTickInterval:i))},_getDataType:function(n){return r.isDate(n)?"dateTime":"numeric"},_getDeltaCoef:function(n,t,i){return n/Math.abs(t-i)},_initializeMajorTicksOptions:function(t,i,f,e,o,s){var h;n.extend(!0,s,{min:i,max:f,screenDelta:e,isHorizontal:!0}),r.isDefined(i)&&r.isDefined(f)&&(h=Math.abs(f-i),this.needTickIntervalCalculation(h,o.majorTickInterval,s.incidentOccured)&&(s.isStartTickGenerated=!0,o.majorTickInterval=u.tickIntervalCalculator.getTickInterval(t,h,e,s.gridSpacingFactor,s.numberMultipliers),s.tickInterval=o.majorTickInterval))},_getTextFunc:function(n){return n.getText||function(n){return n.toString()}},needTickIntervalCalculation:function(n,t,i){var u;if(r.isDefined(t)){if(!r.isNumber(t)&&(u=new Date,t=r.addInterval(u,t)-u,!t))return!0;if(r.isNumber(t))if(t>0&&n/t>f)i&&i("Tick count is too big. So, the tick interval is specified automatically.");else return!1}return!0},getAutoArrangementStep:function(n,t){var e=this,u=this._getMaxDisplayValue(n,t),i=this._getValueSize(u,t),r,f=t.isHorizontal?t.textSpacing:0;return i>0?(r=Math.floor((t.screenDelta+t.textSpacing)/(i+f)),Math.ceil((t.ticksCount||n.length)/r)):1},getAutoArrangementTicks:function(n,t,i){var e=this,u=n,i=r.isNumber(i)?i:e.getAutoArrangementStep(n,t),f;if(i>1)for(u=[],f=0;f<n.length;f+=i)u.push(n[f]);return e._removeInvalidDatesWithUnitBegining(u,t),u.autoArrangementStep=i,u},getTickIntervals:function(n,t,i,u,f){var o=this,c,h,s=o._getDataType(n),e={majorTickInterval:u.tickInterval,minorTickInterval:f.tickInterval,majorTicks:[]};return o._initializeMajorTicksOptions(s,n,t,i,e,u),r.isDefined(n)&&r.isDefined(t)&&(e.majorTicks.push(n),e.majorTicks.push(o._nextTick(n,e.majorTickInterval,{min:n,max:t,setTicksAtUnitBeginning:u.setTicksAtUnitBeginning})),h=Math.abs(e.majorTicks[0]-e.majorTicks[1]),o._initializeMinorTicksOptions(s,n,t,i,e,f)),e},getFullTicks:function(n,t,i,u,f){var o=this,s,h=o._getDataType(n),e={customBoundaryTicks:[],fullTicks:[],majorTickInterval:u.tickInterval,majorTicks:[],minorTickInterval:f.tickInterval,minorTicks:[]};if(o._initializeMajorTicksOptions(h,n,t,i,e,u),e.majorTicks=o.getTicks(u),r.isDefined(n)&&r.isDefined(t)&&e.majorTicks.length>0){for(e.majorTicks.autoArrangementStep&&e.majorTicks.autoArrangementStep>1&&!r.isDefined(f.tickInterval)&&!r.isDefined(f.minorTickCount)&&(f.tickInterval=e.minorTickInterval=u.tickInterval),o._initializeMinorTicksOptions(h,n,t,i,e,f),o._addLeftBoudedTicks(e,n,f),s=0;s<e.majorTicks.length-1;s++)e.fullTicks.push(e.majorTicks[s]),o._addMinorTicks(e.majorTicks[s],e.majorTicks[s+1],e,f);o._addRightBoudedTicks(e,t,f)}return e},getTicks:function(t){var s=this,f=[],e,c=t.max-t.min>0,l,a,o,h=t.isStartTickGenerated,v,y=t.useTicksAutoArrangement;if(!r.isDefined(t.min)||!r.isDefined(t.max)||isNaN(t.min)||isNaN(t.max))f=t.isHorizontal?["canvas_position_left","canvas_position_center","canvas_position_right"]:["canvas_position_bottom","canvas_position_middle","canvas_position_top"],y=!1,f.hideLabels=!0;else if(o=n.isNumeric(t.min)&&n.isNumeric(t.max)&&!n.isNumeric(t.tickInterval)?i:t.tickInterval,v=Math.abs(t.max-t.min),this.needTickIntervalCalculation(v,o,t.incidentOccured)&&(h=r.isDefined(h)?h:!0,o=u.tickIntervalCalculator.getTickInterval(r.isDate(t.min)?"dateTime":"numeric",Math.abs(t.max-t.min),t.screenDelta,t.gridSpacingFactor,t.numberMultipliers)),o.valueOf()!==0&&t.min.valueOf()!==t.max.valueOf()){e=h?s._generateStartTick(o,t):t.min;do{if(f.push(e),e=s._nextTick(e,o,t),f[f.length-1].valueOf()===e.valueOf())break;l=e-t.min>0,a=t.max-e>0}while(c===l&&c===a);f.push(e),s._correctBoundedTicks(t.min,t.max,f,t.addMinMax)}return t.beforeTicksAutoArrangement&&t.beforeTicksAutoArrangement(f),y?s.getAutoArrangementTicks(f,t):f}}}(jQuery,DevExpress),function(n,t,i){var f=t.utils,e=f.isNumber,o=f.isDate,u=f.isDefined,r=Math.round;t.viz.core.LinearTranslator=t.Class.inherit(function(){var f=function(n,t){this.canvas=t,this.updateBusinessRange(n)},s=function(){var n=this;n.canvas=null,n.businessRange.dispose(),n.businessRange=null,n.categoriesXToPoints=null,n.categoriesYToPoints=null},h=function(){var n=this,i=n.canvas,r=n.businessRange,u=n.businessRange.categoriesX,f=n.businessRange.categoriesY,s,h;n.width=i.width-i.left-i.right,n.height=i.height-i.top-i.bottom,u?(n.categoriesXNumber=u.length,n.horizontalInterval=r.stickX?n.width/(n.categoriesXNumber-1):n.width/n.categoriesXNumber,n.categoriesXToPoints=t(u,n.businessRange.invertX),n.translateX=g,n.getIntervalX=nt):(n.translateX=y,n.getIntervalX=rt,e(r.minX)?n.untranslateX=p:o(r.minX)&&(n.untranslateX=w)),f?(n.categoriesYNumber=f.length,n.verticalInterval=r.stickY?n.height/(n.categoriesYNumber-1):n.height/n.categoriesYNumber,n.categoriesYToPoints=t(f,n.businessRange.invertY),n.translateY=tt,n.getIntervalY=it):(n.translateY=b,n.getIntervalY=ut,e(r.minY)?n.untranslateY=k:o(r.minY)&&(n.untranslateY=d))},c=function(n){this.businessRange=n,n.minVisibleX===i&&(n.minVisibleX=n.minX),n.maxVisibleX===i&&(n.maxVisibleX=n.maxX),n.minVisibleY===i&&(n.minVisibleY=n.minY),n.maxVisibleY===i&&(n.maxVisibleY=n.maxY),this.init()},l=function(){return this.businessRange},a=function(n,t){var i=this.businessRange;i.minVisibleX=n,i.maxVisibleX=t,i.applyEqualLimitsMargins(),this.init()},v=function(n,t){var i=this.businessRange;i.minVisibleY=n,i.maxVisibleY=t,i.applyEqualLimitsMargins(),this.init()},n=function(n,t,i){var f=(t+"").match(/canvas_position_(.*)/),r=n.canvas,u=n.businessRange;if(f){if(t=f[1],t==="default")return u["minVisible"+i]<=0&&0<=u["maxVisible"+i]?n["translate"+i](0):i==="X"?u.invertX?r.left+n.width:r.left:u.invertY?r.top:r.top+n.height;if(i==="X"){if(t==="left")return r.left;if(t==="center")return r.left+n.width/2;if(t==="right")return r.left+n.width}else{if(t==="bottom")return r.top+n.height;if(t==="middle")return r.top+n.height/2;if(t==="top")return r.top}}return null},y=function(t){var f=this,i=f.businessRange,o=f.canvas,e,s=n(f,t,"X");return u(s)?s:t<i.minX?null:t>i.maxX?null:(e=i.invertX?o.left+(1-(t-i.minVisibleX)/(i.maxVisibleX-i.minVisibleX))*f.width:o.left+(t-i.minVisibleX)/(i.maxVisibleX-i.minVisibleX)*f.width,r(e))},p=function(n){var i=this,t=i.businessRange,r=i.canvas;return n<r.left?null:n>r.left+i.width?null:t.invertX?t.minVisibleX+(i.width-(n-r.left))*(t.maxVisibleX-t.minVisibleX)/i.width:t.minVisibleX+(n-r.left)*(t.maxVisibleX-t.minVisibleX)/i.width},w=function(n){var i=this,t=i.businessRange,r=i.canvas;return n<r.left?null:n>r.left+i.width?null:t.invertX?new Date(t.minVisibleX.valueOf()+(i.width-(n-r.left))*(t.maxVisibleX-t.minVisibleX)/i.width):new Date(t.minVisibleX.valueOf()+(n-r.left)*(t.maxVisibleX-t.minVisibleX)/i.width)},b=function(t){var f=this,i=f.businessRange,e=f.canvas,o,s=n(f,t,"Y");return u(s)?s:t<i.minY?null:t>i.maxY?null:(o=i.invertY?e.height-e.bottom-(1-(t-i.minVisibleY)/(i.maxVisibleY-i.minVisibleY))*f.height:e.height-e.bottom-(t-i.minVisibleY)/(i.maxVisibleY-i.minVisibleY)*f.height,r(o))},k=function(n){var i=this,t=i.businessRange,r=i.canvas;return n<r.top?null:n>r.top+i.height?null:t.invertY?t.maxVisibleY-(i.height-(n-r.top))*(t.maxVisibleY-t.minVisibleY)/i.height:t.maxVisibleY-(n-r.top)*(t.maxVisibleY-t.minVisibleY)/i.height},d=function(n){var i=this,t=i.businessRange,r=i.canvas;return n<r.top?null:n>r.top+i.height?null:t.invertY?new Date(t.maxVisibleY.valueOf()-(i.height-(n-r.top))*(t.maxVisibleY-t.minVisibleY)/i.height):new Date(t.maxVisibleY.valueOf()-(n-r.top)*(t.maxVisibleY-t.minVisibleY)/i.height)},g=function(t){var i=this,o=i.canvas,f,e=0,s=n(i,t,"X");return u(s)?s:(f=i.categoriesXToPoints[t],!f)?0:(e=i.businessRange.stickX?o.left+i.horizontalInterval*f.index:o.left+i.horizontalInterval*(f.index+.5),r(e))},nt=function(){return this.horizontalInterval},tt=function(t){var i=this,o=i.canvas,f,e=0,s=n(i,t,"Y");return u(s)?s:(f=i.categoriesYToPoints[t],!f)?0:(e=i.businessRange.stickY?o.top+i.verticalInterval*f.index:o.top+i.verticalInterval*(f.index+.5),r(e))},it=function(){return this.verticalInterval},rt=function(){var n=this,t=0;return n.businessRange.intervalX!==i&&(t=n.width*n.businessRange.intervalX/(n.businessRange.maxVisibleX-n.businessRange.minVisibleX)),r(t)},ut=function(){var n=this,t=0;return n.businessRange.intervalY!==i&&(t=n.height*n.businessRange.intervalY/(n.businessRange.maxVisibleY-n.businessRange.minVisibleY)),r(t)},ft=function(){var t=this.businessRange,n={};return n.minX=t.minVisibleX,n.maxX=t.maxVisibleX,n.minY=t.minVisibleY,n.maxY=t.maxVisibleY,t.categoriesX&&(n.categoriesX=t.categoriesX,n.minCategoryXPos=0,n.maxCategoryXPos=n.minCategoryXPos+n.categoriesX.length-1),t.categoriesY&&(n.categoriesY=t.categoriesY,n.minCategoryYPos=0,n.maxCategoryYPos=n.minCategoryYPos+n.categoriesY.length-1),n},et=function(){var n=this.canvas;return{minX:n.left,maxX:n.width-n.right,minY:n.top,maxY:n.height-n.bottom}},t=function(n,t){var u={},r,i;if(t)for(i=n.length-1;i>=0;i--)r=n[n.length-1-i],u[r]={name:r,index:i};else for(i=0;i<n.length;i++)r=n[i],u[r]={name:r,index:i};return u};return{ctor:f,dispose:s,init:h,getCanvasVisibleArea:et,getBusinessVisibleArea:ft,updateBusinessRange:c,getBusinessRange:l,zoomX:a,zoomY:v}}())}(jQuery,DevExpress),function(n){var r=window.NaN,i=window.Number;n.viz.core.Translator1D=n.Class.inherit({ctor:function(n,t,r,u){var f=this;f._domainStart=i(n),f._domainEnd=i(t),f._codomainStart=i(r),f._codomainEnd=i(u),f._domainDelta=f._domainEnd-f._domainStart,f._codomainDelta=f._codomainEnd-f._codomainStart},getDomainStart:function(){return this._domainStart},getDomainEnd:function(){return this._domainEnd},getCodomainStart:function(){return this._codomainStart},getCodomainEnd:function(){return this._codomainEnd},getDomainRange:function(){return this._domainDelta},getCodomainRange:function(){return this._codomainDelta},translate:function(n){var t=this,i=(n-t._domainStart)/t._domainDelta;return 0<=i&&i<=1?t._codomainStart+i*t._codomainDelta:r},adjust:function(n){var t=this,u=(n-t._domainStart)/t._domainDelta,f=r;return u<0?f=t._domainStart:u>1?f=t._domainEnd:0<=u&&u<=1&&(f=i(n)),f}})}(DevExpress),function(n){var i=window.isFinite;n.viz.core.Rectangle=n.Class.inherit({ctor:function(n){var t=this;n=n||{},t.left=Number(n.left)||0,t.right=Number(n.right)||0,t.top=Number(n.top)||0,t.bottom=Number(n.bottom)||0},width:function(){return this.right-this.left},height:function(){return this.bottom-this.top},horizontalMiddle:function(){return(this.left+this.right)/2},verticalMiddle:function(){return(this.top+this.bottom)/2},raw:function(){var n=this;return{left:n.left,top:n.top,right:n.right,bottom:n.bottom}},clone:function(){return new this.constructor(this.raw())},move:function(n,t){var r=this.clone();return i(n)&&i(t)&&(r.left+=Number(n),r.right+=Number(n),r.top+=Number(t),r.bottom+=Number(t)),r},inflate:function(n,t){var r=this.clone();return i(n)&&i(t)&&(r.left-=Number(n),r.right+=Number(n),r.top-=Number(t),r.bottom+=Number(t)),r},scale:function(n){var t=this;return n>0?t.inflate(t.width()*(n-1)/2,t.height()*(n-1)/2):t.clone()}})}(DevExpress),function(n,t){var r=t.viz.core,u=t.viz;r.findTheme=function(n){for(var r=u.themes,i,t=0;t<r.length;t++)if(i=r[t],i.name===n)return i},r.registerTheme=function(t,i){var f,e;t&&t.name&&!r.findTheme(t.name)&&(i?(f=r.findTheme(i),f&&(e=n.extend(!0,{},f,t),u.themes.push(e))):u.themes.push(t))}}(jQuery,DevExpress),function(n,t){function u(n){var t=0;this.next=function(){var i=n[t++];return t==n.length&&this.reset(),i},this.reset=function(){t=0}}var r=t.viz.core;r.palettes={"default":["#5F8B95","#BA4D51","#AF8A53","#955F71","#859666","#7E688C"],"Harmony Light":["#FCB65E","#679EC5","#AD79CE","#A6C567","#E18E92","#DDED6E","#B7ABEA","#A8E7E3"],"Soft Pastel":["#7CBAB4","#92C7E2","#75B5D6","#B78C9B","#F2CA84","#A7CA74"]},r.findPalette=function(n){return r.palettes[n]},r.registerPalette=function(n,t){return r.palettes[n]=t},r.Palette=t.Class.inherit({ctor:function(t,i){var f=this;f.currentColor=0,f.stepHighlight=i||0,n.isArray(t)?f.originalPalette=t:(f.originalPalette=r.findPalette(t),f.originalPalette||(f.originalPalette=r.palettes["default"])),f.palette=f.originalPalette.slice(0),f.paletteActions=new u(["highlight","highlight","darken","darken"])},dispose:function(){this.originalPalette=null,this.palette=null,this.paletteActions=null},getNextColor:function(){var n=this,i=n.palette,f=i[n.currentColor],u,r;if(n.currentColor++,n.currentColor>=i.length&&(n.currentColor=0,n.stepHighlight))for(u=n.paletteActions.next(),r=0;r<i.length;r++)i[r]=new t.Color(i[r])[u](n.stepHighlight);return f},reset:function(){this.currentColor=0,this.palette=this.originalPalette.slice(0),this.paletteActions.reset()}})}(jQuery,DevExpress),function(n,t){var r=t.viz,u=r.core,f=function(n){return u.findTheme(n)||r.themes[0]};u.BaseThemeManager=t.Class.inherit({ctor:function(t,i){t=t||{};var u=this,e=typeof t=="string"?t:t.name,r=f(e);u.font=n.extend(!0,{},r.font,t.font||{}),i&&r&&n.each(i.split("."),function(){r=r[this]}),u.theme=n.extend(!0,{},r||{},typeof t=="string"?{}:t)},dispose:function(){this.font=null,this.theme=null},initializeFont:function(t){n.extend(t,this.font,n.extend({},t))},applyTheme:function(t,i){return n.extend(!0,{},t,i||{})},getTheme:function(){return this.theme}})}(jQuery,DevExpress),function(n){var i=Math.min;n.viz.core.TextCloud=n.Class.inherit(function(){var t={horMargin:8,verMargin:4,tailLength:10},n={};return n["right-bottom"]=n.rb=[0,-1,-1,0,0,1,1,0],n["bottom-right"]=n.br=[-1,0,0,-1,1,0,0,1],n["left-bottom"]=n.lb=[0,-1,1,0,0,1,-1,0],n["bottom-left"]=n.bl=[1,0,0,-1,-1,0,0,1],n["left-top"]=n.lt=[0,1,1,0,0,-1,-1,0],n["top-left"]=n.tl=[1,0,0,1,-1,0,0,-1],n["right-top"]=n.rt=[0,1,-1,0,0,-1,1,0],n["top-right"]=n.tr=[-1,0,0,1,1,0,0,-1],{setup:function(r){var e=this,f=$.extend({},t,r),h=f.x,c=f.y,u=n[f.type],o=f.textWidth+2*f.horMargin,s=f.textHeight+2*f.verMargin,l=f.tailLength,a=l,v=h,y=c;return u[0]&1?a=i(a,s/3):l=i(l,o/3),e._points=[h,c,h+=u[0]*(o+l),c+=u[1]*(s+a),h+=u[2]*o,c+=u[3]*s,h+=u[4]*o,c+=u[5]*s,h+=u[6]*(o-l),c+=u[7]*(s-a)],e._cx=v+u[0]*l+(u[0]+u[2])*o/2,e._cy=y+u[1]*a+(u[1]+u[3])*s/2,e._cloudWidth=o,e._cloudHeight=s,e._tailLength=f.tailLength,e},points:function(){return this._points.slice(0)},cx:function(){return this._cx},cy:function(){return this._cy},width:function(){return this._cloudWidth},height:function(){return this._cloudHeight},tailLength:function(){return this._tailLength}}}())}(DevExpress),function(n,t){var r=t.viz,u=r.core,f=t.Class,i=t.utils.isDefined,e=f.inherit({ctor:function(t){t=t||{},this._incidentOccured=n.isFunction(t.incidentOccured)?t.incidentOccured:n.noop},correctValueType:function(n){return n==="numeric"||n==="datetime"||n==="string"?n:""},_parsers:{string:function(n){return i(n)?""+n:n},numeric:function(n){if(!i(n))return n;var t=Number(n);return isNaN(t)&&(t=undefined),t},datetime:function(n){if(!i(n))return n;var t,r=Number(n);return t=isNaN(r)?new Date(n):new Date(r),isNaN(Number(t))&&(t=undefined),t}},getParser:function(t,i){var u=this,r,f="valueType is unknown.";return i&&(f="The type specified as the valueType property of the "+i+" configuration object is unknown."),t=u.correctValueType(t),r=u._parsers[t],r||this._incidentOccured.call(null,f),r||n.noop}});u.ParseUtils=e}(jQuery,DevExpress),function(n,t,i){t.viz.themes=t.viz.themes||[],t.viz.themes.push({name:"default",font:{color:"#808080",opacity:.75,family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400,size:12,cursor:"default"},chart:{containerBackgroundColor:"#FFFFFF",defaultPalette:"default",commonSeriesSettings:{border:{visible:!1,width:2},hoverMode:"excludePoints",selectionMode:"includePoints",hoverStyle:{hatching:"none",border:{visible:!1,width:3}},selectionStyle:{hatching:"right",border:{visible:!1,width:3}},point:{visible:!0,symbol:"circle",size:6,border:{visible:!1,width:1},hoverMode:"onlyPoint",selectionMode:"onlyPoint",hoverStyle:{border:{visible:!0,width:4},size:6},selectionStyle:{border:{visible:!0,width:4},size:6}},label:{font:{color:"#FFFFFF",opacity:1},border:{visible:!1,width:1,color:"#808080",dashStyle:"solid"},connector:{visible:!1,width:1}},scatter:{},line:{width:2,dashStyle:"solid",hoverStyle:{width:3},selectionStyle:{width:3}},stackedline:{width:2,dashStyle:"solid",hoverStyle:{width:3},selectionStyle:{width:3}},fullstackedline:{width:2,dashStyle:"solid",hoverStyle:{width:3},selectionStyle:{width:3}},stepline:{width:2,dashStyle:"solid",hoverStyle:{width:3},selectionStyle:{width:3}},area:{point:{visible:!1}},stackedarea:{point:{visible:!1}},fullstackedarea:{point:{visible:!1}},steparea:{border:{visible:!0,width:2},point:{visible:!1},hoverStyle:{border:{visible:!0,width:3}},selectionStyle:{border:{visible:!0,width:3}}},spline:{width:2,hoverStyle:{width:3},selectionStyle:{width:3}},splinearea:{point:{visible:!1}},bar:{cornerRadius:0},stackedbar:{cornerRadius:0},fullstackedbar:{cornerRadius:0},rangebar:{cornerRadius:0},rangearea:{point:{visible:!1}},rangesplinearea:{point:{visible:!1}},pie:{border:{visible:!1,width:2,color:"#FFFFFF"},hoverStyle:{border:{visible:!0,width:3,color:"#FFFFFF"}},selectionStyle:{border:{visible:!0,width:3,color:"#FFFFFF"}}},doughnut:{innerRadius:.5},candlestick:{width:1,innerColor:"#ffffff",reduction:{color:"#FF0000"},hoverStyle:{width:3},selectionStyle:{width:3}},stock:{width:1,reduction:{color:"#FF0000"},hoverStyle:{width:3},selectionStyle:{width:3}}},legend:{verticalAlignment:"top",horizontalAlignment:"right",position:"outside",font:{color:"#808080"},visible:!0,customizeText:i,itemTextPosition:i,margin:20,equalColumnWidth:!1,markerSize:12,backgroundColor:i,border:{visible:!1,width:1,color:"#808080",cornerRadius:0,opacity:.35,dashStyle:"solid"},paddingLeftRight:20,paddingTopBottom:15,columnCount:0,rowCount:0,columnItemSpacing:20,rowItemSpacing:8},tooltip:{enabled:!1,font:{family:"'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:200,size:26,color:"#ffffff"},arrowLength:10,paddingLeftRight:22,paddingTopBottom:6,format:"",argumentFormat:"",precision:0,argumentPrecision:0,percentPrecision:0,customizeText:i},title:{font:{family:"'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:200,color:"#232323",size:28,opacity:1}},commonAxisSettings:{discreteAxisDivisionMode:"betweenLabels",visible:!1,color:"#808080",opacity:.35,width:1,multipleAxesSpacing:5,label:{visible:!0,staggered:!1,staggeringSpacing:5,overlappingBehavior:{mode:"enlargeTickInterval",rotationAngle:90,staggeringSpacing:5},precision:0,format:"",customizeText:i,indentFromAxis:10},grid:{visible:!1,color:"#808080",opacity:.35,width:1},tick:{visible:!1,color:"#808080",opacity:.35},title:{font:{size:16},margin:10},stripStyle:{paddingLeftRight:10,paddingTopBottom:5}},horizontalAxis:{isHorizontal:!0,position:"bottom",axisDivisionFactor:50,label:{alignment:"center"},stripStyle:{label:{horizontalAlignment:"center",verticalAlignment:"top"}}},verticalAxis:{isHorizontal:!1,position:"left",axisDivisionFactor:30,label:{alignment:"right"},stripStyle:{label:{horizontalAlignment:"left",verticalAlignment:"center"}}},argumentAxisStyle:{},valueAxisStyle:{grid:{visible:!0}},commonPaneSettings:{border:{color:"#808080",opacity:.35,width:1}}},gauge:{area:{radius:120,fromAngle:225,toAngle:315,formatText:i},range:{type:"multicolor",sizes:{length:5},colors:["#00FF00","#FFFF00","#FF0000"]},scale:{type:"TODO",tick:{sizes:{length:5,width:2},color:"#BFBFBF"},text:{indent:10,color:"#7F7F7F",font:{family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400,size:12}}},needle:{type:"line",sizes:{width:3},color:"#BFBFBF"},marker:{type:"triangle",sizes:{length:12,width:10},color:"#679EC5"}},rangeSelector:{containerBackgroundColor:"white",scale:{label:{topIndent:7,font:{size:11}},tick:{width:1,color:"black",opacity:.1},marker:{separatorHeight:33,topIndent:10,textLeftIndent:7,textTopIndent:11}},sliderMarker:{padding:7,pointerSize:6,color:"#9B9B9B",invalidRangeColor:"red",font:{color:"white",size:11}},sliderHandles:{width:1,color:"black",opacity:.1},shutter:{color:i,opacity:.75},background:{color:"#C0BAE1"},chart:{containerBackgroundColor:i,defaultPalette:"default",commonSeriesSettings:{border:{visible:!1,width:1},hoverStyle:{border:{}},selectionStyle:{border:{}},point:{visible:!1,symbol:"circle",border:{visible:!1,width:1},size:6,hoverStyle:{border:{}},selectionStyle:{border:{}}},line:{width:2},stackedline:{width:2},fullstackedline:{width:2},area:{},stackedarea:{},fullstackedarea:{},spline:{width:2},splinearea:{},bar:{cornerRadius:0},stackedbar:{cornerRadius:0},fullstackedbar:{cornerRadius:0},rangebar:{cornerRadius:0},rangearea:{},rangesplinearea:{},pie:{},candlestick:{width:1,innerColor:"#ffffff",reduction:{color:"#FF0000"}},stock:{width:1,reduction:{color:"#FF0000"}}}}}})}(jQuery,DevExpress),function(n){n.viz.renderers={}}(DevExpress),function(n,t){var c=t.viz.renderers,i=t.utils,l=t.Class,o=document,s,u=1e10;(function(){var i=n.fx.step,f=n.fx.prototype,c=f.cur,e=i.d,o=i.rotate,h=i.translate,u;u=function(n,t,i,r,u){var f=n.renderer.animOptions.easing;return s[f||"easeOutCubic"](t,i,r)+(u=="%"?"%":"")},f.cur=function(){var i=this,t=i.prop;return i.elem instanceof r?((t==="svgheight"||t==="svgwidth")&&(t=t.substr(3)),n(i.elem.element).attr(t)):c.apply(i,arguments)},n.each(["x","y","cx","cy","r","rx","ry","strokeWidth"],function(n,f){var e=t.inflector.camelize(f),s,o=i[e];i[e]=function(n){var t=n.elem,i;if(!(t instanceof r)){o?o.apply(this,arguments):0;return}i={sharpEdges:!1},i[n.prop]=u(t,n.pos,n.start,n.end,n.unit),t.applySettings(i)}}),n.each(["width","height"],function(n,t){var r="svg"+t,f;i[r]=function(n){var i=n.elem,r=n.prop.substr(3),t;t={sharpEdges:!1},t[r]=u(i,n.pos,n.start||0,n.end||0,n.unit),i.applySettings(t)}}),i.d=function(t){var s=t.elem,i,f,o,h,c;if(!(s instanceof r)){e?e.apply(this,arguments):0;return}t.initialized||(i=s.fromSegments||[],f=s.segments||[],i.length==0&&(i=[].concat(f)),o=f.length-i.length,o>0?(h=[].concat(i).splice(i.length-o,o),i=i.concat(h)):o<0&&(h=[].concat(f).splice(f.length+o,-o),f=f.concat(h)),t.start=i,t.end=f,t.initialized=!0),c=t.pos===1?t.end:n.map(t.start,function(i,r){var e=t.end[r],f;return f=n.map(i,function(i,r){var f;return n.isNumeric(i)?(f=e[r],u(s,t.pos,i,f)):i}),[f]}),s.applySettings({d:n.map(c,function(n){return n.join(" ")}).join(" ")})},i.rotate=function(n){var t=n.elem,i,f,e;if(!(t instanceof r)){o?o.apply(this,arguments):0;return}n.initialized||(i=n.end,f=t.transformation||{},n.start=f.rotateAngle||0,n.end=i.angle||0,n.x=i.x||0,n.y=i.y||0,n.initialized=!0),e=u(t,n.pos,n.start,n.end),t.applySettings({rotate:[e,n.x,n.y]})},i.translate=function(n){var t=n.elem,i,f,e,o;if(!(t instanceof r)){h?h.apply(this,arguments):0;return}n.initialized||(i=n.end,f=t.transformation||{},n.startX=f.translateX||0,n.startY=f.translateY||0,n.endX=i.x||0,n.endY=i.y||0,n.initialized=!0),e=u(t,n.pos,n.startX,n.endX),o=u(t,n.pos,n.startY,n.endY),t.applySettings({translateX:e,translateY:o})}})(),s={easeOutCubic:function(n,t,i){return n===1?i:(1-Math.pow(1-n,3))*(i-t)+ +t},linear:function(n,t,i){return n===1?i:n*(i-t)+ +t}};var r=l.inherit({ctor:function(t,i,r){this.renderer=t,this.element=this.createElement(i),this.$element=n(this.element),this.applySettings(n.extend({},this.defaultSettings(),r))},defaultSettings:n.noop,createElement:function(n){return this._nodeName=n,o.createElementNS("http://www.w3.org/2000/svg",n)},dispose:function(){this.off(),this.remove(),this.renderer=null,this.element=null,this.settings=null,this.$element=null,this.transformation=null},append:function(n){var t=n||this.renderer.getRoot();return t.element.appendChild(this.element),this},toBackground:function(){return this.element.parentNode&&this.element.parentNode.insertBefore(this.element,this.element.parentNode.firstChild),this},toForeground:function(){return this.element.parentNode&&this.element.parentNode.appendChild(this.element),this},addClass:function(t){var i=this.$element.attr("class"),r,u;return t&&(i?(u=i.split(" "),r=n.inArray(t,u),r===-1&&(i+=" "+t)):i=t,this.$element.attr("class",i)),this.$element},removeClass:function(t){var f=this.$element.attr("class"),r,u,e="",i;if(f&&t&&(r=f.split(" "),u=n.inArray(t,r),u!==-1)){for(i=0;i<r.length;i++)i!==u&&(e+=r[i]+" ");this.$element.attr("class",e.replace(/ $/,""))}return this.$element},applySettings:function(t){var i;return this.settings=n.extend(this.settings||{},t||{}),this.adjustSettings(),i=this._normalizeSettings(this.settings),this.applyStyle(this._style),this._applyAttributes(i),this},_applyAttributes:function(n){this.$element.attr(n)},adjustSettings:function(){},applyStyle:function(n){return this.$element.css(n||{}),this},trigger:function(n,t){this.$element.trigger(n,t)},on:function(){return this.$element.on.apply(this.$element,arguments),this},data:function(n){return this.$element.data(n),this},removeData:function(){return this.$element.removeData(),this},off:function(n){return this.$element.off(n),this},getBBox:function(){function t(t){var i={};try{if(n.isFunction(t.getBBox))i=t.getBBox();else throw{};}catch(r){i={x:0,y:0,width:t.offsetWidth||0,height:t.offsetHeight||0}}return i}var h=this,t,it=this.element,s=h.transformation,c=s.rotateAngle||0,f=s.rotateX||0,e=s.rotateY||0,o=Math.abs,l=Math.min;if(t=n.extend({},t(it)),c){var a=i.getCosAndSin(c),r=a.sin.toFixed(3),u=a.cos.toFixed(3),v=t.x-f,y=t.y-e,p=t.x+t.width-f,w=t.y-e,b=t.x-f,k=t.y+t.height-e,d=t.x+t.width-f,g=t.y+t.height-e,nt,tt;nt=o(t.height*r)+o(t.width*u),tt=o(t.height*u)+o(t.width*r),t.x=l(v*u-y*r+f,p*u-w*r+f,b*u-k*r+f,d*u-g*r+f),t.y=l(v*r+y*u+e,p*r+w*u+e,b*r+k*u+e,d*r+g*u+e),t.width=nt,t.height=tt}return h._normalizeBBox(t)},_normalizeBBox:function(t){var s=Math.ceil,h=Math.floor,o=n.isNumeric,i=h(t.x),r=h(t.y),c=s(t.width+t.x),l=s(t.height+t.y),f,e;return t.x=o(i)&&i<u&&i>-u?i:0,t.y=o(r)&&r<u&&r>-u?r:0,f=c-i,e=l-r,t.width=o(f)&&f<u&&f>-u?f:0,t.height=o(e)&&e<u&&e>-u?e:0,t.isEmpty=!t.x&&!t.y&&!t.width&&!t.height,t},clear:function(n){n?this.$element.find(n).remove():this.$element.empty()},detach:function(){this.$element.detach()},animate:function(t,i,r){i=i||{},this.renderer.animOptions.enabled?(n.each(["height","width"],function(n,i){i in t&&(t["svg"+i]=t[i],delete t[i])}),n(this).stop(),r&&n.extend(i,{complete:r}),n(this).animate(t,n.extend({duration:this.renderer.animOptions.duration},i))):(t.translate&&("x"in t.translate&&(t.translateX=t.translate.x),"y"in t.translate&&(t.translateY=t.translate.y),delete t.translate),i&&i.step?(i.step.call(this,undefined,{pos:1}),i.complete&&i.complete.call(this)):this.applySettings(t))},show:function(n){n&&this.renderer.animOptions.enabled?this.$element.show(this.renderer.animOptions.duration):this.$element.show()},hide:function(n){n&&this.renderer.animOptions.enabled?this.$element.hide(this.renderer.animOptions.duration):this.$element.hide()},move:function(n,t,i,r){n=n||0,t=t||0,r=r||{},i?this.animate({translate:{x:n,y:t}},r):this.applySettings({translateX:n,translateY:t})},rotate:function(n,t,i,r,u){n=n||0,t=t||0,i=i||0,u=u||{},r?this.animate({rotate:{angle:n,x:t,y:i}},u):this.applySettings({rotate:[n,t,i]})},remove:function(){this.$element.remove()},_normalizeSettings:function(i){var o,s,e,f,r,u,h={},c;for(o in i){if(r=o,u=i[r],r==="align")r="text-anchor",u={left:"start",center:"middle",right:"end"}[u];else if(r==="font"){if(s=this._style=this._style||{},!n.isPlainObject(u))continue;n.each(u,function(n){switch(n){case"color":f="fill";break;case"opacity":f="fillOpacity";break;case"cursor":f=n;break;default:e=n.charAt(0),f="font"+n.replace(e,e.toUpperCase())}s[f]=u[n]});continue}else if(r==="dashStyle")r="stroke-dasharray",u=u.toLowerCase(),u=u==="solid"?"none":u.replace(/longdash/g,"8,3,").replace(/dash/g,"4,3,").replace(/dot/g,"1,3,").replace(/,$/,"").split(","),u!=="none"&&(u=n.map(u,function(n){return+n*(i.strokeWidth||1)}).join(","));else if(/^(linecap|linejoin)$/i.test(r))r="stroke-"+r;else if(/^(translateX|translateY|rotate|scale)$/i.test(r)){this["_"+r]=u;continue}else if(r==="clipId")r="clip-path",u="url(#"+u+")";else if(r==="style"){this._style=this._style||{},n.extend(!0,this._style,u);continue}else if(r==="text")continue;else if(r==="segments")continue;else r=t.inflector.dasherize(r);h[r]=u}return this._applyTransformation(h)},_applyTransformation:function(t){this.transformation={translateX:this._translateX,translateY:this._translateY,rotateAngle:0,rotateX:0,rotateY:0};var r=this.transformation,u=this._rotate,e=this._scale,f=[];return(i.isDefined(r.translateX)||i.isDefined(r.translateY))&&f.push("translate("+(r.translateX||0)+","+(r.translateY||0)+")"),i.isDefined(u)&&(i.isNumber(u)?(r.rotateAngle=u,r.rotateX=t.x||0,r.rotateY=t.y||0):n.isArray(u)?(r.rotateAngle=u[0]||0,r.rotateX=u[1]||0,r.rotateY=u[2]||0):i.isObject(u)&&(r.rotateAngle=u.angle||0,r.rotateX=u.x||0,r.rotateY=u.y||0),f.push("rotate("+r.rotateAngle+","+r.rotateX+","+r.rotateY+")")),i.isDefined(e)&&f.push("scale("+(e||0)+","+(e||0)+")"),f.length&&(t.transform=f.join(" ")),t}}),a=r.inherit({defaultSettings:function(){return{width:0,height:0,style:{"-webkit-tap-highlight-color":"rgba(0, 0, 0, 0)"},xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",version:"1.1",stroke:"none",strokeWidth:0,fill:"none"}},ctor:function(n,t){this.callBase(n,"svg",t)}}),e={defaultSettings:function(){return{x:0,y:0,width:0,height:0}},adjustSettings:function(){(!i.isDefined(this.settings.sharpEdges)||this.settings.sharpEdges)&&(this.sharpEdges(),delete this.settings.sharpEdges)},prepareSettings:function(n){var f=this.settings?Number(this.settings.strokeWidth)||0:0,t,u,r=!1;i.isDefined(n.width)&&(this._realWidth=Number(n.width)),i.isDefined(n.height)&&(this._realHeight=Number(n.height)),i.isDefined(n.x)&&(this._realX=Number(n.x)),i.isDefined(n.y)&&(this._realY=Number(n.y)),i.isDefined(n.strokeWidth)&&(this._realStrokeWidth=Number(n.strokeWidth)),this._realStrokeWidth=this._realStrokeWidth||this.defaultSettings().strokeWidth||0,u=~~((this._realWidth<this._realHeight?this._realWidth:this._realHeight)/2),t=this._realStrokeWidth<u?this._realStrokeWidth:u,t!==f&&(r=!0,n.sharpEdges=!0,t>0&&(n.strokeWidth=t)),(i.isDefined(n.x)||r)&&(n.x=this._realX+t/2),(i.isDefined(n.y)||r)&&(n.y=this._realY+t/2),(i.isDefined(n.width)||r)&&(n.width=this._realWidth-t),(i.isDefined(n.height)||r)&&(n.height=this._realHeight-t)},applySettings:function(t){var t=n.extend(!0,{},t);this.prepareSettings(t),this.callBase(t)},sharpEdges:function(){var t=Math.round(this.settings.strokeWidth||0),n=t%2/2;this.settings.x=Math.floor(this.settings.x-n||0)+n,this.settings.y=Math.floor(this.settings.y-n||0)+n,this.settings.width=Math.floor(this.settings.width||0),this.settings.height=Math.floor(this.settings.height||0),this.settings.strokeWidth>0&&(this.settings.strokeWidth=t)}},v=r.inherit(e).inherit({ctor:function(n,t,r,u){var f={full:"none",lefttop:"xMinYMin",leftcenter:"xMinYMid",leftbottom:"xMinYMax",centertop:"xMidYMin",center:"xMidYMid",centerbottom:"xMidYMax",righttop:"xMaxYMin",rightcenter:"xMaxYMid",rightbottom:"xMaxYMax"};this.href=i.isDefined(r)?r:"",this.preserveAspectRatio=f[(u||"").toLowerCase()],this.preserveAspectRatio=this.preserveAspectRatio||"none",this.callBase(n,"image",t)},adjustSettings:function(){this.callBase(),this.element.setAttributeNS("http://www.w3.org/1999/xlink","href",this.href),this.preserveAspectRatio&&this.element.setAttribute("preserveAspectRatio",this.preserveAspectRatio)}}),y=r.inherit(e).inherit({defaultSettings:function(){return{x:0,y:0,width:0,height:0,rx:0,ry:0}},ctor:function(n,t){this.callBase(n,"rect",t)}}),f=r.inherit({defaultSettings:function(){return{points:{x:0,y:0}}},getNodeName:function(){return"path"},getPathAttributeName:function(){return"d"},ctor:function(n,t){this.callBase(n,this.getNodeName(),t)},dispose:function(){this.segments=null,this.fromSegments=null,this.callBase()},adjustSettings:function(){this.prepareSegments(this.settings)},applySettings:function(n){var n=n||{};this.settings&&n.strokeWidth&&this.settings.strokeWidth!==n.strokeWidth&&(n.sharpEdges=!0),this.callBase(n)},prepareSegments:function(t){if("points"in t){var u=t.points,e=u[0],o=this.closePath||t.closePath,f=[],r;if(i.isObject(e))f=n.map(u,function(n,t){return t?[["L",n.x,n.y]]:[["M",n.x,n.y]]});else if(i.isNumber(e))for(r=0;r<u.length;r+=2){if(!r){f=[["M",u[r]||0,u[r+1]||0]];continue}f.push(["L",u[r]||0,u[r+1]||0])}else f=[["M",0,0]];o&&f.push(["Z"]),this.segments=f,delete t.points,delete t.closePath,t.sharpEdges=!0}t.sharpEdges&&(this.sharpEdges(),this.combinePathParams(t),delete t.sharpEdges)},customizeSegments:function(n){return n},combinePathParams:function(t){var i;this.segments=this.customizeSegments(this.segments),this.segments&&(i=n.map(this.segments,function(n){return n.join(" ")}),i=i.join(" "),t[this.getPathAttributeName()]=i)},animate:function(t,i){var r=this.callBase;if(!("points"in t))return this.callBase(t,i);this.fromSegments=this.segments,this.prepareSegments(t),this.renderer.animOptions.enabled&&n.extend(t,{d:1}),this.callBase=r,this.callBase(t,i)},sharpEdges:function(){var o=this,v=o.segments.length,i=0,n,t,s,h,l,a,r,u,f,e,y=Math.round(o.settings.strokeWidth||0),c=y%2/2;for(i;i<v-1;i++){n=o.segments[i],t=o.segments[i+1],t[0]==="Z"&&i&&(t=o.segments[0]);switch(n[0]){case"M":case"L":r=1,u=2;break;case"C":r=5,u=6;break;case"A":r=6,u=7;break;case"Z":continue}switch(t[0]){case"M":case"L":f=1,e=2;break;case"C":f=5,e=6;break;case"A":f=6,e=7;break;case"Z":continue}s=Math.floor(n[r]),h=Math.floor(n[u]),l=t[f]=Math.floor(t[f]),a=t[e]=Math.floor(t[e]),n[r]=i==0?s:n[r],n[u]=i==0?h:n[u],s==l&&(n[r]=s+c,t[f]=l+c),h==a&&(n[u]=h+c,t[e]=a+c)}}}),p=f.inherit(e).inherit({defaultSettings:function(){return n.extend(!0,{},this.callBase(),{segments:{top:!0,bottom:!0,left:!0,right:!0}})},prepareSegments:function(){var h=this,t=h.settings,i=t.x,u=i+t.width,r=t.y,f=r+t.height,e=[],o,s=0,c=0,l={top:[["M",i,r],["L",u,r]],right:[["M",u,r],["L",u,f]],bottom:[["M",u,f],["L",i,f]],left:[["M",i,f],["L",i,r]]};n.each(l,function(n){var i=!!h.settings.segments[n];s=s*2+~~i});switch(s){case 13:case 9:o=["left","top","right","bottom"];break;case 11:o=["bottom","left","top","right"];break;default:o=["top","right","bottom","left"]}n.each(o,function(t,i){var r=!!h.settings.segments[i];r&&n.each(l[i].slice(c),function(n,t){e.push(t)}),c=~~r}),s==15&&e.push(["Z"]),this.segments=e.length?e:[["M",0,0],["Z"]],this.combinePathParams(t)},adjustSettings:function(){this.callBase(),this.prepareSegments()},applySettings:function(t){var i=this.settings&&this.settings.segments||this.defaultSettings().segments;t.segments=n.extend(!0,{},i||{},t.segments),this.callBase(t)}}),w=f.inherit({defaultSettings:function(){return{points:{x:0,y:0}}},ctor:function(n,t){this.closePath=!0,this.callBase(n,t)}}),h=f.inherit({defaultSettings:function(){return{points:{x:0,y:0}}},prepareSegments:function(n){if("points"in n){var o=n.points,s=o[0],h=this.closePath||n.closePath,u=[],t=[],r,f,e,c=0;if(i.isObject(s)){for(r=0;r<o.length;r++){if(f=o[r].x,e=o[r].y,!r){u=[["M",f,e]];continue}if((r-1)%3==0){t.length>0&&u.push(t),t=["C",f,e];continue}t.push(f),t.push(e)}t.length>0&&u.push(t)}else if(i.isNumber(s)){for(r=0;r<o.length;r+=2){if(f=o[r],e=o[r+1],!r){u=[["M",f,e||0]];continue}if((r-2)%6==0){t.length>0&&u.push(t),t=["C",f,e||0];continue}t.push(f),t.push(e||0)}t.length>0&&u.push(t)}else u=[["M",0,0]];h&&u.push(["Z"]),this.segments=u,delete n.points,delete n.closePath,this.combinePathParams(n)}}}),b=h.inherit({defaultSettings:function(){return{points:{x:0,y:0}}},ctor:function(n,t){this.closePath=!0,this.callBase(n,t)}}),k=f.inherit({defaultSettings:function(){return{x:0,y:0,linejoin:"round"}},createArcSegments:function(n,t,i,r,u,f){var e=Math.abs(f-u)>Math.PI?"1":"0",o=n+r*Math.cos(u),s=t-r*Math.sin(u),h=n+r*Math.cos(f),c=t-r*Math.sin(f),l=n+i*Math.cos(f),a=t-i*Math.sin(f),v=n+i*Math.cos(u),y=t-i*Math.sin(u);return[["M",o,s],["A",r,r,0,e,0,h,c],["L",l,a],["A",i,i,0,e,1,v,y],["Z"]]},prepareSegments:function(n){var e;if("x"in n||"y"in n||"outerRadius"in n||"innerRadius"in n||"startAngle"in n||"endAngle"in n){var o=i.isNumber(n.x)?Number(n.x):0,s=i.isNumber(n.y)?Number(n.y):0,u=i.isNumber(n.outerRadius)?Number(n.outerRadius):0,f=i.isNumber(n.innerRadius)?Number(n.innerRadius):0,t=i.isNumber(n.startAngle)?Number(n.startAngle):0,r=i.isNumber(n.endAngle)?Number(n.endAngle):360;this.segments=[["M",0,0],["Z"]],(u||f)&&(e=Math.min(u,f),u=Math.max(u,f),f=e,Math.round(t)!=Math.round(r)&&(Math.abs(r-t)%360==0&&(r-=.0001),t>360&&(t=t%360),r>360&&(r=r%360),t>r&&(t-=360),t=t*Math.PI/180,r=r*Math.PI/180,this.segments=this.createArcSegments(o,s,f,u,t,r))),delete n.x,delete n.y,delete n.outerRadius,delete n.innerRadius,delete n.startAngle,delete n.endAngle,this.combinePathParams(n)}}}),d=r.inherit({defaultSettings:function(){return{cx:0,cy:0,r:0}},ctor:function(n,t){this.callBase(n,"circle",t)}}),g=r.inherit({defaultSettings:function(){return{x:0,y:0}},ctor:function(n,t){this.tspans=[],this.callBase(n,"text",t)},dispose:function(){this.tspans=null,this.callBase()},updateText:function(n){i.isDefined(n)||(n=""),this.applySettings({text:n})},adjustSettings:function(){if(!("text"in this.settings)){this.changeX();return}this._createElementWithText(this.settings.text)},changeX:function(){for(var n=0;n<this.tspans.length;n++)this.tspans[n].settings.x!=undefined&&this.tspans[n].applySettings({x:this.settings.x})},_createElementWithText:function(n){var t,i;this.clear(),n=n.toString().replace(/\r/g,""),n=n.replace(/\n/g,"<br/>"),t=o.createElement("div"),t.innerHTML=n,t.params={style:{}},this._orderText(t)},clear:function(){this.callBase(),this.tspans=[]},_orderText:function(n){var i=[],f=(this.settings.font?this.settings.font.size:12)||12,u=function(n,t,i){var r={style:{}},i=i||[],f,o,e;if(t.params=t.params||{},t.parentNode&&t.nodeName!="#text"&&t.parentNode.params)for(f in t.parentNode.params)t.params[f]=t.parentNode.params[f];switch(t.tagName){case"B":t.params.fontWeight="bold";break;case"I":t.params.fontStyle="italic";break;case"U":t.params.textDecoration="underline";break;case"BR":n++}for(t.style&&(t.style.fontSize&&(t.params.fontSize=t.style.fontSize.split("p")[0]||t.params.fontSize),t.params.fill=t.style.color||t.params.fill,t.params.fontStyle=t.style.fontStyle||t.params.fontStyle,t.params.fontWeight=t.style.fontWeight||t.params.fontWeight,t.params.textDecoration=t.style.textDecoration||t.params.textDecoration),o=t.childNodes.length,e=0;e!=o;)n=u(n,t.childNodes[e++],i);return t.wholeText!=undefined&&(r.fill=t.parentNode.params.fill,r.text=t.wholeText,t.parentNode.params.fontSize&&(r.style.fontSize=t.parentNode.params.fontSize),t.parentNode.params.fontStyle&&(r.style.fontStyle=t.parentNode.params.fontStyle),t.parentNode.params.fontWeight&&(r.style.fontWeight=t.parentNode.params.fontWeight),t.parentNode.params.textDecoration&&(r.style.textDecoration=t.parentNode.params.textDecoration),i.push({params:r,line:n})),n},t,r;for(u(0,n,i),t=0;t<i.length;t++)t!=0?i[t].line!=i[t-1].line?(i[t].params.dy=i[t].params.fontSize||f,i[t].params.x=this.settings.x):(i[t].params.dy=0,i[t].params.dx=0):(i[t].params.x=this.settings.x,i[t].params.dy=0),r=new nt(this.renderer,i[t].params),r.append(this),this.tspans.push(r)}}),nt=r.inherit({ctor:function(n,t){var i=t.text||"";delete t.text,this.callBase(n,"tspan",t),this.element.appendChild(o.createTextNode(i))}}),tt=r.inherit({ctor:function(n,t){this.callBase(n,"g",t)},update:n.noop}),it=r.inherit({ctor:function(n,t){var u=i.getNextPatternId(),r=t.color;this.callBase(n,"pattern",{id:u,width:6,height:6}),this.element.setAttribute("patternUnits","userSpaceOnUse"),this._lines=[],t.hatching==="right"?(this._lines.push(n.createLine(0,0,1,1,{strokeWidth:1,stroke:r,opacity:.8}).append(this)),this._lines.push(n.createLine(5,5,6,6,{strokeWidth:1,stroke:r,opacity:.8}).append(this)),this._lines.push(n.createLine(0,6,6,0,{strokeWidth:2,stroke:r}).append(this))):t.hatching==="left"&&(this._lines.push(n.createLine(5,1,6,0,{strokeWidth:1,stroke:r,opacity:.8}).append(this)),this._lines.push(n.createLine(0,6,1,5,{strokeWidth:1,stroke:r,opacity:.8}).append(this)),this._lines.push(n.createLine(0,0,6,6,{strokeWidth:2,stroke:r}).append(this))),this.id="url(#"+u+")"},append:function(){return this.callBase(this.renderer.defsSvg)},clear:function(){this.callBase(),this._lines=[]},dispose:function(){this._lines=null,this.callBase()}}),rt=r.inherit({ctor:function(n,t){var u=t.x,f=t.y,e=t.w,o=t.h,r=i.getNextClipId();delete t.x,delete t.y,delete t.w,delete t.h,this.callBase(n,"clipPath",{id:r}),this.id=r,this._rect=n.createRect(u,f,e,o,0,t),this._rect.append(this)},append:function(){return this.callBase(this.renderer.defsSvg)},updateRectangle:function(n){this._rect.applySettings(n)},dispose:function(){this._rect=null,this.callBase()}});c.SvgRenderer=l.inherit({ctor:function(n){n=n||{},this._setAnimationOptions(n.animation||{}),this.cssClass=n.cssClass||"",this.recreateCanvas(n.width,n.height)},dispose:function(){this.killContainer(),this.animOptions=null},_setAnimationOptions:function(n){this.animOptions={enabled:!0,duration:1e3,easing:"easeOutCubic"},"enabled"in n&&(this.animOptions.enabled=n.enabled),"duration"in n&&(this.animOptions.duration=n.duration),"easing"in n&&s[n.easing]&&(this.animOptions.easing=n.easing)},updateAnimationOptions:function(t){this._setAnimationOptions(n.extend(this.animOptions||{},t))},killContainer:function(){this.svgRoot&&(this.svgRoot.remove(),this.svgRoot=null),this.defsSvg&&(this.defsSvg.remove(),this.defsSvg=null),this.drawn=null},recreateCanvas:function(n,t,i){n>0&&t>0&&(this.svgRoot?this.svgRoot.applySettings({width:n,height:t}):(this.cssClass=i||this.cssClass,this.svgRoot=new a(this,{width:n,height:t,"class":this.cssClass})),this.defsSvg&&this.defsSvg.clear("pattern"))},resize:function(n,t){var i=this.getRoot();i&&n>0&&t>0&&i.applySettings({width:n,height:t})},getRoot:function(){return this.svgRoot},isInitialized:function(){return!!this.svgRoot},draw:function(n){n&&!this.drawn&&(n.appendChild(this.getRoot().element),this.drawn=!0)},updateParams:function(n,t){t&&t.strokeWidth&&(n.strokeWidth=t.strokeWidth)},createRect:function(t,i,r,u,f,e){var o={x:t,y:i,width:r,height:u,rx:f,ry:f};return e&&!e.inh&&n.extend(o,e),this.updateParams(o,e),new y(this,o)},createSegmentRect:function(t,i,r,u,f,e,o){var s=n.extend({},o||{},{x:t,y:i,width:r,height:u,rx:f,ry:f,segments:e});return new p(this,s)},createClipRect:function(n,t,i,u){var f={x:n,y:t,w:i,h:u,fill:"none",stroke:"none",strokeWidth:0};return this.defsSvg||(this.defsSvg=new r(this,"defs"),this.defsSvg.append()),new rt(this,f)},createPattern:function(n,t){return(t=(t||"").toLowerCase(),t!=="right"&&t!=="left")?{id:n,append:function(){return this},clear:function(){}}:(this.defsSvg||(this.defsSvg=new r(this,"defs"),this.defsSvg.append()),new it(this,{hatching:t,color:n}))},createImage:function(t,i,r,u,f,e){var o=n.extend({},e||{},{x:t,y:i,width:r,height:u});return new v(this,o,f,o.location)},createLine:function(t,i,r,u,e){var o={points:[t,i,r,u]};return e&&!e.inh&&n.extend(o,e),this.updateParams(o,e),new f(this,o)},createPath:function(t,i){var r={points:t};return i&&!i.inh&&n.extend(r,i),this.updateParams(r,i),new f(this,r)},createBezierPath:function(t,i){var r={points:t};return i&&!i.inh&&n.extend(r,i),this.updateParams(r,i),new h(this,r)},createArea:function(t,i){var r={points:t};return i&&!i.inh&&n.extend(r,i),this.updateParams(r,i),new w(this,r)},createBezierArea:function(t,i){var r={points:t};return i&&!i.inh&&n.extend(r,i),this.updateParams(r,i),new b(this,r)},createCircle:function(t,i,r,u){var f={cx:t,cy:i,r:r};return u&&!u.inh&&n.extend(f,u),new d(this,f)},createArc:function(t,i,r,u,f,e,o){var s={x:t,y:i,outerRadius:r,innerRadius:u,startAngle:f,endAngle:e};return o&&!o.inh&&n.extend(s,o),this.updateParams(s,o),new k(this,s)},createText:function(t,i,r,u){var f={x:i,y:r,text:t};return u&&!u.inh&&n.extend(f,u),new g(this,f)},createGroup:function(n){return new tt(this,n)}}),c._svgRendererInternals={BaseSvgElement:r,RootSvgElement:a,RectSvgElement:y,ImageSvgElement:v,PathSvgElement:f,AreaSvgElement:w,BezierSvgElement:h,BezierAreaSvgElement:b,CircleSvgElement:d,TextSvgElement:g,TspanSvgElement:nt,GroupSvgElement:tt,ArcSvgElement:k,RectSvgBaseElement:e,SegmentRectSvgElement:p,ClipRectSvgElement:rt,PatternSvgElement:it}}(jQuery,DevExpress),function(n,t){var s=t.viz.renderers,u=t.utils,f=document,i=s._svgRendererInternals,y={x:0,y:0,width:1,height:1,position:"absolute"},e=function(t,i){return n.extend(!0,i||{},y,t)},h=function(t,i,r){var f;return u.isDefined(t)&&(u.isNumber(t)?f={angle:t,x:i||0,y:r||0}:n.isArray(t)?f={angle:t[0]||0,x:t[1]||0,y:t[2]||0}:u.isObject(t)&&(f={angle:t.angle||0,x:t.x||0,y:t.y||0})),f},p=function(n,t,i){var e=n.element,r,u=t[i];(i==="opacity"||i==="fillOpacity")&&(e.fill?e.fill.opacity=u>=.002?u:.002:(r=f.createElement("vml:fill"),e.appendChild(r),r.opacity=u>=.002?u:.002,r.className="vml",t.fillcolor&&(r.color=t.fillcolor))),i==="joinStyle"&&(e.stroke?e.stroke.joinStyle=u:(r=f.createElement("vml:stroke"),n.element.appendChild(r),r.className="vml",r.joinStyle=u)),(i==="opacity"||i==="strokeOpacity")&&(e.stroke?e.stroke.opacity=u>=.002?u:.002:(r=f.createElement("vml:stroke"),n.element.appendChild(r),r.className="vml",r.opacity=u>=.002?u:.002,t.strokecolor&&(r.color=t.strokecolor))),i==="dashstyle"&&(e.stroke?e.stroke.dashstyle=u:(r=f.createElement("vml:stroke"),n.element.appendChild(r),r.className="vml",r.dashstyle=u))},l=function(n){var r,t,i,e=n.tagName.toLowerCase(),o,u,f;if(e==="div"){if(n.childNodes.length>0)for(t={},r=0;r<n.childNodes.length;r++)(i=l(n.childNodes[r]),i)&&(t.left=t.left===undefined||i.left<t.left?i.left:t.left,t.top=t.top===undefined||i.top<t.top?i.top:t.top,t.right=t.right===undefined||i.right>t.right?i.right:t.right,t.bottom=t.bottom===undefined||i.bottom>t.bottom?i.bottom:t.bottom)}else if(e==="shape"||e==="vml:shape"){for(o=(n.path.value||n.path).match(/[-0-9]+/g),t={},i=n.getBoundingClientRect(),r=0;r<o.length;r++)u=parseInt(o[r]),r%2?(t.top=t.top===undefined||u<t.top?u:t.top,t.bottom=t.bottom===undefined||u>t.bottom?u:t.bottom):(t.left=t.left===undefined||u<t.left?u:t.left,t.right=t.right===undefined||u>t.right?u:t.right);t.left=t.left||0,t.top=t.top||0,t.right=t.right||0,t.bottom=t.bottom||0,i.right-i.left<=1&&i.top-i.bottom<=1?(t.right=t.right+i.left,t.bottom=t.bottom+i.top,t.left=t.left+i.left,t.top=t.top+i.top):(t.right=t.right-t.left+i.left,t.bottom=t.bottom-t.top+i.top,t.left=i.left,t.top=i.top),f=Math.ceil(parseFloat(n.strokeweight)/2),f&&f>1&&(t.left-=f,t.top-=f,t.right+=f,t.bottom+=f)}else t=n.getBoundingClientRect();return t},r={isVml:function(){return!0},dispose:function(){this.childElements=null,this._style=null,this.callBase()},defaultSettings:function(n){return e(n,this.callBase?this.callBase():{})},createElement:function(n){if(this._nodeName=n,this.childElements=[],this.isVml()){var t=f.createElement("vml:"+n);return t.className="vml",t}return f.createElement(n)},clear:function(){this.callBase(),this.childElements=[]},_fillAttributesFromCurrentStyle:function(n){var t=this.element,r,i=this.renderer.getRoot(),u=i&&i.element.currentStyle&&i.element.currentStyle.color;this.isVml()&&t.style&&t.currentStyle&&(t.style.backgroundColor==="transparent"&&(t.style.backgroundColor=""),t.currentStyle.backgroundColor!=="transparent"&&(r=t.currentStyle.backgroundColor,this instanceof a||(t.style.backgroundColor="transparent"),n.filled="t",n.fillcolor=r,t.currentStyle.opacity&&(t.style.filter="alpha(opacity="+t.currentStyle.opacity*100+")",delete n.opacity,delete n.fillOpacity)),u&&t.currentStyle.color!==u&&(n.stroked="t",n.strokecolor=this.element.currentStyle.color,t.currentStyle.opacity&&(n.strokeOpacity=t.currentStyle.opacity)))},_applyAttributes:function(n){var t,i;if(n&&n.arcsize!==undefined){try{this.element.setAttribute("arcsize",n.arcsize)}catch(r){}delete n.arcsize}if(this._isAppended){if(n=n||this._delayedAttributes,n){this._fillAttributesFromCurrentStyle(n);for(t in n)i=n[t],t==="opacity"||t==="fillOpacity"||t==="strokeOpacity"||t==="dashstyle"||t==="joinStyle"?p(this,n,t):t==="class"?this.element.className=this.isVml()?"vml "+i:i:this.element[t]=i;delete this._delayedAttributes}}else this._delayedAttributes=n,u.isDefined(n["class"])&&(this.isVml()||(this.element.className=n["class"]))},appendComplete:function(){this._isAppended=!0,this._applyAttributes(),n.each(this.childElements,function(n,t){t.appendComplete()})},append:function(n){var i=this.renderer.getRoot(),t=n||i;return t&&(t.element.appendChild(this.element),t.childElements.push(this)),(t===i||t._isAppended)&&this.appendComplete(),this},_normalizeSettings:function(t){var c,u={},f={},e,o,r,i,s,h,v=["position","display","visibility","filter","margin","marginTop","marginLeft","marginRight","marginBottom","whiteSpace","clip"];for(c in t)if(r=c,i=t[r],r==="x"||r==="translateX")o=t.x||0,t.translateX&&(o+=t.translateX),u.left=o+"px";else if(r==="y"||r==="translateY")o=t.y||0,t.translateY&&(o+=t.translateY),u.top=o+"px";else if(r==="width")u.width=i+"px";else if(r==="height")u.height=i+"px";else if(r==="align")u.textAlign=i;else if(n.inArray(r,v)!=-1)u[r]=i;else if(r==="fill")this.isVml()?(f.filled=i==="none"?"f":"t",f.fillcolor=i):u.color=i;else if(r==="opacity")f.opacity=i<.002?"99f":i;else if(r==="stroke")f.stroked=i==="none"?"f":"t",f.strokecolor=i;else if(r==="strokeWidth")f.strokeweight=i+"px";else if(r==="lineJoin")f.joinStyle=i;else if(r==="font"){if(!n.isPlainObject(i))continue;n.each(i,function(n){switch(n){case"color":case"cursor":s=n;break;case"opacity":s="opacity";break;default:h=n.charAt(0),s="font"+n.replace(h,h.toUpperCase())}u[s]=i[n]})}else if(r==="style")n.extend(!0,u,i);else if(r==="rotate")this._rotate=i;else if(r==="dashStyle")i=i.toLowerCase(),i!=="solid"&&(f.dashstyle=i);else if(r==="clipId"){if(e=this.renderer.getClipRect(i,this),e){var y=e.width,p=e.height,l=e.x,a=e.y,w=y+l,b=p+a;u.width=e.cSize.width,u.height=e.cSize.height,u.clip="rect("+a+"px, "+w+"px, "+b+"px, "+l+"px)"}}else if(r==="segments")continue;else f[r]=i;return this._style=u,f},_getBBox:function(){var u,f,n,e,i=0,r=0,t=this.element;try{n=l(t),u=n.right-n.left,f=n.bottom-n.top,e=this.renderer.getRoot().element.getBoundingClientRect(),i=n.left-e.left,r=n.top-e.top,t.tagName.toLowerCase()==="div"&&(i=i-parseInt(t.style.left,10),r=r-parseInt(t.style.top,10))}catch(o){u=t.offsetWidth||0,f=t.offsetHeight||0}return{x:i,y:r,width:u,height:f}},getBBox:function(){return this._getBBox()},sharpEdges:function(){}},w=function(n){switch(n){case"M":return"m";case"L":return"l";case"Z":return"x e"}return n},o={defaultSettings:function(){return n.extend(this.callBase(),{coordsize:"1,1",fill:"none",strokecolor:"black",stroked:"t"})},getNodeName:function(){return"shape"},getPathAttributeName:function(){return"path"},customizeSegments:function(t){var i=t;return t&&(i=n.map(t,function(n){var i,r=[],u=w(n[0]);for(r.push(u),i=1;i<n.length;i++)r.push(Math.floor(n[i]));return[r]})),i}},b=i.BaseSvgElement.inherit(r).inherit({isVml:function(){return!1},defaultSettings:function(){return{width:0,height:0,position:"relative",display:"inline-block",overflow:"hidden"}},ctor:function(n,t){this.callBase(n,"div",t)}}),k=i.BaseSvgElement.inherit(i.RectSvgBaseElement).inherit(r).inherit({ctor:function(n,t){this.callBase(n,"image",t)},defaultSettings:function(){return n.extend(this.callBase(),{strokeWidth:0})},adjustSettings:function(){this.callBase(),this.settings.href&&(this.settings.src=this.settings.href,delete this.settings.href)}}),a=i.BaseSvgElement.inherit(i.RectSvgBaseElement).inherit(r).inherit({defaultSettings:function(){return e({stroked:"f",strokeWidth:0,rx:0,ry:0})},recreateElement:function(t){var r,i;this._nodeName=t,r=this.$element.parent()[0],r?(i=this.$element,this.element=this.createElement(t),this.$element=n(this.element),this.$element.insertBefore(i),i.remove()):(this.element=this.createElement(t),this.$element=n(this.element)),this.applySettings()},_adjustArcSize:function(){var t=this.settings,f=t.rx||0,e=t.ry||0,o=t.width,s=t.height,r,u,i;(t.rx!==undefined||t.ry!==undefined)&&(r=Math.max(f,e),u=Math.max(o,s)/2,i=r/u,t.arcsize=i,n.isNumeric(i)&&i!=0?this._nodeName!=="roundrect"&&this.recreateElement("roundrect"):this._nodeName==="roundrect"&&this.recreateElement("rect"),delete t.rx,delete t.ry)},_adjustRotation:function(){var n=this.settings,v=this.settings.rotate,e,o,s,c,i,r,l,a,u,f,t;t=h(v,n.x,n.y),t&&(e=t.angle,i=t.x,r=t.y,o=e*Math.PI/180,s=Math.cos(o),c=Math.sin(o),u=n.x+(n.translateX||0)+n.width/2,f=n.y+(n.translateY||0)+n.height/2,a=(u-i)*s-(f-r)*c+i-u,l=(u-i)*c+(f-r)*s+r-f,this.settings.marginLeft=Math.round(a)+"px",this.settings.marginTop=Math.round(l)+"px",this.settings.rotation=e)},adjustSettings:function(){this.callBase(),this._adjustArcSize(),this._adjustRotation()},ctor:function(n,t){this.callBase(n,"rect",t)}}),c=i.PathSvgElement.inherit(r).inherit(o).inherit({prepareSegments:function(t){var p=t.rotate,l,r,u,a,f,e,o,s,c,v,y,i;this.callBase(t),a=this.segments,i=h(p,t.x,t.y),i&&(l=i.angle,r=i.x,u=i.y,this.segments&&(f=l*Math.PI/180,e=Math.cos(f),o=Math.sin(f),this.segments=n.map(this.segments,function(n){return n.length===3?(s=n[1],c=n[2],v=(s-r)*e-(c-u)*o+r,y=(s-r)*o+(c-u)*e+u,[[n[0],Math.floor(v),Math.floor(y)]]):[n]}),this.combinePathParams(t),this.segments=a))}}),d=c.inherit({defaultSettings:function(){var n=this.callBase();return e({points:{x:0,y:0},fill:"black",stroke:"none"},n)},ctor:function(n,t){this.closePath=!0,this.callBase(n,t)}}),g=i.SegmentRectSvgElement.inherit(r).inherit(o).inherit({defaultSettings:function(){var n=this.callBase();return n.lineJoin="miter",delete n.fill,delete n.stroke,delete n.strokecolor,delete n.stroked,n},prepareSegments:function(){this.callBase(),this.segments=this.customizeSegments(this.segments),this.settings.x=0,this.settings.y=0,this.settings.width=1,this.settings.height=1},applySettings:function(n){var t=n.x,i=n.y,r=n.width,u=n.height;this.callBase(n),this.settings.x=t,this.settings.y=i,this.settings.width=r,this.settings.height=u}}),v=i.BezierSvgElement.inherit(r).inherit(o),nt=v.inherit({defaultSettings:function(){var n=this.callBase();return e({points:{x:0,y:0},fill:"black",stroke:"none"},n)},ctor:function(n,t){this.closePath=!0,this.callBase(n,t)}}),tt=i.ArcSvgElement.inherit(r).inherit(o).inherit({createArcSegments:function(n,t,i,r,u,f){var e=n+r*Math.cos(u),o=t-r*Math.sin(u),s=n+r*Math.cos(f),h=t-r*Math.sin(f),c=n+i*Math.cos(f),l=t-i*Math.sin(f),a=n+i*Math.cos(u),v=t-i*Math.sin(u);return[["wr",n-i,t-i,n+i,t+i,c,l,a,v],["at",n-r,t-r,n+r,t+r,e,o,s,h],["x e"]]}}),it=i.BaseSvgElement.inherit(r).inherit({defaultSettings:function(){return e({cx:0,cy:0,r:0})},applySettings:function(n){return n.cx=n.cx||n.x,n.cy=n.cy||n.y,this.callBase(n)},adjustSettings:function(){var n,t,i;(this.settings.cx!==undefined||this.settings.cy!==undefined||this.settings.r!==undefined)&&(n="r"in this.settings?this.settings.r:this.settings.width/2,t="cx"in this.settings?this.settings.cx:this.settings.x+this.settings.width/2,i="cy"in this.settings?this.settings.cy:this.settings.y+this.settings.width/2,this.settings.x=t-n,this.settings.y=i-n,this.settings.width=this.settings.height=n*2,delete this.settings.cx,delete this.settings.cy,delete this.settings.r)},ctor:function(n,t){this.callBase(n,"oval",t)}}),rt=i.BaseSvgElement.inherit(r).inherit({isVml:function(){return!1},defaultSettings:function(){return{x:0,y:0,position:"absolute",whiteSpace:"nowrap"}},ctor:function(n,t){this.callBase(n,"span",t)},adjustSettings:function(){var t;"text"in this.settings&&(t=u.isDefined(this.settings.text)?this.settings.text:"",t=t.toString().replace(/\r/g,""),t=t.replace(/\n/g,"<br/>"),n(this.element).html(t),delete this.settings.text)},updateText:function(n){this.applySettings({text:u.isDefined(n)?n:""})},_applyAttributes:function(n){this.callBase(n);var n=this.settings,d=this.settings.rotate,t=0,v,y,i=1,r=0,p,w=this.settings.y+(this.settings.translateY||0),b=this.settings.x+(this.settings.translateX||0),g=this.settings.align,k=this.getBBox(),c=this._style||{},f=0,e=0,u,a,l,o=k.width,s=k.height;l=h(d,b,w),l&&(t=l.angle,v=l.x,y=l.y,Math.abs(t)>360&&(t=t%360),t<0&&(t=t+360),t?(p=t*Math.PI/180,i=Math.cos(p),r=Math.sin(p),c.filter='progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = '+i.toFixed(5)+", M12 = "+(-r).toFixed(5)+", M21 = "+r.toFixed(5)+", M22 = "+i.toFixed(5)+")"):c.filter="",f=(b-v)*(i-1)-(w-y)*r,e=(b-v)*r+(w-y)*(i-1)),(s||o)&&(u=s*(.55+.45/2),t<90?(e-=u*i,f-=(s-u)*r):t<180?(e+=(s-u)*i,f+=o*i-(s-u)*r):t<270?(e+=(s-u)*i+o*r,f+=o*i+u*r):(e+=o*r-u*i,f+=u*r),a={center:.5,right:1}[g],a&&(f-=o*a*i,e-=o*a*r),c.marginLeft=Math.round(f)+"px",c.marginTop=Math.round(e)+"px"),this.applyStyle(c)}}),ut=i.BaseSvgElement.inherit(r).inherit({isVml:function(){return!1},defaultSettings:function(){return{x:0,y:0,position:"absolute"}},ctor:function(n,t){this.callBase(n,"div",t)},applySettings:function(t){var r=this.callBase,i;return t=t||{},i=t.rotate,i&&(u.isNumber(i)&&(i=[i,t.x||0,t.y||0]),n.each(this.childElements,function(n,t){t.applySettings({rotate:i})})),delete t.rotate,t.x=0,t.y=0,this.callBase=r,this.callBase(t)},getBBox:function(){return this._getBBox()},update:function(){if(this.settings.clipId){var n=this.getBBox();this.applyStyle({left:n.x+(this.settings.translateX||0),right:n.y+(this.settings.translateY||0),width:n.width,height:n.height})}}});s.VmlRenderer=s.SvgRenderer.inherit({ctor:function(n){n=n||{},n.animation={enabled:!1},document.namespaces&&!document.namespaces.vml&&(document.namespaces.add("vml","urn:schemas-microsoft-com:vml"),document.createStyleSheet().addRule(".vml","behavior: url(#default#VML); display: inline-block;")),this._clipRects={},this.cssClass=n.cssClass||"",this.callBase(n)},dispose:function(){this.callBase(),this._clipRects=null,this._size=null},updateAnimationOptions:n.noop,recreateCanvas:function(n,t,i){n>0&&t>0&&(this._size={width:n,height:t},this.svgRoot?this.svgRoot.applySettings({width:n,height:t}):(this.cssClass=i||this.cssClass,this.svgRoot=new b(this,{width:n,height:t,"class":this.cssClass})),this.defsSvg&&this.defsSvg.clear())},_getSize:function(){return this._size||{}},createRect:function(t,i,r,u,f,e){var o=n.extend(!0,{},e||{},{x:t,y:i,width:r,height:u,rx:f,ry:f});return new a(this,o)},createSegmentRect:function(t,i,r,u,f,e,o){var s=n.extend({},o||{},{x:t,y:i,width:r,height:u,rx:f,ry:f,segments:e});return new g(this,s)},createClipRect:function(t,i,r,f){var e=u.getNextClipId(),o=[],s={id:e,x:t,y:i,width:r,height:f,cSize:this._getSize(),addElement:function(t){var i=!1;n.each(o,function(){if(this===t)return i=!0,!1}),i||o.push(t)},append:function(){return this},remove:function(){},updateRectangle:function(t){return"x"in t&&(this.x=t.x),"translateX"in t&&(this.x+=t.translateX),"y"in t&&(this.y=t.y),"translateY"in t&&(this.y+=t.translateY),"width"in t&&(this.width=t.width),"height"in t&&(this.height=t.height),n.each(o,function(){this.applySettings({clipId:e})}),this}};return this._clipRects[e]=s,s},getClipRect:function(n,t){var i=this._clipRects[n];return i&&t&&i.addElement(t),this._clipRects[n]},createImage:function(t,i,r,u,f,e){var o=n.extend(!0,{},e||{},{x:t,y:i,width:r,height:u,href:f});return new k(this,o)},createLine:function(t,i,r,u,f){var e=n.extend(!0,{},f||{},{points:[t,i,r,u]});return new c(this,e)},createPath:function(t,i){var r=n.extend(!0,{},i||{},{points:t});return new c(this,r)},createBezierPath:function(t,i){var r=n.extend(!0,{},i||{},{points:t});return new v(this,r)},createArea:function(t,i){var r=n.extend(!0,{},i||{},{points:t});return new d(this,r)},createBezierArea:function(t,i){var r=n.extend(!0,{},i||{},{points:t});return new nt(this,r)},createCircle:function(t,i,r,u){var f=n.extend(!0,{},u||{},{cx:t,cy:i,r:r});return new it(this,f)},createArc:function(t,i,r,u,f,e,o){var s=n.extend(!0,{},o||{},{x:t,y:i,outerRadius:r,innerRadius:u,startAngle:f,endAngle:e});return new tt(this,s)},createText:function(t,i,r,u){var f=n.extend(!0,{},u||{},{x:i,y:r,text:t});return new rt(this,f)},createGroup:function(n){return new ut(this,n)},createPattern:function(n){return{id:n,append:function(){return this},clear:function(){}}}})}(jQuery,DevExpress),function(n,t){function u(){return!!document.createElementNS&&!!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect}var i=t.viz.renderers,r=t.browser;r.msie&&r.version<9?i.Renderer=i.VmlRenderer:u()&&(i.Renderer=i.SvgRenderer)}(jQuery,DevExpress),function(n){n.viz.charts={series:{}}}(DevExpress),function(n,t,i){var r=t.utils.isDefined,u=t.utils.isDate,f=1,e=6e4;t.viz.charts.Range=t.Class.inherit(function(){var p=function(t){t&&n.extend(this,t)},w=function(){this.categoriesY=null,this.categoriesX=null},o=function(n,t){return t<n},s=function(n,t){return t>n},t=function(n,t,r,u){var e=n!==i,f=t!==i;e?f&&u(n,t)&&r(t):f&&r(t)},b=function(n){return c.call(this,n),h.call(this,n),this},h=function(r){var u=this,h=u.categoriesY,f=r.categoriesY,e,c=function(n){var t=(u[n+"Priority"]||0)-(r[n+"Priority"]||0);((u[n]||0)<r[n]&&t===0||t<0)&&(u[n]=r[n],u[n+"Priority"]=r[n+"Priority"])};if(u.invertY=u.invertY||r.invertY,u.stickY=u.stickY||r.stickY,u.keepValueMarginsY=u.keepValueMarginsY||r.keepValueMarginsY,t(u.minY,r.minY,function(n){u.minY=n},o),t(u.intervalY,r.intervalY,function(n){u.intervalY=n},o),t(u.maxY,r.maxY,function(n){u.maxY=n},s),t(u.minVisibleY,r.minVisibleY,function(n){u.minVisibleY=n},o),t(u.maxVisibleY,r.maxVisibleY,function(n){u.maxVisibleY=n},s),c("minValueMarginY"),c("maxValueMarginY"),h===i)u.categoriesY=f;else if(f&&f.length)for(e=0;e<f.length;e++)n.inArray(f[e],h)===-1&&h.push(f[e]);return this},c=function(r){var u=this,h=u.categoriesX,f=r.categoriesX,e,c=function(n){var t=(u[n+"Priority"]||0)-(r[n+"Priority"]||0);((u[n]||0)<r[n]&&t===0||t<0)&&(u[n]=r[n],u[n+"Priority"]=r[n+"Priority"])};if(u.invertX=u.invertX||r.invertX,u.stickX=u.stickX||r.stickX,u.keepValueMarginsX=u.keepValueMarginsX||r.keepValueMarginsX,t(u.minX,r.minX,function(n){u.minX=n},o),t(u.intervalX,r.intervalX,function(n){u.intervalX=n},o),t(u.maxX,r.maxX,function(n){u.maxX=n},s),t(u.minVisibleX,r.minVisibleX,function(n){u.minVisibleX=n},o),t(u.maxVisibleX,r.maxVisibleX,function(n){u.maxVisibleX=n},s),c("minValueMarginX"),c("maxValueMarginX"),h===i)u.categoriesX=f;else if(f&&f.length)for(e=0;e<f.length;e++)n.inArray(f[e],h)===-1&&h.push(f[e]);return this},k=function(){return l.call(this)||a.call(this)},l=function(){return r(this.minX)&&r(this.maxX)||r(this.categoriesX)},a=function(){return r(this.minY)&&r(this.maxY)||r(this.categoriesY)},d=function(n){v.call(this,n),y.call(this,n)},v=function(t){var i=(new Date).getYear()-1,r=t==="datetime"?new Date(i,0,1):0,u=t==="datetime"?new Date(i,11,31):10;n.extend(this,{minX:r,maxX:u,stubDataX:!0})},y=function(t){var i=(new Date).getYear()-1,r=t==="datetime"?new Date(i,0,1):0,u=t==="datetime"?new Date(i,11,31):10;n.extend(this,{minY:r,maxY:u,stubDataY:!0})},g=function(n){var t,i,f=u(n.maxX)||u(n.minX),e=u(n.maxY)||u(n.minY);r(n.maxX)&&r(n.minX)&&(t=n.maxX-n.minX),r(n.maxY)&&r(n.minY)&&(i=n.maxY-n.minY),!i||e||n.keepValueMarginsY||(n.minY<=0&&n.maxY<=0&&n.maxValueMarginY&&n.maxValueMarginY>n.maxY/(n.minY-n.maxY)&&(n.maxValueMarginY=0,n.maxY=0),n.minY>=0&&n.maxY>=0&&n.minValueMarginY&&n.minValueMarginY>n.minY/(n.maxY-n.minY)&&(n.minValueMarginY=0,n.minY=0)),!t||f||n.keepValueMarginsX||(n.minX<=0&&n.maxX<=0&&n.maxValueMarginX&&n.maxValueMarginX>n.maxX/(n.minX-n.maxX)&&(n.maxValueMarginX=0,n.maxX=0),n.minX>=0&&n.maxX>=0&&n.minValueMarginX&&n.minValueMarginX>n.minX/(n.maxX-n.minX)&&(n.minValueMarginX=0,n.minX=0))},nt=function(){var n=this,t,i,f,e,o=u(n.maxX)||u(n.minX),s=u(n.maxY)||u(n.minY);g(n),r(n.maxX)&&r(n.minX)&&(t=n.maxX-n.minX),r(n.maxY)&&r(n.minY)&&(i=n.maxY-n.minY),(!r(n.minVisibleX)||n.minVisibleX<n.minX||n.minVisibleX>n.maxX)&&(n.minVisibleX=n.minX),(!r(n.maxVisibleX)||n.maxVisibleX<n.minX||n.maxVisibleX>n.maxX)&&(n.maxVisibleX=n.maxX),(!r(n.minVisibleY)||n.minVisibleY<n.minY||n.minVisibleY>n.maxY)&&(n.minVisibleY=n.minY),(!r(n.maxVisibleY)||n.maxVisibleY<n.minY||n.maxVisibleY>n.maxY)&&(n.maxVisibleY=n.maxY),f=n.maxVisibleX-n.minVisibleX,e=n.maxVisibleY-n.minVisibleY,r(n.minX)&&n.minValueMarginX&&(o?n.minX=new Date(n.minX.valueOf()-t*n.minValueMarginX):n.minX-=t*n.minValueMarginX),r(n.minVisibleX)&&n.minValueMarginX&&(o?n.minVisibleX=new Date(n.minVisibleX.valueOf()-f*n.minValueMarginX):n.minVisibleX-=f*n.minValueMarginX),r(n.maxX)&&n.maxValueMarginX&&(o?n.maxX=new Date(n.maxX.valueOf()+t*n.maxValueMarginX):n.maxX+=t*n.maxValueMarginX),r(n.maxVisibleX)&&n.maxValueMarginX&&(o?n.maxVisibleX=new Date(n.maxVisibleX.valueOf()+f*n.maxValueMarginX):n.maxVisibleX+=f*n.maxValueMarginX),r(n.minY)&&n.minValueMarginY&&(s?n.minY=new Date(n.minY.valueOf()-i*n.minValueMarginY):n.minY-=i*n.minValueMarginY),r(n.minVisibleY)&&n.minValueMarginY&&(s?n.minVisibleY=new Date(n.minVisibleY.valueOf()-e*n.minValueMarginY):n.minVisibleY-=e*n.minValueMarginY),r(n.maxY)&&n.maxValueMarginY&&(s?n.maxY=new Date(n.maxY.valueOf()+i*n.maxValueMarginY):n.maxY+=i*n.maxValueMarginY),r(n.maxVisibleY)&&n.maxValueMarginY&&(s?n.maxVisibleY=new Date(n.maxVisibleY.valueOf()+e*n.maxValueMarginY):n.maxVisibleY+=e*n.maxValueMarginY),n.applyEqualLimitsMargins()},tt=function(){var n=this,t=u(n.maxX)||u(n.minX),i=u(n.maxY)||u(n.minY);r(n.minX)&&r(n.maxX)&&n.minX.valueOf()===n.maxX.valueOf()&&(t?(n.minX=new Date(n.minX.valueOf()-e),n.maxX=new Date(n.maxX.valueOf()+e)):(n.minX=n.minX-f,n.maxX=n.maxX+f)),r(n.minVisibleX)&&r(n.maxVisibleX)&&n.minVisibleX.valueOf()===n.maxVisibleX.valueOf()&&(t?(n.minVisibleX=n.minVisibleX.valueOf()-e<n.minX.valueOf()?n.minX:new Date(n.minVisibleX.valueOf()-e),n.maxVisibleX=n.maxVisibleX.valueOf()+e>n.maxX.valueOf()?n.maxX:new Date(n.maxVisibleX.valueOf()+e)):(n.minVisibleX=n.minVisibleX-f<n.minX?n.minX:n.minVisibleX-f,n.maxVisibleX=n.maxVisibleX+f>n.maxX?n.maxX:n.maxVisibleX+f)),r(n.minY)&&r(n.maxY)&&n.minY.valueOf()===n.maxY.valueOf()&&(i?(n.minY=new Date(n.minY.valueOf()-e),n.maxY=new Date(n.maxY.valueOf()+e)):(n.minY=n.minY-f,n.maxY=n.maxY+f)),r(n.minVisibleY)&&r(n.maxVisibleY)&&n.minVisibleY.valueOf()===n.maxVisibleY.valueOf()&&(i?(n.minVisibleY=n.minVisibleY.valueOf()-e<n.minY.valueOf()?n.minY:new Date(n.minVisibleY.valueOf()-e),n.maxVisibleY=n.maxVisibleY.valueOf()+e>n.maxY.valueOf()?n.maxY:new Date(n.maxVisibleY.valueOf()+e)):(n.minVisibleY=n.minVisibleY-f<n.minY?n.minY:n.minVisibleY-f,n.maxVisibleY=n.maxVisibleY+f>n.maxY?n.maxY:n.maxVisibleY+f))};return{ctor:p,dispose:w,getBoundRange:b,getBoundRangeX:c,getBoundRangeY:h,isDefined:k,isDefinedX:l,isDefinedY:a,setStubData:d,setStubDataX:v,setStubDataY:y,applyValueMargins:nt,applyEqualLimitsMargins:tt}}())}(jQuery,DevExpress),function(n,t){t.viz.charts.Legend=t.Class.inherit({ctor:function(n,t,i){this.legendGroup=t,this.trackerGroup=i,this._init(n)},update:function(n){this._init(n)},dispose:function(){var t=this;n.each(t.trackers||[],function(n,t){t.removeData()}),t.trackers=null,t.labelFormatObject=null,t.seriesGroups=null,t.insideLegendGroup=null,t.legendGroup=null,t.trackerGroup=null,t.renderer=null,t.series=null,t.options=null},_init:function(t){var i,r=[];this.renderer=t.renderer,t.renderer=null,t.horizontalAlignment=(t.horizontalAlignment||"").toLowerCase(),t.horizontalAlignment!=="center"&&t.horizontalAlignment!=="right"&&t.horizontalAlignment!=="left"&&(t.horizontalAlignment="right"),t.verticalAlignment=(t.verticalAlignment||"").toLowerCase(),t.verticalAlignment!=="top"&&t.verticalAlignment!=="bottom"&&(t.horizontalAlignment==="center"&&(t.verticalAlignment="bottom"),(t.horizontalAlignment==="right"||t.horizontalAlignment==="left")&&(t.verticalAlignment="top")),t.layout=(t.layout||"").toLowerCase(),t.layout!=="horizontal"&&t.layout!=="vertical"&&(t.horizontalAlignment==="center"&&(t.layout="horizontal"),(t.horizontalAlignment==="right"||t.horizontalAlignment==="left")&&(t.layout="vertical")),t.position=(t.position||"").toLowerCase(),t.position!=="outside"&&t.position!=="inside"&&(t.position="outside"),t.hoverMode=(t.hoverMode||"").toLowerCase(),t.customizeText=n.isFunction(t.customizeText)?t.customizeText:function(){return this.seriesName},this.series=n.map(t.series||[],function(n){return n.options.showInLegend?n:null}),t.series=null,this.options=t},formatLabel:function(n){return n.customizeText.call(this,this)},draw:function(){var f=this,a=f.renderer,t=f.options,u=f.series||{},g=0,nt=0,h=[],c,ot,k,rt,b,ut=t.markerSize,d=t.layout==="horizontal",o,v,i=t.columnCount,r=t.rowCount,s,tt,st=t.equalColumnWidth,y=[],ft,p,e,it=!1,w=f.canvas,l,et=t.border.visible&&t.border.width&&t.border.color&&t.border.color!=="none";if(t.visible&&u&&u.length){for(this.createClipRect(),this.legendGroup&&(this.legendGroup.clear(),this.trackerGroup.clear(),this.legendGroup.move(0,0),this.trackerGroup.move(0,0),this.clipRect&&this.legendGroup.applySettings({clipId:this.clipRect.id})),this.insideLegendGroup&&(this.insideLegendGroup.detach(),this.insideLegendGroup.remove(),this.insideLegendGroup=null),(t.position==="inside"||t.backgroundColor||et)&&(tt=a.createRect(0,0,0,0,0,{fill:t.backgroundColor||(t.position==="inside"?t.containerBackgroundColor:"none"),"class":"dxc-border"}).append(this.legendGroup)),this.insideLegendGroup=a.createGroup().append(this.legendGroup),c=0;c<u.length;c++)b=a.createGroup({"class":"dxc-item"}),b.append(this.insideLegendGroup),rt=a.createRect(g,nt,ut,ut,0,{fill:u[c].styles.themeColor,"class":u[c].className}).append(b),o=rt.getBBox(),s=t.itemTextPosition?t.itemTextPosition==="right":!d,f.labelFormatObject={seriesName:u[c].name,seriesNumber:u[c].index,seriesColor:u[c].styles.themeColor},ft=f.formatLabel.call(f.labelFormatObject,t),k=a.createText(ft,s?g+o.width+7:g,s?nt:nt+o.height+2,{font:t.font,align:s?"left":"center"}).append(b),v=k.getBBox(),s?k.move(0,~~(o.y+o.height/2-(v.y+v.height/2))):k.move(~~(o.x+o.width/2-(v.x+v.width/2)),o.y+o.height+2-v.y),y.push(a.createRect(0,0,0,0,0,{stroke:"none",fill:"grey",opacity:.0001,inh:!0})),h.push(b);if(i&&!r?r=Math.ceil(u.length/i):!i&&r?i=Math.ceil(u.length/r):i&&r?d&&i<Math.ceil(u.length/r)?i=Math.ceil(u.length/r):!d&&r<Math.ceil(u.length/i)&&(r=Math.ceil(u.length/i)):(it=!0,d?(r=1,i=u.length):(i=1,r=u.length)),p=f.getDataRowsColumns(h,i,r),f.moveItems(p,h,this.insideLegendGroup,s,y),it&&r===1)for(e=this.insideLegendGroup.getBBox();e.width>w.width-w.right-w.left&&i>1;)i=Math.ceil(i/2),r=Math.ceil(u.length/i),p=f.getDataRowsColumns(h,i,r),f.moveItems(p,h,this.insideLegendGroup,s,y),e=this.insideLegendGroup.getBBox();else if(it&&i===1)for(e=this.insideLegendGroup.getBBox();e.height>w.height-w.top-w.bottom&&r>1;)r=Math.ceil(r/2),i=Math.ceil(u.length/r),p=f.getDataRowsColumns(h,i,r),f.moveItems(p,h,this.insideLegendGroup,s,y),e=this.insideLegendGroup.getBBox();tt&&(e=this.legendGroup.getBBox(),l={x:Math.round(e.x),y:Math.round(e.y),width:Math.round(e.width)+2*t.paddingLeftRight,height:Math.round(e.height)+2*t.paddingTopBottom},et&&(l.strokeWidth=t.border.width,l.stroke=t.border.color,l.strokeOpacity=t.border.opacity,l.dashStyle=t.border.dashStyle,l.rx=t.border.cornerRadius||0,l.ry=t.border.cornerRadius||0),tt.applySettings(l),f.insideLegendGroup.move(t.paddingLeftRight,t.paddingTopBottom),n.each(y,function(n,i){i.move(t.paddingLeftRight,t.paddingTopBottom)})),f.seriesGroups=h,f.trackers=y,f.drawTrackers()}},drawTrackers:function(){var t=this;n.each(t.trackers||[],function(n,i){i.data({series:t.series[n],mode:t.options.hoverMode}),i.append(t.trackerGroup)})},getDataRowsColumns:function(n,t,i){for(var c=this,u,l=c.options,a=l.equalColumnWidth,v=c.series||{},e=[],s=0,h=0,o,f,r=0;r<t;r++)e[r]=0;for(r=0;r<i;r++)for(u=0;u<t;u++){if(o=i<t?n[r*t+u]:n[r+u*i],!o)break;f=o.getBBox(),h<f.height&&(h=f.height),a?s<f.width&&(s=f.width):e[u]<f.width&&(e[u]=f.width)}return{rows:i,cols:t,maxWidthPerColumn:e,maxWidthColumn:s,maxHeightRow:h}},moveItems:function(n,t,i,r,u){var d=this,h,e,p,w,c,l,o,f=0,s=0,a,k=d.options,v=k.columnItemSpacing,y=k.rowItemSpacing,tt=k.equalColumnWidth,it=d.renderer,g=[],nt=0,b=0;for(p=n.rows,w=n.cols,b=n.maxHeightRow,nt=n.maxWidthColumn,g=n.maxWidthPerColumn,h=0;h<p;h++){for(e=0;e<w;e++){if(c=p<w?h*w+e:h+e*p,l=t[c],!l)break;o=l.getBBox(),a=tt?nt:g[e],r?(l.move(f-o.x,s),u[c].applySettings({x:f-v/2,y:s+o.y-y/2,height:b+y,width:a+v})):(l.move(f-o.x-o.width/2+a/2,s),u[c].applySettings({x:f-v/2,y:s+o.y-y/2,height:b+y,width:a+v})),f=f+a+v}s=s+b+y,f=0}},getBoundingRect:function(){return this.legendGroup?this.legendGroup.getBBox():{}},toForeground:function(){this.legendGroup&&this.legendGroup.toForeground()},createClipRect:function(){var n=this.canvas;n&&(this.clipRect?this.clipRect.updateRectangle({x:n.left,y:n.top,width:n.width-n.left-n.right,height:n.height-n.top-n.bottom}):this.clipRect=this.renderer.createClipRect(n.left,n.top,n.width-n.left-n.right,n.height-n.top-n.bottom).append())},updateClip:function(n){this.clipRect&&this.clipRect.updateRectangle({translateX:-n.translateX,translateY:-n.translateY}),this.legendGroup.update()},shift:function(n,t){var i={};n&&(i.translateX=n),t&&(i.translateY=t),this.legendGroup.applySettings(i),this.trackerGroup.applySettings(i),this.updateClip(i)}})}(jQuery,DevExpress),function(n,t,i){var r=t.formatHelper;t.viz.charts.Tooltip=t.Class.inherit({ctor:function(n,t){this.style={visibility:"hidden"},this.textStyle={align:"center",visibility:"hidden"},this.tooltipGroup=t,this._reinit(n)},dispose:function(){this.shadow=null,this.cloud=null,this.text=null,this.tooltipGroup=null,this.options=null,this.style=null,this.textStyle=null,this.renderer=null},update:function(n){this._reinit(n)},_reinit:function(t){t=t||{},this.renderer=t.renderer||this.renderer,this.customColor=t.color||this.customColor,this.textStyle.font=t.font||this.textStyle.font,this.canvasWidth=t.canvasWidth||this.canvasWidth,this.canvasHeight=t.canvasHeight||this.canvasHeight,delete t.renderer,delete t.font,this.options=n.extend(!0,{},this.options||{},t)},formatValueTooltip:function(n){return r.format(this.value,n.format,n.precision)},formatTooltip:function(n){return this.argumentText=r.format(this.argument,n.argumentFormat,n.argumentPrecision),this.percent!==i&&(this.percentText=r.format(this.percent,"percent",n.percentPrecision)),n.customizeText?n.customizeText.call(this,this):this.valueText},_getData:function(){var p=4,f=this.x,o=this.y,a=f,v=o,h,y="center",t=[],c=[],e=this.text.getBBox(),l=this.options.paddingLeftRight,w=this.options.paddingTopBottom,r=this.options.arrowLength>0?this.options.arrowLength:0,u=e.width+l*2,i=e.height+w*2,s;for(s=this._checkWidthText(u,i),s&&(e=s.bbox,u=s.cloudWidth,i=s.cloudHeight,l=s.paddingLeftRight,w=s.paddingTopBottom),u/2>f?(c=this._setArrowLeft(u,i,e,r,f,o),y="left",a+=l):f+u/2>this.canvasWidth?(c=this._setArrowRight(u,i,e,r,f,o),y="right",a-=l):c=this._setArrowCenter(u,i,e,r,f,o),i+r<o?v-=r+i/2-e.height/2+this.tooltipOffset:v+=r+i/2+e.height/2+this.tooltipOffset,n.extend(t,c),h=1;h<t.length;h+=2)i+r<o?t[h]+=p:t[h]-=p;return r>0&&(i+r<o?t[1]+=2:t[1]-=2,u/2>f?t[2]+=2:f+u/2>this.canvasWidth?t[t.length-2]-=2:(t[2]+=2,t[t.length-2]-=2)),{points:c,text:{x:a,y:v,align:y},pointsOfShadow:t}},_updateTooltip:function(){var n,t,i;this.text.updateText(this.tooltipText),t=this._getData(),this.shadow.applySettings({points:t.pointsOfShadow}),this.cloud.applySettings({points:t.points,fill:this.style.fill,"class":this.className}),this.text.applySettings({y:t.text.y}),n=this.text.getBBox(),this.text.applySettings({x:t.text.x,y:t.text.y-(n.y+n.height-t.text.y),align:t.text.align}),n=this.tooltipGroup.getBBox(),n.y+n.height>this.canvasHeight&&(i=(this.canvasHeight-n.y)/n.height,this.tooltipGroup.applySettings({scale:i,translateX:this.x*(1-i),translateY:this.y*(1-i)}))},draw:function(){this.shadow||(this.shadow=this.renderer.createPath({},{fill:"#000000",stroke:"none",visibility:"hidden",opacity:.1}),this.cloud=this.renderer.createArea({},this.style),this.text=this.renderer.createText("0",0,0,this.textStyle)),this.shadow.append(this.tooltipGroup),this.cloud.append(this.tooltipGroup),this.text.append(this.tooltipGroup)},show:function(){this.cloud.applySettings({visibility:"visible"}),this.text.applySettings({visibility:"visible"}),this.shadow.applySettings({visibility:"visible"})},hide:function(){this.cloud.applySettings({visibility:"hidden"}),this.text.applySettings({visibility:"hidden"}),this.shadow.applySettings({visibility:"hidden"})},move:function(n,t,i,r,u,f){this.x=n,this.y=t,this.tooltipOffset=i,this.tooltipText=r,this.style.fill=this.customColor||u,this.className=f,this._updateTooltip()},_setArrowCenter:function(n,t,i,r,u,f){var h=!1,s=[],o=u,e=f,c=20;return t+r<f?e-=this.tooltipOffset:(e+=this.tooltipOffset,h=!0),s=[o,e],h?e+=r:e-=r,o+=c/2,s.push(o,e),o+=n/2-c/2,s.push(o,e),h?e+=t:e-=t,s.push(o,e),o-=n,s.push(o,e),h?e-=t:e+=t,s.push(o,e),o+=n/2-c/2,s.push(o,e),s},_setArrowLeft:function(n,t,i,r,u,f){var h=!1,s=[],o=u,e=f,c=20;return t+r<f?e-=this.tooltipOffset:(e+=this.tooltipOffset,h=!0),s=[o,e],h?e+=r:e-=r,o+=c,s.push(o,e),o+=n-c,s.push(o,e),h?e+=t:e-=t,s.push(o,e),o-=n,s.push(o,e),h?e-=t+r:e+=t+r,s.push(o,e),s},_setArrowRight:function(n,t,i,r,u,f){var h=!1,s=[],o=u,e=f,c=20;return t+r<f?e-=this.tooltipOffset:(e+=this.tooltipOffset,h=!0),s=[o,e],h?e+=r+t:e-=r+t,s.push(o,e),o-=n,s.push(o,e),h?e-=t:e+=t,s.push(o,e),o+=n-c,s.push(o,e),h?e-=r:e+=r,o+=c,s.push(o,e),s},_checkWidthText:function(n,t){var i=this.x,a=this.y,r=this.tooltipText,u,o=this.options.paddingLeftRight,s=this.options.paddingTopBottom,h,l,c,f,e=this.text.getBBox();if(n<i||i+n<this.canvasWidth||n/2<i&&i+n/2<this.canvasWidth)return!1;if(r.indexOf("<br/>")===-1&&r.indexOf(" ")!==-1){for(l=Math.max(i,this.canvasWidth-i,2*Math.min(i,this.canvasWidth-i)),h=r.length*l/e.width,u=r.substr(0,~~h).lastIndexOf(" "),u===-1&&(u=r.substr(0).indexOf(" ")),c=r.substr(u+1).length,this.tooltipText=r.substr(0,u)+"<br/>";h<=c;)if(f=r.substr(u+1,~~h).lastIndexOf(" "),f===-1&&(f=r.substr(u+1).indexOf(" ")),f!==-1)this.tooltipText+=r.substr(u+1,f)+"<br/>",c=r.substr(u+1+f).length,u+=f+1;else break;this.tooltipText+=r.substr(u+1),this.text.updateText(this.tooltipText),e=this.text.getBBox(),n=e.width+o*2,t=e.height+s*2}return n>i&&i+n>this.canvasWidth&&(n/2>i||i+n/2>this.canvasWidth)&&(o=5,s=5,n=e.width+2*o,t=e.height+2*s),{bbox:e,cloudWidth:n,cloudHeight:t,paddingTopBottom:s,paddingLeftRight:o}}})}(jQuery,DevExpress),function(n,t){var r=t.utils.isDefined,f=function(n,t){return n.substr(n.length-t.length)===t},u=function(n,t){return n.indexOf(t)===0};t.viz.charts.ChartTitle=t.Class.inherit({ctor:function(n,t,i,r){var u=this;u._init(t,i),u.renderer=n,u.clipRect=u.createClipRect(),u.titleGroup=r,u.titleGroup&&u.clipRect&&u.titleGroup.applySettings({clipId:u.clipRect.id})},dispose:function(){var n=this;n.renderer=null,n.clipRect=null,n.title=null,n.innerTitleGroup=null,n.titleGroup=null,n.options=null,n.canvas=null},update:function(n,t){this._init(n,t)},_init:function(n,t){var i=this;t&&(i._parseAlignments(t),i.horizontalAlignment=t.horizontalAlignment,i.verticalAlignment=t.verticalAlignment,i.options=t),i.canvas=n||i.canvas},_parseAlignments:function(n){if(r(n.position)&&!(r(n.verticalAlignment)&&r(n.horizontalAlignment))){n.position=n.position.toLowerCase(),n.verticalAlignment=f(n.position,"top")?"top":"bottom",n.horizontalAlignment=u(n.position,"left")?"left":u(n.position,"center")&&"center"||"right";return}n.verticalAlignment=(n.verticalAlignment||"").toLowerCase(),n.horizontalAlignment=(n.horizontalAlignment||"").toLowerCase(),n.verticalAlignment!=="top"&&n.verticalAlignment!=="bottom"&&(n.verticalAlignment="top"),n.horizontalAlignment!=="left"&&n.horizontalAlignment!=="center"&&n.horizontalAlignment!=="right"&&(n.horizontalAlignment="center")},render:function(){var n=this,t=n.options,i=n.renderer,r;t.text&&(n.innerTitleGroup?n.innerTitleGroup.clear():n.innerTitleGroup=i.createGroup(),n.innerTitleGroup.append(n.titleGroup),r={font:t.font,align:n.horizontalAlignment,style:t.fontStyle},n.title=i.createText(t.text,n.canvas.left,n.canvas.top,r).append(n.innerTitleGroup),n.title.text=t.text,n.correctTitleLength())},correctTitleLength:function(){var n=this,t=n.canvas,i=n.title.text,r,u,f=t.width-t.right-t.left,e=n.getBoundingRect();f>e.width||i.indexOf("<br/>")!=-1||(u=i.length*f/e.width,r=i.substr(0,~~u-4)+"...",n.title.updateText(r),n.title.text=r)},getBoundingRect:function(){var t=this.options,n;return this.innerTitleGroup?(n=this.innerTitleGroup.getBBox(),r(t.placeholderSize)&&(n.height=t.placeholderSize),n):{width:0,height:0,x:0,y:0}},shift:function(n,t){this.innerTitleGroup.move(n,t)},createClipRect:function(){if(r(this.options.placeholderSize))return this.renderer.createClipRect(0,0,0,0)},setClipRectSettings:function(){var n=this.canvas,i=this.verticalAlignment,t=this.clipRect;t&&(t.append(),i==="top"?t.updateRectangle({x:0,y:0,width:n.width,height:n.top}):i==="bottom"&&t.updateRectangle({x:0,y:n.height-n.bottom,width:n.width,height:n.bottom}))}})}(jQuery,DevExpress),function(n,t,i){var r=t.utils,u=Math.abs,c=100,a=5,v=2,h=4,l="canvas_position_",f="canvas_position_bottom",e="canvas_position_top",o="canvas_position_left",s="canvas_position_right";t.viz.charts.Axis=t.Class.inherit(function(){var b=function(t,i){this.renderer=t,this.init(i),this._$axis=n(this)},k=function(){var t=this;t._axisElementsGroup&&t._axisElementsGroup.dispose(),n.each(t.labels||[],function(n,t){t.removeData()}),t._$axis=null,t.labels=null,t.title=null,t.stripLabels=null,t.stripRects=null,t._axisStripGroup=null,t._axisLineGroup=null,t._axisElementsGroup=null,t._axisGridGroup=null,t._axisGroup=null,t.axesContainerGroup=null,t.stripsGroup=null,t.renderer=null,t.translator=null,t.options=null,t.textOptions=null,t._tickValues=null,t._fullTickValues=null,t._fullTickPositions=null},d=function(n){var i=n.categories,t=n.label;n.hoverMode=n.hoverMode?n.hoverMode.toLowerCase():"none",this.hasLabelFormat=t.format!==""&&r.isDefined(t.format),this.options=n,this.staggered=t.staggered,t.minSpacing=r.isDefined(t.minSpacing)?t.minSpacing:a,ft(n),i&&(this.labelsNumber=i.length,this.ticksNumber=this.labelsNumber),n.range={min:n.min,max:n.max,categories:n.categories&&n.categories.slice(0)},this.pane=n.pane,this.textOptions={align:t.alignment,font:t.font,opacity:t.opacity,style:t.style}},g=function(n){var t,i,e=n.options,r=n.translator.getBusinessRange(),f;if(r&&r.getBoundRange&&!e.categories)for(i=n.getTickValues(),t=0;t<i.length-1;t++)f=u(i[t]-i[t+1]),e.isHorizontal?r.getBoundRange({intervalX:f}):r.getBoundRange({intervalY:f})},nt=function(n){var u=n.options,i,t=u.label;if(u.isHorizontal&&t&&r.isDefined(t.overlappingBehavior)){switch(t.overlappingBehavior.mode){case"enlargeTickInterval":case"stagger":i=null;break;case"rotate":i=t.overlappingBehavior.rotationAngle;break;default:i=t.rotationAngle}t.userAlignment||(n.textOptions.align=i?"left":"center"),n.textOptions.rotate=i}},tt=function(n){var n=this,t=n.options.label;return t?!n.staggered&&n.isStaggerOverlapping?t.overlappingBehavior.staggeringSpacing:t.staggeringSpacing:0},it=function(n){this.translator=n,this.needsLabelAdjustment=!1,this.resetTicks(),g(this)},rt=function(){this._tickValues=this._tickPositions=this._fullTickValues=this._fullTickPositions=null},ut=function(n){var i=this,t=i.options;t.isHorizontal?(t.min=n.minVisibleX,t.max=n.maxVisibleX,t.categories=n.categoriesX,t.stubData=n.stubDataX):(t.min=n.minVisibleY,t.max=n.maxVisibleY,t.categories=n.categoriesY,t.stubData=n.stubDataY),i.needsLabelAdjustment=!1,this.resetTicks()},ft=function(n){var t=n.label,i="left",r="right",u="top",f="bottom";n.isHorizontal?n.position===f||n.position===u||(n.position=f):n.position===i||n.position===r||(n.position=i),n.position===r&&(t.indentFromAxis*=-1,t.userAlignment||(t.alignment=i)),n.position===u&&(t.indentFromAxis*=-1),t.rotationAngle&&n.isHorizontal&&(t.userAlignment||(t.alignment=i))},et=function(n){var t=0;return n.delta&&(t=n.delta[n.options.position]||0),n.translator.translateX(l+n.options.position)+t},ot=function(n){var t=0;return n.delta&&(t=n.delta[n.options.position]||0),n.translator.translateY(l+n.options.position)+t},st=function(n,t){var i=n.translator,r=n.options,c=r,v={strokeWidth:c.width,stroke:c.color,strokeOpacity:c.opacity},a,l=n.axisPosition,u,h;c.visible&&(n.options.isHorizontal?(r.categories?(u=i.translateX(o),h=i.translateX(s)):(u=i.translateX(r.min),h=i.translateX(r.max)),a=n.renderer.createLine(u,l,h,l,v)):(r.categories?(u=i.translateY(e),h=i.translateY(f)):(u=i.translateY(r.min),h=i.translateY(r.max)),a=n.renderer.createLine(l,u,l,h,v)),a.append(t))},ht=function(){var i=this,e=i.options,h=e.tickProvider,p=i.translator,o=e.label,s=e.categories,c,f,l=o.overlappingBehavior,a=e.isHorizontal?i.translator.translateX:i.translator.translateY,y;return(f=lt(i,e,a,s),i._tickValues||(i.textOptions.rotate=o.rotationAngle,i.textOptions.align=o.alignment,i._fullTickValues=i._tickValues=n.isArray(s)?s:h.getTicks(f),this._needProcessOverlapping=!0),i.options.stubData)?i._tickValues:((r.isDate(e.min)||r.isDate(s&&s[0]))&&!this.hasLabelFormat&&(o.format=t.formatHelper.getDateFormatByTicks(i._tickValues)),y=i._tickValues&&i._tickValues.length?a.call(i.translator,i._tickValues[i._tickValues.length-1])-a.call(i.translator,i._tickValues[0]):null,y?(f.screenDelta=u(y),f.ticksCount=i._tickValues.length-1):f.ticksCount=i._tickValues.length,this._needProcessOverlapping&&l&&l.mode!=="ignore"&&(l.mode==="stagger"&&(f.screenDelta*=v),c=h.getAutoArrangementStep(i._tickValues,f),c>1?(i.staggered=!1,nt(i),c=h.getAutoArrangementStep(i._tickValues,f),i._tickValues=c>1?h.getAutoArrangementTicks(i._tickValues,f,c):i._tickValues):(i.staggered=o.staggered,i.staggeringSpacing=o.staggeringSpacing),this._needProcessOverlapping=!1,h._removeInvalidDatesWithUnitBegining(i._tickValues,f)),n.isArray(s)||(i._fullTickValues=i._tickValues),i._tickValues)},ct=function(n){this.resetTicks(),this._fullTickValues=this._tickValues=n,n&&(this._needProcessOverlapping=!0)},lt=function(n,t,i,h){var v=t.isHorizontal?[o,s]:[f,e],y=u(i.call(n.translator,v[1])-i.call(n.translator,v[0])),w=r.getSignificantDigitPosition(u(t.max-t.min)/y),l,c=t.min,a=t.max;return r.isNumber(c)&&(c=r.roundValue(t.min,w),c<t.min&&(l=Math.pow(10,-w),c=r.applyPrecisionByMinDelta(c,l,c+l)),c>a&&(c=t.min)),h&&h.length>0&&(c=h[0],a=h[h.length-1]),{min:c,max:a,textOptions:n.textOptions,getText:function(n){return p(n,t.label)},renderer:n.renderer,textSpacing:n.options.label.minSpacing,translator:n.translator,tickInterval:n.options.stubData?null:t.tickInterval,screenDelta:y,gridSpacingFactor:t.axisDivisionFactor,isHorizontal:t.isHorizontal,setTicksAtUnitBeginning:t.setTicksAtUnitBeginning,incidentOccured:t.incidentOccured}},at=function(n){var f=n.options,t,r=[],u,i;for(u=f.isHorizontal?n.translator.translateX:n.translator.translateY,t=n.getTickValues(),(t.hideLabels||f.stubData)&&(r.hideLabels=!0),i=0;i<t.length;i++)r.push({text:t[i],pos:u.call(n.translator,t[i])});return r},vt=function(n,t){var i=n.options,f=n.translator,u,r;if(i.categories&&(i.discreteAxisDivisionMode!=="crossLabels"||!i.discreteAxisDivisionMode))for(i.isHorizontal?(u=f.getIntervalX()/2,i.valueMarginsEnabled||(t=t.slice(0,t.length-1))):(u=-f.getIntervalY()/2,i.valueMarginsEnabled||(t=t.slice(1,t.length))),r=0;r<t.length;r++)t[r].pos=t[r].pos+u;return t},y=function(n){var u=n.options,t=n._fullTickValues,r=[],f=u.isHorizontal?n.translator.translateX:n.translator.translateY,i;if(!n._fullTickPositions){for(t||(n.getTickValues(),t=n._fullTickValues||[]),i=0;i<t.length;i++)r.push({pos:f.call(n.translator,t[i])});n._fullTickPositions=vt(n,r)}return n._fullTickPositions},yt=function(n,t){var h=n.renderer,o=n.options,s=o.tick,l=o.categories,a=o.discreteAxisDivisionMode==="crossLabels"?0:.5,i,f=8,c={strokeWidth:1,stroke:s.color,strokeOpacity:s.opacity},v,e=n.axisPosition,p,w,r,u;if(s.visible)if(u=y(n),n.options.isHorizontal)for(i=0;i<u.length;i++)r=u[i],h.createLine(r.pos,e-f/2,r.pos,e+f/2,c).append(t);else for(i=0;i<u.length;i++)r=u[i],h.createLine(e-f/2,r.pos,e+f/2,r.pos,c).append(t)},p=function(n,i){var r={value:n,valueText:t.formatHelper.format(n,i.format,i.precision)||""};return i.customizeText?i.customizeText.call(r,r):r.valueText},pt=function(){var n=this.options.label;n.format||(n.format="percent")},wt=function(n,t,i,r){return this.createText(n,i,t,r)},bt=function(n,t){var u,f=n.options,b=f.categories,c=n.renderer,l=n.axisPosition,h=f.label,a=h.indentFromAxis,i,e,o,v=[],y=f.isHorizontal?c.createText:wt,w=f.isHorizontal?l+a:l-a,s;if(h.visible){if(i=at(n),i.length===0||i.hideLabels)return!0;for(u=0;u<i.length;u++)e=i[u],s=p(e.text,h),r.isDefined(s)&&s!==""&&(o=y.call(c,s,e.pos,w,n.textOptions),v.push(o),o.append(t),o.data({argument:e.text}));n.labels=v}},kt=function(){return this.options.multipleAxesSpacing||0},dt=function(n,t){var s,o=n.options,f=n.renderer,e=n.axisPosition,i=o.title,h=i.margin,r,u={font:i.font,opacity:i.opacity,align:"center","class":"dx-chart-axis-title"};i.text&&(n.options.isHorizontal?r=n.options.position==="bottom"?f.createText(i.text,n.translator.canvas.left+n.translator.width/2,e,u):f.createText(i.text,n.translator.canvas.left+n.translator.width/2,e,u):n.options.position==="left"?(u.rotate=270,r=f.createText(i.text,e,n.translator.canvas.top+n.translator.height/2,u)):(u.rotate=90,r=f.createText(i.text,e,n.translator.canvas.top+n.translator.height/2,u)),r.append(t),n.title=r)},gt=function(n,t,r){var nt=n.renderer,g=n.options,p=g.grid,it=g.categories,l=n.translator,rt=g.discreteAxisDivisionMode==="crossLabels"?0:.5,v,a,tt={strokeWidth:p.width,stroke:p.color,strokeOpacity:p.opacity},ut,ft=n.axisPosition,w,b,c,k,d,r=r||{visible:!1};if(p.visible)if(v=y(n),n.options.isHorizontal)for(w=l.translateY(f),b=l.translateY(e),k=r.visible&&r.left?l.translateX(o):i,d=r.visible&&r.right?l.translateX(s):i,a=0;a<v.length;a++)(c=v[a],u(c.pos-k)<h||u(c.pos-d)<h)||nt.createLine(c.pos,w,c.pos,b,tt).append(t);else for(w=l.translateX(o),b=l.translateX(s),k=r.visible&&r.top?l.translateY(e):i,d=r.visible&&r.bottom?l.translateY(f):i,a=0;a<v.length;a++)(c=v[a],u(c.pos-k)<h||u(c.pos-d)<h)||nt.createLine(w,c.pos,b,c.pos,tt).append(t)},ni=function(t,u){var nt=t.renderer,tt=t.options,k=tt.strips,l=t.translator,a,y=[],d=[],v,h,p,b,c,g;if(!tt.stubData){if(g=function(t,i,u,h){var p=u?!!(h.minVisibleX||h.maxVisibleX):!!(h.minVisibleY||h.maxVisibleY),w=(u?h.categoriesX:h.categoriesY)||[],c=u?function(n){return l.translateX(n)}:function(n){return l.translateY(n)},k=u?!!h.invertX:h.invertY,a=u?[o,s]:[f,e],d,v=c(t),y=c(i),b=u?h.minVisibleX:h.maxVisibleY,g=u?h.maxVisibleX:h.maxVisibleY;return(k&&a.reverse(),!p&&(n.inArray(t,w)===-1||n.inArray(i,w)===-1))?{stripFrom:0,stripTo:0}:(!r.isDefined(v)&&p&&(v=t<b?c(a[0]):c(a[1])),!r.isDefined(y)&&p&&(y=i<b?c(a[0]):c(a[1])),v<y?{stripFrom:v,stripTo:y}:{stripFrom:y,stripTo:v})},t.options.isHorizontal){for(p=l.translateY(f),b=l.translateY(e),a=0;a<k.length;a++)if(h=k[a],h.startValue!==i&&h.endValue!==i&&h.color!==i){if(c=g(h.startValue,h.endValue,!0,l.businessRange),c.stripTo-c.stripFrom==0)continue;v=nt.createRect(c.stripFrom,b,c.stripTo-c.stripFrom,p-b,0,{fill:h.color}),v.append(u),d.push(v),h.label&&h.label.text?y.push(w(t,h.label,c.stripFrom,c.stripTo,u)):y.push(null)}}else for(p=l.translateX(o),b=l.translateX(s),a=0;a<k.length;a++)if(h=k[a],h.startValue!==i&&h.endValue!==i&&h.color!==i){if(c=g(h.startValue,h.endValue,!1,l.businessRange),c.stripTo-c.stripFrom==0)continue;v=nt.createRect(p,c.stripFrom,b-p,c.stripTo-c.stripFrom,0,{fill:h.color}),v.append(u),d.push(v),h.label&&h.label.text?y.push(w(t,h.label,c.stripFrom,c.stripTo,u)):y.push(null)}t.stripLabels=y,t.stripRects=d}},w=function(n,t,i,r,u){var c=n.renderer,l=t.text,f=n.translator.canvas,e={align:n.options.isHorizontal?"center":"left",font:t.font||n.options.label.font},h,o,s;return n.options.isHorizontal?(t.horizontalAlignment==="center"?(o=i+(r-i)/2,e.align="center"):t.horizontalAlignment==="left"?(o=i,e.align="left"):t.horizontalAlignment==="right"&&(o=r,e.align="right"),t.verticalAlignment==="top"?s=f.top:t.verticalAlignment==="center"?s=(f.height-f.top-f.bottom)/2+f.top:t.verticalAlignment==="bottom"&&(s=f.height-f.bottom)):(t.horizontalAlignment==="center"?(o=(f.width-f.left-f.right)/2+f.left,e.align="center"):t.horizontalAlignment==="left"?(o=f.left,e.align="left"):t.horizontalAlignment==="right"&&(o=f.width-f.right,e.align="right"),t.verticalAlignment==="top"?s=i:t.verticalAlignment==="center"?s=r+(i-r)/2:t.verticalAlignment==="bottom"&&(s=r)),h=c.createText(l,o,s,e),h.append(u),h},ti=function(n){n.axisPosition=n.options.isHorizontal?ot(n):et(n)},ii=function(n,t){var i,r=n.options.label,u,e,o,s,f=!!n.staggered;if(t=n.options.inverted?t.slice(0).reverse():t,n.options.isHorizontal){if(r.overlappingBehavior&&r.overlappingBehavior.mode==="stagger")for(i=1;i<t.length;i++)o=t[i-1],s=t[i],u=o.getBBox(),e=s.getBBox(),e.x<u.x+u.width+r.minSpacing&&(n.isStaggerOverlapping=!0,f=!0)}else f=!1;return n.needsLabelAdjustment=n.needsLabelAdjustment||f},ri=function(n){var r=n.options,u=n.labels,h=r.label,i,e,o,s,t,f;if(r.label.visible&&u&&u.length){for(t=0;t<u.length;t++)i=u[t],f=i.getBBox(),r.isHorizontal&&r.position==="bottom"?i.applySettings({y:2*i.settings.y-f.y}):r.isHorizontal||r.position!=="left"&&r.position!=="right"?r.isHorizontal&&r.position==="top"&&i.applySettings({y:2*i.settings.y-f.y-f.height}):i.applySettings({y:i.settings.y+~~(i.settings.y-f.y-f.height/2)});if(o=ii(n,u),o){for(e=0,t=0;t<u.length;t=t+2)i=u[t],f=i.getBBox(),f.height>e&&(e=f.height);for(s=n.getStaggeringSpacing(n),e=Math.round(e)+s,t=1;t<u.length;t=t+2)i=u[t],r.position==="bottom"?i.move(0,e):r.position==="top"&&i.move(0,-e);for(t=0;t<u.length;t++)u[t].rotate(0)}}},ui=function(n){var v=n.options,t,c=n.stripLabels,l=n.stripRects,a,e,r,o,s,u,h,f;if(c!==i||l!==i)for(r=0;r<c.length;r++)h=f=0,u=v.strips[r],t=u.label,e=c[r],e!==null&&(a=l[r],o=e.getBBox(),s=a.getBBox(),t.horizontalAlignment==="left"?h+=u.paddingLeftRight:t.horizontalAlignment==="right"&&(h-=u.paddingLeftRight),t.verticalAlignment==="top"?f+=s.y-o.y+u.paddingTopBottom:t.verticalAlignment==="center"?f+=s.y+s.height/2-o.y-o.height/2:t.verticalAlignment==="bottom"&&(f-=u.paddingTopBottom),e.move(h,f))},fi=function(n,t){var f=n.options,e=n.axisPosition,i,r,u=n.title;u&&(r=u.getBBox(),i=t.getBBox(),n.options.isHorizontal?n.options.position==="bottom"?u.move(0,i.y+i.height-r.y+f.title.margin):u.move(0,i.y-r.y-r.height-f.title.margin):n.options.position==="left"?u.move(i.x-r.x-r.width-f.title.margin,0):u.move(i.x+i.width-r.x+f.title.margin,0))},ei=function(n){var t=this,r=t.options.isHorizontal?"dxc-h-axis":"dxc-v-axis",u=t.options.isHorizontal?"dxc-h-strips":"dxc-v-strips",f=t.clipRectID&&t.options.placeholderSize?t.clipRectID:i;n=n||{},t._axisGroup?(t._axisGroup.detach(),t._axisStripGroup.detach(),t._axisGridGroup.clear(),t._axisElementsGroup.clear(),t._axisLineGroup.clear(),t._axisStripGroup.clear()):(t._axisGroup=t.renderer.createGroup({"class":r,clipId:f}),t._axisStripGroup=t.renderer.createGroup({"class":u}),t._axisGridGroup=t.renderer.createGroup({"class":"dxc-grid"}).append(t._axisGroup),t._axisElementsGroup=t.renderer.createGroup({"class":"dxc-elements"}).append(t._axisGroup),t._axisLineGroup=t.renderer.createGroup({"class":"dxc-line"}).append(t._axisGroup)),ti(t),t._virtual||(st(t,t._axisLineGroup),yt(t,t._axisLineGroup),bt(t,t._axisElementsGroup),t.options.title.text&&dt(t,t._axisElementsGroup)),t.options.strips&&ni(t,t._axisStripGroup),gt(t,t._axisGridGroup,n.borderOptions),t._axisStripGroup.append(t.stripsGroup),t._axisGroup.append(t.axesContainerGroup),ri(t),ui(t),fi(t,t._axisElementsGroup)},oi=function(){var n=this._axisElementsGroup.getBBox(),f=this._axisLineGroup.getBBox(),e=this.options.placeholderSize,t,u=this.options.isHorizontal,i=u&&"y"||"x",r=u&&"height"||"width",o=this.options.position===(u&&"bottom"||"right");return n.x||n.y||n.width||n.height?(t=f[i]||this.axisPosition,o?(n[r]=e||n[r]-(t-n[i]),n[i]=t):n[r]=e||f[r]+t-n[i],n):n},si=function(n,t){var i={};n&&(i.translateX=n),t&&(i.translateY=t),this._axisGroup.applySettings(i)},hi=function(n){this._axisStripGroup.applySettings({clipId:n})},ci=function(){var n=this.options,t={},i=function(i,u){n.valueMarginsEnabled?r.isDefined(n[i])&&(t[i+u]=n[i],t[i+u+"Priority"]=c):(t[i+u]=0,t[i+u+"Priority"]=c)};return n.isHorizontal?(t.minX=n.range.min,t.maxX=n.range.max,t.minVisibleX=n.range.min,t.maxVisibleX=n.range.max,i("minValueMargin","X"),i("maxValueMargin","X"),t.invertX=n.inverted,t.stickX=!n.valueMarginsEnabled,t.categoriesX=n.range.categories):(t.minY=n.range.min,t.maxY=n.range.max,t.minVisibleY=n.range.min,t.maxVisibleY=n.range.max,t.invertY=n.inverted||n.type==="discrete"&&n.oppositeDirectionYAxis,t.stickY=!n.valueMarginsEnabled,i("minValueMargin","Y"),i("maxValueMargin","Y"),t.categoriesY=n.range.categories),t},li=function(n,t,i){return this._$axis&&this._$axis.on(n,t,i),this},ai=function(n){return this._$axis&&this._$axis.off(n),this};return{ctor:b,dispose:k,init:d,resetTicks:rt,getStaggeringSpacing:tt,setTranslator:it,getTickValues:ht,setTickValues:ct,getRangeData:ci,getMultipleAxesSpacing:kt,setRange:ut,setPercentLabelFormat:pt,draw:ei,getBoundingRect:oi,shift:si,on:li,off:ai,applyClipRectForStrips:hi}}())}(jQuery,DevExpress),function(n,t,i){var f=t.ui,u=t.viz.charts,r=t.utils,o=t.data.utils,h=100,s={animate:!1},e=["processAxesOption","reinit","_reinitDataSource","_handleDataSourceChanged","force_render"];u.BaseChart=f.Component.inherit({_defaultOptions:function(){return{done:n.noop,drawn:n.noop,redrawOnResize:!0,incidentOccured:n.noop,margin:{left:0,top:0,right:0,bottom:0},size:{width:i,height:i},title:{text:null},legend:{hoverMode:"includePoints"},animation:{enabled:!0,duration:1e3,easing:"easeOutCubic",maxPointCountSupported:300,asyncSeriesRendering:!0,asyncTrackersRendering:!0,trackerRenderingDelay:1200},seriesSelectionMode:"single",pointSelectionMode:"single",seriesClick:n.noop,pointClick:n.noop,argumentAxisClick:n.noop,seriesHover:n.noop,pointHover:n.noop,seriesSelected:n.noop,pointSelected:n.noop}},_init:function(){var n=this;n._saveUserCanvas(),n._initRenderer(),n._createHtmlStructure(),n._needHandleRenderComplete=!0,n.layoutManager=u.factory.createChartLayoutManager(),n._reinit()},_reinit:function(){var t=this;t.layoutManager.update(t),t.option("redrawOnResize")&&window?t._resizeHandlerCallback||(t._resizeHandlerCallback=t._resizeHandler(),r.windowResizeCallbacks.add(t._resizeHandlerCallback)):(r.windowResizeCallbacks.remove(t._resizeHandlerCallback),delete t._resizeHandlerCallback),n.isFunction(t.option("incidentOccured"))||t.option("incidentOccured",n.noop),t._createTracker(),t._reinitDataSource()},_createHtmlStructure:function(){var n=this,t=n.renderer;n._panesBackgroundGroup=t.createGroup({"class":"dxc-background"}),n._titleGroup=t.createGroup({"class":"dxc-title"}),n._legendGroup=t.createGroup({"class":"dxc-legend"}),n._stripsGroup=t.createGroup({"class":"dxc-strips-group"}),n._axesGroup=t.createGroup({"class":"dxc-axes-group"}),n._panesBorderGroup=t.createGroup({"class":"dxc-border"}),n._seriesGroup=t.createGroup({"class":"dxc-series-group"}),n._labelsGroup=t.createGroup({"class":"dxc-labels-group"}),n._tooltipGroup=t.createGroup({"class":"dxc-tooltip"}),n._trackerGroup=t.createGroup({"class":"dxc-trackers",opacity:.0001}),n._seriesTrackerGroup=t.createGroup({"class":"dxc-series-trackers"}).append(n._trackerGroup),n._markerTrackerGroup=t.createGroup({"class":"dxc-markers-trackers",stroke:"none",fill:"grey"}).append(n._trackerGroup),n._legendTrackerGroup=t.createGroup({"class":"dxc-legend-trackers",stroke:"none",fill:"grey"}).append(n._trackerGroup)},_cleanHtmlStructure:function(){var n=this;n._legendGroup.detach(),n._stripsGroup.detach(),n._axesGroup.detach(),n._seriesGroup.detach(),n._labelsGroup.detach(),n._trackerGroup.detach(),n._panesBackgroundGroup.clear(),n._titleGroup.clear(),n._legendGroup.clear(),n._stripsGroup.clear(),n._axesGroup.clear(),n._panesBorderGroup.clear(),n._seriesGroup.clear(),n._labelsGroup.clear(),n._tooltipGroup.clear(),n._seriesTrackerGroup.clear(),n._markerTrackerGroup.clear(),n._legendTrackerGroup.clear()},_disposeObjectsInArray:function(t){n.each(this[t]||[],function(n,t){t&&t.dispose()}),this[t]=null},_dispose:function(){var n=this,t=function(t){n[t]&&n[t].dispose(),n[t]=null},i=this._disposeObjectsInArray;clearTimeout(n.delayedRedraw),n._resizeHandlerCallback&&(n._resizeHandlerCallback.stop(),r.windowResizeCallbacks.remove(n._resizeHandlerCallback),n._resizeHandlerCallback=null),n.callBase(),i.call(n,"businessRanges"),i.call(n,"translators"),i.call(n,"series"),t("layoutManager"),t("themeManager"),t("renderer"),t("tracker"),t("tooltip"),t("chartTitle"),n.paneAxis=null,n._userOptions=null,n.dirtyCanvas=null,n.canvas=null,n._legendGroup.detach(),n._stripsGroup.detach(),n._axesGroup.detach(),n._seriesGroup.detach(),n._labelsGroup.detach(),n._trackerGroup.detach(),t("canvasClipRect"),t("_panesBackgroundGroup"),t("_titleGroup"),t("_legendGroup"),t("_stripsGroup"),t("_axesGroup"),t("_panesBorderGroup"),t("_seriesGroup"),t("_labelsGroup"),t("_tooltipGroup"),t("_seriesTrackerGroup"),t("_markerTrackerGroup"),t("_legendTrackerGroup"),t("_trackerGroup")},_clean:function(){var n=this;n._cleanHtmlStructure(),n.callBase(),n._saveDirtyCanvas()},_initRenderer:function(){if(!this.renderer){var t=this,n=t.option("animation");n=n===!0?t._defaultOptions().animation:n,t.renderer=u.factory.createRenderer({animation:n,cssClass:"dxc dxc-chart"})}},_initSeries:function(){var n=this;n.series=n.series||n._populateSeries()},_reinitDataSource:function(){this._initDataSource(),this._loadDataSource()},_initOptions:function(n){var t=this,i;t._optionsInitializing=!0,i=t._processTitleOption(n.title,t.option("title")),i&&(n.title=i),t._userOptions=n,t._processAxesOption(n),t._createThemeManager(n),t.option(t.themeManager.applyChartTheme(n)),delete t._userOptions.userCommonAxisSettings},_processTitleOption:function(n,t){if(r.isString(n)){var i=n;return n=t,n.text=i,n}},_processAxesOption:function(t){var u=n.isArray(t.argumentAxis)?t.argumentAxis:[t.argumentAxis],f=n.isArray(t.valueAxis)?t.valueAxis:[t.valueAxis],i=function(n){for(var t,u,i=0,i=0;i<n.length;i++)t=n[i],t&&t.title&&r.isString(t.title)&&(u=t.title,t.title={},t.title.text=u),t&&t.label&&(t.label.alignment&&(t.label.userAlignment=!0),r.isString(t.label.overlappingBehavior)&&(t.label.overlappingBehavior={mode:t.label.overlappingBehavior}),t.label.overlappingBehavior&&t.label.overlappingBehavior.mode||(t.label.overlappingBehavior=t.label.overlappingBehavior||{},t.label.rotationAngle&&(t.label.overlappingBehavior.mode="rotate",t.label.overlappingBehavior.rotationAngle||(t.label.overlappingBehavior.rotationAngle=t.label.rotationAngle)),t.label.staggered&&(t.label.overlappingBehavior.mode="stagger",t.label.overlappingBehavior.staggeringSpacing||(t.label.overlappingBehavior.staggeringSpacing=t.label.staggeringSpacing))))};t.userCommonAxisSettings=this._userOptions.commonAxisSettings,i([t.commonAxisSettings]),i(u),i(f)},_saveUserCanvas:function(){var n=this.option("size");n.width!==i&&(n.userWidth=n.width),n.height!==i&&(n.userHeight=n.height)},_saveDirtyCanvas:function(){this.dirtyCanvas=this._calculateCanvas()},_resizeHandler:function(){var n=this;return r.createResizeHandler(function(){n._render(s)})},_createThemeManager:function(n){n=n||{};var t=this;t.themeManager&&t.themeManager.dispose(),t.themeManager=u.factory.createThemeManager({theme:n.theme,palette:n.palette})},_calculateCanvas:function(){var i=this,t=i.option("size"),u=i._element();return r.isDefined(t.userWidth)||(t.width=u.width(),t.width||(t.width=400)),r.isDefined(t.userHeight)||(t.height=u.height(),t.height||(t.height=400)),n.extend({},t,i.option("margin"))},_createTracker:function(){var n=this,t=n.option("rotated"),i=n.option("tooltip")||{};n.tracker&&n.tracker.dispose(),n.tracker=u.factory.createTracker({series:n.series,valueAxis:t?n.horizontalAxes:n.verticalAxes,argumentAxis:t?n.verticalAxes:n.horizontalAxes,seriesSelectionMode:n.option("seriesSelectionMode"),pointSelectionMode:n.option("pointSelectionMode"),tooltipShown:n.option("tooltipShown"),tooltipHidden:n.option("tooltipHidden"),markerTrackerGroup:n._markerTrackerGroup,seriesTrackerGroup:n._seriesTrackerGroup,legendGroup:n._legendTrackerGroup,seriesGroup:n._seriesGroup,tooltipEnabled:i.enabled,events:{seriesClick:n.option("seriesClick"),pointClick:n.option("pointClick"),argumentAxisClick:n.option("argumentAxisClick"),seriesHover:n.option("seriesHover"),seriesSelected:n.option("seriesSelected"),pointHover:n.option("pointHover"),pointSelected:n.option("pointSelected")}})},_updateTracker:function(){var n=this,t=n.option("rotated");n.tracker?n.tracker._reinit({series:n.series,valueAxis:t?n.horizontalAxes:n.verticalAxes,argumentAxis:t?n.verticalAxes:n.horizontalAxes}):n._createTracker()},_render:function(n){this._optionsInitializing=!1;var t=this,i=t.renderer,f=t.translators,r=t.canvas,o=this._element(),e=t._calculateCanvas(),u=t.dirtyCanvas;if(n=n||{recreateCanvas:!0},n.recreateCanvas=n.recreateCanvas||!i.isInitialized(),!n.force&&u&&u.width===e.width&&u.height===e.height&&!t.hiddenContainer){t.stopRedraw=!0;return}if(clearTimeout(t.delayedRedraw),n.recreateCanvas&&(r=t._calculateCanvas()),r.width&&r.height&&o.is(":visible"))t.hiddenContainer=!1;else{t.option("incidentOccured")("Chart can not be drawn as container is not visible"),t.hiddenContainer=!0,t.stopRedraw=!0,i.killContainer();return}n.recreateCanvas&&(t.canvas=r,i.recreateCanvas(t.canvas.width,t.canvas.height),i.draw(t._element()[0]),t._createCanvasClipRect(),f&&(f.length=0)),t.layoutManager.update(t),t._cleanGroups(n),t._saveDirtyCanvas()},_cleanGroups:function(n){var t=this;t._stripsGroup.detach(),t._axesGroup.detach(),t._seriesGroup.detach(),t._labelsGroup.detach(),t._trackerGroup.detach(),t._tooltipGroup.detach(),(!n||n.drawLegend)&&(t._legendGroup.detach(),t._legendGroup.clear()),t._stripsGroup.clear(),t._axesGroup.clear(),t._seriesGroup.clear(),t._labelsGroup.clear(),t._tooltipGroup.clear(),t._seriesTrackerGroup.clear(),t._markerTrackerGroup.clear(),t._legendTrackerGroup.clear()},_drawTitle:function(){var n=this;n.chartTitle?n.chartTitle.update(n.canvas,n.option("title")):n.chartTitle=u.factory.createTitle(n.renderer,n.canvas,n.option("title"),n._titleGroup),n.chartTitle.render()},_createTooltip:function(){var t=this,e,o=t.tracker.pointAtShownTooltip,f=n.extend(!0,{renderer:t.renderer,canvasWidth:t.canvas.width,canvasHeight:t.canvas.height},t.option("tooltip")||{});!n.isFunction(f.customizeText)&&r.isDefined(f.customizeText)&&(t.option("incidentOccured").call(null,"customizeText can not be applied as it is not a function"),f.customizeText=i),t.tooltip?t.tooltip.update(f):t.tooltip=u.factory.createTooltip(f,t._tooltipGroup),t.tooltip.draw(),t.tracker.tooltip=t.tooltip,o&&(e=o.getTooltipCoords(),t.tooltip.move(~~e.x,~~e.y,e.offset,t.tooltip.tooltipText,t.tooltip.style.fill,t.tooltip.className))},_prepareDrawOptions:function(t){var i=this.option("animation"),u;return i=i===!0?this._defaultOptions().animation:i,u=n.extend({},{force:!1,adjustAxes:!0,drawLegend:!0,drawTitle:!0,adjustSeriesLabels:!0,animate:i.enabled,animationPointsLimit:i.maxPointCountSupported,asyncSeriesRendering:i.asyncSeriesRendering,asyncTrackersRendering:i.asyncTrackersRendering,trackerRenderingDelay:i.trackerRenderingDelay},t),r.isDefined(u.recreateCanvas)||(u.recreateCanvas=!(!u.adjustAxes||!u.drawLegend||!u.drawTitle)),u},_processRefreshData:function(t){var i=this,r=n.inArray(i._currentRefreshData,e),u=n.inArray(t,e);(!i._currentRefreshData||r>=0&&u<r)&&(i._currentRefreshData=t)},_disposeSeries:function(){var t=this;n.each(t.series||[],function(n,t){t.dispose()}),t.series=null,n.each(t.seriesFamilies||[],function(n,t){t.dispose()}),t.seriesFamilies=null},_optionValuesEqual:function(n,t,i){return(n==="valueAxis"||n==="argumentAxis"||n==="commonAxisSettings"||n==="userCommonAxisSettings")&&t&&i&&(r.isArray(i)&&!r.isArray(t)?(t.strips=null,t.categories=null):r.isArray(i)||r.isArray(t)||(i.strips&&(t.strips=null),i.categories&&(t.categories=null))),this.callBase.apply(this,arguments)},_optionChanged:function(n,t,i){var r=this,u;if(r._optionsInitializing||(r._optionValuesEqual(n,r._userOptions[n],t),o.compileSetter(n)(r._userOptions,t,{functionsAsIs:!0,merge:!0})),n=="animation"){r.renderer.updateAnimationOptions(t);return}clearTimeout(r.delayedRedraw);switch(n){case"dataSource":r._needHandleRenderComplete=!0,r._processRefreshData("_reinitDataSource");break;case"palette":r.themeManager.updatePalette(t),r._disposeSeries(),r._needHandleRenderComplete=!0,r._processRefreshData("_handleDataSourceChanged");break;case"series":case"commonSeriesSettings":case"backgroundColor":r._disposeSeries(),r._needHandleRenderComplete=!0,r._processRefreshData("_handleDataSourceChanged");break;case"legend":case"seriesTemplate":r._processRefreshData("_handleDataSourceChanged");break;case"title":if(u=r._processTitleOption(t,i),u){r.option("title",i);return}r._processRefreshData("force_render");break;case"valueAxis":case"argumentAxis":case"commonAxisSettings":r._needHandleRenderComplete=!0,r._processRefreshData("processAxesOption"),r._disposeSeries(),r.paneAxis={};break;case"panes":case"defaultPane":r._disposeSeries(),r.paneAxis={},r._needHandleRenderComplete=!0,r._processRefreshData("reinit");break;case"size":r._saveUserCanvas(),r._processRefreshData("force_render");break;case"theme":r._initOptions(r._userOptions),r._processRefreshData("reinit");break;default:r._processRefreshData("reinit")}r.callBase.apply(r,arguments)},_refresh:function(){var n=this;if(n._clean(),n._currentRefreshData){switch(n._currentRefreshData){case"force_render":n._render({force:!0});break;case"processAxesOption":n._processAxesOption(n._options),n._reinit(!0);break;case"reinit":n._reinit(!0);break;default:n[n._currentRefreshData]&&n[n._currentRefreshData]()}delete n._currentRefreshData}else n._render({force:!0})},_dataSourceOptions:function(){return{paginate:!1,_preferSync:!0}},_createCanvasClipRect:function(){var t=this,n=t.canvas;t.canvasClipRect?t.canvasClipRect.updateRectangle({x:n.left,y:n.top,width:n.width-n.left-n.right,height:n.height-n.top-n.bottom}):t.canvasClipRect=t.renderer.createClipRect(n.left,n.top,n.width-n.left-n.right,n.height-n.top-n.bottom).append()},_getCanvasClipRectID:function(){return this.canvasClipRect.id},_handleDataSourceChanged:function(){this._dataSpecificInit(!0)},_dataSpecificInit:function(n){var t=this;t._initSeries(),t._repopulateSeries(),t._handleSeriesPopulated(n)},_processSeriesTemplate:function(){var t=this,e=t.option("seriesTemplate"),v=r.isFunction(e.customizeSeries)?e.customizeSeries:n.noop,o=e.nameField||"series",h=t._dataSource,f,a,u;if(h){var s={},c=[],l=h.items(),i;for(f=0,a=l.length;f<a;f++)u=l[f],i=s[u[o]],i||(i=s[u[o]]={name:u[o],data:[]},c.push(i.name)),i.data.push(u);t._templatedSeries=n.map(c,function(t){var i=s[t],r=v.call(null,i.name);return n.extend(i,r)}),t._populateSeries(),delete t._templatedSeries}},_processSingleSeries:function(){},_repopulateSeries:function(){var t=this,i=t._dataSource&&t._dataSource.items(),r=t.option("seriesTemplate");t.themeManager.resetPalette(),t._dataSource&&r?t._processSeriesTemplate():i&&n.each(t.series,function(n,r){r.reinitData(i),t._processSingleSeries(r,r.userOptions)})},_handleRenderComplete:function(){var t=this,r=t.option("done"),i=!0;t._needHandleRenderComplete&&(n.each(t.series,function(n,t){i=i&&t.canRenderCompleteHandle()}),i&&(n.isFunction(r)&&r.call(t),t._needHandleRenderComplete=!1))},getAllSeries:function(){return this.series.slice()},getSeriesByName:function(t){var i=null;return n.each(this.series,function(n,r){if(r.name===t)return i=r,!1}),i},getSeriesByPos:function(n){return this.series[n]},getSelectedSeries:function(){return null},clearSelection:function(){this.tracker.clearSelection()},hideTooltip:function(){this.tracker._hideTooltip(null,!0)},render:function(n){this._render(n)}}).include(f.DataHelperMixin)}(jQuery,DevExpress),function(n,t,i){var r=t.viz.charts,u=t.utils,o=5,e="default",s="defaultAxisName",f=.1;r.Chart=r.BaseChart.inherit({_defaultOptions:function(){return n.extend(!0,this.callBase(),{commonSeriesSettings:{type:"line",maxLabelCount:i,stack:"default",label:{visible:!1,alignment:"center",rotationAngle:0,horizontalOffset:0,verticalOffset:0,radialOffset:0,format:"",argumentFormat:"",precision:0,argumentPrecision:0,percentPrecision:0,customizeText:i,position:"outside",connector:{visible:!1,width:0}}},defaultPane:e,adjustOnZoom:!0,rotated:!1,synchronizeMultiAxes:!0,equalBarWidth:!0,commonPaneSettings:{backgroundColor:"none",border:{visible:!1,top:!0,bottom:!0,left:!0,right:!0,dashStyle:"solid"}},panes:[{name:e,border:{}}],commonAxisSettings:{tickInterval:i,setTicksAtUnitBeginning:!0,valueMarginsEnabled:!0,placeholderSize:null}})},_dispose:function(){var t=this,i=this._disposeObjectsInArray;t.callBase(),t.panes=null,t.legend.dispose(),t.legend=null,i.call(t,"panesBackground"),i.call(t,"panesClipRects"),i.call(t,"horizontalAxes"),i.call(t,"verticalAxes"),i.call(t,"seriesFamilies"),n.each(t._paneTrackerGroups||[],function(n,t){t.paneSeriesGroup.dispose(),t.paneMarkerGroup.dispose()}),t._paneTrackerGroups=null},_init:function(){this.paneAxis={},this.callBase()},_reinit:function(n){var t=this;t._disposeObjectsInArray("translators"),t.translators=[],t.panes=t._createPanes(),t._populateAxes(),t.callBase(),delete t._seriesInitializing,t.series?t._correctValueAxes():t._dataSpecificInit(),n&&t._render({force:!0})},_correctBusinessRange:function(t,i,r,f){var e="min"+r,s="max"+r,o,h;return!i||!u.isDefined(t[e])||!u.isDefined(t[s])?!1:(o={},h=i,i=n.isNumeric(i)?i:u.convertDateTickIntervalToMilliseconds(i),i>=Math.abs(t[s]-t[e]))?(u.isDate(t[e])?(n.isNumeric(h)?(o[e]=new Date(t[e].valueOf()-i),o[s]=new Date(t[s].valueOf()+i)):(o[e]=u.addInterval(t[e],h,!0),o[s]=u.addInterval(t[s],h,!1)),f&&(u.correctDateWithUnitBeginning(o[s],h),u.correctDateWithUnitBeginning(o[e],h))):(o[e]=t[e]-i,o[s]=t[s]+i),t.getBoundRange(o),!0):!1},_populateBusinessRange:function(t){var u=this,tt=u.panes,a=[],ft,c,l=u.option("rotated"),v,h=l?u.horizontalAxes:u.verticalAxes,p=l?u.verticalAxes:u.horizontalAxes,y=l&&"X"||"Y",s=l&&"Y"||"X",w="getBoundRange"+y,b="getBoundRange"+s,et,it=n.map(tt,function(n){return n.name}),k=u.series,d,g,nt;u._disposeObjectsInArray("businessRanges");var rt=function(t){var r=[],i;n.each(h,function(n,i){i.pane===t&&r.push(i)}),r.length>1&&u.option("synchronizeMultiAxes")&&n.each(r,function(n,t){var r=t.options.grid;i&&r&&r.visible?r.visible=!1:i=i?i:r&&r.visible})},o=u.paneAxis,e=new r.Range,ut=function(n,t){for(var r,i=0;i<n.length;i++)if(n[i].pane===t){r=n[i].name;break}return r||(r=h[0].name),r};n.each(k,function(n,t){t.axis=t.axis||ut(h,t.pane),t.axis&&(o[t.pane]=o[t.pane]||{},o[t.pane][t.axis]=!0)}),n.each(h,function(t,i){i.name&&i.pane&&n.inArray(i.pane,it)!=-1&&(o[i.pane]=o[i.pane]||{},o[i.pane][i.name]=!0)}),u._correctValueAxes(),n.each(o,function(u,o){rt(u),n.each(o,function(o){var l=[],it=[],rt=[],nt=new r.Range({pane:u,axis:o,minValueMarginX:f,maxValueMarginX:f,minValueMarginY:f,maxValueMarginY:f}),tt;for(n.each(k,function(n,t){t.pane===u&&t.axis===o&&l.push(t)}),n.each(p,function(n,t){rt.push(t)}),n.each(h,function(n,t){t.pane===u&&t.name===o&&it.push(t)}),n.each(rt,function(n,t){t.options.type=l&&l.length?l[0].options.argumentAxisType:null,e=e[b](t.getRangeData()),d=t.options.tickInterval,g=t.options.setTicksAtUnitBeginning}),n.each(it,function(n,t){t.options.type=l&&l.length?l[0].options.valueAxisType:null;var u=new r.Range(t.getRangeData());u.applyEqualLimitsMargins(),tt=tt||t.options.valueType==="datetime"?"datetime":i,nt=nt[w](u)}),c=0;c<l.length;c++)v=l[c].getRangeData(t),nt=nt[w](v),e=e[b](v);nt["isDefined"+y]()||nt["setStubData"+y](tt),a.push(nt)})}),e["isDefined"+s]()||e["setStubData"+s](p[0].options.argumentType),nt=u._correctBusinessRange(e,d,s,g),n.each(a,function(n,t){t=t.getBoundRange(e),nt||t.applyValueMargins(),t["stubData"+s]=e["stubData"+s],t.isDefined()||t.setStubData()}),u.businessRanges=a},_createPanes:function(){var i=this,t=i.option("panes"),r;return n.each(i.panesClipRects||[],function(n,t){t.remove()}),i.panesClipRects=[],i.defaultPane=i.option("defaultPane"),t=n.isArray(t)?t:t?[t]:[],!i._doesPaneExists(t,i.defaultPane)&&t.length>0&&(r=t[t.length-1].name,i.option("incidentOccured")('Pane "'+i.defaultPane+'" does not exist. Use pane "'+r+'" instead'),i.defaultPane=r),i.option("rotated")&&(t=t.reverse()),t},_doesPaneExists:function(t,i){var r=!1;return n.each(t,function(n,t){if(t.name===i)return r=!0,!1}),r},_populateSeries:function(){var t=this,k=!!t.option("seriesTemplate"),s=k?t._templatedSeries:t.option("series"),y=n.isArray(s)?s:s?[s]:[],h=t.option("argumentAxis"),e=t.option("valueAxis"),p=t.themeManager,l,i,w=t.option("commonSeriesSettings"),d=t._userOptions.commonSeriesSettings,c,g=t.option("rotated"),b=t.option("incidentOccured"),o,nt=n.map(t.panes,function(n){return n.name}),a,v,f;for(n.each(t._paneTrackerGroups||[],function(n,t){t.paneSeriesGroup.remove(),t.paneMarkerGroup.remove()}),t._paneTrackerGroups=[],n.each(t.panes,function(){var r=t.renderer.createGroup({"class":"dxc-pane-tracker"}),u=t.renderer.createGroup({"class":"dxc-pane-tracker"});t._paneTrackerGroups.push({paneSeriesGroup:r,paneMarkerGroup:u})}),t._disposeSeries(),t.series=[],p.resetPalette(),w.containerBackgroundColor=t.option("containerBackgroundColor"),o=0;o<y.length;o++)(i=y[o],i.type&&!u.isString(i.type)&&(i.type=""),l=i.data,i.data=null,i.rotated=g,h&&(i.argumentCategories=h.categories,i.argumentAxisType=h.type,i.argumentType=h.argumentType),e&&(u.isArray(e)?n.each(e,function(n,t){(i.axis||n)&&i.axis!==t.name||(i.valueCategories=t.categories,i.valueAxisType=t.type,i.valueType=t.valueType)}):(i.valueCategories=e.categories,i.valueAxisType=e.type,i.valueType=e.valueType)),i.incidentOccured=b,i.name||(i.name="Series "+(o+1).toString()),f=p.applyNextSeriesTheme(i,w,d),f.pane=f.pane||t.defaultPane,a=f.pane,v=t._getPaneIndex(a),n.inArray(a,nt)!==-1)&&(f.seriesGroup=t._seriesGroup,f.seriesLabelsGroup=t._labelsGroup,f.seriesTrackerGroup=t._paneTrackerGroups[v].paneSeriesGroup,f.markerTrackerGroup=t._paneTrackerGroups[v].paneMarkerGroup,c=r.factory.createSeries(f.type,t.renderer,l,f),c?(c.index=o,t.series.push(c)):b.call(null,"Unknown series type requested: "+f.type),i.data=l);return t.series},_createValueAxis:function(t,i,u){var f=this,e;return t=n.extend({isHorizontal:i,tickProvider:u,incidentOccured:f.option("incidentOccured")},t),t=n.extend(!0,{},f.option("commonAxisSettings"),f.option(i?"horizontalAxis":"verticalAxis"),f.option("valueAxisStyle"),f.option("userCommonAxisSettings"),f.option("valueAxis"),t),t.strips&&n.each(t.strips,function(i){t.strips[i]=n.extend(!0,{},t.stripStyle,t.strips[i])}),e=r.factory.createAxis(f.renderer,t),e.name=t.name,e.pane=e.pane||t.pane,e.priority=t.priority,e},_disposeAxes:function(){var t=this;n.each(t.horizontalAxes||[],function(n,t){t.dispose()}),n.each(t.verticalAxes||[],function(n,t){t.dispose()}),t.horizontalAxes=null,t.verticalAxes=null},_populateAxes:function(){var t=this,o=[],h=[],u=t.panes,f=t.option("rotated"),tt=t.themeManager,c=t.option("valueAxis")||{},l=t.option("argumentAxis")||{},a=n.isArray(l)?l:[l],b=n.isArray(c)?c:[c],it,e,y=[],rt,p=r.factory.getAxisTickProvider(),v,w;t._disposeAxes(),w=function(i,u){i=n.extend(!0,{isHorizontal:!f,tickProvider:p,pane:t.defaultPane,incidentOccured:t.option("incidentOccured")},i),i=n.extend(!0,{},t.option("commonAxisSettings"),t.option(f?"verticalAxis":"horizontalAxis"),t.option("argumentAxisStyle"),t.option("userCommonAxisSettings"),t.option("argumentAxis"),i),i.strips&&n.each(i.strips,function(t){i.strips[t]=n.extend(!0,{},i.stripStyle,i.strips[t])}),e=r.factory.createAxis(t.renderer,i),e._virtual=u,i.isHorizontal?o.push(e):h.push(e)},v=f?a[0].position==="right"?u[u.length-1].name:u[0].name:a[0].position==="top"?u[0].name:u[u.length-1].name,n.each(u,function(t,i){var r=i.name,u=r!=v,f=n.extend(!0,{},{pane:r},a[0]);w(f,u)});var k=function(n){var i=t._createValueAxis(n,f,p);f?o.push(i):h.push(i)},d=0,g=function(){return s+d++},nt=function(t){for(var r={},u=t.length,i=0;i<u;i++)r[t[i]]=!0;return n.map(r,function(n,t){return t})};n.each(b,function(r,u){var f=[],e=u.name;if(e&&n.inArray(e,y)!=-1){t.option("incidentOccured").call(null,"The valueAxis configuration array contains axes with the same name.");return}e&&y.push(e),u.pane&&f.push(u.pane),u.panes&&u.panes.length&&(f=f.concat(u.panes.slice(0))),f=nt(f),f.length||f.push(i),n.each(f,function(t,i){k(n.extend(!0,{},u,{name:e||g(),pane:i,priority:r}))})}),t.horizontalAxes=o,t.verticalAxes=h},_correctValueAxes:function(){var i=this,s=i.option("rotated"),b=i.themeManager,e=i.option("valueAxis")||{},h=n.isArray(e)?e:[e],v=r.factory.getAxisTickProvider(),t=(s?i.horizontalAxes:i.verticalAxes)||[],y=t[0].name,f=i.paneAxis||{},o=i.panes,u,c={},p=function(t){var r;return n.each(i.paneAxis,function(i,u){n.each(u,function(n){if(t==n)return r=i,!1})}),r},w=n.map(t,function(n){return n.pane?null:n}),l,a;for(n.each(w,function(n,t){t.pane=p(t.name),t.pane||(t.pane=i.defaultPane,f[t.pane]=f[t.pane]||{},f[t.pane][t.name]=!0),t.options.pane=t.pane}),u=0;u<o.length;u++)f[o[u].name]||(f[o[u].name]={},f[o[u].name][y]=!0);l=function(n){for(var u,r=0;r<h.length;r++)if(h[r].name==n){u=e[r],u.priority=r;break}if(!u)for(r=0;r<t.length;r++)if(t[r].name==n){u=t[r].options,u.priority=t[r].priority;break}return u||(i.option("incidentOccured").call(null,'Value axis with name "'+n+'" does not exist. It was created.'),u={name:n,priority:t.length}),u},a=function(n,i){var r;for(u=0;u<t.length;u++)if(r=t[u],r.name===i&&r.pane===n)return r},n.each(i.paneAxis,function(r,u){n.each(u,function(u){if(c[u+"-"+r]=!0,!a(r,u)){var e=l(u);e&&t.push(i._createValueAxis(n.extend(!0,{},e,{pane:r,name:u}),s,v))}})}),t=n.grep(t,function(n){return!!c[n.name+"-"+n.pane]}),t.sort(function(n,t){return n.priority-t.priority}),s?i.horizontalAxes=t:i.verticalAxes=t},_processSeriesFamilies:function(){var t=this,i=[],f=[],u,e=t.option("rotated");t.seriesFamilies&&t.seriesFamilies.length||(n.each(t.series,function(t,r){n.inArray(r.type,i)===-1&&i.push(r.type)}),n.each(t.panes,function(o,s){u=[],n.each(t.series,function(n,t){t.pane===s.name&&u.push(t)}),n.each(i,function(n,i){var o=r.factory.createSeriesFamily({type:i,pane:s.name,rotated:e,equalBarWidth:t.option("equalBarWidth")});o.add(u),o.adjustSeriesValues(),f.push(o)})}),t.seriesFamilies=f)},_createLegend:function(){var t=this,i=n.extend(!0,{renderer:t.renderer,series:t.series,containerBackgroundColor:t.option("commonSeriesSettings").containerBackgroundColor},t.option("legend"));t.legend?t.legend.update(i):t.legend=r.factory.createLegend(i,t._legendGroup,t._legendTrackerGroup)},_createTranslator:function(n,i){return new t.viz.core.LinearTranslator(n,i)},_createPanesBorderOptions:function(){var i=this.option("commonPaneSettings").border,t={};return n.each(this.panes,function(r,u){var f=n.extend(!0,{},i,u.border);t[u.name]=f}),t},_render:function(t){var i=this,w=i.renderer,e=i.translators,h=i.option("rotated"),u,f=i.layoutManager,y=i.option("title"),c=0,l,p=new r.MultiAxesSynchronizer,s=i._createPanesBorderOptions(),a=function(n,t){var i,r,f;for(u=0;u<t.length;u++)r=t[u],l=r.pane,f=r.name,i=n._getTranslator(l,f),i&&(i.init(),r.setRange(i.getBusinessRange()),r.setTranslator(i))},v=function(){var r,e;for(n.each(i.seriesFamilies||[],function(n,t){var r=i._getTranslator(t.pane);t.updateSeriesValues(r),t.adjustSeriesDimensions(r)}),u=0;u<i.series.length;u++)r=i.series[u],r.elementsClipRectID=i._getElementsClipRectID(i.series[u].pane),r.markersClipRectID=i._getMarkersClipRectID(i.series[u].pane),r.adjustSeriesLabels=t.adjustSeriesLabels,r.draw(i._getTranslator(r.pane,r.axis)),t.animate&&r.getPoints().length<=t.animationPointsLimit&&r.animate();t.drawLegend&&i.legend&&i.legend.options.position==="inside"?(i.legend.canvas=i.canvas,i._legendGroup.append(),i._tooltipGroup.append(),i.legend.draw(),f.applyLegendLayout()):i.legend.options.position=="inside"&&i.legend.toForeground(),i.option("drawn")(),e=function(){for(n.each(i._paneTrackerGroups||[],function(n,t){t.paneSeriesGroup.clear(),t.paneMarkerGroup.clear()}),u=0;u<i.series.length;u++)i.series[u].drawTrackers();i.legend&&i.legend.drawTrackers(),i.tracker._prepare(),n.each(i._paneTrackerGroups,function(n,t){var u=i._getPaneBorderVisibility(n),r=i.panesClipRects[n].id;t.paneSeriesGroup.applySettings({clipId:r}),u&&t.paneMarkerGroup.applySettings({clipId:r}),t.paneSeriesGroup.append(i._seriesTrackerGroup),t.paneMarkerGroup.append(i._markerTrackerGroup)}),i._trackerGroup.append(),i._handleRenderComplete()},i._createTooltip(),t.asyncTrackersRendering?i.delayedRedraw=setTimeout(e,t.trackerRenderingDelay):e()};if(t=i._prepareDrawOptions(t),i.callBase(t),i.stopRedraw){i.stopRedraw=!1;return}if(i._createPanesBackground(),y.text&&t.drawTitle&&(i._titleGroup.append(),i._drawTitle(),f.applyTitleLayout()),t.drawLegend&&i.legend&&i.legend.options.position==="outside"&&(i.legend.canvas=i.canvas,i._legendGroup.append(),i.legend.draw(),f.applyLegendLayout(),f.isCanvasExceeded(!1))){i.option("incidentOccured")("Container is too small to draw chart with current settings"),i._clean();return}i._setPanesClipRectPadding(s,h),t.recreateCanvas?(f.createPanesCanvases(),n.each(i.paneAxis,function(t,u){n.each(u,function(n){var f=i._createTranslator(new r.Range(i._getBusinessRange(t,n)),i._getCanvasForPane(t));f.pane=t,f.axis=n,e.push(f)})})):n.each(e,function(n,t){t.updateBusinessRange(new r.Range(i._getBusinessRange(t.pane,t.axis))),t.init()}),a(i,i.horizontalAxes),a(i,i.verticalAxes),i._stripsGroup.append(),i._axesGroup.append();do{for(u=0;u<i.horizontalAxes.length;u++)i.horizontalAxes[u].resetTicks();for(u=0;u<i.verticalAxes.length;u++)i.verticalAxes[u].resetTicks();for(i.option("synchronizeMultiAxes")&&p.synchronize(h?i.horizontalAxes:i.verticalAxes,h),u=0;u<i.horizontalAxes.length;u++)i.horizontalAxes[u].clipRectID=i._getCanvasClipRectID(),i.horizontalAxes[u].stripsGroup=i._stripsGroup,i.horizontalAxes[u].axesContainerGroup=i._axesGroup,i.horizontalAxes[u].draw({borderOptions:s[i.horizontalAxes[u].pane]});for(f.requireAxesRedraw=!1,t.adjustAxes&&(f.applyHorizontalAxesLayout(),n.each(e,function(n,t){t.init()})),u=0;u<i.verticalAxes.length;u++)i.verticalAxes[u].clipRectID=i._getCanvasClipRectID(),i.verticalAxes[u].stripsGroup=i._stripsGroup,i.verticalAxes[u].axesContainerGroup=i._axesGroup,i.verticalAxes[u].draw({borderOptions:s[i.verticalAxes[u].pane]});if(t.adjustAxes&&(f.applyVerticalAxesLayout(),n.each(e,function(n,t){t.init()})),c=c+1,f.isCanvasExceeded(!0)){i.option("incidentOccured")("Container is too small to draw chart with current settings"),i._clean();return}}while(f.requireAxesRedraw&&c<o);for(i.chartTitle&&i.chartTitle.setClipRectSettings(),i._drawPanesBorders(s),i._createClipRectsForPanes(),u=0;u<i.horizontalAxes.length;u++)i.horizontalAxes[u].applyClipRectForStrips(i._getElementsClipRectID(i.horizontalAxes[u].pane));for(u=0;u<i.verticalAxes.length;u++)i.verticalAxes[u].applyClipRectForStrips(i._getElementsClipRectID(i.verticalAxes[u].pane));i._fillPanesBackground(),i._seriesGroup.append(),i._labelsGroup.append(),i._tooltipGroup.append(),t.asyncSeriesRendering?i.delayedRedraw=setTimeout(v,25):v()},_isInBarTypes:function(n){return n.slice(-3)==="bar"?!0:!1},_setPanesClipRectPadding:function(t){var r=this,u=!0,e=t[r.panes[0].name].visible,o=t[r.panes[r.panes.length-1].name].visible,f="";n.each(r.panes,function(n,i){u=u&&!!t[i.name].visible}),n.each(r.horizontalAxes,function(n,t){f+=t.options.position}),n.each(r.verticalAxes,function(n,t){f+=t.options.position})},_createPanesBackground:function(){var n=this,f=n.option("commonPaneSettings").backgroundColor,t,e=n.renderer,u,i,r=[];for(n._panesBackgroundGroup&&n._panesBackgroundGroup.clear(),i=0;i<n.panes.length;i++){if(t=n.panes[i].backgroundColor||f,!t||t==="none"){r.push(null);continue}u=e.createRect(0,0,0,0,0,{fill:t,strokeWidth:0}).append(n._panesBackgroundGroup),r.push(u)}n.panesBackground=r,n._panesBackgroundGroup.append()},_fillPanesBackground:function(){var i=this,t;n.each(i.panes,function(n,r){t=r.borderCoords,i.panesBackground[n]!=null&&i.panesBackground[n].applySettings({x:t.left,y:t.top,width:t.width,height:t.height})})},_calcPaneBorderCoords:function(n){var r=n.canvas,i=n.borderCoords=n.borderCoords||{};i.left=r.left,i.top=r.top,i.right=r.width-r.right,i.bottom=r.height-r.bottom,i.width=i.right-i.left,i.height=i.bottom-i.top},_drawPanesBorders:function(t){var i=this,r=i.option("rotated");i._panesBorderGroup&&(i._panesBorderGroup.detach(),i._panesBorderGroup.clear()),n.each(i.panes,function(n,u){var e,f=t[u.name],o={fill:"none",stroke:f.color,strokeOpacity:f.opacity,strokeWidth:f.width,dashStyle:f.dashStyle};(i._calcPaneBorderCoords(u,r),f.visible)&&(e=u.borderCoords,i.renderer.createSegmentRect(e.left,e.top,e.width,e.height,0,f,o).append(i._panesBorderGroup))}),i._panesBorderGroup.append()},_createClipRectsForPanes:function(){var t=this;n.each(t.panes,function(n,i){var r=i.borderCoords,u=t.panesClipRects[n];u?u.updateRectangle({x:r.left,y:r.top,width:r.width,height:r.height}):(u=t.renderer.createClipRect(r.left,r.top,r.width,r.height).append(),t.panesClipRects.push(u))})},_getPaneIndex:function(t){var i;return n.each(this.panes,function(n,r){if(r.name===t)return i=n,!1}),i},_getPaneBorderVisibility:function(n){var i=this.option("commonPaneSettings").border.visible,r=this.panes[n]||{},t=r.border||{};return"visible"in t?t.visible:i},_getElementsClipRectID:function(n){return this.panesClipRects[this._getPaneIndex(n)].id},_getMarkersClipRectID:function(n){var t=this,r=t._getPaneIndex(n),u=t._getPaneBorderVisibility(r);return u?t._getElementsClipRectID(n):i},_getTranslator:function(n,t){for(var r=this.translators,f=r.length,u=null,i=0;i<f;i++)if(r[i].pane===n&&r[i].axis===t){u=r[i];break}if(!u)for(i=0;i<f;i++)if(r[i].pane===n){u=r[i];break}return u},_getCanvasForPane:function(n){for(var i=this.panes,r=i.length,t=0;t<r;t++)if(i[t].name===n)return i[t].canvas},_getBusinessRange:function(n,t){for(var r=this.businessRanges||[],f=r.length,u,i=0;i<f;i++)if(r[i].pane===n&&r[i].axis===t){u=r[i];break}if(!u)for(i=0;i<f;i++)if(r[i].pane===n){u=r[i];break}return u},_handleSeriesPopulated:function(n){var t=this;t._processSeriesFamilies(),t._createLegend(),t._populateBusinessRange(),t._processValueAxisFormat(),t._updateTracker(),n&&t._render({force:!0})},_processValueAxisFormat:function(){var t=this,r=t.option("rotated")?t.horizontalAxes:t.verticalAxes,i=[];n.each(t.series,function(){this.isFullStackedSeries()&&n.inArray(this.axis,i)===-1&&i.push(this.axis)}),n.each(r,function(){n.inArray(this.name,i)!==-1&&this.setPercentLabelFormat()})},zoomArgument:function(t,i){var r=this;r.option("adjustOnZoom")&&r._populateBusinessRange({minArg:t,maxArg:i}),n.each(r.paneAxis,function(u,f){n.each(f,function(n){var e=r._getTranslator(u,n),o=r._getBusinessRange(u,n);e.updateBusinessRange(o),(t||i)&&(r._options.rotated?e.zoomY(t,i):e.zoomX(t,i),e.init())})}),r._render({force:!0,drawTitle:!1,drawLegend:!1,adjustAxes:!1,animate:!1,adjustSeriesLabels:!1,asyncSeriesRendering:!1})}})}(jQuery,DevExpress),function(n,t,i){var r=t.viz.charts,u=t.utils,f=12;r.PieChart=r.BaseChart.inherit({_defaultOptions:function(){return n.extend(!0,this.callBase(),{commonSeriesSettings:{type:"pie",pie:{label:{percentPrecision:0}}},legend:{hoverMode:"markPoint"}})},_reinit:function(n){var t=this;t.callBase(),t.series||t._dataSpecificInit(),n&&t._render({force:!0})},_populateBusinessRange:function(){var i=[],f=this.series,t=f[0],n,u;this._disposeObjectsInArray("businessRanges"),t&&(n=new r.Range({series:t}),u=t.getRangeData(),n=n.getBoundRange(u),n.isDefined()||n.setStubData(),i.push(n)),this.businessRanges=i},_createTranslator:function(n){return new DevExpress.viz.core.Translator1D(n.minY,n.maxY,360-.0001,0)},_populateSeries:function(){var t=this,y=t.renderer,p=!!t.option("seriesTemplate"),s=p?t._templatedSeries:t.option("series"),l=n.isArray(s)?s:s?[s]:[],a=t.themeManager,h,f,o,e,c,w=t.option("commonSeriesSettings"),b=t._userOptions.commonSeriesSettings,v=t.option("incidentOccured");return t._disposeSeries(),t.series=[],a.resetPalette(),l.length&&(f=l[0],f.type&&!u.isString(f.type)&&(f.type=""),h=f.data,f.data=null,f.incidentOccured=v,e=a.applyPieSeriesTheme(f,w,b),e.seriesGroup=t._seriesGroup,e.trackerGroup=t._trackerGroup,e.seriesLabelsGroup=t._labelsGroup,e.seriesTrackerGroup=t._seriesTrackerGroup,e.markerTrackerGroup=t._markerTrackerGroup,c=e.type!==i?e.type:t.option("commonSeriesSettings").type,o=r.factory.createSeries(c,y,h,e),o?(t._processSingleSeries(o,o.userOptions),t.series.push(o)):v.call(null,"Unknown series type requested: "+c),f.data=h),t.series},_processSingleSeries:function(n,t){var u=this,o=u.option("commonSeriesSettings"),r,s=t.seriesGroup,h=t.trackerGroup,c=t.seriesTrackerGroup,l=t.markerTrackerGroup,a=t.seriesLabelsGroup,i,f,e;for(n.arrangePoints(),r=n&&n.getPoints()||[],t.seriesGroup=null,t.trackerGroup=null,t.seriesTrackerGroup=null,t.markerTrackerGroup=null,t.seriesLabelsGroup=null,i=0;i<r.length;i++)f=u.themeManager.applyNextPieSegmentTheme(t,o),e=n.parseStyleOptions(f),r[i].setOptions(e.point),r[i].index=i;t.seriesGroup=s,t.trackerGroup=h,t.seriesTrackerGroup=c,t.markerTrackerGroup=l,t.seriesLabelsGroup=a},_handleSeriesPopulated:function(n){var t=this;t._populateBusinessRange(),t._createLegend(),t._updateTracker(),n&&t._render({force:!0,recreateCanvas:!0})},_createLegend:function(){var t=this,i=n.extend(!0,{renderer:t.renderer,series:n.map(t.series[0]?t.series[0].getPoints():[],function(n){return n.name=n.argument,n.options.showInLegend=!0,n.styles={themeColor:n.options.attributes.fill},n})},t.option("legend"));i.position!=="outside"&&(i.position="outside"),t.legend=r.factory.createLegend(i,t._legendGroup,t._legendTrackerGroup)},_setPaddings:function(n){var t=this,u="original"+n,r=n.toLowerCase(),i=f-t.canvas[r];i>0&&(t.canvas[u]+=i,t.canvas[r]+=i)},_render:function(n){var t=this,r=t.option("title"),i=t.layoutManager;if(n=t._prepareDrawOptions(n),t.callBase(n),t.stopRedraw){t.stopRedraw=!1;return}if(r.text&&n.drawTitle&&(t._titleGroup.append(),t._drawTitle(),i.applyTitleLayout()),n.drawLegend&&t.legend&&(t.legend.canvas=t.canvas,t._legendGroup.append(),t.legend.draw(),i.applyLegendLayout()),i.isCanvasExceeded(!1)){t.option("incidentOccured")("Container is too small to draw chart with current settings"),t._clean();return}if(t.chartTitle&&t.chartTitle.setClipRectSettings(),t._setPaddings("Bottom"),t._setPaddings("Top"),t._setPaddings("Left"),t._setPaddings("Right"),t.series&&t.series[0]){if(!i.applyPieChartSeriesLayout()){t.option("incidentOccured")("Container is too small to draw chart with current settings"),t._clean();return}t._seriesGroup.append(),t._labelsGroup.append(),t.series[0].canvas=t.canvas,t.series[0].draw(t._createTranslator(t.businessRanges[0],t.canvas)),t.series[0].redraw&&(t._seriesGroup.detach(),t._trackerGroup.detach(),t._labelsGroup.detach(),t._seriesGroup.clear(),t._labelsGroup.clear(),t._seriesGroup.append(),t._labelsGroup.append(),i.applyPieChartSeriesLayout(),t.series[0].draw(t._createTranslator(t.businessRanges[0],t.canvas))),t.series[0].animate(),t._tooltipGroup.append(),t._trackerGroup.append(),t._createTooltip(),t.series[0].drawTrackers(),t.tracker._prepare("pieChart")}t._handleRenderComplete()},getSeries:function(){return this.series&&this.series[0]}})}(jQuery,DevExpress),function(n,t){var r=t.viz,u=r.core.Palette,f=t.utils.isArray,s=120,e=20,h=20,c=20,l=30,a=20,o=50;r.charts.ThemeManager=r.core.BaseThemeManager.inherit(function(){var i=function(n,t){var i=this;n=n||{},i.callBase(n.theme,t||"chart"),i.palette=new u(n.palette||i.theme.defaultPalette,o),i.init()},r=function(){this.palette.dispose(),this.palette=null,this.callBase()},s=function(){var n=this;n.theme.legend=n.theme.legend||{},n.theme.legend.font=n.theme.legend.font||{},n.initializeFont(n.theme.legend.font),h(n),c(n),n.theme.title=n.theme.title||{},n.theme.title.font=n.theme.title.font||{},n.initializeFont(n.theme.title.font),n.theme.tooltip=n.theme.tooltip||{},n.theme.tooltip.font=n.theme.tooltip.font||{},n.initializeFont(n.theme.tooltip.font)},h=function(n){var i=n.theme,t=i.commonSeriesSettings,r=i.font,u;t.point=t.point||{},t.containerBackgroundColor=t.containerBackgroundColor||i.containerBackgroundColor,t.label=t.label||{},n.initializeFont(t.label.font)},c=function(n){var i=n.theme,t=i.commonAxisSettings,r=i.font,u,f;t&&(t.label=t.label||{},t.grid=t.grid||{},t.ticks=t.ticks||{},t.line=t.line||{},t.title=t.title||{},t.label.font=t.label.font||{},n.initializeFont(t.label.font),t.title.font=t.title.font||{},n.initializeFont(t.title.font))},l=function(t){var u=this,r={dataSource:t.dataSource,series:t.series},i;return delete t.dataSource,delete t.series,(t.valueAxis&&f(t.valueAxis)&&!t.valueAxis.length||n.isEmptyObject(t.valueAxis))&&delete t.valueAxis,(t.panes&&f(t.panes)&&!t.panes.length||n.isEmptyObject(t.panes))&&delete t.panes,i=u.applyTheme(u.theme,t),i.dataSource=r.dataSource,i.series=r.series,t.series=r.series,i},a=function(i,r,u){var c=this,f=n.extend(!0,{},r||c.theme.commonSeriesSettings),s=n.extend(!0,{},u||{}),h=((i.type||f.type||"")+"").toLowerCase(),l=~h.indexOf("area")||~h.indexOf("bar"),o;return s=n.extend(!0,s,s[h]),f=n.extend(!0,f,f[h],s),i=i||{},o=new t.Color(i.color||s.color||c.palette.getNextColor()),f.color=o.toHex(),f.border.color=f.border.color||o.toHex(),f.hoverStyle.color=f.hoverStyle.color||l&&o.highlight(e)||o.toHex(),f.hoverStyle.border.color=f.hoverStyle.border.color||o.toHex(),f.selectionStyle.color=f.selectionStyle.color||l&&o.highlight(e)||o.toHex(),f.selectionStyle.border.color=f.selectionStyle.border.color||o.toHex(),f.point.color=f.point.color||o.toHex(),f.point.border.color=f.point.border.color||o.toHex(),f.point.hoverStyle.color=f.point.hoverStyle.color||f.containerBackgroundColor,f.point.hoverStyle.border.color=f.point.hoverStyle.border.color||o.toHex(),f.point.selectionStyle.color=f.point.selectionStyle.color||f.containerBackgroundColor,f.point.selectionStyle.border.color=f.point.selectionStyle.border.color||o.toHex(),c.applyTheme(f,i)},v=function(t,i,r){var e=this,u=i||e.theme.commonSeriesSettings||{},f=(t.type||u.type||"").toLowerCase();return f&&f!=="pie"&&(u[f]=n.extend(!0,{},u[f],u.pie)),r=r||{},t=t||{},t=n.extend(!0,{},u,u[f],r,r[f],t)},y=function(i,r){var e=this,o=r||e.theme.commonSeriesSettings||{},u=n.extend(!0,{},o.pie),s=i.type||u.type||"",f;return i=i||{},f=new t.Color(i.color||e.palette.getNextColor()),u.color=f.toHex(),u.border.color=u.border.color||f.toHex(),u.hoverStyle.color=u.hoverStyle.color||f.highlight(20),u.hoverStyle.border.color=u.hoverStyle.border.color||f.toHex(),u.selectionStyle.color=u.selectionStyle.color||f.highlight(20),u.selectionStyle.border.color=u.selectionStyle.border.color||f.toHex(),e.applyTheme(u,i)},p=function(){this.palette.reset()},w=function(n){this.palette=new u(n||this.theme.defaultPalette,o)};return{ctor:i,dispose:r,init:s,applyChartTheme:l,applyNextSeriesTheme:a,applyPieSeriesTheme:v,applyNextPieSegmentTheme:y,resetPalette:p,updatePalette:w}}())}(jQuery,DevExpress),function(n,t){var u=t.utils.isNumber,r=Math.round;t.viz.charts.LayoutManager=t.Class.inherit(function(){var a=function(n){this.chart=n,t(n&&n.canvas)},v=function(){this.chart=null},t=function(n){n&&(n.originalTop=n.top,n.originalBottom=n.bottom,n.originalLeft=n.left,n.originalRight=n.right)},y=function(){for(var l=this.chart,i=l.canvas,f=l.panes,t,e=f.length,a=i.height-i.top-i.bottom,v=i.width-i.left-i.right,o=0,y,p,s=f.padding||10,h=0,c=0,u=0;u<e;u++)t=f[u],t.weight=t.weight||1,o=o+t.weight;if(y=(a-s*(e-1))/o,p=(v-s*(e-1))/o,l.option("rotated"))for(u=0;u<e;u++)t=f[u],t.calcWidth=r(t.weight*p),t.canvas=n.extend({},i),t.canvas.left=t.canvas.originalLeft=i.left+c,t.canvas.right=t.canvas.originalRight=i.right+(v-t.calcWidth-c),c=c+t.calcWidth+s;else for(u=0;u<e;u++)t=f[u],t.calcHeight=r(t.weight*y),t.canvas=n.extend({},i),t.canvas.top=t.canvas.originalTop=i.top+h,t.canvas.bottom=t.canvas.originalBottom=i.bottom+(a-t.calcHeight-h),h=h+t.calcHeight+s},p=function(){var o=this.chart,n=o.canvas,u=o.chartTitle,i,s=15,h=10,f,e;if(u){i=u.getBoundingRect();switch(u.horizontalAlignment){case"left":f=r(s+n.left);break;case"center":f=r((n.width-n.left-n.right-i.width)/2+n.left)-i.x;break;case"right":f=r(n.width-n.right-i.x-i.width-s)}u.verticalAlignment==="top"?(e=r(n.top-i.y),n.top=n.top+i.height+h):(e=r(n.height-n.bottom-i.height-i.y),n.bottom=n.bottom+i.height+h),u.shift(f,e),t(n)}},w=function(){var f=this.chart,n=f.canvas,t=f.chartTitle,e=15,i,u,o=t.innerTitleGroup.settings.translateY||0;t.canvas=n,t.correctTitleLength(),i=t.getBoundingRect();switch(t.horizontalAlignment){case"left":u=r(e+n.left);break;case"center":u=r((n.width-n.right-n.left-i.width)/2+n.left-i.x);break;case"right":u=r(n.width-n.right-i.x-i.width-e)}t.shift(u,o)},b=function(){var y=this,c=y.chart,i=c.canvas,l=c.legend,p=c.chartTitle,h=c.panes,e=l.options,f=l.getBoundingRect(),a=10,v=10,o,s;if(e.visible&&u(f.width)&&u(f.height))if(e.position==="outside"){switch(e.horizontalAlignment){case"left":o=r(i.left-f.x+v),i.left=i.left+f.width+e.margin+v,p&&y.adjustTitleLayout();break;case"center":o=r((i.width-i.left-i.right-f.width)/2+i.left-f.x);break;case"right":o=r(i.width-i.right-f.width-f.x-v),i.right=i.right+f.width+e.margin+v,p&&y.adjustTitleLayout()}switch(e.verticalAlignment){case"top":s=r(a+i.top-f.y),e.horizontalAlignment==="center"&&(i.top=i.top+f.height+e.margin+a);break;case"bottom":s=r(i.height-f.height-i.bottom-a-f.y),e.horizontalAlignment==="center"&&(i.bottom=i.bottom+f.height+e.margin+a)}l.shift(o,s),t(i)}else{i=n.extend(!0,{},h[0].canvas),i.bottom=h[h.length-1].canvas.bottom,i.right=h[h.length-1].canvas.right;switch(e.horizontalAlignment){case"left":o=r(i.left-f.x+e.margin);break;case"center":o=r((i.width-i.left-i.right-f.width)/2+i.left-f.x);break;case"right":o=r(i.width-i.right-f.width-f.x-e.margin)}switch(e.verticalAlignment){case"top":s=r(i.top-f.y+e.margin);break;case"bottom":s=r(i.height-f.height-i.bottom-e.margin-f.y)}l.shift(o,s)}},k=function(){var s=this.chart,i=s.canvas,n=s.series[0]||{},f=i.height-i.top-i.bottom,e=i.width-i.left-i.right,h=e<f?e:f,o,c=n.outerRadius,t=n.type==="pie"?0:n.innerRadius||0;if(n&&n.correctPosition)return(n.type!=="pie"&&(u(t)?(t=Number(t),t<.2&&(t=.2),t>.8&&(t=.8)):t=.5),h<n.labelSpace)?!1:(o=c||(h-n.labelSpace-n.hoverSpace)/2,n.correctPosition({centerX:r(e/2+i.left),centerY:r(f/2+i.top),radiusInner:r(o*t),radiusOuter:r(o)}),!0)},f=function(n){return!!(n.x||n.y||n.width||n.height)},e=function(t,r,u){var o,f,s,e,h;return n.each(t,function(t,c){o=i(r,c.name),f=r[o.row][o.col],s=f.canvas,n.each(u,function(n,t){e="delta"+t,f[e]=Math.max(f[e]-(s[t.toLowerCase()]-s["original"+t]),0),f[e]>0&&(h=!0)})}),h},d=function(){for(var u=this,w=u.chart,r=w.verticalAxes,p,b,s,t,h,l,v,d,g=0,a,k,y=o(u,w.panes),n=0;n<r.length;n++)(v=r[n],s=v.options.position||"left",v.delta={},h=v.getBoundingRect(),f(h))&&(b=i(y,r[n].pane),t=y[b.row][b.col],p=t.canvas,s=="right"?(a="deltaRight",k=1):(a="deltaLeft",k=-1),d=h.width,!v.delta[s]&&t[a]>0&&(t[a]+=r[n].getMultipleAxesSpacing()),r[n].delta[s]=r[n].delta[s]||0,r[n].delta[s]+=t[a]*k,t[a]+=d,l=h.y+h.height-(p.height-p.originalBottom),l>0&&(u.requireAxesRedraw=!0,t.deltaBottom+=l),l=p.originalTop-h.y,l>0&&(u.requireAxesRedraw=!0,t.deltaTop+=l));u.requireAxesRedraw=e(w.panes,y,["Left","Right"])||u.requireAxesRedraw,c(y)},g=function(){for(var u=this,k=u.chart,d=k.panes,t=k.horizontalAxes,y,p,r,s,h,w,g,l,b,a,v=o(u,d),n=t.length-1;n>=0;n--)(w=t[n],a=w.options.position||"bottom",t[n].delta={},s=t[n].getBoundingRect(),f(s))&&(p=i(v,t[n].pane),r=v[p.row][p.col],y=r.canvas,a=="top"?(l="deltaTop",b=-1):(l="deltaBottom",b=1),g=s.height,!w.delta[a]&&r[l]>0&&(r[l]+=t[n].getMultipleAxesSpacing()),t[n].delta[a]=t[n].delta[a]||0,t[n].delta[a]+=r[l]*b,r[l]+=g,h=y.originalLeft-s.x,h>0&&(u.requireAxesRedraw=!0,r.deltaLeft+=h),h=s.x+s.width-(y.width-y.originalRight),h>0&&(u.requireAxesRedraw=!0,r.deltaRight=h));u.requireAxesRedraw=e(d,v,["Bottom","Top"])||u.requireAxesRedraw,c(v)},o=function(n,t){for(var e=t.length,s,u=[],r=[],f=n.chart.option("rotated"),i=0;i<e;i++)f||(r=[]),r.push({canvas:t[i].canvas,pane:t[i].name,deltaLeft:0,deltaRight:0,deltaTop:0,deltaBottom:0}),f||u.push(r);return f&&u.push(r),u},i=function(n,t){for(var u,r=0;r<n.length;r++)for(u=0;u<n[r].length;u++)if(n[r][u].pane===t)return{row:r,col:u}},s=function(n,t,i){for(var r=0;r<n[t].length;r++)i(n[t][r].canvas)},h=function s(n,t,i){for(var r=0;r<n.length;r++)i(n[r][t].canvas)},c=function(n){for(var t,i,u=0,f=0,e=0,o=0,l=0,r=0;r<n.length;r++){for(e=0,o=0,i=n[r],i.length>l&&(l=i.length),t=0;t<i.length;t++)i[t]&&i[t].deltaTop>e&&(e=i[t].deltaTop),i[t]&&i[t].deltaBottom>o&&(o=i[t].deltaBottom);e&&s(n,r,function(n){n.top+=e}),o&&s(n,r,function(n){n.bottom+=o})}for(t=0;t<l;t++){for(u=0,f=0,r=0;r<n.length;r++)i=n[r],i[t]&&i[t].deltaLeft>u&&(u=i[t].deltaLeft),i[t]&&i[t].deltaRight>f&&(f=i[t].deltaRight);u&&h(n,t,function(n){n.left+=u}),f&&h(n,t,function(n){n.right+=f})}},l=function(n){if(n.left>n.width-n.right||n.right>n.width-n.left||n.top>n.height-n.bottom||n.bottom>n.height-n.top)return!0},nt=function(t){var i=this.chart,r=!1;return l(i.canvas)?!0:(t&&n.each(i&&i.panes||{},function(n,t){if(t.canvas&&l(t.canvas))return r=!0,!1}),r)};return{update:a,createPanesCanvases:y,applyLegendLayout:b,applyTitleLayout:p,adjustTitleLayout:w,applyVerticalAxesLayout:d,applyHorizontalAxesLayout:g,applyPieChartSeriesLayout:k,isCanvasExceeded:nt,dispose:v}}())}(jQuery,DevExpress),function(n,t){var u=t.viz.charts,r=t.utils;u.MultiAxesSynchronizer=t.Class.inherit(function(){var f=function(t){var i={};return n.each(t,function(){i[this.pane]||(i[this.pane]=[]),i[this.pane].push(this)}),i},e=function(n,t){var i,r="minVisible"+t,f="maxVisible"+t,e,o;n.translator._originalBusinessRange?(e=n.translator.businessRange[r],o=n.translator.businessRange[f],i=new u.Range(n.translator._originalBusinessRange),i[r]=e,i[f]=o,n.translator.updateBusinessRange(i),n.setRange(i)):n.translator._originalBusinessRange=new u.Range(n.translator.getBusinessRange())},o=function(t,i){var u=[];return n.each(t,function(){var n,o,s,h,f,t,c=i&&"stubDataX"||"stubDataY";e(this,i?"Y":"X"),n=this.getTickValues(),n&&n.length>0&&r.isNumber(n[0])&&this.options.type!=="discrete"&&(t=this.translator.getBusinessRange(),o=i?t.minVisibleX:t.minVisibleY,s=i?t.maxVisibleX:t.maxVisibleY,h=i?t.invertX:t.invertY,f={axis:this,tickValues:n,minValue:o,oldMinValue:o,maxValue:s,oldMaxValue:s,inverted:h,synchronizedValue:this.options.synchronizedValue},t[c]&&(f.stubData=!0,f.tickInterval=f.axis.options.tickInterval),!f.tickInterval&&n.length>1&&(f.tickInterval=n[1]-n[0]),u.push(f))}),u},s=function(t){var i=0,u,f,e=0;n.each(t,function(){i=Math.max(i,this.tickValues.length)}),n.each(t,function(){if(r.isDefined(this.synchronizedValue))this.baseTickValue=this.synchronizedValue,this.invertedBaseTickValue=this.synchronizedValue,this.tickValues=[this.baseTickValue];else{if(this.tickValues.length>1&&this.tickInterval){for(u=Math.floor((i+1)/this.tickValues.length),f=u>1?Math.floor((i+1)/u):i,e=Math.floor((f-this.tickValues.length)/2);e>0&&this.tickValues[0]!==0;)this.tickValues.unshift(r.adjustValue(this.tickValues[0]-this.tickInterval)),e--;while(this.tickValues.length<f)this.tickValues.push(r.adjustValue(this.tickValues[this.tickValues.length-1]+this.tickInterval));this.tickInterval=this.tickInterval/u}this.baseTickValue=this.tickValues[0],this.invertedBaseTickValue=this.tickValues[this.tickValues.length-1]}})},t=function(n){return n.maxValue-n.minValue},i=function(n){for(var t=0;t<n.length;t++)if(!n[t].stubData)return n[t];return null},h=function(u){var f=i(u);n.each(u,function(){var u,n,i;this!==f&&(f.tickInterval&&this.tickInterval&&(this.stubData&&r.isDefined(this.synchronizedValue)&&(this.oldMinValue=this.minValue=this.baseTickValue-(f.baseTickValue-f.minValue)/f.tickInterval*this.tickInterval,this.oldMaxValue=this.maxValue=this.baseTickValue-(f.baseTickValue-f.maxValue)/f.tickInterval*this.tickInterval,this.stubData=!1),u=f.tickInterval/t(f)/this.tickInterval*t(this),this.maxValue=this.minValue+t(this)/u),i=f.inverted&&!this.inverted||!f.inverted&&this.inverted?f.maxValue-f.invertedBaseTickValue:f.baseTickValue-f.minValue,n=(i/t(f)-(this.baseTickValue-this.minValue)/t(this))*t(this),this.minValue-=n,this.maxValue-=n)})},c=function(i){var f,e,r=0,u=0;return n.each(i,function(){f=this.minValue>this.oldMinValue?(this.minValue-this.oldMinValue)/t(this):0,e=this.maxValue<this.oldMaxValue?(this.oldMaxValue-this.maxValue)/t(this):0,this.inverted?(r=Math.max(r,e),u=Math.max(u,f)):(r=Math.max(r,f),u=Math.max(u,e))}),{start:r,end:u}},l=function(i,u){var f;n.each(i,function(){f=t(this),this.inverted?(this.minValue-=u.end*f,this.maxValue+=u.start*f):(this.minValue-=u.start*f,this.maxValue+=u.end*f),this.minValue=Math.min(this.minValue,r.adjustValue(this.minValue)),this.maxValue=Math.max(this.maxValue,r.adjustValue(this.maxValue))})},a=function(t){var i=!1;n.each(t,function(){i=i||r.isDefined(this.synchronizedValue)}),n.each(t,function(){var n;if(i&&this.tickInterval){while(this.tickValues[0]-this.tickInterval>=this.minValue)this.tickValues.unshift(r.adjustValue(this.tickValues[0]-this.tickInterval));for(n=this.tickValues[this.tickValues.length-1];(n=n+this.tickInterval)<=this.maxValue;)this.tickValues.push(r.adjustValue(n))}while(this.tickValues[0]<this.minValue)this.tickValues.shift();while(this.tickValues[this.tickValues.length-1]>this.maxValue)this.tickValues.pop()})},v=function(t,i){var f,u,e=i&&"stubDataX"||"stubDataY";n.each(t,function(){f=this.axis,u=f.translator.getBusinessRange(),i?(u.minX===u.minVisibleX&&(u.minX=this.minValue),u.maxX===u.maxVisibleX&&(u.maxX=this.maxValue),u.minVisibleX=this.minValue,u.maxVisibleX=this.maxValue):(u.minY===u.minVisibleY&&(u.minY=this.minValue),u.maxY===u.maxVisibleY&&(u.maxY=this.maxValue),u.minVisibleY=this.minValue,u.maxVisibleY=this.maxValue),r.isDefined(this.stubData)&&(u[e]=this.stubData),f.translator.updateBusinessRange(u),f.setRange(u),f.setTickValues(this.tickValues)})};return{synchronize:function(t,r){var u;u=f(t),n.each(u,function(n,t){var u,f;if(t.length>1){if(u=o(t,r),u.length===0||!i(u))return;s(u),h(u),f=c(u),l(u,f),a(u),v(u,r)}})}}}())}(jQuery,DevExpress),function(n){n.viz.charts.series.consts={events:{mouseover:"mouseover",mouseout:"mouseout",mousemove:"mousemove",touchstart:"touchstart",touchmove:"touchmove",touchend:"touchend",mousedown:"mousedown",mouseup:"mouseup",click:"click",selectSeries:"selectseries",deselectSeries:"deselectseries",selectPoint:"selectpoint",deselectPoint:"deselectpoint",showPointTooltip:"showpointtooltip",hidePointTooltip:"hidepointtooltip"},states:{hover:"hover",normal:"normal",selected:"selected",normalMark:0,hoverMark:1,selectedMark:2}}}(DevExpress),function(n,t){var u=t.viz.charts.series,o=u.consts.events,i=u.consts.states,r=t.utils,f=t.formatHelper,e="canvas_position_default";u.BasePoint=t.Class.inherit({ctor:function(n){this.LABEL_BACKGROUND_PADDING_X=8,this.LABEL_BACKGROUND_PADDING_Y=4,this.LABEL_OFFSET=10,this.rotated=!!n.rotated,n.options.label&&n.options.label.position&&n.options.label.position!=="outside"&&n.options.label.position!=="inside"&&(n.options.label.position="outside"),this.options=n.options,this.series=n.series,this.value=this.initialValue=n.value,this.argument=this.initialArgument=n.argument,this.originalValue=n.originalValue,this.originalArgument=n.originalArgument,this.minValue=e,this.labelFormatObject={argument:this.initialArgument,value:this.initialValue,seriesName:this.options.seriesName,originalValue:this.originalValue,originalArgument:this.originalArgument},this.tag=n.tag,this.pointClassName=n.pointClassName||""},dispose:function(){var n=this;n.off(),n.trackerGraphic&&n.trackerGraphic.removeData(),n.graphic=null,n.trackerGraphic=null,n.hoverPattern=null,n.selectedPattern=null,n.label=null,n.labelBackground=null,n.connector=null,n.insideLabelGroup=null,n.labelGroup=null,n.points=null,n.translator=null,n.options=null,n.series=null,n.tag=null,n.labelFormatObject=null},formatLabel:function(n){return this.valueText=f.format(this.value,n.format,n.precision),this.argumentText=f.format(this.argument,n.argumentFormat,n.argumentPrecision),this.percent!==undefined&&(this.percentText=f.format(this.percent,"percent",n.percentPrecision)),n.customizeText?n.customizeText.call(this,this):this.valueText},setOptions:function(n){this.options=n},translate:function(n){(this.translator=n=n||this.translator,this.translator&&this.hasValue())&&(this.rotated?(this.y=n.translateY(this.argument),this.x=n.translateX(this.value),this.minX=n.translateX(this.minValue),this.defaultX=n.translateX(e)):(this.y=n.translateY(this.value),this.minY=n.translateY(this.minValue),this.x=n.translateX(this.argument),this.defaultY=n.translateY(e)),this._calculateVisibility(this.x,this.y,0,0),this.prepareStatesOptions())},_calculateVisibility:function(n,t,i,r){var u;this.translator&&this.translator.getCanvasVisibleArea&&(u=this.translator.getCanvasVisibleArea()||{},this.visible=u.minX>n+(i||0)||u.maxX<n||u.minY>t+(r||0)||u.maxY<t?!1:!0)},correctValue:function(n){this.value+=n,r.isNumber(this.minValue)?this.minValue+=n:this.minValue=n,this.translate()},normalizeValue:function(n){this.value=this.value/n||0,r.isNumber(this.minValue)?(this.minValue=this.minValue/n||0,this.labelFormatObject.percent=this.value-this.minValue):this.labelFormatObject.percent=this.value,this.translate()},getCoords:function(n){return n?this.rotated?{x:this.minX,y:this.y}:{x:this.x,y:this.minY}:{x:this.x,y:this.y}},getDefaultCoords:function(){return this.rotated?{x:this.defaultX,y:this.y}:{x:this.x,y:this.defaultY}},getTooltipCoords:function(){return this.graphic?{x:this.x,y:this.y,offset:this.graphic.getBBox().height/2}:{x:this.x,y:this.y,offset:0}},isInVisibleArea:function(){return this.visible},drawMarker:function(n,t){if(this.hasValue()){var u=this.options.attributes.r,f=this.options.states.normal,r,e;switch(this.options.symbol){case"circle":r=n.createCircle(this.x,this.y,u,this.options.attributes).append(t);break;case"square":case"polygon":case"triangle":case"cross":r=n.createArea(this.points,this.options.attributes).append(t)}this.graphic=r;switch(this.state){case i.selected:this.series.setPointSelectedState(this);break;case i.hover:this.series.setPointHoverState(this);break;default:this.state=i.normal,this.fullState=i.normalMark}}},_trackerAttrs:{stroke:"none",fill:"grey",opacity:.0001,inh:!0},storeTrackerR:function(){var n=window.navigator,i="ontouchstart"in window||n.msPointerEnabled&&n.msMaxTouchPoints>0,t=i?20:6;return this.options.trackerR=this.options.attributes.r<t?t:this.options.attributes.r},drawTrackerMarker:function(n,t){this.hasValue()&&(this.trackerGraphic=n.createCircle(this.x,this.y,this.options.trackerR||this.storeTrackerR(),this._trackerAttrs).append(t),this.trackerGraphic.data({point:this}))},select:function(){this.series.selectPoint(this)},clearSelection:function(){this.series.deselectPoint(this)},_populatePointShape:function(n,t){var i=this,r,u;i.options.symbol==="square"&&(n.points=[{x:i.x-t,y:i.y-t},{x:i.x+t,y:i.y-t},{x:i.x+t,y:i.y+t},{x:i.x-t,y:i.y+t},{x:i.x-t,y:i.y-t}]),i.options.symbol==="polygon"&&(n.points=[{x:i.x-t,y:i.y},{x:i.x,y:i.y-t},{x:i.x+t,y:i.y},{x:i.x,y:i.y+t},{x:i.x-t,y:i.y}]),i.options.symbol==="triangle"&&(n.points=[{x:i.x-t,y:i.y-t},{x:i.x+t,y:i.y-t},{x:i.x,y:i.y+t},{x:i.x-t,y:i.y-t}]),i.options.symbol==="cross"&&(r=Math.floor(t/2),u=Math.ceil(t/2),n.points=[{x:i.x-t,y:i.y-r},{x:i.x-r,y:i.y-t},{x:i.x,y:i.y-u},{x:i.x+r,y:i.y-t},{x:i.x+t,y:i.y-r},{x:i.x+u,y:i.y},{x:i.x+t,y:i.y+r},{x:i.x+r,y:i.y+t},{x:i.x,y:i.y+u},{x:i.x-r,y:i.y+t},{x:i.x-t,y:i.y+r},{x:i.x-u,y:i.y}])},prepareStatesOptions:function(){var n=this;n.options.states&&n.options.states.normal&&n._populatePointShape(n,n.options.states.normal.r)},applyNormalStyle:function(){return this.graphic&&(this._populatePointShape(this.options.states.normal,this.options.states.normal.r),this.graphic.applySettings(this.options.states.normal)),this},applyHoverStyle:function(){return this.graphic&&(this._populatePointShape(this.options.states.hover,this.options.states.hover.r),this.graphic.applySettings(this.options.states.hover),this.graphic.toForeground(),this.graphic.addClass("dx-chart-hovered-point")),this},applySelectionStyle:function(){return this.graphic&&(this._populatePointShape(this.options.states.selected,this.options.states.selected.r),this.graphic.applySettings(this.options.states.selected),this.graphic.toForeground(),this.graphic.addClass("dx-chart-selected-point")),this},setHoverState:function(){this.series.setPointHoverState(this)},releaseHoverState:function(){this.series.releasePointHoverState(this),this.graphic&&(this.graphic.removeClass("dx-chart-hovered-point"),this.state!=="selected"&&this.graphic.toBackground())},setSelectedState:function(){this.series.setPointSelectedState(this)},releaseSelectedState:function(){this.series.releasePointSelectedState(this),this.graphic&&this.graphic.removeClass("dx-chart-selected-point")},showTooltip:function(){this.series.showPointTooltip(this)},hideTooltip:function(){this.series.hidePointTooltip(this)},on:function(t,i,r){n(this).on(t,i,r);return this},off:function(t){return n(this).off(t),this},correctLabel:function(){this.correctBackgroundPosition(),this.rotateLabel(),this.correctLabelPosition()},drawLabel:function(n,t){if(this.hasValue()&&r.isDefined(this.labelFormatObject.value)){var i=this.options.label,u=this.formatLabel.call(this.labelFormatObject,i);r.isDefined(u)&&(this.labelGroup=n.createGroup().append(t),this.options.label.connector&&this.options.label.connector.strokeWidth&&(this.connector=n.createPath([],i.connector).append(this.labelGroup)),this.insideLabelGroup=n.createGroup().append(this.labelGroup),i.background["class"]=this.pointClassName,(i.background.fill&&i.background.fill!=="none"||i.background.strokeWidth&&i.background.stroke&&i.background.stroke!=="none")&&(this.labelBackground=n.createRect(this.x,this.y,0,0,0,i.background).append(this.insideLabelGroup)),this.label=n.createText(u,this.x,this.y,i.attributes).append(this.insideLabelGroup),this.correctLabel(),this.correctConnectorPosition())}},rotateLabel:function(){var n=this.insideLabelGroup.getBBox(),t=this.options.label;this.insideLabelGroup.applySettings({x:n.x+n.width/2,y:n.y+n.height/2,rotate:t.rotationAngle})},getGraphicSettings:function(){return{x:this.graphic.settings.x||0,y:this.graphic.settings.y||0,height:this.graphic.settings.height||0,width:this.graphic.settings.width||0}},correctLabelPosition:function(){var n=this.insideLabelGroup.getBBox(),t=this.graphic?this.graphic.getBBox():{x:this.x,y:this.y,height:0,width:0},r=0,i=0;t.isEmpty&&(t={x:this.x,y:this.y,height:0,width:0}),this.rotated?(i+=t.y-n.y-n.height/2+t.height/2,r+=this.initialValue>0||this.series.isFullStackedSeries()?t.x+t.width-n.x+this.LABEL_OFFSET:t.x-n.x-n.width-this.LABEL_OFFSET):i+=this.initialValue>0||this.series.isFullStackedSeries()?t.y-n.y-n.height-this.LABEL_OFFSET:t.y+t.height-n.y+this.LABEL_OFFSET,r+=this.options.label.horizontalOffset,i+=this.options.label.verticalOffset,this.checkLabelPosition({x:n.x+r,y:n.y+i,height:n.height,width:n.width},r,i)},checkLabelPosition:function(n,t,i){var u=this.graphic?this.graphic.getBBox():{x:this.x,y:this.y,height:0,width:0},r=this.translator.getCanvasVisibleArea();u.isEmpty&&(u={x:this.x,y:this.y,height:0,width:0}),this.rotated||r.minX<=u.x+u.width&&r.maxX>=u.x&&(r.minX>n.x&&this.adjustSeriesLabels&&(t+=r.minX-n.x),r.maxX<n.x+n.width&&this.adjustSeriesLabels&&(t-=n.x+n.width-r.maxX),r.minY>n.y&&(i+=u.y+u.height-n.y+this.LABEL_OFFSET),r.maxY<n.y+n.height&&(i-=n.y+n.height-u.y+this.LABEL_OFFSET)),this.rotated&&r.minY<=u.y+u.height&&r.maxY>=u.y&&(r.minX>n.x&&(t+=u.x+u.width-n.x+this.LABEL_OFFSET),r.maxX<n.x+n.width&&(t-=n.x+n.width-u.x+this.LABEL_OFFSET),r.minY>n.y&&this.adjustSeriesLabels&&(i+=r.minY-n.y),r.maxY<n.y+n.height&&this.adjustSeriesLabels&&(i-=n.y+n.height-r.maxY)),this.insideLabelGroup.move(~~t,~~i)},correctBackgroundPosition:function(){if(this.labelBackground){var n=this.label.getBBox(),t=n.x-this.LABEL_BACKGROUND_PADDING_X,i=n.y-this.LABEL_BACKGROUND_PADDING_Y,r=n.width+2*this.LABEL_BACKGROUND_PADDING_X,u=n.height+2*this.LABEL_BACKGROUND_PADDING_Y;this.labelBackground.applySettings({x:t,y:i,width:r,height:u})}},correctConnectorPosition:function(n){var t=this.insideLabelGroup.getBBox(),n=n||(this.graphic?this.graphic.getBBox():{x:this.x,y:this.y,height:0,width:0}),i,u,r,f,e,o;if(this.connector){if(n.isEmpty&&(n={x:this.x,y:this.y,height:0,width:0}),t.x=t.x+(this.insideLabelGroup.settings.translateX||0),t.y=t.y+(this.insideLabelGroup.settings.translateY||0),e=this.labelBackground?t.y+t.height/2:null,o=this.labelBackground?t.x+t.width/2:null,this.rotated){if((o||t.x)>n.x+n.width)i=o||t.x,u=n.x+n.width;else if((o||t.x+t.width)<n.x)i=o||t.x+t.width,u=n.x;else return;r=Math.round(t.y+t.height/2),f=r>n.y+n.height?n.y+n.height:r<n.y?n.y:r}else{if((e||t.y+t.height)<n.y)r=e||t.y+t.height,f=n.y;else if((e||t.y)>n.y+n.height)r=e||t.y,f=n.y+n.height;else return;i=Math.round(t.x+t.width/2),u=i>n.x+n.width?n.x+n.width:i<n.x?n.x:i}this.connector.applySettings({points:[i,r,u,f]})}},getColor:function(){return this.options.attributes.fill},getTooltipFormatObject:function(t){var i=t.formatValueTooltip.call({value:this.initialValue},t.options);return n.extend({},this.labelFormatObject,{point:this,valueText:i})},animate:function(){var n=this,t=n.graphic;t&&n.translator&&(n.rotated?t.move(n.defaultX-n.x,0):t.move(0,n.defaultY-n.y),t.move(0,0,!0))},hasValue:function(){return this.initialValue!==null},getClassName:function(){return this.pointClassName}})}(jQuery,DevExpress),function(n,t){var u=t.viz.charts.series,i=u.consts.states,f="canvas_position_default",e=t.utils.isDefined,r=function(n,t,i){return n<t?t:n>i?i:n};u.BarPoint=u.BasePoint.inherit({translate:function(n){var t,i,u,o,s;(this.translator=n=n||this.translator,this.translator&&this.hasValue())&&(t=n.getCanvasVisibleArea()||{},this.rotated?(this.y=n.translateY(this.argument)+(this.yCorrection||0),s=n.translateX(this.value),this.minX=e(this.minX)?this.minX:Infinity,i=n.translateX(this.minValue),this.width=Math.abs(s-i),this._calculateVisibility(Math.min(s,i),this.y,this.width,0),s=r(s,t.minX,t.maxX),i=r(i,t.minX,t.maxX),this.minX=i+(this.minXCorrection||0),this.width=Math.abs(s-i),this.x=Math.min(i,s)+(this.xCorrection||0),this.defaultX=n.translateX(f)):(this.x=n.translateX(this.argument)+(this.xCorrection||0),o=n.translateY(this.value),this.minY=e(this.minY)?this.minY:Infinity,u=n.translateY(this.minValue),this.height=Math.abs(u-o),this._calculateVisibility(this.x,Math.min(o,this.minY),0,this.height),o=r(o,t.minY,t.maxY),u=r(u,t.minY,t.maxY),this.height=Math.abs(u-o),this.y=Math.min(o,u)+(this.yCorrection||0),this.minY=u+(this.yCorrection||0),this.defaultY=n.translateY(f)))},getTooltipCoords:function(){var n=this,t=n.x+n.width/2,i=n.y+n.height/2;return{x:t,y:i,offset:0}},correctCoordinates:function(n){var t=n.offset-Math.round(n.width/2);this.rotated?(this.height=n.width,this.yCorrection=t,this.minYCorrection=t):(this.width=n.width,this.xCorrection=t,this.minXCorrection=t)},drawMarker:function(n,t){var r;if(this.hasValue()){switch(this.state){case i.hover:r=this.options.states.hover;break;case i.selected:r=this.options.states.selected;break;default:r=this.options.attributes,this.state=i.normal,this.fullState=i.normalMark}this.graphic=n.createRect(this.x,this.y,this.width,this.height,r.r,r).append(t)}},drawTrackerMarker:function(n,t){if(this.hasValue()){var i=this,f=i.y,r=i.height,e=i.x,u=i.width;i.rotated?u===1&&(u=9,e-=4):r===1&&(r=9,f-=4),this.trackerGraphic=n.createRect(e,f,u,r,i.options.attributes.r,i._trackerAttrs).append(t),this.trackerGraphic.data({point:i})}},correctConnectorPosition:function(){this.callBase(this.getBboxGraphic())},drawLabel:function(n,t){if(this.hasValue()&&(this.options.label.showForZeroValues||this.labelFormatObject.value))this.callBase(n,t);else return},getBboxGraphic:function(){var n=this.graphic&&this.graphic.getBBox(),t,i;return n.isEmpty&&(n=this.getGraphicSettings()),t=n.x-this.x,i=n.y-this.y,n.x-=t,n.y-=i,n.width+=2*t,n.height+=2*i,n},correctLabelPosition:function(){var n=this.insideLabelGroup.getBBox(),t=this.getBboxGraphic(),u=this.translator.getBusinessRange(),f=this.series.options.valueAxisType==="discrete",e=!f&&(this.initialValue>=0&&!u.invertY||this.initialValue<0&&u.invertY)||f&&!u.invertY||this.series.isFullStackedSeries(),o=!f&&(this.initialValue>=0&&!u.invertX||this.initialValue<0&&u.invertX)||f&&!u.invertX||this.series.isFullStackedSeries(),i=0,r=0;this.initialValue===0&&this.series.isFullStackedSeries()?this.rotated?(r+=t.y-n.y-n.height/2+t.height/2,i+=this.defaultX-n.x+this.LABEL_OFFSET):(i+=t.width/2,r+=this.defaultY-n.y-n.height-this.LABEL_OFFSET):this.options.label.position==="outside"?this.rotated?(r+=t.y-n.y-n.height/2+t.height/2,i+=o?t.x+t.width-n.x+this.LABEL_OFFSET:t.x-n.x-n.width-this.LABEL_OFFSET):(i+=t.width/2,r+=e?t.y-n.y-n.height-this.LABEL_OFFSET:t.y+t.height-n.y+this.LABEL_OFFSET):this.options.label.position==="inside"&&(this.rotated?(r+=t.y-n.y-n.height/2+t.height/2,i+=o?t.x+t.width-n.x-n.width-this.LABEL_OFFSET:t.x-n.x+this.LABEL_OFFSET):(i+=t.width/2,r+=e?t.y-n.y-n.height+this.LABEL_OFFSET+n.height:t.y+t.height-n.y-this.LABEL_OFFSET-n.height)),i+=this.options.label.horizontalOffset,r+=this.options.label.verticalOffset,this.checkLabelPosition({x:n.x+i,y:n.y+r,height:n.height,width:n.width},i,r,t)},checkLabelPosition:function(n,t,i,r){var r=r||this.graphic.getBBox(),u=this.translator.getCanvasVisibleArea();r.isEmpty&&(r=this.getGraphicSettings()),u.minX<=r.x+r.width&&u.maxX>=r.x&&u.minY<=r.y+r.height&&u.maxY>=r.y&&(this.rotated||(u.minX>n.x&&this.adjustSeriesLabels&&(t+=u.minX-n.x),u.maxX<n.x+n.width&&this.adjustSeriesLabels&&(t-=n.x+n.width-u.maxX),u.minY>n.y&&(i+=u.minY-n.y),u.maxY<n.y+n.height&&(i-=n.y+n.height-u.maxY)),this.rotated&&(u.minX>n.x&&(t+=u.minX-n.x),u.maxX<n.x+n.width&&(t-=n.x+n.width-u.maxX),u.minY>n.y&&this.adjustSeriesLabels&&(i+=u.minY-n.y),u.maxY<n.y+n.height&&this.adjustSeriesLabels&&(i-=n.y+n.height-u.maxY))),this.insideLabelGroup.move(~~t,~~i)},animate:function(){var n=this,t=n.graphic;t&&n.translator&&(n.rotated?(t.applySettings({width:0,x:n.defaultX,sharpEdges:!1}),t.animate({width:n.width,x:n.x})):(t.applySettings({height:0,y:n.defaultY,sharpEdges:!1}),t.animate({height:n.height,y:n.y})))}})}(jQuery,DevExpress),function(n,t){var u=t.viz.charts.series,f=t.utils,r=u.consts.states,i=t.formatHelper;u.OhlcPoint=u.BasePoint.inherit({ctor:function(n){this.LABEL_BACKGROUND_PADDING_X=8,this.LABEL_BACKGROUND_PADDING_Y=4,this.LABEL_OFFSET=10,this.argument=this.initialArgument=n.argument,this.openValue=n.openValue,this.highValue=n.highValue,this.lowValue=n.lowValue,this.closeValue=n.closeValue,this.value=this.initialValue=n.reductionValue,this.originalOpenValue=n.originalOpenValue,this.originalCloseValue=n.originalCloseValue,this.originalLowValue=n.originalLowValue,this.originalHighValue=n.originalHighValue,this.originalArgument=n.originalArgument,this.tag=n.tag,this.options=n.options,this.options.attributes&&(this.options.attributes.inh=!1),this.series=n.series,this.rotated=!!(this.series&&this.series.options&&this.series.options.rotated||!1),this.labelFormatObject={openValue:this.openValue,highValue:this.highValue,lowValue:this.lowValue,closeValue:this.closeValue,reductionValue:this.initialValue,argument:this.initialArgument,value:this.initialValue,seriesName:this.options.seriesName,originalOpenValue:this.originalOpenValue,originalCloseValue:this.originalCloseValue,originalLowValue:this.originalLowValue,originalHighValue:this.originalHighValue,originalArgument:this.originalArgument},this.pointClassName=n.pointClassName||""},formatLabel:function(n){return this.openValueText=i.format(this.openValue,n.format,n.precision),this.highValueText=i.format(this.highValue,n.format,n.precision),this.lowValueText=i.format(this.lowValue,n.format,n.precision),this.closeValueText=i.format(this.closeValue,n.format,n.precision),this.reductionValueText=i.format(this.reductionValue,n.format,n.precision),this.valueText=i.format(this.value,n.format,n.precision),this.argumentText=i.format(this.argument,n.argumentFormat,n.argumentPrecision),n.customizeText?n.customizeText.call(this,this):this.valueText},translate:function(n){var t=this,u=t.rotated,f=u?"translateY":"translateX",i=u?"translateX":"translateY",r;(t.translator=n=n||t.translator,t.translator&&t.hasValue())&&(t.x=n[f](t.argument)+(t.xCorrection||0),t.openY=n[i](t.openValue),t.highY=n[i](t.highValue),t.lowY=n[i](t.lowValue),t.closeY=n[i](t.closeValue),r=Math.abs(t.lowY-t.highY),t.rotated?t._calculateVisibility(Math.min(t.lowY,t.highY),t.x-t.width/2,r,t.width):t._calculateVisibility(t.x-t.width/2,Math.min(t.lowY,t.highY),t.width,r))},correctCoordinates:function(n){var t=1+2*this.options.attributes.lineWidth,i=10;this.width=n.width<t?t:n.width>i?i:n.width,this.xCorrection=n.offset},drawMarker:function(n,t){if(this.hasValue()){var i=this,f,e=i.rotated,u=e?function(n,t){return{x:t,y:n}}:function(n,t){return{x:n,y:t}};switch(i.state){case r.selected:f=i.options.states.selected;break;case r.hover:f=i.options.states.hover;break;default:f=i.options.attributes,i.state=r.normal,i.fullState=r.normalMark}i.openValue>i.closeValue?i.graphic=n.createArea([u(i.x,i.highY),u(i.x,i.openY),u(i.x+i.width/2,i.openY),u(i.x+i.width/2,i.closeY),u(i.x,i.closeY),u(i.x,i.lowY),u(i.x,i.closeY),u(i.x-i.width/2,i.closeY),u(i.x-i.width/2,i.openY),u(i.x,i.openY)],f).append(t):i.openValue<i.closeValue?i.graphic=n.createArea([u(i.x,i.highY),u(i.x,i.closeY),u(i.x+i.width/2,i.closeY),u(i.x+i.width/2,i.openY),u(i.x,i.openY),u(i.x,i.lowY),u(i.x,i.openY),u(i.x-i.width/2,i.openY),u(i.x-i.width/2,i.closeY),u(i.x,i.closeY)],f).append(t):i.openValue===i.closeValue&&(i.graphic=n.createArea([u(i.x,i.highY),u(i.x,i.lowY),u(i.x,i.closeY),u(i.x-i.width/2,i.closeY),u(i.x+i.width/2,i.closeY),u(i.x,i.closeY)],f).append(t))}},drawTrackerMarker:function(n,t){if(this.hasValue()){var i=this,r=i.highY,u=i.lowY,e=i.rotated,f=Math,o,s,h,c;r===u&&(r=e?r+2:r-2,u=e?u-2:u+2),e?(o=f.min(u,r),s=i.x-i.width/2,h=f.abs(u-r),c=i.width):(o=i.x-i.width/2,s=f.min(u,r),h=i.width,c=f.abs(u-r)),i.trackerGraphic=n.createRect(o,s,h,c,0,i._trackerAttrs).append(t),i.trackerGraphic.data({point:i})}},animate:function(){},drawLabel:function(n,t){if(this.hasValue()&&f.isDefined(this.labelFormatObject.value)){var i=this.options.label,r=this.formatLabel.call(this.labelFormatObject,i),u=this.rotated;f.isDefined(r)&&(this.labelGroup=n.createGroup().append(t),this.insideLabelGroup=n.createGroup().append(this.labelGroup),i.background["class"]=this.pointClassName,(i.background.fill&&i.background.fill!=="none"||i.background.strokeWidth&&i.background.stroke&&i.background.stroke!=="none")&&(i.background.fill=this.options.attributes.stroke,this.labelBackground=u?n.createRect(this.highY,this.x,0,0,0,i.background).append(this.insideLabelGroup):n.createRect(this.x,this.highY,0,0,0,i.background).append(this.insideLabelGroup)),this.label=u?n.createText(r,this.highY,this.x,i.attributes).append(this.insideLabelGroup):n.createText(r,this.x,this.highY,i.attributes).append(this.insideLabelGroup),this.correctBackgroundPosition(),this.rotateLabel(),this.correctLabelPosition())}},correctLabelPosition:function(){var n=this.insideLabelGroup.getBBox(),r=this.graphic.getBBox(),u=this.rotated,t=0,i=0;u?t+=r.x-n.x+r.width+this.LABEL_OFFSET:i+=r.y-n.y-n.height-this.LABEL_OFFSET,t+=this.options.label.horizontalOffset,i+=this.options.label.verticalOffset,this.checkLabelPosition({x:n.x+t,y:n.y+i,height:n.height,width:n.width},t,i)},checkLabelPosition:function(n,t,i){var r=this.translator.getCanvasVisibleArea(),u=this.graphic.getBBox();r.minX<=u.x+u.width&&r.maxX>=u.x&&(r.minX>n.x&&this.adjustSeriesLabels&&(t+=r.minX-n.x),r.maxX<n.x+n.width&&this.adjustSeriesLabels&&(t-=n.x+n.width-r.maxX),r.minY>n.y&&(i+=r.minY-n.y),r.maxY<n.y+n.height&&(i-=n.y+n.height-r.maxY)),this.insideLabelGroup.move(~~t,~~i)},getTooltipCoords:function(){var u,f,n,i,t=Math,e=t.min(this.lowY,this.highY),o=t.max(this.lowY,this.highY),r=this.translator.getCanvasVisibleArea();if(this.graphic)return this.rotated?(n=t.max(r.minX,e),i=t.min(r.maxX,o),f=this.x,u=n+(i-n)/2):(n=t.max(r.minY,e),i=t.min(r.maxY,o),u=this.x,f=n+(i-n)/2),{x:u,y:f,offset:0}},getTooltipFormatObject:function(t){var i=t.formatValueTooltip.call({value:this.highValue},t.options),r=t.formatValueTooltip.call({value:this.openValue},t.options),u=t.formatValueTooltip.call({value:this.closeValue},t.options),f=t.formatValueTooltip.call({value:this.lowValue},t.options);return n.extend({},this.labelFormatObject,{valueText:"h: "+i+" o: "+r+" c: "+u+" l: "+f,highValueText:i,openValueText:r,closeValueText:u,lowValueText:f,point:this})},getColor:function(){return this.options.attributes.stroke},hasValue:function(){return this.openValue!==null&&this.closeValue!==null&&this.highValue!==null&&this.lowValue!==null}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series,r=i.consts.states,u=i.OhlcPoint;i.StockPoint=i.OhlcPoint.inherit({correctCoordinates:function(n){var t=2+this.options.attributes.lineWidth,i=10;this.width=n.width<t?t:n.width>i?i:n.width,this.xCorrection=n.offset},drawMarker:function(n,t){var i=this,f,e=i.rotated,u=e?function(n,t){return{x:t,y:n}}:function(n,t){return{x:n,y:t}};if(i.hasValue()){switch(i.state){case r.selected:f=i.options.states.selected;break;case r.hover:f=i.options.states.hover;break;default:f=i.options.attributes,i.state=r.normal,i.fullState=r.normalMark}i.graphic=n.createPath([u(i.x,i.highY),u(i.x,i.openY),u(i.x-i.width/2,i.openY),u(i.x,i.openY),u(i.x,i.closeY),u(i.x+i.width/2,i.closeY),u(i.x,i.closeY),u(i.x,i.lowY)],f).append(t)}}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series,r=t.utils,f=i.consts.events,u=i.consts.states;i.RangePoint=i.BasePoint.inherit({ctor:function(n){this.callBase(n),this.minValue=this.initialMinValue=n.minValue!==undefined?n.minValue:"default",this.originalMinValue=n.originalMinValue,this.minLabelFormatObject={argument:this.initialArgument,value:this.initialMinValue,seriesName:this.options.seriesName,originalMinValue:this.originalMinValue,originalArgument:this.originalArgument}},dispose:function(){var n=this;n.minLabel=null,n.minLabelBackground=null,n.minConnector=null,n.insideMinLabelGroup=null,n.minLabelGroup=null,n.maxLabel=null,n.maxLabelBackground=null,n.maxConnector=null,n.insideMaxLabelGroup=null,n.maxLabelGroup=null,n.topPoints=null,n.bottomPoints=null,n.minLabelFormatObject=null,n.callBase()},getTooltipCoords:function(){var u,f,i,r,n,t=this.translator.getCanvasVisibleArea();return this.rotated?(n=Math.min(this.x,this.minX),f=this.y,i=t.minX>n?t.minX:n,r=t.maxX<n+this.width?t.maxX:n+this.width,u=i+(r-i)/2):(n=Math.min(this.y,this.minY),u=this.x,i=t.minY>n?t.minY:n,r=t.maxY<n+this.height?t.maxY:n+this.height,f=i+(r-i)/2),{x:u,y:f,offset:0}},translate:function(n){this.minX=this.minY=n.translateY(this.minValue),this.callBase(n),this.rotated?(this.width=Math.abs(this.x-this.minX),this.height=0):(this.height=Math.abs(this.minY-this.y),this.width=0)},isInVisibleArea:function(){var t=Math.min(this.minX,this.x)||this.x,i=Math.max(this.minX,this.x)||this.x,r=Math.max(this.minY,this.y)||this.y,u=Math.min(this.minY,this.y)||this.y,s,h,c,l,f=!0,e=!0,o=!0,n;return this.translator&&this.translator.getCanvasVisibleArea&&(n=this.translator.getCanvasVisibleArea(),s=n.maxX<t&&n.maxX<i,h=n.minX>t&&n.minX>i,l=n.minY>u&&n.minY>r,c=n.maxY<u&&n.maxY<r,l||c||s||h?f=e=o=!1:this.rotated?(e=n.minX<t&&n.maxX>t,f=n.minX<i&&n.maxX>i):(f=n.minY<u&&n.maxY>u,e=n.minY<r&&n.maxY>r)),this.visibleTopMarker=f,this.visibleBottomMarker=e,this.visibleRangeArea=o,o},drawMarker:function(n,t){if(this.hasValue()){var s=this.options.attributes.r,e,r,f,o,i=n.createGroup().append(t);switch(this.options.symbol){case"circle":this.rotated?(r=Math.min(this.x,this.minX),f=this.y):(r=this.x,f=Math.min(this.y,this.minY)),e=this.visibleTopMarker?n.createCircle(r+this.width,f,s,this.options.attributes).append(i):null,o=this.visibleBottomMarker?n.createCircle(r,f+this.height,s,this.options.attributes).append(i):null;break;case"square":case"polygon":case"triangle":case"cross":e=this.visibleTopMarker?n.createArea(this.topPoints,this.options.attributes).append(i):null,o=this.visibleBottomMarker?n.createArea(this.bottomPoints,this.options.attributes).append(i):null}this.graphic=i,this.graphic.topMarker=e,this.graphic.bottomMarker=o;switch(this.state){case u.selected:this.series.setPointSelectedState(this);break;case u.hover:this.series.setPointHoverState(this);break;default:this.state=u.normal,this.fullState=u.normalMark}}},_populatePointShape:function(n,t){var o=this,e,s,i,r,u,f;this.rotated?(i=Math.max(o.x,o.minX),u=Math.min(o.x,o.minX),r=f=o.y):(i=u=o.x,r=Math.min(o.y,o.minY),f=Math.max(o.y,o.minY)),o.options.symbol==="square"&&(n.topPoints=[{x:i-t,y:r-t},{x:i+t,y:r-t},{x:i+t,y:r+t},{x:i-t,y:r+t},{x:i-t,y:r-t}],n.bottomPoints=[{x:u-t,y:f-t},{x:u+t,y:f-t},{x:u+t,y:f+t},{x:u-t,y:f+t},{x:u-t,y:f-t}]),o.options.symbol==="polygon"&&(n.topPoints=[{x:i-t,y:r},{x:i,y:r-t},{x:i+t,y:r},{x:i,y:r+t},{x:i-t,y:r}],n.bottomPoints=[{x:u-t,y:f},{x:u,y:f-t},{x:u+t,y:f},{x:u,y:f+t},{x:u-t,y:f}]),o.options.symbol==="triangle"&&(n.topPoints=[{x:i-t,y:r-t},{x:i+t,y:r-t},{x:i,y:r+t},{x:i-t,y:r-t}],n.bottomPoints=[{x:u-t,y:f-t},{x:u+t,y:f-t},{x:u,y:f+t},{x:u-t,y:f-t}]),o.options.symbol==="cross"&&(e=Math.floor(t/2),s=Math.ceil(t/2),n.topPoints=[{x:i-t,y:r-e},{x:i-e,y:r-t},{x:i,y:r-s},{x:i+e,y:r-t},{x:i+t,y:r-e},{x:i+s,y:r},{x:i+t,y:r+e},{x:i+e,y:r+t},{x:i,y:r+s},{x:i-e,y:r+t},{x:i-t,y:r+e},{x:i-s,y:r}],n.bottomPoints=[{x:u-t,y:f-e},{x:u-e,y:f-t},{x:u,y:f-s},{x:u+e,y:f-t},{x:u+t,y:f-e},{x:u+s,y:f},{x:u+t,y:f+e},{x:u+e,y:f+t},{x:u,y:f+s},{x:u-e,y:f+t},{x:u-t,y:f+e},{x:u-s,y:f}])},drawTrackerMarker:function(n,t){if(this.hasValue()){var i=this,e=i.options,r=e.trackerR||i.storeTrackerR(),u,f;i.rotated?(u=Math.min(i.x,i.minX)-r,f=i.y-r):(u=i.x-r,f=Math.min(i.y,i.minY)-r),i.trackerGraphic=n.createRect(u,f,i.width+2*r,i.height+2*r,0,i._trackerAttrs).append(t),i.trackerGraphic.data({point:i})}},applyStyle:function(n){this.graphic&&(this._populatePointShape(n,n.r),this.graphic.topMarker&&this.graphic.topMarker.applySettings(n.topPoints?{points:n.topPoints,style:n}:n),this.graphic.bottomMarker&&this.graphic.bottomMarker.applySettings(n.bottomPoints?{points:n.bottomPoints,style:n}:n))},applyNormalStyle:function(){return this.applyStyle(this.options.states.normal),this.callBase()},applyHoverStyle:function(){return this.applyStyle(this.options.states.hover),this.callBase()},applySelectionStyle:function(){return this.applyStyle(this.options.states.selected),this.callBase()},drawLabel:function(n,t){if(this.hasValue()&&r.isDefined(this.labelFormatObject.value)&&r.isDefined(this.minLabelFormatObject.value)){var i=this.options.label,f=this.formatLabel.call(this.labelFormatObject,i),e=this.formatLabel.call(this.minLabelFormatObject,i),u=this.translator.getBusinessRange(),o=this.series.options.valueAxisType==="discrete",s=o&&(!u.invertY&&!this.rotated||u.invertX&&this.rotated)||!o&&this.value>this.minValue&&(!u.invertY&&!this.rotated||!u.invertX&&this.rotated);r.isDefined(f)&&r.isDefined(e)&&(this.labelGroup=n.createGroup().append(t),this.options.label.connector&&this.options.label.connector.strokeWidth&&(this.visibleTopMarker&&(this.maxConnector=n.createLine(0,0,0,0,this.options.label.connector).append(this.labelGroup)),this.visibleBottomMarker&&(this.minConnector=n.createLine(0,0,0,0,this.options.label.connector).append(this.labelGroup))),this.maxLabelGroup=n.createGroup().append(this.labelGroup),this.insideMaxLabelGroup=n.createGroup().append(this.maxLabelGroup),this.minLabelGroup=n.createGroup().append(this.labelGroup),this.insideMinLabelGroup=n.createGroup().append(this.minLabelGroup),(i.background.fill&&i.background.fill!=="none"||i.background.strokeWidth&&i.background.stroke&&i.background.stroke!=="none")&&(this.maxLabelBackground=n.createRect(this.x,this.y,0,0,0,i.background).append(this.insideMaxLabelGroup),this.minLabelBackground=n.createRect(this.x,this.y,0,0,0,i.background).append(this.insideMinLabelGroup)),this.maxLabel=n.createText(s?f:e,this.x,this.y,i.attributes).append(this.insideMaxLabelGroup),this.minLabel=n.createText(s?e:f,this.x,this.y,i.attributes).append(this.insideMinLabelGroup),this.correctLabel(),this.correctConnectorPosition(this.maxLabelGroup.getBBox(),this.maxConnector),this.correctConnectorPosition(this.minLabelGroup.getBBox(),this.minConnector))}},rotateLabel:function(){var n=this.insideMaxLabelGroup.getBBox(),t=this.insideMinLabelGroup.getBBox(),i=this.options.label;this.insideMaxLabelGroup.applySettings({x:n.x+n.width/2,y:n.y+n.height/2,rotate:i.rotationAngle}),this.insideMinLabelGroup.applySettings({x:t.x+t.width/2,y:t.y+t.height/2,rotate:i.rotationAngle})},correctLabelPosition:function(){var n=this.insideMaxLabelGroup.getBBox(),i=this.insideMinLabelGroup.getBBox(),t=this.graphic&&this.graphic.topMarker?this.graphic.topMarker.getBBox():{x:this.rotated?Math.max(this.x,this.minX):this.x,y:this.rotated?this.y:Math.min(this.y,this.minY),height:0,width:0},r=this.graphic&&this.graphic.bottomMarker?this.graphic.bottomMarker.getBBox():{x:this.rotated?Math.min(this.x,this.minX):this.x,y:this.rotated?this.y:Math.max(this.y,this.minY),height:0,width:0},e=0,u=0,o=0,f=0;this.options.label.position==="outside"?this.rotated?(u=f+=t.y-n.y-n.height/2+t.height/2,e+=t.x+t.width-n.x+this.LABEL_OFFSET,o+=r.x-i.x-i.width-this.LABEL_OFFSET):(u+=t.y-n.y-n.height-this.LABEL_OFFSET,f+=r.y+r.height-i.y+this.LABEL_OFFSET):this.options.label.position==="inside"&&(this.rotated?(u=f+=t.y-n.y-n.height/2+t.height/2,e+=t.x-n.x-n.width-this.LABEL_OFFSET,o+=r.x+r.width-i.x+this.LABEL_OFFSET):(u+=t.y+t.height-n.y+this.LABEL_OFFSET,f+=r.y-i.y-i.height-this.LABEL_OFFSET)),e+=this.options.label.horizontalOffset,u+=this.options.label.verticalOffset,o+=this.options.label.horizontalOffset,f+=this.options.label.verticalOffset,this.checkLabelPosition(e,u,o,f)},checkLabelPosition:function(n,t,i,r){var f=this.insideMaxLabelGroup.getBBox(),e=this.insideMinLabelGroup.getBBox(),o={},s={},v=this.graphic&&this.graphic.topMarker?this.graphic.topMarker.getBBox():{x:this.rotated?Math.max(this.x,this.minX):this.x,y:this.rotated?this.y:Math.min(this.y,this.minY),height:0,width:0},y=this.graphic&&this.graphic.bottomMarker?this.graphic.bottomMarker.getBBox():{x:this.rotated?Math.min(this.x,this.minX):this.x,y:this.rotated?this.y:Math.max(this.y,this.minY),height:0,width:0},h=f.x+n,c=f.y+t,l=e.x+i,a=e.y+r,u=this.translator.getCanvasVisibleArea();this.visibleRangeArea&&(this.rotated||(u.minX>h&&this.adjustSeriesLabels&&(n+=u.minX-h),u.minX>l&&this.adjustSeriesLabels&&(i+=u.minX-l),u.maxX<h+f.width&&this.adjustSeriesLabels&&(n-=h+f.width-u.maxX),u.maxX<l+e.width&&this.adjustSeriesLabels&&(i-=l+e.width-u.maxX),u.minY>c&&(t+=u.minY-c),u.maxY<a+e.height&&(r-=a+e.height-u.maxY),o.y=f.y+t,s.y=e.y+r,o.y+f.height>s.y&&(t-=(o.y+f.height-s.y)/2,r+=(o.y+f.height-s.y)/2,o.y=f.y+t,s.y=e.y+r,u.minY>o.y?(r+=u.minY-o.y,t+=u.minY-o.y):u.maxY<s.y+e.height&&(t-=s.y+e.height-u.maxY,r-=s.y+e.height-u.maxY))),this.rotated&&(u.minX>l&&(i+=u.minX-l),u.maxX<h+f.width&&(n-=h+f.width-u.maxX),u.minY>a&&this.adjustSeriesLabels&&(r+=u.minY-a),u.minY>c&&this.adjustSeriesLabels&&(t+=u.minY-c),u.maxY<a+e.height&&this.adjustSeriesLabels&&(r-=a+e.height-u.maxY),u.maxY<c+f.height&&this.adjustSeriesLabels&&(t-=c+f.height-u.maxY),o.x=f.x+n,s.x=e.x+i,o.x<s.x+e.width&&(n+=(s.x+e.width-o.x)/2,i-=(s.x+e.width-o.x)/2,o.x=f.x+n,s.x=e.x+i,u.minX>s.x?(i+=u.minX-s.x,n+=u.minX-s.x):u.maxX<o.x+f.width&&(n-=o.x+f.width-u.maxX,i-=o.x+f.width-u.maxX)))),this.insideMaxLabelGroup.move(~~n,~~t),this.insideMinLabelGroup.move(~~i,~~r)},correctBackgroundPosition:function(){if(this.maxLabelBackground&&this.minLabelBackground){var n=this.maxLabel.getBBox(),t=this.minLabel.getBBox(),i=n.x-this.LABEL_BACKGROUND_PADDING_X,r=t.x-this.LABEL_BACKGROUND_PADDING_X,u=n.y-this.LABEL_BACKGROUND_PADDING_Y,f=t.y-this.LABEL_BACKGROUND_PADDING_Y,e=n.width+2*this.LABEL_BACKGROUND_PADDING_X,o=t.width+2*this.LABEL_BACKGROUND_PADDING_X,s=n.height+2*this.LABEL_BACKGROUND_PADDING_Y,h=t.height+2*this.LABEL_BACKGROUND_PADDING_Y;this.maxLabelBackground.applySettings({x:i,y:u,width:e,height:s}),this.minLabelBackground.applySettings({x:r,y:f,width:o,height:h})}},correctConnectorPosition:function(n,t){if(t){var i=this.graphic?this.graphic.getBBox():{x:this.rotated?Math.min(this.x,this.minX):this.x,y:this.rotated?this.y:Math.min(this.y,this.minY),height:this.height,width:this.width},o=this.maxLabelBackground||this.minLabelBackground?n.y+n.height/2:null,s=this.maxLabelBackground||this.minLabelBackground?n.x+n.width/2:null,r,f,u,e;if(this.rotated){if((s||n.x)>i.x+i.width)r=s||n.x,f=i.x+i.width;else if((s||n.x+n.width)<i.x)r=s||n.x+n.width,f=i.x;else return!1;u=Math.round(n.y+n.height/2),e=u>i.y+i.height?i.y+i.height:u<i.y?i.y:u}else{if((o||n.y+n.height)<i.y)u=o||n.y+n.height,e=i.y;else if((o||n.y)>i.y+i.height)u=o||n.y,e=i.y+i.height;else return!1;r=Math.round(n.x+n.width/2),f=r>i.x+i.width?i.x+i.width:r<i.x?i.x:r}t.applySettings({points:[r,u,f,e]})}},getTooltipFormatObject:function(n){var t=n.formatValueTooltip.call({value:this.initialMinValue},n.options),i=n.formatValueTooltip.call({value:this.initialValue},n.options);return{argument:this.initialArgument,valueText:t+" - "+i,rangeValue1Text:t,rangeValue2Text:i,rangeValue1:this.initialMinValue,rangeValue2:this.initialValue,seriesName:this.options.seriesName,point:this,originalMinValue:this.originalMinValue,originalValue:this.originalValue,originalArgument:this.originalArgument}},animate:function(){var n=this,t=n.graphic;t&&n.translator&&(n.rotated?(t.topMarker&&t.topMarker.move(n.defaultX-Math.max(n.minX,n.x),0),t.bottomMarker&&t.bottomMarker.move(n.defaultX-Math.min(n.minX,n.x),0)):(t.topMarker&&t.topMarker.move(0,n.defaultY-Math.min(n.minY,n.y)),t.bottomMarker&&t.bottomMarker.move(0,n.defaultY-Math.max(n.minY,n.y))),t.topMarker&&t.topMarker.move(0,0,!0),t.bottomMarker&&t.bottomMarker.move(0,0,!0))},hasValue:function(){return this.initialValue!==null&&this.initialMinValue!==null}})}(jQuery,DevExpress),function(n,t){var r=t.viz.charts.series,u=r.BarPoint,i=t.utils;r.RangeBarPoint=r.BarPoint.inherit({ctor:function(n){this.callBase(n),this.minValue=this.initialMinValue=n.minValue!==undefined?n.minValue:"default",this.originalMinValue=n.originalMinValue,this.minLabelFormatObject={argument:this.initialArgument,value:this.initialMinValue,seriesName:this.options.seriesName,originalMinValue:this.originalMinValue,originalArgument:this.originalArgument}},dispose:function(){var n=this;n.minLabel=null,n.minLabelBackground=null,n.minConnector=null,n.insideMinLabelGroup=null,n.minLabelGroup=null,n.maxLabel=null,n.maxLabelBackground=null,n.maxConnector=null,n.insideMaxLabelGroup=null,n.maxLabelGroup=null,n.minLabelFormatObject=null,n.callBase()},translate:function(n){this.hasValue()&&(this.callBase(n),this.rotated?this.width=this.width||1:this.height=this.height||1)},drawLabel:function(n,t){if(this.hasValue()||i.isDefined(this.labelFormatObject.value)&&i.isDefined(this.minLabelFormatObject.value)){var r=this.options.label,f=this.formatLabel.call(this.labelFormatObject,r),e=this.formatLabel.call(this.minLabelFormatObject,r),u=this.translator.getBusinessRange(),o=this.series.options.valueAxisType==="discrete",s=o&&(!u.invertY&&!this.rotated||u.invertX&&this.rotated)||!o&&this.value>this.minValue&&(!u.invertY&&!this.rotated||!u.invertX&&this.rotated);i.isDefined(f)&&i.isDefined(e)&&(this.labelGroup=n.createGroup().append(t),this.options.label.connector&&this.options.label.connector.strokeWidth&&(this.maxConnector=n.createLine(0,0,0,0,this.options.label.connector).append(this.labelGroup),this.minConnector=n.createLine(0,0,0,0,this.options.label.connector).append(this.labelGroup)),this.maxLabelGroup=n.createGroup().append(this.labelGroup),this.insideMaxLabelGroup=n.createGroup().append(this.maxLabelGroup),this.minLabelGroup=n.createGroup().append(this.labelGroup),this.insideMinLabelGroup=n.createGroup().append(this.minLabelGroup),(r.background.fill&&r.background.fill!=="none"||r.background.strokeWidth&&r.background.stroke&&r.background.stroke!=="none")&&(this.maxLabelBackground=n.createRect(this.x,this.y,0,0,0,r.background).append(this.insideMaxLabelGroup),this.minLabelBackground=n.createRect(this.x,this.y,0,0,0,r.background).append(this.insideMinLabelGroup)),this.maxLabel=n.createText(s?f:e,this.x,this.y,r.attributes).append(this.insideMaxLabelGroup),this.minLabel=n.createText(s?e:f,this.x,this.y,r.attributes).append(this.insideMinLabelGroup),this.correctLabel(),this.correctConnectorPosition(this.maxLabelGroup.getBBox(),this.maxConnector),this.correctConnectorPosition(this.minLabelGroup.getBBox(),this.minConnector))}},rotateLabel:function(){var n=this.insideMaxLabelGroup.getBBox(),t=this.insideMinLabelGroup.getBBox(),i=this.options.label;this.insideMaxLabelGroup.applySettings({x:n.x+n.width/2,y:n.y+n.height/2,rotate:i.rotationAngle}),this.insideMinLabelGroup.applySettings({x:t.x+t.width/2,y:t.y+t.height/2,rotate:i.rotationAngle})},correctLabelPosition:function(){var t=this.insideMaxLabelGroup.getBBox(),i=this.insideMinLabelGroup.getBBox(),n=this.graphic.getBBox(),r=0,u=0,f=0,e=0;n.isEmpty&&(n=this.getGraphicSettings()),this.options.label.position==="outside"?this.rotated?(u=e+=n.y-t.y-t.height/2+n.height/2,r+=n.x+n.width-t.x+this.LABEL_OFFSET,f+=n.x-i.x-i.width-this.LABEL_OFFSET):(r=f+=n.width/2,u+=n.y-t.y-t.height-this.LABEL_OFFSET,e+=n.y+n.height-i.y+this.LABEL_OFFSET):this.options.label.position==="inside"&&(this.rotated?(u=e+=n.y-t.y-t.height/2+n.height/2,r+=n.x+n.width-t.x-t.width-this.LABEL_OFFSET,f+=n.x-i.x+this.LABEL_OFFSET):(r=f+=n.width/2,u+=n.y-t.y+this.LABEL_OFFSET,e+=n.y+n.height-i.y-i.height-this.LABEL_OFFSET)),r+=this.options.label.horizontalOffset,u+=this.options.label.verticalOffset,f+=this.options.label.horizontalOffset,e+=this.options.label.verticalOffset,this.checkLabelPosition(r,u,f,e)},checkLabelPosition:function(n,t,i,r){var f=this.insideMaxLabelGroup.getBBox(),e=this.insideMinLabelGroup.getBBox(),o={},s={},h=this.graphic.getBBox(),c=f.x+n,l=f.y+t,a=e.x+i,v=e.y+r,u=this.translator.getCanvasVisibleArea();u.minX<=h.x+h.width&&u.maxX>=h.x&&u.minY<=h.y+h.height&&u.maxY>=h.y&&(this.rotated||(u.minX>c&&this.adjustSeriesLabels&&(n+=u.minX-c),u.minX>a&&this.adjustSeriesLabels&&(i+=u.minX-a),u.maxX<c+f.width&&this.adjustSeriesLabels&&(n-=c+f.width-u.maxX),u.maxX<a+e.width&&this.adjustSeriesLabels&&(i-=a+e.width-u.maxX),u.minY>l&&(t+=u.minY-l),u.maxY<v+e.height&&(r-=v+e.height-u.maxY),o.y=f.y+t,s.y=e.y+r,o.y+f.height>s.y&&(t-=(o.y+f.height-s.y)/2,r+=(o.y+f.height-s.y)/2,o.y=f.y+t,s.y=e.y+r,u.minY>o.y?(r+=u.minY-o.y,t+=u.minY-o.y):u.maxY<s.y+e.height&&(t-=s.y+e.height-u.maxY,r-=s.y+e.height-u.maxY))),this.rotated&&(u.minX>a&&(i+=u.minX-a),u.maxX<c+f.width&&(n-=c+f.width-u.maxX),u.minY>v&&this.adjustSeriesLabels&&(r+=u.minY-v),u.minY>l&&this.adjustSeriesLabels&&(t+=u.minY-l),u.maxY<v+e.height&&this.adjustSeriesLabels&&(r-=v+e.height-u.maxY),u.maxY<l+f.height&&this.adjustSeriesLabels&&(t-=l+f.height-u.maxY),o.x=f.x+n,s.x=e.x+i,o.x<s.x+e.width&&(n+=(s.x+e.width-o.x)/2,i-=(s.x+e.width-o.x)/2,o.x=f.x+n,s.x=e.x+i,u.minX>s.x?(i+=u.minX-s.x,n+=u.minX-s.x):u.maxX<o.x+f.width&&(n-=o.x+f.width-u.maxX,i-=o.x+f.width-u.maxX)))),this.insideMaxLabelGroup.move(~~n,~~t),this.insideMinLabelGroup.move(~~i,~~r)},correctBackgroundPosition:function(){if(this.maxLabelBackground&&this.minLabelBackground){var n=this.maxLabel.getBBox(),t=this.minLabel.getBBox(),i=n.x-this.LABEL_BACKGROUND_PADDING_X,r=t.x-this.LABEL_BACKGROUND_PADDING_X,u=n.y-this.LABEL_BACKGROUND_PADDING_Y,f=t.y-this.LABEL_BACKGROUND_PADDING_Y,e=n.width+2*this.LABEL_BACKGROUND_PADDING_X,o=t.width+2*this.LABEL_BACKGROUND_PADDING_X,s=n.height+2*this.LABEL_BACKGROUND_PADDING_Y,h=t.height+2*this.LABEL_BACKGROUND_PADDING_Y;this.maxLabelBackground.applySettings({x:i,y:u,width:e,height:s}),this.minLabelBackground.applySettings({x:r,y:f,width:o,height:h})}},correctConnectorPosition:function(n,t){if(t){var i=this.graphic.getBBox(),r,f,u,e,o=this.maxLabelBackground||this.minLabelBackground?n.y+n.height/2:null,s=this.maxLabelBackground||this.minLabelBackground?n.x+n.width/2:null;if(i.isEmpty&&(i=this.getGraphicSettings()),this.rotated){if((s||n.x)>i.x+i.width)r=s||n.x,f=i.x+i.width;else if((s||n.x+n.width)<i.x)r=s||n.x+n.width,f=i.x;else return!1;u=Math.round(n.y+n.height/2),e=u>i.y+i.height?i.y+i.height:u<i.y?i.y:u}else{if((o||n.y+n.height)<i.y)u=o||n.y+n.height,e=i.y;else if((o||n.y)>i.y+i.height)u=o||n.y,e=i.y+i.height;else return!1;r=Math.round(n.x+n.width/2),f=r>i.x+i.width?i.x+i.width:r<i.x?i.x:r}t.applySettings({points:[r,u,f,e]})}},getTooltipFormatObject:function(n){var t=n.formatValueTooltip.call({value:this.initialMinValue},n.options),i=n.formatValueTooltip.call({value:this.initialValue},n.options);return{argument:this.initialArgument,valueText:t+" - "+i,rangeValue1Text:t,rangeValue2Text:i,rangeValue1:this.initialMinValue,rangeValue2:this.initialValue,seriesName:this.options.seriesName,point:this,originalMinValue:this.originalMinValue,originalValue:this.originalValue,originalArgument:this.originalArgument}},hasValue:function(){return this.initialValue!==null&&this.initialMinValue!==null}})}(jQuery,DevExpress),function(n,t){var f=t.viz.charts.series,u=f.consts.states,i=Math.round,r=t.utils.getCosAndSin;f.PiePoint=f.BasePoint.inherit({ctor:function(t){this.centerX=300,this.centerY=150,this.radiusOuter=120,this.radiusInner=0,this.INDENT_FROM_PIE=30,this.CONNECTOR_LENGTH=20,this.setLabelEllipsis=!1,this.callBase(t),this.minValue=0,this.tag=t.tag,this._pieTrackerAttrs=n.extend({},this._trackerAttrs,{inh:!1,fill:"grey"})},translate:function(n){var t=this;(t.translator=n=n||t.translator,t.translator)&&(t.fromAngle=n.translate(t.minValue),t.toAngle=n.translate(t.value),t.middleAngle=n.translate((t.value-t.minValue)/2+t.minValue))},correctValue:function(n,t){var i=this;i.value+=n,i.minValue+=n,i.percent=t,i.labelFormatObject.percent=t},getTooltipCoords:function(){var n=r(this.middleAngle);return{x:this.centerX+(this.radiusInner+(this.radiusOuter-this.radiusInner)/2)*n.cos,y:this.centerY-(this.radiusInner+(this.radiusOuter-this.radiusInner)/2)*n.sin,offset:0}},correctPosition:function(n){var t=this;t.radiusInner=n.radiusInner,t.radiusOuter=n.radiusOuter,t.centerX=n.centerX,t.centerY=n.centerY},drawMarker:function(n,t){this.options.attributes.inh=!1,this.graphic=n.createArc(this.centerX,this.centerY,this.radiusOuter,this.radiusInner,this.toAngle,this.fromAngle,this.options.attributes).append(t);switch(this.state){case u.selected:this.series.setPointSelectedState(this);break;case u.hover:this.series.setPointHoverState(this);break;default:this.state=u.normal,this.fullState=u.normalMark}},drawTrackerMarker:function(n,t){this.trackerGraphic=n.createArc(this.centerX,this.centerY,this.radiusOuter,this.radiusInner,this.toAngle,this.fromAngle,this._pieTrackerAttrs).append(t),this.trackerGraphic.data({point:this})},correctLabel:function(){this.correctLabelPosition(),this.checkEllipsis(),this.correctBackgroundPosition(),this.rotateLabel(),this.checkLabelPosition()},correctLabelPosition:function(){var e=this.label.getBBox(),o=this.options.label,n=r(this.middleAngle),u="center",t=this.radiusOuter+o.radialOffset,f,s;switch(o.position){case"outside":t+=this.INDENT_FROM_PIE,n.cos>.1?u="left":n.cos<-.1&&(u="right"),f=this.centerX+t*n.cos;break;case"inside":t-=this.INDENT_FROM_PIE,f=this.centerX+t*n.cos;break;case"columns":t+=this.CONNECTOR_LENGTH,n.cos>0?(u="right",f=this.series.canvas.width-this.series.canvas.right):n.cos<0&&(u="left",f=this.series.canvas.left)}s=i(this.label.settings.y+this.centerY-t*n.sin-e.y-e.height/2),this.label.applySettings({x:f,y:s,align:u})},correctConnectorPosition:function(){if(this.options.label.position!=="inside"&&this.connector){var t=r(i(this.middleAngle)),s=this.series.styles.attributes,c=this.series.userOptions.containerBackgroundColor===s.stroke?~~(s.strokeWidth/2):~~(-s.strokeWidth/2),f=this.radiusOuter,l=i(this.centerX+(f-c)*t.cos),a=i(this.centerY-(f-c)*t.sin),h,u,e,v,n,o=this.options.label,y;h=i(this.centerX+(f+o.radialOffset+this.CONNECTOR_LENGTH)*t.cos),o.position==="outside"&&(u=i(this.centerY-(f+o.radialOffset+this.CONNECTOR_LENGTH)*t.sin),this.connector.applySettings({points:[l,a,h,u]})),o.position==="columns"&&(n=this.insideLabelGroup.getBBox(),n.x=n.x+(this.insideLabelGroup.settings.translateX||0),n.y=n.y+(this.insideLabelGroup.settings.translateY||0),u=n.y+n.height/2,this.labelBackground?e=n.x+n.width/2:t.cos<0?e=n.x+n.width:t.cos>0&&(e=n.x),v=u,this.connector.applySettings({points:[{x:l,y:a},{x:h,y:u},{x:e,y:v}]}))}},rotateLabel:function(){var t=this.options.label,f=this.radiusOuter+t.radialOffset,e=r(this.middleAngle),i,u,n=this.insideLabelGroup.getBBox();switch(t.position){case"outside":i=this.centerX+(f+t.radialOffset+this.CONNECTOR_LENGTH)*e.cos,u=this.centerY-(f+t.radialOffset+this.CONNECTOR_LENGTH)*e.sin;break;case"inside":i=n.x+n.width/2,u=n.y+n.height/2;break;case"columns":i=n.x+n.width/2,u=n.y+n.height/2}this.insideLabelGroup.applySettings({x:i,y:u,rotate:t.rotationAngle})},checkEllipsis:function(){var i=this,c,s=10,t,a,b=0,v=[],k=[],d,o,y,f,l,e,h=r(i.options.label.rotationAngle),u=i.series.canvas,g=this.options.label,p=r(this.middleAngle),w=this.centerX+(this.radiusOuter+this.CONNECTOR_LENGTH)*p.cos;if(i.label.tspans&&i.setLabelEllipsis){if(t=i.label.getBBox(),f=t.x+t.width<i.centerX?t.x+t.width:t.x,l=t.y+t.height/2,e=t.x+t.width<i.centerX?-t.width:t.width,l+e*h.sin>u.height-u.bottom+s||l+e*h.sin<u.top-s||f+e*h.cos<u.left-s||f+e*h.cos>u.width-u.right+s||g.position==="columns"&&(p.cos<0&&w<f||p.cos>0&&w>f))for(c=0;c<i.label.tspans.length;c++)b+=i.label.tspans[c].element.getNumberOfChars(),(!i.label.tspans[c+1]||i.label.tspans[c+1].settings.dy>0)&&(v.push(b),k.push(c),b=0);while(l+e*h.sin>u.height-u.bottom+s||l+e*h.sin<u.top-s||f+e*h.cos<u.left-s||f+e*h.cos>u.width-u.right+s||g.position==="columns"&&(p.cos<0&&w<f||p.cos>0&&w>f)){if(d=Math.max.apply(null,v),d===0)break;y=n.inArray(d,v),o=k[y],i.label.tspans[o].element.textContent==="..."?i.label.tspans[o].settings.dy>0||!i.label.tspans[o-1]?v[y]=0:i.label.tspans[o-1]&&(i.label.tspans[o].element.textContent="",k[y]-=1,i.label.tspans[o-1].element.textContent+="..."):(a=i.label.tspans[o].element.textContent,a=a.substr(0,a.length-4)+"...",i.label.tspans[o].element.textContent=a,v[y]-=1),t=i.label.getBBox(),f=t.x+t.width<i.centerX?t.x+t.width:t.x,l=t.y+t.height/2,e=t.x+t.width<i.centerX?-t.width:t.width}}},checkLabelPosition:function(){var i=this,n=i.insideLabelGroup.getBBox(),t=i.series.canvas;n.y+n.height>t.height-t.bottom?i.insideLabelGroup.move(0,t.height-n.y-n.height-t.bottom):n.y<t.top&&i.insideLabelGroup.move(0,t.top-n.y),n.x+n.width>t.width-t.right?i.insideLabelGroup.move(t.width-t.right-n.x-n.width,0):n.x<t.left&&i.insideLabelGroup.move(t.left-n.x,0)},animate:function(){},isInVisibleArea:function(){return!0}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.pointFactory={createPoint:function(n,t){n=(n||"").toLowerCase();switch(n){case"line":return new i.BasePoint(t);case"stackedline":return new i.BasePoint(t);case"fullstackedline":return new i.BasePoint(t);case"area":return new i.BasePoint(t);case"stackedarea":return new i.BasePoint(t);case"fullstackedarea":return new i.BasePoint(t);case"bar":return new i.BarPoint(t);case"stackedbar":return new i.BarPoint(t);case"fullstackedbar":return new i.BarPoint(t);case"spline":return new i.BasePoint(t);case"splinearea":return new i.BasePoint(t);case"scatter":return new i.BasePoint(t);case"candlestick":return new i.OhlcPoint(t);case"stock":return new i.StockPoint(t);case"rangearea":return new i.RangePoint(t);case"rangesplinearea":return new i.RangePoint(t);case"rangebar":return new i.RangeBarPoint(t);case"pie":return new i.PiePoint(t);case"doughnut":return new i.PiePoint(t);case"stepline":return new i.BasePoint(t);case"steparea":return new i.BasePoint(t);default:return null}}}}(jQuery,DevExpress),function(n,t){var o=t.viz.charts.series,e=o.consts.events,i=o.consts.states,r=t.utils,v=t.viz.core.ParseUtils,s=20,h=15,c=.3,f="allseriespoints",u="includepoints",l=0,a=1,y=20;o.BaseSeries=t.Class.inherit({ctor:function(t,i,r,u){this.type=r.specificType||"unknown",this.isRangeSeries=u,this.renderer=t,this._rawData=i||[],this._parseOptions(r),this._parsedUserOptions=n.extend(!0,{},r),this._parseInputData(this._rawData),this.userOptions=r,this.tag=r.tag},dispose:function(){var t=this;t.off(),n.each(t.points||[],function(n,t){t.dispose()}),t.points=null,n.each(t.trackerElements||[],function(n,t){t.removeData()}),t.trackerElements=null,t.hoverPattern=null,t.selectedPattern=null,t.seriesGroup=null,t.pointsByArgument=null,t.segments=null,t.preparedSegments=null,t.renderer=null,t._rawData=null,t._parsedUserOptions=null,t.options=null,t.userOptions=null,t.tag=null,t._validationResult=null,t.rangeData=null,t.translator=null,t.styles=null,t._parseUtils=null},_checkValue:function(n){if(!r.isDefined(n.value))return this._validationResult.error=this._errorMessages.missingFieldMessage(n.field),this.options.incidentOccured.call(null,this._errorMessages.missingFieldMessage(n.field)),!1;if(r.isString(n.value))n.axisType="discrete",n.type="string";else if(r.isDate(n.value))n.axisType=n.axisType||"continuous",n.type="datetime";else if(r.isNumber(n.value))n.axisType=n.axisType||"continuous",n.type="numeric";else return this._validationResult.error=this._errorMessages.unsupportedFieldMessage(n.field),this.options.incidentOccured.call(null,this._errorMessages.unsupportedFieldMessage(n.field)),!1;return!0},_correctAxisType:function(n,t){return n&&(n==="discrete"||n==="continuous")?n:t&&t.length?"discrete":""},reinitData:function(n){this._parseInputData(n)},_errorMessages:{missingFieldMessage:function(n){return"Data source does not contain the '"+n+"' field."},unsupportedFieldMessage:function(n){return"The '"+n+"' field contains data of unsupported type."},incorrectDataMessage:function(){return"Data source contains unsupported data."},incompatibleTypesDataMessage:function(n){return n==="argument"?"The agrument type and argument axis type are incompatible.":"The value type and value axis type are incompatible."},dataItemMissingMessage:function(n){return n==="argument"?"An argument is missed in the specified data.":"A value is missed in the specified data."},numericParsingMessage:function(n){return"A point's "+n+" cannot be parsed to a correct numeric value."},dateParsingMessage:function(n){return"A point's "+n+" cannot be parsed to a correct date."}},getRangeData:function(t){function s(t){a?n.inArray(t,i.visibleValCategories)===-1&&i.visibleValCategories.push(t):((t<i.minVisibleVal||!r.isDefined(i.minVisibleVal))&&(i.minVisibleVal=t),(t>i.maxVisibleVal||!r.isDefined(i.maxVisibleVal))&&(i.maxVisibleVal=t))}function y(t,i){var r={};return n.map(t,function(n){var t=n[i],u=r[t]?null:t;return r[t]=!0,u})}var h,c;if(this._validationResult.error)return{};var f=this,e=f.options,p=e.argumentCategories,l=e.argumentAxisType==="discrete",w=e.argumentType,b=e.valueCategories,a=e.valueAxisType==="discrete",k=e.valueType,i={visibleValCategories:[],categoriesVal:[],categoriesArg:[]},u=f.points,v=u&&u.length,o,d,g;return h=function(n,t){var u;(n<i.minArg||!r.isDefined(i.minArg))&&(i.minArg=n),(n>i.maxArg||!r.isDefined(i.maxArg))&&(i.maxArg=n),r.isDefined(t)&&(u=Math.abs(n-t)),r.isDefined(u)&&(u<i.minIntervalArg||!r.isDefined(i.minIntervalArg))&&(i.minIntervalArg=u)},c=function(n,t,u,e){var o;(n<i.minVal||!r.isDefined(i.minVal))&&(i.minVal=n),(n>i.maxVal||!r.isDefined(i.maxVal))&&(i.maxVal=n),f.isRangeSeries&&((t<i.minVal||!r.isDefined(i.minVal))&&(i.minVal=t),(t>i.maxVal||!r.isDefined(i.maxVal))&&(i.maxVal=t)),r.isDefined(u)&&(o=Math.abs(n-u)),f.isRangeSeries&&r.isDefined(e)&&(o=Math.min(o,Math.abs(t-e))),r.isDefined(o)&&(o<i.minIntervalVal||!r.isDefined(i.minIntervalVal))&&(i.minIntervalVal=o)},l&&(i.categoriesArg=y(u,"argument"),h=n.noop),a&&(i.categoriesVal=y(u,"value"),c=n.noop),v&&(n.each(u,function(n,e){var a,w=e.value,b=e.minValue,v=e.argument,y,p,k;(n!==0&&(a=u[n-1],y=a.value,p=a.minValue,k=a.argument),e.hasValue()&&c(w,b,y,p),h(v,k),l||!t||v<t.minArg||v>t.maxArg)||(!r.isDefined(i.minVisibleVal)&&n&&a.hasValue()&&(s(y),f.isRangeSeries&&s(p)),e.hasValue()&&(o=n,s(w),f.isRangeSeries&&s(b)))}),r.isDefined(o)&&o<v-1&&u[o+1].hasValue()&&(s(u[o+1].value),f.isRangeSeries&&s(u[o+1].minValue)),f.options.rotated?(r.isDefined(i.minVal)&&(i.minX=i.minVal,i.maxX=i.maxVal,i.intervalX=undefined),r.isDefined(i.minArg)&&(i.minY=i.minArg,i.maxY=i.maxArg,i.intervalY=i.minIntervalArg),i.categoriesArg.length&&(i.categoriesY=i.categoriesArg.slice(0)),i.categoriesVal.length&&(i.categoriesX=i.categoriesVal.slice(0)),i.visibleValCategories.length&&(i.visibleCategoriesX=i.visibleValCategories.slice(0)),i.minVisibleX=i.minVisibleVal,i.maxVisibleX=i.maxVisibleVal):(r.isDefined(i.minVal)&&(i.minY=i.minVal,i.maxY=i.maxVal,i.intervalY=undefined),r.isDefined(i.minArg)&&(i.minX=i.minArg,i.maxX=i.maxArg,i.intervalX=i.minIntervalArg),i.categoriesArg.length&&(i.categoriesX=i.categoriesArg.slice(0)),i.categoriesVal.length&&(i.categoriesY=i.categoriesVal.slice(0)),i.visibleValCategories.length&&(i.visibleCategoriesY=i.visibleValCategories.slice(0)),i.minVisibleY=i.minVisibleVal,i.maxVisibleY=i.maxVisibleVal)),delete i.minArg,delete i.maxArg,delete i.minVal,delete i.maxVal,delete i.minIntervalArg,delete i.minIntervalVal,delete i.minVisibleVal,delete i.maxVisibleVal,delete i.visibleValCategories,delete i.categoriesArg,delete i.categoriesVal,i=this.addLabelPaddingsToRange(i),i=this.processRangeForFullStackedSeries(i),this.rangeData=i,i=this.getRangeMinValue(i)},getRangeMinValue:function(n){if(this.type.slice(-3)==="bar"||this.type.slice(-4)==="area"){if(!n||this.isRangeSeries)return n;this.options.rotated?n.keepValueMarginsY=!0:n.keepValueMarginsX=!0,n.minY===undefined||this.options.rotated?n.minX!==undefined&&this.options.rotated&&(n.minX=n.minX>0?0:n.minX,this.setZeroPadding(n,n.minX,"minValueMarginX"),n.maxX=n.maxX<0?0:n.maxX,(n.maxX===0||n.maxX>0&&n.minX<0)&&(n.minValueMarginX=n.maxValueMarginX,n.minValueMarginXPriority=n.maxValueMarginXPriority),this.setZeroPadding(n,n.maxX,"maxValueMarginX")):(n.minY=n.minY>0?0:n.minY,this.setZeroPadding(n,n.minY,"minValueMarginY"),n.maxY=n.maxY<0?0:n.maxY,(n.maxY===0||n.maxY>0&&n.minY<0)&&(n.minValueMarginY=n.maxValueMarginY,n.minValueMarginYPriority=n.maxValueMarginYPriority),this.setZeroPadding(n,n.maxY,"maxValueMarginY"))}return n},setZeroPadding:function(n,t,i){t===0&&this.setPadding(n,i,0,y)},setPadding:function(n,t,i,r){n[t]=i,n[t+"Priority"]=r},addLabelPaddingsToRange:function(n){var t=this;return t.areLabelsVisible()&&t.styles.point.label.position!=="inside"&&(t.options.rotated?(this.setPadding(n,"maxValueMarginX",c,s),t.isRangeSeries&&this.setPadding(n,"minValueMarginX",c,s)):(this.setPadding(n,"maxValueMarginY",c,s),t.isRangeSeries&&this.setPadding(n,"minValueMarginY",c,s))),n},isFullStackedSeries:function(){return this.type.indexOf("fullstacked")===0},isStackedSeries:function(){return this.type.indexOf("stacked")===0},processRangeForFullStackedSeries:function(t){var i=this,u,r=n.isEmptyObject(t);return i.isFullStackedSeries()&&(i.options.rotated?(i.setPadding(t,"minValueMarginX",0,h),i.setPadding(t,"maxValueMarginX",0,h),r||(t.minX=0)):(i.setPadding(t,"minValueMarginY",0,h),i.setPadding(t,"maxValueMarginY",0,h),r||(t.minY=0))),t},draw:function(t){var h={"class":"dxc-series"},r={"class":"dxc-elements"},u=n.extend({"class":"dxc-markers"},this.styles.point.states.normal),o={"class":"dxc-series-labels"},f,e,s;if(t){this.translator=t,this._translateCoors(),this.elementsClipRectID&&(r.clipId=this.elementsClipRectID,o.clipId=this.elementsClipRectID),this.markersClipRectID&&(u.clipId=this.markersClipRectID),this.seriesGroup?(this.seriesGroup.clear(),f=this.renderer.createGroup(r).append(this.seriesGroup),e=this.renderer.createGroup(u).append(this.seriesGroup)):(this.seriesGroup=this.renderer.createGroup(h),f=this.renderer.createGroup(r).append(this.seriesGroup),e=this.renderer.createGroup(u).append(this.seriesGroup)),this.seriesGroup.append(this.options.seriesGroup),s=this.renderer.createGroup(o).append(this.options.seriesLabelsGroup),this.hoverPatternColor||(this.hoverPatternColor=this.styles.states.hover.fill,this.selectedPatternColor=this.styles.states.selected.fill),this.createPatterns(),this.drawSeriesData(f,e,s);switch(this.state){case i.selected:this.setSelectedState(this.lastSelectionMode);break;case i.hover:this.setHoverState(this.lastHoverdMode);break;default:this.state=i.normal,this.fullState=i.normalMark}return this}},createPatterns:function(){this.hoverPattern||(this.hoverPattern=this.renderer.createPattern(this.hoverPatternColor,this.styles.states.hover.hatching),this.selectedPattern=this.renderer.createPattern(this.selectedPatternColor,this.styles.states.selected.hatching)),this.hoverPattern.append(),this.selectedPattern.append()},drawSeriesData:function(n,t,i){return this.hoverPattern&&(this.styles.states.hover.fill=this.hoverPattern.id,this.styles.states.selected.fill=this.selectedPattern.id),this.drawPoints(t,i),this},drawPoints:function(t,i){var r=this,u=r.styles.point.visible,f=r.areLabelsVisible();n.each(r.points,function(n,e){(e.adjustSeriesLabels=r.adjustSeriesLabels,e.isInVisibleArea(e.x,e.y,e.width||0,e.height||0))&&(u&&e.drawMarker(r.renderer,t),f&&e.drawLabel(r.renderer,i))})},drawTrackers:function(){this.drawPointTrackers()},drawPointTrackers:function(){var t=this,i=!t._suppressTrackers;n.each(t.points,function(n,r){r.isInVisibleArea(r.x,r.y,r.width||0,r.height||0)&&i&&r.drawTrackerMarker(t.renderer,t.options.markerTrackerGroup)})},areLabelsVisible:function(){var n=this;return n.styles.point.label.visible&&(!r.isDefined(n.styles.maxLabelCount)||n.points.length<=n.styles.maxLabelCount)},getPoints:function(){return this.points},select:function(){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.selectSeries,{target:this}),this.options.selectionMode),this.seriesGroup&&this.seriesGroup.toForeground(),this.trackerElements&&this.trackerElements.length&&n.each(this.trackerElements,function(n,t){t.toBackground()})},clearSelection:function(){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.deselectSeries,{target:this}),this.options.selectionMode)},selectPoint:function(t){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.selectPoint),t)},deselectPoint:function(t){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.deselectPoint),t)},showPointTooltip:function(t){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.showPointTooltip),t)},hidePointTooltip:function(t){this.options.seriesGroup&&this.options.seriesGroup.trigger(new n.Event(e.hidePointTooltip),t)},getAllPoints:function(){return this.points.slice()},getPointByPos:function(n){return this.points&&this.points[n]},getPointByArg:function(n){return this.pointsByArgument[n.valueOf()]||null},animate:function(){this.styles.point.visible&&this.segments&&n.each(this.segments,function(t,i){n.each(i,function(n,t){t.animate()})})},on:function(t,i,r){n(this).on(t,i,r);return this},off:function(t){return n(this).off(t),this},applyNormalStyle:function(t){(t===f||t===u)&&n.each(this.segments,function(t,r){n.each(r,function(n,t){t.fullState&i.selectedMark||t.applyNormalStyle()})})},applyHoverStyle:function(t){(t===f||t===u)&&n.each(this.segments,function(t,r){n.each(r,function(n,t){t.fullState&i.selectedMark||t.applyHoverStyle()})})},applySelectionStyle:function(t){(t===f||t===u)&&n.each(this.segments,function(t,r){n.each(r,function(n,t){t.fullState&i.selectedMark||t.applySelectionStyle()})})},setHoverState:function(n){(this.fullState=this.fullState|i.hoverMark,n=n||this.options.hoverMode,this.lastHoverMode=n,this._checkBehavior(n,l))&&(this.state=i.hover,this.applyHoverStyle(n))},releaseHoverState:function(){var n=this.lastHoverMode||this.options.hoverMode;(this.fullState=this.fullState&~i.hoverMark,delete this.lastHoverMode,this._checkBehavior(n,l))&&(this.state=i.normal,this.applyNormalStyle(n))},setSelectedState:function(n){(this.state=i.selected,this.fullState=this.fullState|i.selectedMark,this.lastSelectionMode=n,this._checkBehavior(n,a))&&((this.lastHoverMode===f||this.lastHoverMode===u)&&this.applyNormalStyle(u),n=n||this.options.selectionMode,this.applySelectionStyle(n))},releaseSelectedState:function(){var n=this.lastSelectionMode||this.options.selectionMode;(this.fullState=this.fullState&~i.selectedMark,this._checkBehavior(n,a))&&(this.fullState&i.hoverMark?(this.state=i.hover,(n===u||n===f)&&(this.lastHoverMode!==u||this.lastHoverMode===f)&&this.applyNormalStyle(n),this.applyHoverStyle(this.lastHoverMode)):(this.state=i.normal,this.applyNormalStyle(n)),delete this.lastSelectionMode)},_checkBehavior:function(n,t){if(n==="none")return!1;switch(t){case l:return!(this.fullState&i.selectedMark)||this.options.selectionMode==="none"?!0:!1;case a:return!0}return!1},setPointHoverState:function(n){n.fullState=n.fullState|i.hoverMark,this.fullState&i.selectedMark&&(this.lastSelectionMode===f||this.lastSelectionMode===u)||n.fullState&i.selectedMark||(n.state=i.hover,n.applyHoverStyle())},releasePointHoverState:function(n){n.fullState=n.fullState&~i.hoverMark,this.fullState&i.selectedMark&&(this.lastSelectionMode===f||this.lastSelectionMode===u)||n.fullState&i.selectedMark||(n.state=i.normal,this.fullState&i.hoverMark&&(this.lastSelectionMode===f||this.lastSelectionMode===u)||n.applyNormalStyle())},setPointSelectedState:function(n){n.state=i.selected,n.fullState=n.fullState|i.selectedMark,n.applySelectionStyle()},releasePointSelectedState:function(n){n.state=i.normal,n.fullState=n.fullState&~i.selectedMark,this.fullState&i.hoverMark&&(this.lastHoverMode===f||this.lastHoverMode===u)||n.fullState&i.hoverMark?(n.applyHoverStyle(),n.fullState&i.hoverMark&&(n.state=i.hover)):this.fullState&i.selectedMark&&(this.lastSelectionMode===f||this.lastSelectionMode===u)?n.applySelectionStyle():n.applyNormalStyle()},_translateCoors:function(){var t=this,i=t.translator;n.each(t.points,function(n,t){t.translate(i)})},_checkAndPrepareInputData:function(n,t,i){return this._checkInputData(n,t,i),this._validationResult.error?null:this._prepareInputData(n,t,i)},_checkInputData:function(t,i,r){this._validationResult={error:null},this._parseUtils=new v({incidentOccured:this.options.incidentOccured});var u=this,f=t.length,o,s,h,c,l,a,e=t[0],y={};if(f){if(n.type(e)!=="object"){u._validationResult.error=u._errorMessages.incorrectDataMessage(),u.options.incidentOccured.call(null,u._errorMessages.incorrectDataMessage());return}(u._checkArgumentAxisParams(t,i),u._validationResult.error)||u._checkValueAxisParams(t,r)}},_checkArgumentAxisParams:function(n,t){var r=this,i=r.options,o=r._parsedUserOptions,l=o.argumentCategories,u=r._correctAxisType(o.argumentAxisType,o.argumentCategories),e=r._parseUtils.correctValueType(o.argumentType),s,c,h,f={};t=t||i.argumentField||"arg",i.userArgumentType=e,i.userArgumentAxisType=u;switch(e.toLowerCase()){case"numeric":case"datetime":u?(i.argumentAxisType=u,i.argumentType=e):(i.argumentAxisType=u="continuous",i.argumentType=e);return;case"string":u&&u!=="discrete"&&(r._validationResult.error=r._errorMessages.incompatibleTypesDataMessage("argument"),r.options.incidentOccured.call(null,r._errorMessages.incompatibleTypesDataMessage("argument"))),i.argumentAxisType=u="discrete",i.argumentType=e;return}for(s=0;s<n.length;s++)if(h=n[s],r._isTypeSupported(h[t])){c=h[t];break}if(f.value=c,f.field=t,f.axisType=u,f.type=e,r._checkValue(f))i.argumentAxisType=f.axisType,i.argumentType=f.type;else return},_checkValueAxisParams:function(t,i){var u=this,r=u.options,c=u._parsedUserOptions,y=r.valueField||"val",p=r.rangeValue1Field||"val1",w=r.rangeValue2Field||"val2",b=c.valueCategories,e=u._correctAxisType(c.valueAxisType,c.valueCategories),s=u._parseUtils.correctValueType(c.valueType),f,h,l={},k,d,a,o={},g,v;i=i||[],i.length||(i=u.isRangeSeries?[p,w]:[y]),r.userValueType=s,r.userValueAxisType=e;switch(s.toLowerCase()){case"numeric":case"datetime":e?(r.valueAxisType=e,r.valueType=s):(r.valueAxisType=e="continuous",r.valueType=s);return;case"string":e&&e!=="discrete"&&(u._validationResult.error=u._errorMessages.incompatibleTypesDataMessage("value"),u.options.incidentOccured.call(null,u._errorMessages.incompatibleTypesDataMessage("value"))),r.valueAxisType=e="discrete",r.valueType=s;return}for(o.axisType=e,o.type=s,f=0;f<t.length;f++){for(v=!0,a=t[f],h=0;h<i.length;h++)u._isTypeSupported(a[i[h]])&&(l[i[h]]=a[i[h]]);if(n.each(i,function(n,t){return v=t in l}),v)break}for(f=0;f<i.length;f++)if(o.value=l[i[f]],o.field=i[f],!u._checkValue(o))return;r.valueAxisType=o.axisType,r.valueType=o.type},_prepareInputData:function(i,u,f){function rt(){for(var i=h.length,f=i,t={},n=0;n<i;n++)t[h[n]]=n;return function(n,i){var s=n[u],h=i[u],e=t[s],o=t[h];return r.isDefined(e)||(e=f),r.isDefined(o)||(o=f),e-o}}function ut(n,t){return n[u]-t[u]}var o=this,e=o.options,h=e.argumentCategories,l=e.argumentAxisType,y=e.argumentType,c=o._errorMessages,a=o.options.incidentOccured,p=e.valueField||"val",w=e.rangeValue1Field||"val1",b=e.rangeValue2Field||"val2",ot=e.valueCategories,st=e.valueAxisType,k=e.userValueType,d=e.userArgumentType,g=e.userValueAxisType,nt=e.userArgumentAxisType,tt=e.valueType,it=e.tagField||"tag",ht=t.data.query,ct=n.noop,lt=n.noop,s=[];if(u=u||e.argumentField||"arg",f=f||[],f.length||(f=o.isRangeSeries?[w,b]:[p]),!i.length)return s;var v=function(t,i,u){var e=o._parseUtils.getParser(i.toLowerCase(),t+"Axis"),f;switch(i.toLowerCase()){case"numeric":f=c.numericParsingMessage;break;case"datetime":f=c.dateParsingMessage;break;default:f=n.noop}return function(n){var i;return u&&!r.isDefined(n)||n===undefined?(a.call(null,c.dataItemMissingMessage(t)),undefined):n===null?null:(i=e(n),r.isDefined(i)||a.call(null,f(t)),i)}},ft=v("argument",y,!0),et=v("value",tt);return s=n.map(i,function(n){var o=nt==="discrete"&&!d?n[u]:ft(n[u]),i={tag:n[it]},e,t;if(!r.isDefined(o))return null;for(i[u]=o,i["original"+u]=n[u],t=0;t<f.length;t++){if(e=g==="discrete"&&!k?n[f[t]]:et(n[f[t]]),e===undefined)return null;i[f[t]]=e,i["original"+f[t]]=n[f[t]]}return i}),l==="discrete"&&h&&h.length?s.sort(rt()):l!=="discrete"&&s.sort(ut),s},_parseInputData:function(n){var t=this,a=o.pointFactory.createPoint,v=t.options.rotated,y=t.styles.point,u,f=0,i,r,h,c,l,e=t.options,s=s||e.argumentField||"arg",p=e.tagField||"tag";if(n&&n.length&&(this._canRenderCompleteHandle=!0),t.points=[],t.pointsByArgument={},t.segments=[],u=t._checkAndPrepareInputData(n),u&&!t._validationResult.error){if(t.isRangeSeries)for(c=e.rangeValue1Field||"val1",l=e.rangeValue2Field||"val2";f<u.length;f++)i=u[f],r=a(t.type,{minValue:i[c],value:i[l],argument:i[s],originalMinValue:i["original"+c],originalValue:i["original"+l],originalArgument:i["original"+s],rotated:v,options:y,tag:i.tag,series:t}),t.pointsByArgument[r.argument]=t.pointsByArgument[r.argument]||r,t.points.push(r);else for(h=e.valueField||"val";f<u.length;f++)i=u[f],r=a(t.type,{value:i[h],argument:i[s],originalValue:i["original"+h],originalArgument:i["original"+s],rotated:v,options:y,tag:i.tag,series:t}),t.points.push(r),t.pointsByArgument[r.argument.valueOf()]=t.pointsByArgument[r.argument.valueOf()]||r;this._segmenting()}},_segmenting:function(){var i=this,t=[];n.each(this.points,function(n,r){r.hasValue()?t.push(r):t.length!==0&&(i.segments.push(t),t=[])}),t.length&&this.segments.push(t)},_parseOptions:function(t){this.options={incidentOccured:t.incidentOccured,rotated:!!t.rotated,seriesGroup:t.seriesGroup,seriesLabelsGroup:t.seriesLabelsGroup,seriesTrackerGroup:t.seriesTrackerGroup,markerTrackerGroup:t.markerTrackerGroup,argumentCategories:t.argumentCategories,argumentAxisType:t.argumentAxisType,argumentType:t.argumentType,argumentField:t.argumentField,valueCategories:t.valueCategories,valueAxisType:t.valueAxisType,valueType:t.valueType,valueField:t.valueField,rangeValue1Field:t.rangeValue1Field,rangeValue2Field:t.rangeValue2Field,tagField:t.tagField,selectionMode:(t.selectionMode||"").toLowerCase(),hoverMode:(t.hoverMode||"").toLowerCase(),showInLegend:t.showInLegend!==undefined?t.showInLegend:!0},n.isFunction(this.options.incidentOccured)||(this.options.incidentOccured=n.noop),this.name=t.name,this.axis=t.axis,this.pane=t.pane,this.styles=this.parseStyleOptions(t),this.adjustOptions&&this.adjustOptions()},parseStyleOptions:function(t){var i=n.extend(!0,{},this.getDefaultStyleOptions(),t),r={strokeWidth:i.border.visible?i.border.width||0:0,stroke:i.border.visible&&i.border.width?i.border.color:"none",fill:i.color,dashStyle:i.dashStyle,lineWidth:i.width,r:i.cornerRadius},o={strokeWidth:i.hoverStyle.border.visible?i.hoverStyle.border.width||0:0,stroke:i.hoverStyle.border.visible&&i.hoverStyle.border.width?i.hoverStyle.border.color:"none",fill:i.hoverStyle.color,dashStyle:i.hoverStyle.dashStyle||i.dashStyle,lineWidth:i.hoverStyle.width,hatching:i.hoverStyle.hatching},s={strokeWidth:i.selectionStyle.border.visible?i.selectionStyle.border.width||0:0,stroke:i.selectionStyle.border.visible&&i.selectionStyle.border.width?i.selectionStyle.border.color:"none",fill:i.selectionStyle.color,dashStyle:i.selectionStyle.dashStyle||i.dashStyle,lineWidth:i.selectionStyle.width,hatching:i.selectionStyle.hatching},u={};n.each(["align","translateX","translateY","rotate","linejoin","linecap","opacity","style"],function(n,t){i[t]&&(u[t]=i[t])});var h=n.extend(!0,{},r,u),f={strokeWidth:i.point.border.visible?i.point.border.width||0:0,stroke:i.point.border.visible&&i.point.border.width?i.point.border.color:"none",fill:i.point.color,r:i.point.size+(i.point.border.visible&&i.point.size!==0?~~(i.point.border.width/2)||0:0),inh:!0},c={strokeWidth:i.point.hoverStyle.border.visible?i.point.hoverStyle.border.width||0:0,stroke:i.point.hoverStyle.border.visible&&i.point.hoverStyle.border.width?i.point.hoverStyle.border.color:"none",fill:i.point.hoverStyle.color,r:i.point.hoverStyle.size+(i.point.hoverStyle.border.visible&&i.point.hoverStyle.size!==0?~~(i.point.hoverStyle.border.width/2)||0:0)},l={strokeWidth:i.point.selectionStyle.border.visible?i.point.selectionStyle.border.width||0:0,stroke:i.point.selectionStyle.border.visible&&i.point.selectionStyle.border.width?i.point.selectionStyle.border.color:"none",fill:i.point.selectionStyle.color,r:i.point.selectionStyle.size+(i.point.selectionStyle.border.visible&&i.point.selectionStyle.size!==0?~~(i.point.selectionStyle.border.width/2)||0:0)},e={};n.each(["align","translateX","translateY","rotate","linejoin","linecap","style"],function(n,t){t in i.point&&(e[t]=i.point[t])});var a=n.extend(!0,{},f,e),v={align:i.label.alignment,font:{color:i.label.backgroundColor==="none"&&i.label.font.color.toLowerCase()==="#ffffff"&&i.label.position!=="inside"?i.color:i.label.font.color,family:i.label.font.family,weight:i.label.font.weight,size:i.label.font.size,opacity:i.label.font.opacity},style:i.label.style},y={fill:i.label.backgroundColor||i.color,strokeWidth:i.label.border.visible?i.label.border.width||0:0,stroke:i.label.border.visible&&i.label.border.width?i.label.border.color:"none",dashStyle:i.label.border.dashStyle},p={stroke:i.label.connector.visible&&i.label.connector.width?i.label.connector.color||i.color:"none",strokeWidth:i.label.connector.visible?i.label.connector.width||0:0};return{themeColor:i.color,attributes:h,maxLabelCount:i.maxLabelCount,minBarSize:i.minBarSize,reduction:{color:i.reduction.color,level:i.reduction.level,innerColor:i.innerColor},states:{normal:r,hover:o,selected:s},point:{visible:i.point.visible,symbol:i.point.symbol,minShownBarSize:i.point.minShownBarSize,attributes:a,seriesName:i.point.seriesName,selectionMode:(i.point.selectionMode||"").toLowerCase(),hoverMode:(i.point.hoverMode||"").toLowerCase(),states:{normal:f,hover:c,selected:l},label:{format:i.label.format,argumentFormat:i.label.argumentFormat,precision:i.label.precision,argumentPrecision:i.label.argumentPrecision,percentPrecision:i.label.percentPrecision,customizeText:n.isFunction(i.label.customizeText)?i.label.customizeText:undefined,attributes:v,visible:i.label.font.size!==0?i.label.visible:!1,showForZeroValues:i.label.showForZeroValues,horizontalOffset:i.label.horizontalOffset,verticalOffset:i.label.verticalOffset,radialOffset:i.label.radialOffset,background:y,position:i.label.position,connector:p,rotationAngle:i.label.rotationAngle}}}},canRenderCompleteHandle:function(){var n=this._canRenderCompleteHandle;return delete this._canRenderCompleteHandle,!!n},_isTypeSupported:function(n){return r.isString(n)||r.isNumber(n)||r.isDate(n)},getDefaultStyleOptions:function(){return{color:"#000000",border:{visible:!1,width:1,color:"#000000"},width:2,dashStyle:"solid",cornerRadius:0,innerColor:"#ffffff",reduction:{color:"#FF0000"},maxLabelCount:undefined,minBarSize:undefined,point:{visible:!0,symbol:"circle",color:"#000000",size:6,seriesName:this.name,border:{visible:!1,width:1,color:"#000000"},hoverStyle:{color:"#000000",border:{visible:!0,width:2,color:"#ffffff"},size:6},selectionStyle:{color:"#000000",border:{visible:!0,width:2,color:"#ffffff"},size:6}},label:{visible:!1,showForZeroValues:!0,alignment:"center",font:{family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400,color:"#ffffff",size:14},rotationAngle:0,horizontalOffset:0,verticalOffset:0,radialOffset:0,format:"",argumentFormat:"",precision:0,argumentPrecision:0,position:"outside",connector:{visible:!1,width:1},border:{visible:!1,width:1,color:"#808080",dashStyle:"solid"}},hoverStyle:{hatching:"none",color:"#000000",border:{visible:!1,width:1,color:"#000000"},width:3},selectionStyle:{hatching:"right",color:"#000000",border:{visible:!1,width:1,color:"#000000"},width:3}}}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.LineSeries=i.BaseSeries.inherit({ctor:function(n,t,i,r){i.specificType=i.specificType||"line",this.callBase(n,t,i,r),this.paths=this.paths||[]},dispose:function(){this.paths=null,this.callBase()},drawSegment:function(n,t){return this.renderer.createPath(n,t)},drawSeriesData:function(t,i,r){var u=this;(u.preparedSegments=[],u.paths=[],u.points.length)&&(n.each(this.segments,function(n){u.prepareSegments(n)}),u.styles.attributes.strokeWidth>0&&n.each(u.preparedSegments,function(n,i){u.paths.push(u.drawSegment(i,u.styles.attributes).append(t))}),u.callBase(t,i,r))},prepareSegments:function(n){this.preparedSegments=this.preparedSegments||[],this.preparedSegments[n]=this.segments[n]},drawTrackers:function(){var t=this,i=this.styles,r;if(t.callBase(),t.preparedSegments||(t.preparedSegments=[],n.each(t.segments,function(n){t.prepareSegments(n)})),!this._suppressTrackers)return r=i.attributes.strokeWidth<20?20:i.attributes.strokeWidth,t.trackerElements=[],n.each(this.preparedSegments,function(n,i){var u=t.drawSegment(i,{strokeWidth:r,stroke:"grey",opacity:.0001}).append(t.options.seriesTrackerGroup);t.trackerElements.push(u),u.data({series:t})}),this},applyNormalStyle:function(t){var i=this;if(this.paths)return n.each(this.paths,function(n,t){t.applySettings(i.styles.states.normal)}),i.callBase(t)},applyHoverStyle:function(t){var i=this;if(this.paths)return n.each(this.paths,function(n,t){t.applySettings(i.styles.states.hover)}),i.callBase(t)},applySelectionStyle:function(t){var i=this;if(this.paths)return n.each(this.paths,function(n,t){t&&t.applySettings(i.styles.states.selected)}),i.callBase(t)},animate:function(){this.callBase(),this.animatePath()},animatePath:function(){var t=this,i=t.preparedSegments;i&&i.length&&t.paths&&n.each(t.paths,function(n,r){var u=t.getZeroPathPoints(n);r.applySettings({points:u}),r.animate({points:i[n]})})},getZeroPathPoints:function(t){return n.map(this.preparedSegments[t],function(n){return n.getDefaultCoords()})},adjustOptions:function(){var u=this.styles,n=u.attributes,t=u.states.hover,i=u.states.selected,r=u.states.normal;n.stroke=n.fill,n.fill="none",n.strokeWidth=n.lineWidth,r.stroke=r.fill,r.fill="none",r.strokeWidth=r.lineWidth,t.stroke=t.fill,t.fill="none",t.strokeWidth=t.lineWidth,i.stroke=i.fill,i.fill="none",i.strokeWidth=i.lineWidth}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.AreaSeries=i.LineSeries.inherit({ctor:function(n,t,i,r){this.type=i.specificType=i.specificType||"area",this.callBase(n,t,i,r),this.areas=this.areas||[],this.areaSegments=this.areaSegments||[]},dispose:function(){var n=this;n.areas=null,n.areaSegments=null,n.paths=null,n.callBase()},drawSeriesData:function(t,i,r){var u=this;if(u.resetLineColors(),(u.isStackedSeries()||u.isFullStackedSeries())&&u.seriesGroup.toBackground(),u.areas=[],u.points.length)return u.paths=[],n.each(this.segments,function(n){u.prepareSegments(n)}),n.each(u.preparedSegments,function(n){if(u.prepareAreaPoints(n),u.areaSegments[n].length===2){var r=u.drawSegment(u.areaSegments[n],u.styles.stick).append(t);r.stick=!0,u.areas.push(r);return}u.areas.push(u.renderer.createArea(u.areaSegments[n],u.styles.area).append(t))}),(u.styles.attributes.strokeWidth>0||u.styles.states.hover.strokeWidth>0||u.styles.states.selected.strokeWidth>0)&&n.each(u.preparedSegments,function(n,i){u.paths.push(u.drawSegment(i,u.styles.attributes).append(t))}),u.drawPoints(i,r),u.hoverPattern&&(u.styles.area.states.hover.fill=u.hoverPattern.id,u.styles.area.states.selected.fill=u.selectedPattern.id,u.styles.states.hover.fill="none",u.styles.states.selected.fill="none"),u},resetLineColors:function(){var t=this.styles,i=t.attributes,n=t.states,r=n.hover,u=n.selected,f=n.normal;i.fill="none",delete i.lineWidth,f.fill="none",delete f.lineWidth,r.fill="none",delete r.lineWidth,u.fill="none",delete u.lineWidth},drawTrackers:function(){var t=this;if(!this._suppressTrackers)return t.drawPointTrackers(),t.trackerElements=[],n.each(this.areaSegments,function(n,i){var r;r=i.length===2?t.drawSegment(i,{strokeWidth:20,stroke:"grey",opacity:.0001}).append(t.options.seriesTrackerGroup):t.renderer.createArea(i,{strokeWidth:0,fill:"grey",opacity:.0001}).append(t.options.seriesTrackerGroup),t.trackerElements.push(r),r.data({series:t})}),i},prepareAreaPoints:function(t){var i=this.preparedSegments,r=n.map(i[t],function(n){return n.getCoords()}),u=n.map(i[t].slice().reverse(),function(n){return n.getCoords(!0)});this.areaSegments[t]=r.concat(u)},applyStyle:function(t,i){var r=this;this.areas&&n.each(this.areas,function(n,t){t.stick?t.applySettings(r.styles.stick.states[i]):t.applySettings(r.styles.area.states[i])})},applyNormalStyle:function(n){return this.applyStyle(n,"normal"),this.callBase(n)},applyHoverStyle:function(n){return this.applyStyle(n,"hover"),this.callBase(n)},applySelectionStyle:function(n){return this.applyStyle(n,"selected"),this.callBase(n)},animate:function(){var t=this;this.callBase(),this.preparedSegments&&this.preparedSegments.length&&this.areas&&n.each(this.areas,function(n,i){var r=t.getZeroAreaPoints(n);i.applySettings({points:r}),i.animate({points:t.areaSegments[n]})})},getZeroAreaPoints:function(t){var i,r,u=this.preparedSegments;return i=n.map(u[t],function(n){return n.getDefaultCoords()}),r=n.map(u[t].slice().reverse(),function(n){return n.getDefaultCoords()}),i.concat(r)},adjustOptions:function(){var t=this.styles,i=t.attributes,r=t.states,u=r.hover,f=r.selected,e=r.normal,o={},s={},h={},c={},l={},a={},n;n="opacity"in i?i.opacity:.5,o={fill:e.fill,stroke:"none",strokeWidth:0,opacity:n},s={fill:u.fill,stroke:"none",strokeWidth:0,opacity:n},h={fill:f.fill,stroke:"none",strokeWidth:0,opacity:n},c={fill:"none",stroke:e.fill,strokeWidth:1,opacity:n},l={fill:"none",stroke:u.fill,strokeWidth:1,opacity:n},a={fill:"none",stroke:f.fill,strokeWidth:1,opacity:n},t.area={fill:i.fill,stroke:"none",strokeWidth:0,opacity:n,states:{normal:o,hover:s,selected:h}},t.stick={fill:"none",stroke:i.fill,strokeWidth:1,opacity:n,states:{normal:c,hover:l,selected:a}}}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.BarSeries=i.BaseSeries.inherit({ctor:function(n,t,i,r){i.specificType=i.specificType||"bar",this.callBase(n,t,i,r),this.stackName=i.stack||"default"},getStackName:function(){return this.type==="stackedbar"||this.type==="fullstackedbar"?this.stackName:null},drawSeriesData:function(n,t,i){var r=this;return r.points.length&&r.hoverPattern&&(r.styles.point.states.hover.fill=r.hoverPattern.id,r.styles.point.states.selected.fill=r.selectedPattern.id),this.callBase(n,t,i)},adjustOptions:function(){var t=this.styles,i=this.options,c=t.attributes,l=t.states.hover,a=t.states.selected,v=t.states.normal,r=t.point.attributes,u=t.point.states.hover,f=t.point.states.selected,e=t.point.states.normal,o=i.hoverMode,s=i.selectionMode,h=function(n){if(!n)return!1;switch(n.toLowerCase()){case"allseriespoints":case"allargumentpoints":case"none":return!0}};n.extend(!0,r,c),n.extend(!0,u,l),n.extend(!0,f,a),n.extend(!0,e,v),u.r=f.r=e.r=r.r,t.point.hoverMode=h(o)&&o,t.point.selectionMode=h(s)&&s,t.point.visible=!0}})}(jQuery,DevExpress),function(n,t){var r=t.viz.charts.series,i=t.utils.isDefined;r.CandleStickSeries=r.BaseSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"candlestick",this.callBase(n,t,i)},getRangeData:function(){var t=this,e=t.options,o=e.rotated,s=o?"X":"Y",f=o?"Y":"X",h=t.points,r=[],u=[],c=function(n,t){return n-t},l;return n.each(this.points,function(n,t){i(t.argument)&&u.push(t.argument),t.hasValue()&&(r.push(t.highValue),r.push(t.lowValue))}),t.rangeData={},l=function(n,r){var u;i(r)&&(u=Math.abs(n-r)),i(u)&&(u<t.rangeData.intervalX||!i(t.rangeData.intervalX))&&(t.rangeData.intervalX=u)},r.length&&(r.sort(c),t.rangeData["max"+s]=r[r.length-1],t.rangeData["min"+s]=r[0],n.each(h,function(n,t){var i,u=t.argument,r;n!==0&&(i=h[n-1],r=i.argument),l(u,r)})),!u.length||e.argumentAxisType==="discrete"?t.rangeData["categories"+f]=u:(u.sort(c),t.rangeData["min"+f]=u[0],t.rangeData["max"+f]=u[u.length-1]),this.rangeData},_parseInputData:function(t){var i=this,u,y=r.pointFactory,c=this.options.argumentField||"date",e=this.options.openValueField||"open",s=this.options.highValueField||"high",h=this.options.lowValueField||"low",o=this.options.closeValueField||"close",b=this.options.tagField||"tag",p=this.styles.point,a=this.styles.reduction.color,w=this.styles.reduction.innerColor,v,l,f;if(this.points=[],this.segments=[],t.length){v=i._checkAndPrepareInputData(t,c,[e,s,h,o]),i._validationResult={inputNotations:0,error:null};switch((this.styles.reduction.level||"").toLowerCase()){case"open":u=e;break;case"high":u=s;break;case"low":u=h;break;default:u=o}i.pointsByArgument={},this.points=n.map(v,function(t,r){var v=n.extend(!0,{},p||{}),b;return f="dx-candle-default",t[e]!==null&&t[s]!==null&&t[h]!==null&t[o]!==null&&(r!=0&&l!=null&&t[u]<l&&(v.attributes.fill=v.states.normal.fill=v.states.hover.fill=v.states.selected.fill=a,v.attributes.stroke=v.states.normal.stroke=v.states.hover.stroke=v.states.selected.stroke=a,f="dx-candle-reduction"),l=t[u],t[e]<t[o]&&(v.attributes.fill=v.states.normal.fill=v.states.hover.fill=v.states.selected.fill=w,f=(f?f:"")+" dx-candle-positive")),v.attributes["class"]=f,i.className="dx-candle-default",b=y.createPoint(i.type,{openValue:t[e],pointClassName:f,highValue:t[s],lowValue:t[h],closeValue:t[o],argument:t[c],originalOpenValue:t["original"+e],originalHighValue:t["original"+s],originalLowValue:t["original"+h],originalCloseValue:t["original"+o],originalArgument:t["original"+c],options:v,tag:t.tag,reductionValue:t[u],series:i}),i.pointsByArgument[b.argument.valueOf()]=i.pointsByArgument[b.argument.valueOf()]||b,b}),this._segmenting()}},_parseOptions:function(t){this.callBase(t),n.extend(!0,this.options,{openValueField:t.openValueField,closeValueField:t.closeValueField,highValueField:t.highValueField,lowValueField:t.lowValueField})},drawSeriesData:function(t,i,r){var u=this;return u.hoverPattern&&n.each(u.points,function(n,t){t.options.states.hover.fill=u.hoverPattern.id,t.options.states.selected.fill=u.selectedPattern.id}),this.callBase(t,i,r),this},adjustOptions:function(){var t=this.styles,e=this.options,i=t.attributes,r=t.states.hover,u=t.states.selected,f=t.states.normal,o=t.point.attributes,s=t.point.states.hover,h=t.point.states.selected,c=t.point.states.normal,l=e.hoverMode,a=e.selectionMode,v=function(n){if(!n)return!1;switch(n.toLowerCase()){case"allseriespoints":case"allargumentpoints":case"none":return!0}};i.stroke=i.fill,i.strokeWidth=i.lineWidth,f.stroke=f.fill,f.strokeWidth=f.lineWidth,r.stroke=r.fill,r.strokeWidth=r.lineWidth,u.stroke=u.fill,u.strokeWidth=u.lineWidth,n.extend(!0,o,i),n.extend(!0,s,r),n.extend(!0,h,u),n.extend(!0,c,f),s.r=h.r=c.r=o.r=0,t.point.hoverMode=v(l)&&l,t.point.selectionMode=v(a)&&a,t.point.visible=!0}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.SplineSeries=i.LineSeries.inherit({ctor:function(n,t,i,r){i.specificType=i.specificType||"spline",this.callBase(n,t,i,r)},drawSegment:function(n,t){return this.renderer.createBezierPath(n,t)},prepareSegments:function(i){var r=this,u=[],f=r.segments[i],e,o;r.preparedSegments=r.preparedSegments||[],e=function(n,t,i){return n>t&&i>n||n<t&&i<n?n:i},o=function(n,i,r){var u=t.utils.clone(n);return u.x=i,u.y=r,u},f.length!==1?n.each(f,function(n,t){var a,v,y,p,h,c,i,s,b,k,d,g,st,l=.5,ft,et,ot,it,rt,ut,nt,tt,w;if(!n){u.push(t),u.push(t);return}if(h=f[n-1],n<f.length-1)c=f[n+1],i=t.x,s=t.y,b=h.x,k=c.x,d=h.y,g=c.y,ft=!!(!r.options.rotated&&(s<=h.y&&s<=c.y||s>=h.y&&s>=c.y)||r.options.rotated&&(i<=h.x&&i<=c.x||i>=h.x&&i>=c.x)),ft?r.options.rotated?(y=a=i,p=(s+c.y)/2,v=(s+h.y)/2):(p=v=s,y=(i+c.x)/2,a=(i+h.x)/2):(it=g-d,rt=b-k,ut=d*k-b*g,r.options.rotated?(tt=s,nt=-1*(rt*tt+ut)/it,w=nt-i||0,b-=w,k-=w):(nt=i,tt=-1*(it*nt+ut)/rt,w=tt-s||0,d-=w,g-=w),y=(i+l*k)/(1+l),p=(s+l*g)/(1+l),a=(i+l*b)/(1+l),v=(s+l*d)/(1+l)),r.options.rotated?(a=e(h.x,i,a),y=e(c.x,i,y)):(v=e(h.y,s,v),p=e(c.y,s,p)),et=o(t,a,v),ot=o(t,y,p),u.push(et,t,ot);else{u.push(t,t);return}}):u.push(f[0]),r.preparedSegments[i]=u}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.SplineAreaSeries=i.SplineSeries.inherit({ctor:function(n,t,i,r){i.specificType=i.specificType||"splinearea",this.callBase(n,t,i,r),this.areas=this.areas||[],this.areaSegments=this.areaSegments||[]},dispose:function(){var n=this;n.areas=null,n.areaSegments=null,n.paths=null,n.callBase()},drawSeriesData:function(t,i,r){if(this.points.length){var u=this;if(this.points.length)return this.resetLineColors(),n.each(this.segments,function(n){u.prepareSegments(n)}),this.areas=[],n.each(u.preparedSegments,function(n){u.prepareBezierAreaPoints(n),u.areas.push(u.renderer.createBezierArea(u.areaSegments[n],u.styles.area).append(t))}),(u.styles.attributes.strokeWidth>0||u.styles.states.hover.strokeWidth>0||u.styles.states.selected.strokeWidth>0)&&n.each(u.preparedSegments,function(n,i){u.paths.push(u.drawSegment(i,u.styles.attributes).append(t))}),u.drawPoints(i,r),u.hoverPattern&&(u.styles.area.states.hover.fill=u.hoverPattern.id,u.styles.area.states.selected.fill=u.selectedPattern.id,u.styles.states.hover.fill="none",u.styles.states.selected.fill="none"),u}},resetLineColors:function(){var t=this.styles,i=t.attributes,n=t.states,r=n.hover,u=n.selected,f=n.normal;i.fill="none",delete i.lineWidth,f.fill="none",delete f.lineWidth,r.fill="none",delete r.lineWidth,u.fill="none",delete u.lineWidth},drawTrackers:function(){var t=this;if(!this._suppressTrackers)return t.drawPointTrackers(),t.trackerElements=[],n.each(this.areaSegments,function(n,i){var r=t.renderer.createBezierArea(i,{strokeWidth:0,fill:"grey",opacity:.0001}).append(t.options.seriesTrackerGroup);t.trackerElements.push(r),r.data({series:t})}),i},prepareBezierAreaPoints:function(t){var r=this.preparedSegments,i=n.map(r[t],function(n){return n.getCoords()}),u=n.map(r[t].slice().reverse(),function(n){return n.getCoords(!0)}),f=i[i.length-1],e=u[0];this.areaSegments[t]=i.concat({x:f.x,y:f.y},{x:e.x,y:e.y},u)},applyNormalStyle:function(t){var i=this;return this.areas&&n.each(this.areas,function(n,t){t.applySettings(i.styles.area.states.normal)}),this.callBase(t)},applyHoverStyle:function(t){var i=this;return this.areas&&n.each(this.areas,function(n,t){t.applySettings(i.styles.area.states.hover)}),this.callBase(t)},applySelectionStyle:function(t){var i=this;return this.areas&&n.each(this.areas,function(n,t){t.applySettings(i.styles.area.states.selected)}),this.callBase(t)},animate:function(){var t=this;this.callBase(),this.preparedSegments&&this.preparedSegments.length&&this.areas&&n.each(this.areas,function(n,i){var r=t.getZeroAreaPoints(n);i.applySettings({points:r}),i.animate({points:t.areaSegments[n]})})},getZeroAreaPoints:function(t){var i=n.map(this.preparedSegments[t],function(n){return n.getDefaultCoords()}),r=n.map(this.preparedSegments[t].slice().reverse(),function(n){return n.getDefaultCoords()}),u=i[i.length-1],f=r[0];return i.concat({x:u.x,y:u.y},{x:f.x,y:f.y},r)},adjustOptions:function(){var t=this.styles,i=t.attributes,r=t.states,o=r.hover,s=r.selected,h=r.normal,u={},f={},e={},n;n="opacity"in i?i.opacity:.5,u={fill:h.fill,stroke:"none",strokeWidth:0,opacity:n},f={fill:o.fill,stroke:"none",strokeWidth:0,opacity:n},e={fill:s.fill,stroke:"none",strokeWidth:0,opacity:n},t.area={fill:i.fill,stroke:"none",strokeWidth:0,opacity:n,states:{normal:u,hover:f,selected:e}}}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series,r=20,u=80;i.PieSeries=i.BaseSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"pie",this.callBase(n,t,i),this.labelSpace=this.styles.point.label.visible?u:0,this.hoverSpace=0&&this.styles.point.states.enableHover?r:0,this.innerRadius=this.type==="pie"?0:i.innerRadius,this.outerRadius=i.radius,this.redraw=!1},arrangePoints:function(){var i=this,t,f,u=0,h=this.translator,e=0,o,r,s=i.options.segmentsDirection!=="anticlockwise";for(i.points=n.map(i.points,function(n){return n.value===null||n.value===0||n.value<0?null:n}),t=i.points,f=t.length,r=0;r<f;r++)e+=t[r].value;n.each(s?t:t.concat([]).reverse(),function(n,t){var i=t.value;o=i/e,t.correctValue(u,o),u=u+i})},createPatterns:function(){},drawSeriesData:function(t,i,r){var u=this,f,h,e,o,s;return n.each(u.points,function(n,t){t.hoverPatternColor||(t.hoverPatternColor=t.options.states.hover.fill,t.selectedPatternColor=t.options.states.selected.fill),t.hoverPattern||(t.hoverPattern=u.renderer.createPattern(t.hoverPatternColor,t.options.states.hover.hatching).append(),t.selectedPattern=u.renderer.createPattern(t.selectedPatternColor,t.options.states.selected.hatching).append()),t.hoverPattern.append(),t.selectedPattern.append(),t.options.states.hover.fill=t.hoverPattern.id,t.options.states.selected.fill=t.selectedPattern.id}),this.callBase(t,i,r),u.styles.point.label.visible&&(f=0,u.styles.point.label.position==="columns"?(n.each(u.points,function(n,t){t.setLabelEllipsis=!0,h=t.insideLabelGroup.getBBox(),f=Math.max(h.width+t.INDENT_FROM_PIE+t.options.label.radialOffset,f)}),u.redraw=!0,e=u.canvas.height-u.canvas.top-u.canvas.bottom,o=u.canvas.width-u.canvas.left-u.canvas.right,s=o<e?o:e,u.labelSpace=f>s/2-f?s/2:2*f):n.each(u.points,function(n,t){t.setLabelEllipsis=!0,t.correctLabel()})),this},correctPosition:function(t){n.each(this.points,function(n,i){i.correctPosition(t)})},getRangeData:function(){var n=this.callBase();return n?(n.minY!==undefined&&(n.minY=n.minY>0?0:n.minY,n.maxY=n.maxY<0?0:n.maxY),n):n},parseStyleOptions:function(n){return n.label&&n.label.position&&n.label.position!=="outside"&&n.label.position!=="inside"&&n.label.position!=="columns"&&(n.label.position="outside"),n.label.position&&n.label.position==="columns"&&(n.label.connector.visible=!0),this.options.segmentsDirection=n.segmentsDirection||"clockwise",this.styles=this.callBase(n),this.adjustOptions(),this.styles},adjustOptions:function(){var t=this.styles,i=this.options,c=t.attributes,l=t.states.hover,a=t.states.selected,v=t.states.normal,r=t.point.attributes,u=t.point.states.hover,f=t.point.states.selected,e=t.point.states.normal,o=i.hoverMode,s=i.selectionMode,h=function(n){if(!n)return!1;switch(n.toLowerCase()){case"none":return!0}};n.extend(!0,r,c),n.extend(!0,u,l),n.extend(!0,f,a),n.extend(!0,e,v),u.r=f.r=e.r=r.r,t.point.hoverMode=h(o)&&o,t.point.selectionMode=h(s)&&s,t.point.visible=!0}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series;i.RangeAreaSeries=i.AreaSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"rangearea",this.callBase(n,t,i,!0)}}),i.RangeBarSeries=i.BarSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"rangebar",this.callBase(n,t,i,!0)}}),i.RangeSplineAreaSeries=i.SplineAreaSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"rangesplinearea",this.callBase(n,t,i,!0)}}),i.ScatterSeries=i.BaseSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"scatter",this.callBase(n,t,i)}}),i.StockSeries=i.CandleStickSeries.inherit({ctor:function(n,t,i){i.specificType=i.specificType||"stock",this.callBase(n,t,i)}})}(jQuery,DevExpress),function(n,t){var i=t.viz.charts.series,r=function(i){var u=this,r=[];u.preparedSegments=u.preparedSegments||[],n.each(u.segments[i],function(n,i){var u,f;if(!n){r.push(i);return}u=r[r.length-1].y,u!==i.y&&(f=t.utils.clone(i),f.y=u,r.push(f)),r.push(i)}),u.preparedSegments[i]=r};i.StepLineSeries=i.LineSeries.inherit({ctor:function(n,t,i,r){this.type=i.specificType=i.specificType||"stepline",this.callBase(n,t,i,r)},prepareSegments:r}),i.StepAreaSeries=i.AreaSeries.inherit({ctor:function(n,t,i,r){this.type=i.specificType=i.specificType||"steparea",this.callBase(n,t,i,r)},prepareSegments:r})}(jQuery,DevExpress),function(n,t){t.viz.charts.series.SeriesFamily=t.Class.inherit(function(){var h=function(t){var r=this,u=n.noop;n.extend(r,t),r.type=r.type.toLowerCase(),r.series=[];switch(r.type){case"bar":r.adjustSeriesDimensions=f,r.adjustSeriesValues=u,r.updateSeriesValues=y;break;case"rangebar":r.adjustSeriesDimensions=f,r.adjustSeriesValues=u,r.updateSeriesValues=u;break;case"fullstackedbar":r.fullStacked=!0,r.adjustSeriesDimensions=e,r.adjustSeriesValues=i,r.updateSeriesValues=s;break;case"stackedbar":r.adjustSeriesDimensions=e,r.adjustSeriesValues=i,r.updateSeriesValues=s;break;case"fullstackedarea":case"fullstackedline":r.fullStacked=!0,r.adjustSeriesDimensions=u,r.adjustSeriesValues=i,r.updateSeriesValues=u;break;case"stackedarea":case"stackedline":r.adjustSeriesDimensions=u,r.adjustSeriesValues=i,r.updateSeriesValues=u;break;case"candlestick":case"stock":r.adjustSeriesDimensions=p,r.adjustSeriesValues=u,r.updateSeriesValues=u;break;default:r.adjustSeriesDimensions=u,r.adjustSeriesValues=u,r.updateSeriesValues=u}},c=function(){this.series=null,this.translator=null},l=function(t){var u=this,r,i;for(n.isArray(t)||(t=[t]),i=0;i<t.length;i++)r=t[i],r.type.toLowerCase()===u.type&&u.series.push(r)},r=function(t,i,r,u,f){var e,o,g,c,h,a,d,nt,p,l,w={},v={},b,y,s=Math.round,k;if(u)for(o=u.width&&u.width<0?0:u.width,e=u.spacing&&u.spacing<0?0:u.spacing,o&&!e?r>1?(e=s((i*.7-o*r)/(r-1)),e<1&&(e=1)):e=0:e&&!o?(o=s((i*.7-e*(r-1))/r),o<2&&(o=2)):e||o||(r>1?(e=s(i*.7/r*.2),e<1&&(e=1)):e=0,o=s((i*.7-e*(r-1))/r),o<2&&(o=2)),o*r+e*(r-1)>i&&(e=s((i*.7-o*r)/(r-1)),e<1&&(e=1,g=s((i*.7-e*(r-1))/r))),c=r/2,a=0;a<t.length;a++)h=f(a),nt=t[a].getPoints(),p=(h-c+.5)*(g||o)-(c-h-.5)*e,n.each(nt,function(n,t){t.correctCoordinates({width:o,offset:p})});else{n.each(t,function(n,t){l=t.getStackName&&t.getStackName(),l=l||n.toString(),v[l]||(v[l]=[]),v[l].push(t)}),n.each(t,function(t,i){n.each(i.getPoints(),function(n,t){var i=t.argument;w.hasOwnProperty(i)||(w[i]=1)})});for(k in w)w.hasOwnProperty(k)&&(b=[],n.each(v,function(t,i){n.each(i,function(n,i){return d=i.getPointByArg(k),d&&d.value?(b.push(t),!1):void 0})}),y=b.length,e=s(i*.7/y*.2),e<1&&(e=1),o=s((i*.7-e*(y-1))/y),o<2&&(o=2),c=y/2,n.each(v,function(t,i){(h=n.inArray(t,b),h!==-1)&&(p=(h-c+.5)*o-(c-h-.5)*e,n.each(i,function(n,t){var i=t.getPointByArg(k);i&&i.value&&i.correctCoordinates({width:o,offset:p})}))}))}},f=function(n){var t=this,i=t.series,e=t.equalBarWidth,f;t.translator=n,f=u(t),r(i,f,i.length,e,function(n){return n})},e=function(t){var i=this,o,f=i.series,e={},s=0,h=i.equalBarWidth;n.each(f,function(){var n=this.getStackName();e.hasOwnProperty(n)||(e[n]=s++)}),i.translator=t,o=u(i),r(f,o,s,h,function(n){return e[f[n].getStackName()]})},i=function(){var i=this,r=i.series,t={positive:{},negative:{}};n.each(r,function(i,r){var u=r.getPoints();n.each(u,function(n,i){var o=i.value,e=i.argument,s=r.getStackName?r.getStackName():"default",h=o>=0?"positive":"negative",f;t[h][s]=t[h][s]||{},f=t[h][s],f[e.valueOf()]?(u[n].correctValue(f[e.valueOf()]),f[e.valueOf()]+=o):f[e.valueOf()]=o})}),i.fullStacked&&a(r,t)},a=function(t,i){n.each(t,function(t,r){var u=r.getPoints();n.each(u,function(n,t){var s=t.value,f=r.getStackName?r.getStackName():"default",e=s>=0?"positive":"negative",o;i[e][f]=i[e][f]||{},o=i[e][f],u[n].normalizeValue(o[t.argument.valueOf()])})})},o=function(n,t,i){var u=n.rotated,r=t.getCanvasVisibleArea();return i&&!u?Math.abs(t.untranslateY(r.minY)-t.untranslateY(r.minY+i)):i&&u?Math.abs(t.untranslateX(r.minX)-t.untranslateX(r.minX+i)):void 0},s=function(t){var r=this,u=r.series,i={positive:{},negative:{}};n.each(u,function(u,f){var e=f.getPoints(),s=f.styles&&f.styles.minBarSize;n.each(e,function(n,u){var v=u.value,b=u.minValue,y=u.argument,h,l,c,p=f.getStackName?f.getStackName():"default",w=v>=0?"positive":"negative",a;c=o(r,t,s),i[w][p]=i[w][p]||{},a=i[w][p],a[y.valueOf()]?(l=Math.abs(b-v),h=c&&l<c&&l!==0?c:Math.abs(v-b),e[n].minValue=a[y.valueOf()],e[n].value=a[y.valueOf()]+h,a[y.valueOf()]+=h):(l=v,h=c&&l<c&&l!==0?c:v,e[n].value=h,a[y.valueOf()]=h)})}),r.fullStacked&&v(u,i)},v=function(i,r){n.each(i,function(i,u){var e=u.getStackName?u.getStackName():"default",f=u.getPoints();n.each(f,function(n,i){var h=i.value,s=i.argument,u=h>=0?"positive":"negative",o;r[u][e]=r[u][e]||{},o=r[u][e],f[n].value=f[n].value/o[s.valueOf()]||0,t.utils.isNumber(f[n].minValue)&&(f[n].minValue=f[n].minValue/o[s.valueOf()]||0)})})},y=function(t){var i=this,r=i.series,u=i.rotated,f=t.getCanvasVisibleArea();n.each(r,function(r,u){var f=u.getPoints(),e=u.styles&&u.styles.minBarSize;n.each(f,function(n,r){var s=r.value,h,c,u;u=o(i,t,e),c=Math.abs(s),h=u&&c<u&&c!==0?s>0?u:-u:s,f[n].value=h})})},p=function(n){var t=this,i=t.series,f;t.translator=n,f=u(t),r(i,f,i.length,!0,function(n){return n})},u=function(n){return n.interval=n.rotated?n.translator.getIntervalY():n.translator.getIntervalX()};return{ctor:h,dispose:c,add:l}}())}(jQuery,DevExpress),function(n,t){var r=t.viz.charts,i=r.series,u=t.viz.renderers;r.factory=function(){var n=function(n,t,r,u){u=u||{},u.specificType=null,n=(String(n)||"").toLowerCase();switch(n.toLowerCase()){case"line":return new i.LineSeries(t,r,u);case"fullstackedline":return u.specificType="fullstackedline",new i.LineSeries(t,r,u);case"stackedline":return u.specificType="stackedline",new i.LineSeries(t,r,u);case"area":return new i.AreaSeries(t,r,u);case"fullstackedarea":return u.specificType="fullstackedarea",new i.AreaSeries(t,r,u);case"stackedarea":return u.specificType="stackedarea",new i.AreaSeries(t,r,u);case"bar":return new i.BarSeries(t,r,u);case"fullstackedbar":return u.specificType="fullstackedbar",new i.BarSeries(t,r,u);case"stackedbar":return u.specificType="stackedbar",new i.BarSeries(t,r,u);case"spline":return new i.SplineSeries(t,r,u);case"splinearea":return new i.SplineAreaSeries(t,r,u);case"scatter":return new i.ScatterSeries(t,r,u);case"candlestick":return new i.CandleStickSeries(t,r,u);case"stock":return new i.StockSeries(t,r,u);case"rangearea":return new i.RangeAreaSeries(t,r,u);case"rangebar":return new i.RangeBarSeries(t,r,u);case"pie":return new i.PieSeries(t,r,u);case"doughnut":case"donut":return u.specificType="doughnut",new i.PieSeries(t,r,u);case"stepline":return new i.StepLineSeries(t,r,u);case"steparea":return new i.StepAreaSeries(t,r,u);default:return null}},f=function(n){return new i.SeriesFamily(n)},e=function(n,t){return new r.Axis(n,t)},o=function(n){return new u.Renderer(n)},s=function(n,t){return new r.ThemeManager(n,t)},h=function(n,t,i){return new r.Legend(n,t,i)},c=function(n,t){return new r.Tooltip(n,t)},l=function(n){return new r.Tracker(n)},a=function(n,t,i,u){return new r.ChartTitle(n,t,i,u)},v=function(){return new r.LayoutManager},y=function(){return t.viz.core.tickProvider};return{createSeries:n,createSeriesFamily:f,createAxis:e,getAxisTickProvider:y,createRenderer:o,createThemeManager:s,createLegend:h,createTooltip:c,createTracker:l,createChartLayoutManager:v,createTitle:a}}()}(jQuery,DevExpress),function(n,t){var s=t.viz.charts,u=s.series.consts.events,h=t.utils,c=h.isFunction,r=h.isDefined,f="multiple",e="single",o="allargumentpoints",l="allseriespoints",i=window.navigator.msPointerEnabled&&window.navigator.msMaxTouchPoints||null,v=1e3,y=600,p=400,a="none";s.Tracker=t.Class.inherit({ctor:function(n){n.events=n.events||{},this._reinit(n),this.pointSelectionMode=this._prepareMode(n.pointSelectionMode),this.seriesSelectionMode=this._prepareMode(n.seriesSelectionMode),this.hoverStartDelay=100,this.hoverHoldDelay=200,this.sensitivity=7,this.pointSelectionMode===f?(this._releaseSelectedPoint=this._releaseSelectedPointMultiMode,this.selectedPoint=[]):this._releaseSelectedPoint=this._releaseSelectedPointSingleMode,this.seriesSelectionMode===f?(this._releaseSelectedSeries=this._releaseSelectedSeriesMultiMode,this.selectedSeries=[]):this._releaseSelectedSeries=this._releaseSelectedSeriesSingleMode,this.tooltipEnabled=n.tooltipEnabled,this.tooltipShown=n.tooltipShown,this.tooltipHidden=n.tooltipHidden,this.seriesClick=n.events.seriesClick,this.pointClick=n.events.pointClick,this.argumentAxisClick=n.events.argumentAxisClick,this.seriesHover=n.events.seriesHover,this.seriesSelected=n.events.seriesSelected,this.pointHover=n.events.pointHover,this.pointSelected=n.events.pointSelected,this.seriesTrackerGroup=n.seriesTrackerGroup,this.markerTrackerGroup=n.markerTrackerGroup,this.seriesGroup=n.seriesGroup,this.legendGroup=n.legendGroup;this.seriesGroup.on(u.selectSeries,{tracker:this},this._selectSeries);this.seriesGroup.on(u.deselectSeries,{tracker:this},this._deselectSeries);this.seriesGroup.on(u.selectPoint,{tracker:this},this._selectPoint);this.seriesGroup.on(u.deselectPoint,{tracker:this},this._deselectPoint);this.seriesGroup.on(u.showPointTooltip,{tracker:this},this._showPointTooltip);this.seriesGroup.on(u.hidePointTooltip,{tracker:this},this._hidePointTooltip)},_reinit:function(n){n=n||{},this.storedSeries=n.series||[],this.argumentAxis=n.argumentAxis||[]},dispose:function(){var t=this;clearTimeout(t.tooltipHoldTimeout),clearTimeout(t.hoverStartTimeOut),clearTimeout(t.hoverHoldTimeOut),clearTimeout(t.unlockMouseTimer),clearTimeout(t.lockClickTimer),n.each(t.argumentAxis,function(n,t){t._axisElementsGroup&&t._axisElementsGroup.off()}),t.seriesTrackerGroup.off(),t.markerTrackerGroup.off(),t.legendGroup.off(),t.seriesGroup.off(),t.argumentAxis=null,t.seriesTrackerGroup=null,t.markerTrackerGroup=null,t.legendGroup=null,t.seriesGroup=null,t.selectedPoint=null,t.selectedSeries=null,t.hoveredSeries=null,t.hoveredPoint=null,t.storedSeries=null,t.argumentAxis=null,t.hoveredObject=null,t.pointAtShownTooltip=null},_prepareMode:function(n){return n=(n||"").toLowerCase(),n=n!==e&&n!==f?e:n},_prepare:function(t){var i=this;i._prepared||(n.each(i.argumentAxis,function(n,t){i._eventHandler(t._axisElementsGroup,{parser:i._getOptionsAxis,condition:i._axisCondition,execute:i._axisEvent},{tracker:i,axis:t})}),i._eventHandler(i.seriesTrackerGroup,{parser:i._getOptionsPointSeries,condition:i._seriesCondition,execute:i._seriesEvent},{tracker:i}),i._eventHandler(i.markerTrackerGroup,{parser:i._getOptionsPointSeries,condition:i._pointCondition,execute:i._pointEvent},{tracker:i}),t==="pieChart"?i._eventHandler(i.legendGroup,{parser:i._getOptionsPointSeries,condition:i._pointCondition,execute:i._pointEvent},{tracker:i}):i._eventHandler(i.legendGroup,{parser:i._getOptionsPointSeries,condition:i._seriesCondition,execute:i._seriesEvent},{tracker:i}),i._prepared=!0)},_eventHandler:function(n,t,i){var r=this._designerHandlers(t);n.on(r,i)},_designerHandlers:function(t){var r={},u=t.parser,i=t.condition,f=t.execute,e=function(n,t){i&&i[n]===null||(r[n]=function(r){var f=u?u(r):r;f&&(i&&i[n]&&i[n].call?i[n].apply(null,f.concat([t])):t.apply(null,f))})};return n.each(f,e),r},_getOptionsPointSeries:function(t){var i=n(t.target).data("point")||n(t.target).data("series"),r=t.data.tracker,u=i&&(n(t.target).data("mode")||i.options.hoverMode);return t.type==="mousemove"?[r,t.pageX,t.pageY]:i?[r,i,u]:null},_getOptionsAxis:function(t){var u=t.data.tracker,i=t.data.axis,f=i.options.hoverMode,r;return(r=t.target.tagName==="tspan"?n(t.target).parent().data("argument"):n(t.target).data("argument"),t.type==="mousemove")?[u,t.pageX,t.pageY]:i?[u,i,f,r]:null},_pointEvent:{mouseover:function(n,t,i){n.mouseLocked||(n._setHoveredPoint(t,i),n.tooltipEnabled&&n._showTooltip(n.tooltip,t))},mouseout:function(n){n.mouseLocked||n._clearHover(n)},mousemove:function(n,t,i){n._getCurCoords(n,t,i)},touchstart:function(n,t){n.showHoldTooltip=!1,n._mouseLock(n),n.tooltipEnabled&&(n.tooltipHoldTimeout=setTimeout(function(){n.showHoldTooltip=!0,n._showTooltip(n.tooltip,t)},p))},touchend:function(n,t){n.showHoldTooltip||n._pointClick(n,t,!0),clearTimeout(n.tooltipHoldTimeout),n._clickLock(n),n._clearHover(n)},click:function(n,t){n._pointClick(n,t,!1)},mousedown:function(n,t,i){n._pointEvent.touchstart(n,t,i)},mouseup:function(n,t,i){n._pointEvent.touchend(n,t,i)}},_pointCondition:{mouseover:function(n,t,i,r){if(i===o&&n.hoveredPoint&&n.hoveredPoint.argument===t.argument){n.hoverHoldTimeOut=clearTimeout(n.hoverHoldTimeOut),n.hoveredObject=t,r(n,t,i);return}n._setHover(n,t,i,r)},mouseout:function(n,t,i,r){n._releaseHover(n,t,i,r)},touchstart:!i,touchend:!i,mousedown:i,mouseup:i},_seriesEvent:{mouseover:function(n,t,i){n.mouseLocked||n._setHoveredSeries(t,i)},mouseout:function(n){n._clearHover(n)},mousemove:function(n,t,i){n._getCurCoords(n,t,i)},touchstart:function(n){n._mouseLock(n)},touchend:function(n,t){n._seriesClick(n,t,!0),n._clickLock(n)},click:function(n,t){n._seriesClick(n,t,!1)},mousedown:function(n,t,i){n._seriesEvent.touchstart(n,t,i)},mouseup:function(n,t,i){n._seriesEvent.touchend(n,t,i)}},_seriesCondition:{mouseover:function(n,t,i,r){n._setHover(n,t,i,r)},mouseout:function(n,t,i,r){n._releaseHover(n,t,i,r)},touchstart:!i,touchend:!i,mousedown:i,mouseup:i},_axisEvent:{mouseover:function(t,i,u){t.mouseLocked||r(t.hoveredArgument)&&t.hoveredArgument===u||(t._clearHover(t),r(t.hoveredArgument)&&t._toAllArgumentPoints(t.hoveredArgument,"releasePointHoverState"),t._toAllArgumentPoints(u,"setPointHoverState"),t.hoveredArgument=u,n(i).trigger("testmousehoveraxis"))},mouseout:function(n){!n.mouseLocked&&r(n.hoveredArgument)&&(n._toAllArgumentPoints(n.hoveredArgument,"releasePointHoverState"),n.hoveredArgument=null)},mousemove:function(n,t,i){n._getCurCoords(n,t,i)},touchstart:function(n){n._mouseLock(n)},touchend:function(n,t,i,r){n._argumentAxisClick(n,t,r,!0),n._clearHover(n),n._clickLock(n)},click:function(n,t,i,r){n._clearHover(n),n._argumentAxisClick(n,t,r,!1),n._clickLock(n)},mousedown:function(n){n._axisEvent.touchstart(n,point,mode)},mouseup:function(n,t,i,r){n._axisEvent.touchend(n,t,i,r)}},_axisCondition:{mouseover:function(n,t,i,r,u){i===o&&n._setHover(n,t,r,u)},mouseout:function(n,t,i,r,u){n._releaseHover(n,t,r,u)},touchstart:!i,touchend:!i,mousedown:i,mouseup:i},_setHover:function(n,t,i,r){(t!==n.hoveredObject||(n.hoverHoldTimeOut=clearTimeout(n.hoverHoldTimeOut),i!==t.lastHoverMode))&&(n.mouseLocked||(n.hoverStartTimeOut=setTimeout(function(){n._compareCoords(t,n,i,r)},n.hoverStartDelay)))},_releaseHover:function(n,t,i,r){n.mouseLocked||(n.hoverStartTimeOut=clearTimeout(n.hoverStartTimeOut),t===n.hoveredObject&&(n.hoverHoldTimeOut=setTimeout(function(){n.hoveredObject=null,r(n,t,i)},n.hoverHoldDelay)))},_compareCoords:function(n,t,i,r){if(clearTimeout(t.hoverStartTimeOut),Math.abs(t.pX-t.cX)+Math.abs(t.pY-t.cY)<t.sensitivity){if(t.mouseLocked)return;clearTimeout(t.hoverHoldTimeOut),t.hoveredObject=n,r(t,n,i)}else t.pX=t.cX,t.pY=t.cY,t.hoverStartTimeOut=setTimeout(function(){t._compareCoords(n,t,i,r)},t.hoverStartDelay)},_seriesClick:function(n,t,i){(!n.lockClick||i)&&n.seriesClick&&n.seriesClick.call&&n.seriesClick.call(t,t)},_pointClick:function(t,i,r){var u=i.series;if(!t.lockClick||r){if(t.pointClick&&t.pointClick.call&&t.pointClick!=n.noop){t.pointClick.call(i,i);return}t.seriesClick&&t.seriesClick.call&&t.seriesClick.call(u,u);return}},_argumentAxisClick:function(n,t,i,r){(!n.lockClick||r)&&n.argumentAxisClick&&n.argumentAxisClick.call&&n.argumentAxisClick.call(t,t,i)},_selectSeries:function(n,t){n.data.tracker._setSelectedSeries(n.target,t)},_deselectSeries:function(n,t){n.data.tracker._releaseSelectedSeries(n.target,t)},_selectPoint:function(n,t){n.data.tracker._setSelectedPoint(t)},_deselectPoint:function(n,t){n.data.tracker._releaseSelectedPoint(t)},_showPointTooltip:function(n,t){var i=n.data.tracker;i._showTooltip(i.tooltip,t)},_hidePointTooltip:function(n,t){n.data.tracker._hideTooltip(t)},_hideTooltip:function(n){var t=this&&this.tooltip;t&&(!n||this.pointAtShownTooltip===n)&&(n=n||this.pointAtShownTooltip,t.hide(),this.pointAtShownTooltip&&c(this.tooltipHidden)&&this.tooltipHidden.call(n,n),this.pointAtShownTooltip=null)},_showTooltip:function(n,t){var f=t.getTooltipFormatObject(n),i,u;r(f.valueText)&&(this.pointAtShownTooltip&&this._hideTooltip(this.pointAtShownTooltip),i=t.getTooltipCoords(),u=n.formatTooltip.call(f,n.options),r(u)&&r(i.x)&&r(i.y)&&n)&&(n.show(),n.move(~~i.x,~~i.y,i.offset,u,t.getColor(),t.getClassName()),!this.pointAtShownTooltip&&c(this.tooltipShown)&&this.tooltipShown.call(t,t),this.pointAtShownTooltip=t)},_setHoveredSeries:function(n,t){var i=this;(t!==a&&i.hoveredSeries!==n||n.lastHoverMode!==t)&&(i._clearHover(i),i.hoveredSeries=n,n.setHoverState(t),i.seriesHover&&i.seriesHover.call&&i.seriesHover.call(n,n))},_setSelectedSeries:function(t,i){var r=this,u=!1;this.seriesSelectionMode===f?n.each(r.selectedSeries,function(n,i){if(i==t)return u=!0,!1}):r.selectedSeries==t&&(u=!0),u&&t.lastSelectionMode===i||(r.seriesSelectionMode===e?(this._releaseSelectedSeries(),r.selectedSeries=t):r.selectedSeries.push(t),t.setSelectedState(i),r.seriesSelected&&r.seriesSelected.call&&r.seriesSelected.call(t,t))},_setHoveredPoint:function(n,t){var i=this;(i.hoveredPoint!==n||n.series)&&(i._clearHover(i),i.hoveredPoint=n,i._setHoverStylePointWithMode(n,"setPointHoverState",t||n.options.hoverMode),i.pointHover&&i.pointHover.call&&i.pointHover.call(n,n))},_toAllArgumentPoints:function(t,i){n.each(this.storedSeries,function(n,r){var u=r.getPointByArg(t);u&&r[i](u)})},_setHoverStylePointWithMode:function(t,i,r){switch(r){case o:this._toAllArgumentPoints(t.argument,i);break;case l:n.each(t.series.points,function(n,t){t.series[i](t)});break;case a:break;default:t.series[i](t)}},_setSelectedPoint:function(t){var i=this,r=!1;this.pointSelectionMode===f?(n.each(i.selectedPoint,function(n,i){if(i==t)return r=!0,!1}),r||i.selectedPoint.push(t)):i.selectedPoint!==t?(this._releaseSelectedPoint(),i.selectedPoint=t):r=!0,r||(i._setHoverStylePointWithMode(t,"setPointSelectedState",t.options.selectionMode),i.pointSelected&&i.pointSelected.call&&i.pointSelected.call(t,t))},_releaseHoveredSeries:function(){this.hoveredSeries&&(this.hoveredSeries.releaseHoverState(),this.hoveredSeries=null)},_releaseSelectedSeriesMultiMode:function(t){this.selectedSeries&&(t.releaseSelectedState(),this.selectedSeries=n.map(this.selectedSeries,function(n){if(n!==t)return n}))},_releaseSelectedSeriesSingleMode:function(){this.selectedSeries&&(this.selectedSeries.releaseSelectedState(),this.selectedSeries=null)},_releaseHoveredPoint:function(){var i=this,t=i.hoveredPoint;(i.tooltipEnabled&&!i.showHoldTooltip&&i._hideTooltip(t),t)&&(t.options.hoverMode===l?n.each(t.series.points,function(n,t){t.series.releasePointHoverState(t)}):t.options.hoverMode===o?i._toAllArgumentPoints(t.argument,"releasePointHoverState"):t.releaseHoverState(),i.hoveredPoint=null)},_releaseSelectedPointMultiMode:function(t){var i=this,r=i.selectedPoint;r&&(i._setHoverStylePointWithMode(t,"releasePointSelectedState",t.options.selectionMode),this.selectedPoint=n.map(this.selectedPoint,function(n){if(n!==t)return n}))},_releaseSelectedPointSingleMode:function(){var t=this,n=t.selectedPoint;n&&(t._setHoverStylePointWithMode(n,"releasePointSelectedState",n.options.selectionMode),this.selectedPoint=null)},clearSelection:function(){var t=this;this.pointSelectionMode===e?this._releaseSelectedPoint():n.each(this.selectedPoint,function(n,i){t._releaseSelectedPoint(i)}),this.seriesSelectionMode===e?this._releaseSelectedSeries():n.each(this.selectedSeries,function(n,i){t._releaseSelectedSeries(i)})},_mouseLock:function(n){n.unlockMouseTimer&&clearTimeout(n.unlockMouseTimer),n.mouseLocked=!0,n.unlockMouseTimer=setTimeout(function(){n.mouseLocked=!1},v)},_clickLock:function(n){n.lockClick=!0,n.lockClickTimer&&clearTimeout(n.lockClickTimer),n.lockClickTimer=setTimeout(function(){n.lockClick=!1},y)},_getCurCoords:function(n,t,i){n.cX=t,n.cY=i},_clearHover:function(n){n._releaseHoveredSeries(),n._releaseHoveredPoint()}})}(jQuery,DevExpress),function(n){n.viz.gauges={__internals:{circularNeedles:{},circularMarkers:{},linearNeedles:{},linearMarkers:{}}}}(DevExpress),function(n,t){var e=n.viz.gauges,h=n.viz.renderers,i=e.__internals,u=i.circularNeedles,o=i.circularMarkers,f=i.linearNeedles,s=i.linearMarkers,r=n.utils.isString;e.__factory={createTranslator:function(t,i,r,u){return new n.viz.core.Translator1D(r,u,t,i)},createRenderer:function(n){return new h.Renderer(n)},createCircularNeedle:function(n){if(r(n))switch(n.toLowerCase()){case"rectangle":return new u.RectangleNeedle;case"twocolorrectangle":return new u.TwoColorRectangleNeedle;case"triangle":return new u.TriangleNeedle}return t},createLinearNeedle:function(n){if(r(n))switch(n.toLowerCase()){case"rectangle":return new f.RectangleNeedle;case"rhombus":return new f.RhombusNeedle;case"circle":return new f.CircleNeedle}return t},createCircularMarker:function(n){if(r(n))switch(n.toLowerCase()){case"triangle":return new o.TriangleMarker;case"textcloud":return new o.TextCloudMarker}return t},createLinearMarker:function(n){if(r(n))switch(n.toLowerCase()){case"triangle":return new s.TriangleMarker;case"textcloud":return new s.TextCloudMarker}return t},createCircularRangeBar:function(){return new i.CircularRangeBar},createLinearRangeBar:function(){return new i.LinearRangeBar},createCircularScale:function(){return new i.CircularScale},createLinearScale:function(){return new i.LinearScale},createCircularRangeContainer:function(){return new i.CircularRangeContainer},createLinearRangeContainer:function(){return new i.LinearRangeContainer},createCircularSpindle:function(){return new i.CircularSpindle},createTitle:function(){return new i.Title},createIndicator:function(){return i.Indicator&&new i.Indicator||null},createTooltip:function(){return new i.Tooltip},createLayoutManager:function(){return new i.LayoutManager},createThemeManager:function(n){return new i.ThemeManager(n)},createPresetManager:function(){return new i.PresetManager},createTracker:function(){return new i.Tracker}}}(DevExpress),function(n,t){var r=t.extend;n.viz.gauges.__internals.BaseGaugeItem=n.Class.inherit({ctor:function(){this._options={}},_getDefaultOptions:function(){return{}},create:function(n){var t=this;return t._renderer=n.renderer,t._rootElement=t._renderer.createGroup().append(n.ownerElement),r(!0,t._options,t._getDefaultOptions(),n),t._create(n),t},update:function(n){var t=this;return r(!0,t._options,n),t._update(n),t},showTooltip:function(n,t,i){n&&n.$element&&n.$element.trigger("showToolTip",[t,i])},hideTooltip:function(n){n&&n.$element&&n.$element.trigger("hideToolTip")},destroy:function(){return this._rootElement.remove(),this}})}(DevExpress,jQuery),function(n,t,i){function h(n,t){var i=0,r=t.length-1,e=t[i]-t[r]<0,u,f=-1;for(t[i]===n&&(f=i),t[r]===n&&(f=r);f<0&&i<=r;)u=~~((i+r)/2),t[u]===n?f=u:t[u]-n<0===e?i=u+1:r=u-1;return f}function rt(n,t){var i,r,f;return n>t&&(f=t,t=n,n=f),i=0<=n&&n<=180?u(90-n):u(270-n),i=n<90&&90<t||n<270&&270<t?0:i,r=0<t&&t<180?u(90-t):u(270-t),i<r?i:r}var p=n.formatHelper,c=n.utils.getCosAndSin,l=n.utils.normalizeAngle,w=n.utils.convertAngleToRendererSpace,a=n.utils.isDefined,v=n.utils.isString,b=n.utils.isFunction,e=n.utils.isArray,k=window.isNaN,r=window.Number,d=window.String,o=Math.max,ut=Math.min,u=Math.abs,g=Math.atan,nt=Math.acos,y=Math.ceil,tt=t.extend,f=t.map,s=Math.PI,it=n.viz.core.tickProvider;n.viz.gauges.__internals.BaseScale=n.Class.inherit({setup:function(n){var t=this;return t._renderer=n.renderer,t._owner=n.owner,t._incidentOccured=n.incidentOccured,t},init:function(n){var t=this;return t._options=tt(!0,t._options||{},n),t._options.majorTick||(t._options.majorTick={}),t._options.minorTick||(t._options.minorTick={}),n&&n.majorTick&&a(n.majorTick.customTickValues)&&(t._options.majorTick.customTickValues=e(n.majorTick.customTickValues)?n.majorTick.customTickValues.slice(0):null),n&&n.minorTick&&a(n.minorTick.customTickValues)&&(t._options.minorTick.customTickValues=e(n.minorTick.customTickValues)?n.minorTick.customTickValues.slice(0):null),delete t._processed,t},_getCustomValues:function(n,t){var u=this._options.translator,i=[];return e(n)&&(i=f(n,function(n){return k(u.translate(n))?null:r(n)}).sort(t),i=f(i,function(n,t){return n!==i[t-1]?n:null})),i},_getTicks:function(){var u=this,n=u._options,s=n.translator,y=s.getDomainStart(),p=s.getDomainEnd(),l=y<p?function(n,t){return n-t}:function(n,t){return t-n},w=u._getGridSpacingFactor(),a,t,e,o,c,b,v={};return a=it.getFullTicks(y,p,u._getScreenDelta(),{tickInterval:n.majorTick.tickInterval>0?r(n.majorTick.tickInterval):i,gridSpacingFactor:w.majorTicks,numberMultipliers:[1,2,5]},{tickInterval:n.minorTick.tickInterval>0?r(n.minorTick.tickInterval):i,gridSpacingFactor:w.minorTicks,numberMultipliers:[1,2,5]}),n.majorTick.showCalculatedTicks?(t=a.majorTicks,n.majorTick.useTicksAutoArrangement&&(t=u._cutTicks(t))):t=[],o=u._getCustomValues(n.majorTick.customTickValues,l),o=f(o,function(n){return h(n,t)===-1?n:null}),e=n.minorTick.showCalculatedTicks?a.minorTicks:[],e=f(e,function(n){return h(n,o)===-1?n:null}),c=u._getCustomValues(n.minorTick.customTickValues,l),b=t.concat(e,o).sort(l),c=f(c,function(n){return h(n,b)===-1?n:null}),v.major=f(t.concat(o),function(n){return{value:n,position:s.translate(n)}}),v.minor=f(e.concat(c),function(n){return{value:n,position:s.translate(n)}}),v},_cutTicks:function(n){for(var t=this,u=t._getCuttingFactor(n.length,{width:t._textWidth,height:t._textHeight}),r=[],i=0,f=n.length;i<f;i+=u)r.push(n[i]);return r},_renderContent:function(n){var t=this,r=t._options,i,u,e,f,o,h,c,l,s;if(t._majorTickLength&&t._majorTickWidth)for(h=v(r.majorTick.color)?r.majorTick.color:"none",f=t._getTickPoints(t._majorTickLength,t._majorTickWidth),i=0,u=n.major.length,r.hideFirstTick===!0&&++i,r.hideLastTick===!0&&--u;i<u;++i)e=n.major[i],o=t._renderer.createArea(f,{"class":"dx-major-tick",fill:h,stroke:"none",strokeWidth:0}),t._moveTick(o,e),o.append(t._majorTicks);if(t._minorTickLength&&t._minorTickWidth)for(c=v(r.minorTick.color)?r.minorTick.color:"none",f=t._getTickPoints(t._minorTickLength,t._minorTickWidth),i=0,u=n.minor.length;i<u;++i)e=n.minor[i],o=t._renderer.createArea(f,{"class":"dx-minor-tick",fill:c,stroke:"none",strokeWidth:0}),t._moveTick(o,e),o.append(t._minorTicks);if(t._textIndent)for(l=t._getLabelPosition(t._majorTickLength||0,t._textIndent),i=0,u=n.major.length,r.hideFirstLabel===!0&&++i,r.hideLastLabel===!0&&--u;i<u;++i)e=n.major[i],s=t._formatValue(e.value),f=t._getLabelOptions(s,l,t._textIndent,e),t._renderer.createText(s,f.x,f.y+t._textVerticalOffset,{"class":"dx-gauge-scale-label",align:f.align,font:r.label.font}).append(t._labels)},_processOptions:function(){var n=this,t=n._options;n._processed||(n._processed=!0,n._setupOrientation(),t.majorTick.visible&&(t.majorTick.length>0?n._majorTickLength=r(t.majorTick.length):n._incidentOccured('Major ticks are not rendered because the value of "majorTick.length" option is not valid'),t.majorTick.width>0?n._majorTickWidth=r(t.majorTick.width):n._incidentOccured('Major ticks are not rendered because the value of "majorTick.width" option is not valid')),t.minorTick.visible&&(t.minorTick.length>0?n._minorTickLength=r(t.minorTick.length):n._incidentOccured('Minor ticks are not rendered because the value of "minorTick.length" option is not valid'),t.minorTick.width>0?n._minorTickWidth=r(t.minorTick.width):n._incidentOccured('Minor ticks are not rendered because the value of "minorTick.width" option is not valid')),t.label.visible&&(r(t.label.indentFromTick)!==0?(n._textIndent=r(t.label.indentFromTick),n._measureText()):n._incidentOccured('Labels are not rendered because the value of the "label.indentFromTick" option is not valid')))},render:function(){var n=this,t;return n._rootElement||(n._rootElement=n._renderer.createGroup({"class":"scale"}),n._majorTicks=n._renderer.createGroup({"class":"dx-major-ticks"}).append(n._rootElement),n._minorTicks=n._renderer.createGroup({"class":"dx-minor-ticks"}).append(n._rootElement),n._labels=n._renderer.createGroup({"class":"labels"}).append(n._rootElement)),n._rootElement.append(n._owner),n._majorTicks.clear(),n._minorTicks.clear(),n._labels.clear(),n._processOptions(),n._isVisible()?(t=n._getTicks(),n._renderContent(t)):n._rootElement&&(n._rootElement.remove(),delete n._rootElement,delete n._majorTicks,delete n._minorTicks,delete n._labels),n},_formatValue:function(n){var i=this._options.label,t=p.format(n,i.format,i.precision);return b(i.customizeText)&&(t={value:n,valueText:t},t=d(i.customizeText.call(t,t))),t},_getSampleText:function(){var i=this,f=i._options.translator.getDomainStart(),e=i._options.translator.getDomainEnd(),r=[],n,t,u,o=0,s;for(r.push(i._formatValue(f)),n=1,t=8;n<t;++n)r.push(i._formatValue(((t-n)*f+n*e)/t));for(r.push(i._formatValue(e)),n=0,t=r.length;n<t;++n)u=r[n],u.length>o&&(s=u)&&(o=u.length);return s},_measureText:function(){var n=this,i=n._renderer.createGroup({"class":"scale"}).append(n._rootElement),u=n._renderer.createGroup({"class":"labels"}).append(i),r=n._getSampleText(),f=n._renderer.createText(r,0,0,{"class":"dx-gauge-scale-label",align:"center",font:n._options.label.font}).append(u),t=f.getBBox();i.remove(),n._textVerticalOffset=-t.y-t.height/2,n._textWidth=t.width,n._textHeight=t.height,n._textLength=r.length}}),n.viz.gauges.__internals.CircularScale=n.viz.gauges.__internals.BaseScale.inherit({_getGridSpacingFactor:function(){return{majorTicks:17,minorTicks:5}},_getScreenDelta:function(){var n=this._options;return(n.translator.getCodomainStart()-n.translator.getCodomainEnd())*n.radius*s/180},_getCuttingFactor:function(n,t){var i=this,w=i._options,b=w.translator.getCodomainStart(),k=w.translator.getCodomainEnd(),f=i._getLabelPosition(i._majorTickLength||0,i._textIndent),e=rt(l(b),l(k)),h=c(e),d=(b-k)/n,a,v,tt,p,r,it=1;return tt=(h.sin*f+t.width)/(h.cos*f),v=u(e-g(tt)*180/s),r=h.cos-t.height/f,p=-1>r||r>1?90:u(e-nt(r)*180/s),a=v<p?v:p,d<a&&(it=y(a/d)),o(1,it)},_setupOrientation:function(){var n=this,t=0,i=0;switch(n._options.orientation){case"inside":t=1;break;case"center":t=i=.5;break;default:n._options.orientation!=="outside"&&n._incidentOccured('The value of the "orientation" option is not valid'),i=1}n._inner=t,n._outer=i},_getTickPoints:function(n,t){var i=this._options,r=i.x-t/2,u=i.x+t/2,f=i.y-i.radius-n*this._outer,e=i.y-i.radius+n*this._inner;return[r,f,u,f,u,e,r,e]},_moveTick:function(n,t){n.rotate(w(t.position),this._options.x,this._options.y)},_getLabelPosition:function(n,t){return this._options.radius+n*(t>=0?this._outer:-this._inner)+t},_getLabelOptions:function(n,t,i,r){var u=this,s=u._options,f=c(r.position),e=s.x+f.cos*t,o=s.y-f.sin*t,h=f.cos*(n.length/u._textLength)*u._textWidth/2,l=f.sin*u._textHeight/2;return i>0?(e+=h,o-=l):(e-=h,o+=l),{x:e,y:o,align:"center"}},_isVisible:function(){var n=this,t=n._majorTickLength||0,i=n._options.radius,r=i-n._inner*t,u=i+n._outer*t;return r>0&&u>r},measure:function(){var n=this,i=n._options,t={min:i.radius,max:i.radius};return n._processOptions(),n._majorTickLength&&(t.min-=n._inner*n._majorTickLength,t.max+=n._outer*n._majorTickLength),n._textIndent&&(n._textIndent>=0?(t.horizontalOffset=n._textIndent+n._textWidth,t.verticalOffset=n._textIndent+n._textHeight):(t.horizontalOffset=0,t.verticalOffset=0,t.min+=n._textIndent-o(n._textWidth,n._textHeight)),t.inverseHorizontalOffset=n._textWidth/2,t.inverseVerticalOffset=n._textHeight/2),t}}),n.viz.gauges.__internals.LinearScale=n.viz.gauges.__internals.BaseScale.inherit({_getGridSpacingFactor:function(){return{majorTicks:25,minorTicks:5}},_getScreenDelta:function(){return u(this._options.translator.getCodomainEnd()-this._options.translator.getCodomainStart())},_getCuttingFactor:function(n,t){var i=this._options,r=this._vertical?t.height:t.width,f=u(i.translator.getCodomainEnd()-i.translator.getCodomainStart());return o(1,y(n*r/(f+r)))},_setupOrientation:function(){var n=this,t=0,i=0;if(n._vertical=n._options.orientation==="vertical",n._vertical)switch(n._options.horizontalOrientation){case"left":t=1;break;case"center":t=i=.5;break;default:n._options.horizontalOrientation!=="right"&&n._incidentOccured('The value of the "horizontalOrientation" option is not valid'),i=1}else switch(n._options.verticalOrientation){case"top":t=1;break;case"middle":t=i=.5;break;default:n._options.verticalOrientation!=="bottom"&&n._incidentOccured('The value of the "verticalOrientation" option is not valid'),i=1}n._inner=t,n._outer=i},_getTickPoints:function(n,t){var i=this._options,r,u,f,e;return this._vertical?(r=i.x-n*this._inner,u=i.x+n*this._outer,f=-t/2,e=t/2):(r=-t/2,u=t/2,f=i.y-n*this._inner,e=i.y+n*this._outer),[r,f,u,f,u,e,r,e]},_moveTick:function(n,t){var u=this._options,i=0,r=0;this._vertical?r=t.position:i=t.position,n.move(i,r)},_getLabelPosition:function(n,t){var r=this._options,i=n*(t>=0?this._outer:-this._inner)+t;return i+=this._vertical?r.x:r.y+(t>=0?1:-1)*this._textVerticalOffset},_getLabelOptions:function(n,t,i,r){var u,f,e;return this._vertical?(u=t,f=r.position,e=i>0?"left":"right"):(u=r.position,f=t,e="center"),{x:u,y:f,align:e}},_isVisible:function(){return!0},measure:function(){var n=this,i=n._options,t;return n._processOptions(),n._vertical?(t={min:i.x,max:i.x},n._majorTickLength&&(t.min-=n._inner*n._majorTickLength,t.max+=n._outer*n._majorTickLength),n._textIndent&&(n._textIndent>=0?t.max+=n._textIndent+n._textWidth:t.min+=n._textIndent-n._textWidth,t.indent=n._textHeight/2)):(t={min:i.y,max:i.y},n._majorTickLength&&(t.min-=n._inner*n._majorTickLength,t.max+=n._outer*n._majorTickLength),n._textIndent&&(n._textIndent>=0?t.max+=n._textIndent+n._textHeight:t.min+=n._textIndent-n._textHeight,t.indent=n._textWidth/2)),t}})}(DevExpress,jQuery),function(n,t,i){var r=n.formatHelper,u=n.utils.isFunction,f=window.isFinite,s=window.Number,e=window.String,o=t.extend;n.viz.gauges.__internals.BaseIndicator=n.viz.gauges.__internals.BaseGaugeItem.inherit({setup:function(n){var t=this;return t._renderer=n.renderer,t._owner=n.owner,t._trackerOwner=n.tracker,t._options={},t},init:function(n){return o(!0,this._options,n||{}),this},render:function(){var n=this;return n._actualValue=n._currentValue=n._options.translator.adjust(n._options.currentValue),n._isCurrentValueLocked=!1,delete n._setCurrentValueNext,delete n._setCurrentValueHas,n._animateStep=n._animateStep||function(t,i){var r=n;r._updateActualValue(r._animateStart+r._animateDelta*i.pos)},n._animateComplete=n._animateComplete||function(){var t=n;t._setCurrentValueHas?(t._runAnimation(t._actualValue,t._setCurrentValueNext),t._setCurrentValueHas=!1):(t._isCurrentValueLocked=!1,delete t._animateStart,delete t._animateDelta),t._setCurrentValueNext=i},n},_formatValue:function(n){var t=this._options.text,i=r.format(n,t.format,t.precision),f={value:n,valueText:i};return u(t.customizeText)?e(t.customizeText.call(f,f)):i},_getActualPosition:function(){return this._options.translator.translate(this._actualValue)},_getSampleText:function(){var n=this,t=n._options,i,r,u;return t.text&&(i=n._formatValue(t.translator.getDomainStart()),r=n._formatValue(t.translator.getDomainEnd()),u=i.length>=r.length?i:r),u},_updateActualValue:function(n){this._actualValue=n,this._updateActiveElements()},_runAnimation:function(n,t){var i=this;i._isCurrentValueLocked=!0,i._animateStart=n,i._animateDelta=t-n,i._rootElement.animate({fake:!0},{duration:i._options.animationDuration,step:i._animateStep,complete:i._animateComplete})},getCurrentValue:function(){return this._currentValue},setCurrentValue:function(n){var t=this,i=t._options.translator.adjust(n);return t._currentValue!==i&&f(i)&&(t._currentValue=i,t._rootElement&&(t._options.animationEnabled?t._isCurrentValueLocked?(t._setCurrentValueNext=i,t._setCurrentValueHas=!0):t._runAnimation(t._actualValue,i):t._updateActualValue(i))),t._currentValue}})}(DevExpress,jQuery),function(n,t){var u=t.extend,r=n.viz.core.TextCloud;n.viz.gauges.__internals.BaseTextCloudMarker=n.viz.gauges.__internals.BaseIndicator.inherit({_updateActiveElements:function(){var n=this,i,t=new r,u=n._getTextCloudOptions();n._text.applySettings({text:n._formatValue(n._actualValue)}),i=n._text.getBBox(),t.setup({x:u.x,y:u.y,textWidth:i.width,textHeight:i.height,horMargin:n._options.horizontalOffset,verMargin:n._options.verticalOffset,tailLength:n._options.arrowLength,type:u.type}),n._text.applySettings({x:t.cx(),y:t.cy()+n._textVerticalOffset}),n._cloud.applySettings({points:t.points()}),n._tracker.applySettings({points:t.points()})},_measureText:function(){var n=this,t;n._rootElement=n._rootElement||n._renderer.createGroup({"class":"marker"}),n._rootElement.append(n._owner),n._cloud=n._cloud||n._renderer.createArea().append(n._rootElement),n._text=n._text||n._renderer.createText().append(n._rootElement),n._text.applySettings({x:0,y:0,align:"center",font:n._options.text.font,text:n._getSampleText()}),t=n._text.getBBox(),n._textVerticalOffset=-t.y-t.height/2,n._textWidth=t.width,n._textHeight=t.height,n._textFullWidth=n._textWidth+2*n._options.horizontalOffset,n._textFullHeight=n._textHeight+2*n._options.verticalOffset},render:function(){var n=this;return n.callBase(),n._isVisible()?(n._measureText(),n._tracker=n._tracker||n._renderer.createArea([],{stroke:"none",strokeWidth:0,fill:"#000000",opacity:.0001}).append(n._trackerOwner),n._cloud.applySettings({stroke:"none",strokeWidth:0,fill:n._options.color}),n._updateActiveElements()):n.clear(),n},clear:function(){var n=this;n._rootElement&&(n._rootElement.remove(),delete n._rootElement,delete n._cloud,delete n._text,delete n._tracker)},getTrackingElement:function(){return this._tracker},getTooltipParameters:function(){var n=this._getTextCloudOptions();return{x:n.x,y:n.y,value:this._currentValue,color:this._options.color}}})}(DevExpress,jQuery),function(n,t,i){var r=t.extend;n.viz.gauges.__internals.BaseRangeBar=n.viz.gauges.__internals.BaseIndicator.inherit({_prepare:function(){var n=this,t;n._hasText=n._isTextVisible(),n._hasText&&(n._rootElement=n._rootElement||n._renderer.createGroup({"class":"rangebar"}).append(n._owner),n._text=n._text||n._renderer.createText().append(n._rootElement),n._text.applySettings({x:0,y:0,align:n._getTextAlign(),font:n._getFontOptions(),text:n._getSampleText()}),t=n._text.getBBox(),n._textVerticalOffset=-t.y-t.height/2,n._textWidth=t.width,n._textHeight=t.height)},_updateActiveElements:function(){var n=this;n._updateBarItemsPositions(),n._hasText&&(n._text.applySettings({text:n._formatValue(n._actualValue)}),n._updateTextPosition(),n._updateLinePosition())},_updateBarItems:function(){var n=this,t=n._options,i,r;n._setBarSides(),n._startPosition=t.translator.translate(t.translator.getDomainStart()),n._endPosition=t.translator.translate(t.translator.getDomainEnd()),n._basePosition=t.translator.translate(t.baseValue),n._space=n._getSpace(),i=t.backgroundColor||"none",i!=="none"&&n._space>0?r=t.containerBackgroundColor||"none":(n._space=0,r="none"),n._backItem1.applySettings({fill:i,stroke:"none",strokeWidth:0}),n._backItem2.applySettings({fill:i,stroke:"none",strokeWidth:0}),n._spaceItem1.applySettings({fill:r,stroke:"none",strokeWidth:0}),n._spaceItem2.applySettings({fill:r,stroke:"none",strokeWidth:0}),n._mainItem.applySettings({fill:t.color,stroke:"none",strokeWidth:0})},_getSpace:function(){return 0},_updateTextItems:function(){var n=this,t=n._options;n._isTextVisible()?(n._hasText=!0,n._createTextItems(),n._updateText(),n._updateLine(),n._setTextItemsSides()):(delete n._hasText,n._destroyTextItems())},_isTextVisible:function(){return!1},_createTextItems:function(){var n=this;n._line||(n._line=n._renderer.createPath().append(n._rootElement)),n._text||(n._text=n._renderer.createText().append(n._rootElement))},_destroyTextItems:function(){var n=this;n._line&&n._line.remove()&&delete n._line,n._text&&n._text.remove()&&delete n._text},_updateText:function(){var n=this,t;n._text.applySettings({x:0,y:0,align:n._getTextAlign(),font:n._getFontOptions(),text:n._getSampleText()}),t=n._text.getBBox(),n._textVerticalOffset=-t.y-t.height/2,n._textWidth=t.width,n._textHeight=t.height},_getTextAlign:function(){return i},_getFontOptions:function(){var t=this._options,n=t.text.font;return n&&n.color||(n=r({},n,{color:t.color})),n},_updateLine:function(){var n=this;n._line.applySettings({fill:n._options.color,stroke:"none",strokeWidth:0})},_updateBarItemsPositions:function(){var n=this,t=n._getPositions();n._backItem1.applySettings(n._buildItemSettings(t.start,t.back1)),n._backItem2.applySettings(n._buildItemSettings(t.back2,t.end)),n._spaceItem1.applySettings(n._buildItemSettings(t.back1,t.main1)),n._spaceItem2.applySettings(n._buildItemSettings(t.main2,t.back2)),n._mainItem.applySettings(n._buildItemSettings(t.main1,t.main2)),n._tracker.applySettings(n._buildItemSettings(t.main1,t.main2))},render:function(){var n=this;return n.callBase(),n._isVisible()?(n._prepare(),n._rootElement=n._rootElement||n._renderer.createGroup({"class":"rangebar"}),n._rootElement.append(n._owner),n._backItem1=n._backItem1||n._createBarItem(),n._backItem2=n._backItem2||n._createBarItem(),n._spaceItem1=n._spaceItem1||n._createBarItem(),n._spaceItem2=n._spaceItem2||n._createBarItem(),n._mainItem=n._mainItem||n._createBarItem(),n._tracker=n._tracker||n._createTracker().append(n._trackerOwner),n._updateBarItems(),n._updateTextItems(),n._updateActiveElements()):n.clear(),n},clear:function(){var n=this;n._rootElement&&(n._rootElement.remove(),delete n._rootElement,delete n._backItem1,delete n._backItem2,delete n._spaceItem1,delete n._spaceItem2,delete n._mainItem,delete n._tracker,delete n._hasText,n._destroyTextItems())},getTrackingElement:function(){return this._tracker},getTooltipParameters:function(){var n=this._getTooltipPosition();return{x:n.x,y:n.y,value:this._currentValue,color:this._options.color}}})}(DevExpress,jQuery),function(n,t){var r=n.viz.gauges.__internals.circularNeedles,u=n.utils.convertAngleToRendererSpace,f=t.extend;r.SimpleIndicator=n.viz.gauges.__internals.BaseIndicator.inherit({_updateActiveElements:function(){var n=this,t=n._options,r=n._getActualPosition(),i=u(r);n._rootElement.rotate(i,t.x,t.y),n._tracker.rotate(i,t.x,t.y)},_isVisible:function(){var n=this._options;return n.width>0&&n.indentFromCenter>=0&&n.radius-n.indentFromCenter>0},_getClassName:function(){return"needle"},_getTrackerPoints:function(){var n=this._options,i=n.y-n.radius,r=n.y-n.indentFromCenter||n.y,t=n.x-n.width/2||n.x,u=t+n.width||n.x;return[t,r,t,i,u,i,u,r]},_destroy:function(){delete this._element},render:function(){var n=this;return n.callBase(),n._isVisible()?(n._rootElement=n._rootElement||n._renderer.createGroup({"class":n._getClassName()}),n._rootElement.append(n._owner),n._create(),n._tracker=n._tracker||n._renderer.createArea().append(n._trackerOwner),n._tracker.applySettings({points:n._getTrackerPoints(),stroke:"none",strokeWidth:0,fill:"#000000",opacity:.0001}),n._updateActiveElements()):n._rootElement&&(n._rootElement.remove(),delete n._rootElement,n._destroy(),delete n._tracker),n},measure:function(){var n=this._options,t={max:n.radius};return n.indentFromCenter<0&&(t.inverseHorizontalOffset=t.inverseVerticalOffset=-n.indentFromCenter),t},getTrackingElement:function(){return this._tracker},getTooltipParameters:function(){var t=this._options,i=n.utils.getCosAndSin(this._getActualPosition()),r=(t.radius+t.indentFromCenter)/2;return{x:t.x+i.cos*r,y:t.y-i.sin*r,value:this._currentValue,color:t.color,offset:t.width/2}}}),r.RectangleNeedle=r.SimpleIndicator.inherit({_create:function(){var t=this,n=t._options,r=n.y-n.radius,u=n.y-n.indentFromCenter||n.y,i=n.x-n.width/2||n.x,f=i+n.width||n.x;t._element=t._element||t._renderer.createArea().append(t._rootElement),t._element.applySettings({points:[i,u,i,r,f,r,f,u],stroke:"none",strokeWidth:0,fill:n.color})}}),r.TriangleNeedle=r.SimpleIndicator.inherit({_create:function(){var t=this,n=t._options,r=n.y-n.radius,i=n.y-n.indentFromCenter||n.y,u=n.x-n.width/2||n.x,f=n.x+n.width/2||n.x;t._element=t._element||t._renderer.createArea().append(t._rootElement),t._element.applySettings({points:[u,i,n.x,r,f,i],stroke:"none",strokeWidth:0,fill:n.color})}}),r.TwoColorRectangleNeedle=r.SimpleIndicator.inherit({_create:function(){var n=this,t=n._options,i=t.x-t.width/2||t.x,r=t.x+t.width/2||t.x,f=t.y-t.radius,o=t.y-t.indentFromCenter||t.y,u=f+(o-f)*t.secondFraction||f,e=u+t.space||u;n._firstElement=n._firstElement||n._renderer.createArea().append(n._rootElement),n._spaceElement=n._spaceElement||n._renderer.createArea().append(n._rootElement),n._secondElement=n._secondElement||n._renderer.createArea().append(n._rootElement),n._firstElement.applySettings({points:[i,o,i,e,r,e,r,o],"class":"dx-needle-part1",fill:t.color,stroke:"none",strokeWidth:0}),n._spaceElement.applySettings({points:[i,e,i,u,r,u,r,e],"class":"dx-needle-hole",fill:t.containerBackgroundColor,stroke:"none",strokeWidth:0}),n._secondElement.applySettings({points:[i,u,i,f,r,f,r,u],"class":"dx-needle-part2",fill:t.secondColor,stroke:"none",strokeWidth:0})},_destroy:function(){delete this._firstElement,delete this._secondElement,delete this._spaceElement}})}(DevExpress,jQuery),function(n,t){var r=n.viz.gauges.__internals.linearNeedles,u=t.extend;r.SimpleIndicator=n.viz.gauges.__internals.BaseIndicator.inherit({_updateActiveElements:function(){var n=this,t=n._getActualPosition()-n._zeroPosition;n._rootElement.move(n._vertical?0:t,n._vertical?t:0),n._tracker.move(n._vertical?0:t,n._vertical?t:0)},_isVisible:function(){var n=this._options;return n.length>0&&n.width>0},_getClassName:function(){return"needle"},_getTrackerPoints:function(){var n=this._options,i,r,u,f,t=this._zeroPosition;return this._vertical?(i=n.x-n.length/2||n.x,r=n.x+n.length/2||n.x,u=t+n.width/2||t,f=t-n.width/2||t):(i=t-n.width/2||t,r=t+n.width/2||t,u=n.y+n.length/2||n.y,f=n.y-n.length/2||n.y),[i,u,i,f,r,f,r,u]},_destroy:function(){delete this._element},init:function(n){var t=this;return t.callBase(n),t._vertical=t._options.orientation==="vertical",t},render:function(){var n=this;return n.callBase(),n._isVisible()?(n._zeroPosition=n._options.translator.getCodomainStart(),n._rootElement=n._rootElement||n._renderer.createGroup({"class":n._getClassName()}),n._rootElement.append(n._owner),n._create(),n._tracker=n._tracker||n._renderer.createArea().append(n._trackerOwner),n._tracker.applySettings({points:n._getTrackerPoints(),stroke:"none",strokeWidth:0,fill:"#000000",opacity:.0001}),n._updateActiveElements()):n._rootElement&&(n._rootElement.remove(),delete n._rootElement,n._destroy(),delete n._tracker),n},measure:function(){var n=this._options,t=this._vertical?n.x:n.y;return{min:t-n.length/2,max:t+n.length/2}},getTrackingElement:function(){return this._tracker},getTooltipParameters:function(){var n=this,t=n._options,r=n._getActualPosition(),i={x:r,y:r,value:n._currentValue,color:t.color,offset:t.width/2};return n._vertical?i.x=t.x:i.y=t.y,i}}),r.RectangleNeedle=r.SimpleIndicator.inherit({_create:function(){var t=this,n=t._options,i=t._zeroPosition,r,u,f,e;t._vertical?(r=n.x-n.length/2||n.x,u=n.x+n.length/2||n.x,f=i+n.width/2||i,e=i-n.width/2||i):(r=i-n.width/2||i,u=i+n.width/2||i,f=n.y+n.length/2||n.y,e=n.y-n.length/2||n.y),t._element=t._element||t._renderer.createArea().append(t._rootElement),t._element.applySettings({points:[r,f,r,e,u,e,u,f],stroke:"none",strokeWidth:0,fill:n.color})}}),r.RhombusNeedle=r.SimpleIndicator.inherit({_create:function(){var n=this,t=n._options,i,r,u,f;n._vertical?(i=t.x,r=n._zeroPosition,u=t.length/2||0,f=t.width/2||0):(i=n._zeroPosition,r=t.y,u=t.width/2||0,f=t.length/2||0),n._element=n._element||n._renderer.createArea().append(n._rootElement),n._element.applySettings({points:[i-u,r,i,r-f,i+u,r,i,r+f],stroke:"none",strokeWidth:0,fill:t.color})}}),r.CircleNeedle=r.SimpleIndicator.inherit({_create:function(){var n=this,t=n._options,i,r,u;n._vertical?(i=t.x,r=n._zeroPosition):(i=n._zeroPosition,r=t.y),u=t.length/2||0,n._element=n._element||n._renderer.createCircle().append(n._rootElement),n._element.applySettings({cx:i,cy:r,r:u,stroke:"none",strokeWidth:0,fill:t.color})}})}(DevExpress,jQuery),function(n){var i=n.viz.gauges.__internals.circularMarkers,r=n.utils.normalizeAngle,e=n.utils.convertAngleToRendererSpace,u=n.utils.getCosAndSin,f=Math.min;i.TriangleMarker=n.viz.gauges.__internals.circularNeedles.SimpleIndicator.inherit({_isVisible:function(){var n=this._options;return n.length>0&&n.width>0&&n.radius>0},_getClassName:function(){return"marker"},_create:function(){var t=this,n=t._options,r=n.x,u=n.y-n.radius,e=n.width/2||0,o=u-n.length||u,i;t._element=t._element||t._renderer.createArea([],{"class":"dx-marker-element"}).append(t._rootElement),i={points:[r,u,r-e,o,r+e,o],stroke:"none",strokeWidth:0,fill:n.color},n.space>0&&(i.strokeWidth=f(n.space,n.width/4)||0,i.stroke=i.strokeWidth>0?n.containerBackgroundColor||"none":"none"),t._element.applySettings(i)},_getTrackerPoints:function(){var n=this._options,i=n.x-n.width/2,r=n.x+n.width/2,t=n.y-n.radius,u=t-n.length||t;return[i,t,i,u,r,u,r,t]},measure:function(){var n=this._options;return{min:n.radius,max:n.radius+n.length||n.radius}},getTooltipParameters:function(){var t=this._options,r=n.utils.getCosAndSin(this._getActualPosition()),u=t.radius+t.length/2,i=this.callBase();return i.x=t.x+r.cos*u,i.y=t.y-r.sin*u,i.offset=t.length/2,i}}),i.TextCloudMarker=n.viz.gauges.__internals.BaseTextCloudMarker.inherit({_isVisible:function(){return this._options.radius>0},_getTextCloudOptions:function(){var n=this,i=n._getActualPosition(),f=u(i),t=r(i);return{x:n._options.x+f.cos*n._options.radius,y:n._options.y-f.sin*n._options.radius,type:t>270?"left-top":t>180?"top-right":t>90?"right-bottom":"bottom-left"}},measure:function(){var n=this;return n._measureText(),{min:n._options.radius,max:n._options.radius,horizontalOffset:n._textFullWidth+n._options.arrowLength,verticalOffset:n._textFullHeight+n._options.arrowLength}}})}(DevExpress),function(n,t){var r=n.viz.gauges.__internals.linearMarkers,u=Math.min,f=t.extend;r.TriangleMarker=n.viz.gauges.__internals.linearNeedles.SimpleIndicator.inherit({_getClassName:function(){return"marker"},_create:function(){var t=this,n=t._options,i,e,r,o,f={stroke:"none",strokeWidth:0,fill:n.color};t._vertical?(i=n.x,r=t._zeroPosition,e=i+(t._inverted?n.length:-n.length),f.points=[i,r,e,r-n.width/2,e,r+n.width/2]):(r=n.y,i=t._zeroPosition,o=r+(t._inverted?n.length:-n.length),f.points=[i,r,i-n.width/2,o,i+n.width/2,o]),n.space>0&&(f.strokeWidth=u(n.space,n.width/4)||0,f.stroke=f.strokeWidth>0?n.containerBackgroundColor||"none":"none"),t._element=t._element||t._renderer.createArea().append(t._rootElement),t._element.applySettings(f)},_getTrackerPoints:function(){var t=this,n=t._options,o=Number(n.length)||0,s=n.width/2||0,i,r,u,f,e;return t._vertical?(i=r=n.x,r=i+(t._inverted?n.length:-n.length),u=t._zeroPosition+n.width/2,f=t._zeroPosition-n.width/2,e=[i,u,r,u,r,f,i,f]):(u=n.y,f=u+(t._inverted?n.length:-n.length),i=t._zeroPosition-n.width/2,r=t._zeroPosition+n.width/2,e=[i,u,i,f,r,f,r,u]),e},init:function(n){var t=this;return t.callBase(n),t._inverted=t._vertical?t._options.horizontalOrientation==="right":t._options.verticalOrientation==="bottom",t},measure:function(){var r=this,i=r._options,n,t,u=i.width/2||0;return r._vertical?(n=t=i.x,r._inverted?t=n+i.length||n:n=t-i.length||t):(n=t=i.y,r._inverted?t=n+i.length||n:n=t-i.length||t),{min:n,max:t,indent:u}},getTooltipParameters:function(){var n=this,i=n._options,r=(n._inverted?i.length:-i.length)/2,t=n.callBase();return n._vertical?t.x+=r:t.y+=r,t.offset=i.length/2,t}}),r.TextCloudMarker=n.viz.gauges.__internals.BaseTextCloudMarker.inherit({_isVisible:function(){return!0},_getTextCloudOptions:function(){var n=this,i=n._getActualPosition(),r=i,u=i,t;return n._vertical?(r=n._options.x,t=n._inverted?"top-left":"top-right"):(u=n._options.y,t=n._inverted?"right-top":"right-bottom"),{x:r,y:u,type:t}},init:function(n){var t=this;return t.callBase(n),t._vertical=t._options.orientation==="vertical",t._inverted=t._vertical?t._options.horizontalOrientation==="right":t._options.verticalOrientation==="bottom",t},measure:function(){var t=this,n=t._options,i,r,u;return t._measureText(),t._vertical?(u=t._textFullHeight,t._inverted?(i=n.x,r=n.x+n.arrowLength+t._textFullWidth):(i=n.x-n.arrowLength-t._textFullWidth,r=n.x)):(u=t._textFullWidth,t._inverted?(i=n.y,r=n.y+n.arrowLength+t._textFullHeight):(i=n.y-n.arrowLength-t._textFullHeight,r=n.y)),{min:i,max:r,indent:u}}})}(DevExpress,jQuery),function(n){var i=n.utils.getCosAndSin,r=n.utils.convertAngleToRendererSpace,u=Math.max,f=Math.min;n.viz.gauges.__internals.CircularRangeBar=n.viz.gauges.__internals.BaseRangeBar.inherit({_isVisible:function(){var n=this._options;return n.size>0&&n.radius-n.size>0},_createBarItem:function(){return this._renderer.createArc().append(this._rootElement)},_createTracker:function(){return this._renderer.createArc(0,0,0,0,0,0,{stroke:"none",strokeWidth:0,fill:"#000000",opacity:.0001})},_setBarSides:function(){var n=this,t=n._options;n._minSide=t.radius-t.size,n._maxSide=t.radius},_getSpace:function(){var n=this._options;return n.space>0?n.space*180/n.radius/Math.PI:0},_isTextVisible:function(){var n=this._options.text||{};return n.indent>0},_getTextAlign:function(){return"center"},_setTextItemsSides:function(){var n=this,t=n._options;n._lineFrom=t.y-t.radius,n._lineTo=n._lineFrom-t.text.indent,n._textRadius=t.radius+t.text.indent},_getPositions:function(){var n=this,r=n._basePosition,e=n._getActualPosition(),t,i,o=n._space;return r>=e?(t=r,i=e):(t=e,i=r),{start:n._startPosition,end:n._endPosition,main1:t,main2:i,back1:f(t+o,n._startPosition),back2:u(i-o,n._endPosition)}},_buildItemSettings:function(n,t){var i=this;return{x:i._options.x,y:i._options.y,innerRadius:i._minSide,outerRadius:i._maxSide,startAngle:t,endAngle:n}},_updateTextPosition:function(){var n=this,t=i(n._getActualPosition()),r=n._options.x+n._textRadius*t.cos,u=n._options.y-n._textRadius*t.sin;r+=t.cos*n._textWidth/2,u-=t.sin*n._textHeight/2,n._text.applySettings({x:r,y:u+n._textVerticalOffset})},_updateLinePosition:function(){var n=this,e=r(n._getActualPosition()),f=n._getActualPosition(),t=n._options.x,i,u;n._basePosition>f?(i=t-2,u=t):n._basePosition<f?(i=t,u=t+2):(i=t-1,u=t+1),n._line.applySettings({points:[i,n._lineFrom,i,n._lineTo,u,n._lineTo,u,n._lineFrom]}),n._line.rotate(e,t,n._options.y)},_getTooltipPosition:function(){var n=this,t=i((n._basePosition+n._getActualPosition())/2),r=(n._minSide+n._maxSide)/2;return{x:n._options.x+t.cos*r,y:n._options.y-t.sin*r}},measure:function(){var n=this,t=n._options,i={min:t.radius-t.size||t.radius,max:t.radius};return n._prepare(),n._hasText&&(i.max+=t.text.indent,i.horizontalOffset=n._textWidth,i.verticalOffset=n._textHeight),i}})}(DevExpress),function(n){n.viz.gauges.__internals.LinearRangeBar=n.viz.gauges.__internals.BaseRangeBar.inherit({_isVisible:function(){var n=this._options;return n.size>0},_prepare:function(){var n=this;n.callBase(),n._vertical=n._options.orientation==="vertical",n._inverted=n._vertical?n._options.horizontalOrientation==="right":n._options.verticalOrientation==="bottom"},_createBarItem:function(){return this._renderer.createArea().append(this._rootElement)},_createTracker:function(){return this._renderer.createArea([],{stroke:"none",strokeWidth:0,fill:"#000000",opacity:.0001})},_setBarSides:function(){var t=this,n=t._options,i,r;t._vertical?t._inverted?(i=n.x,r=n.x+n.size):(i=n.x-n.size,r=n.x):t._inverted?(i=n.y,r=n.y+n.size):(i=n.y-n.size,r=n.y),t._minSide=i,t._maxSide=r,t._minBound=i,t._maxBound=r},_getSpace:function(){var n=this._options;return n.space>0?Number(n.space):0},_isTextVisible:function(){var n=this._options.text||{};return n.indent>0||n.indent<0},_getTextAlign:function(){return this._vertical?this._options.text.indent>0?"left":"right":"center"},_setTextItemsSides:function(){var n=this,t=Number(n._options.text.indent);t>0?(n._lineStart=n._maxSide,n._lineEnd=n._maxSide+t,n._textPosition=n._lineEnd+(n._vertical?2:n._textHeight/2),n._maxBound=n._textPosition+(n._vertical?n._textWidth:n._textHeight/2)):t<0&&(n._lineStart=n._minSide,n._lineEnd=n._minSide+t,n._textPosition=n._lineEnd-(n._vertical?2:n._textHeight/2),n._minBound=n._textPosition-(n._vertical?n._textWidth:n._textHeight/2))},_getPositions:function(){var i=this,c=i._options,s=i._startPosition,h=i._endPosition,f=i._space,r=i._basePosition,u=i._getActualPosition(),n,t,e,o;return s<h?(r<u?(n=r,t=u):(n=u,t=r),e=n-f,o=t+f):(r>u?(n=r,t=u):(n=u,t=r),e=n+f,o=t-f),{start:s,end:h,main1:n,main2:t,back1:e,back2:o}},_buildItemSettings:function(n,t){var u=this,i=u._minSide,r=u._maxSide,f=u._vertical?[i,n,i,t,r,t,r,n]:[n,i,n,r,t,r,t,i];return{points:f}},_updateTextPosition:function(){var n=this,i=n._options,t=n._getActualPosition();n._text.applySettings(n._vertical?{x:n._textPosition,y:t+n._textVerticalOffset}:{x:t,y:n._textPosition+n._textVerticalOffset})},_updateLinePosition:function(){var n=this,t=n._getActualPosition(),i,r,u;n._vertical?(n._basePosition>=t?(i=t,r=t+2):(i=t-2,r=t),u=[n._lineStart,i,n._lineStart,r,n._lineEnd,r,n._lineEnd,i]):(n._basePosition<=t?(i=t-2,r=t):(i=t,r=t+2),u=[i,n._lineStart,i,n._lineEnd,r,n._lineEnd,r,n._lineStart]),n._line.applySettings({points:u})},_getTooltipPosition:function(){var n=this,i=(n._minSide+n._maxSide)/2,r=(n._basePosition+n._getActualPosition())/2,t={};return t=n._vertical?{x:i,y:r}:{x:r,y:i}},measure:function(){var t=this,n=t._options,i,r,u;return t._prepare(),t._vertical?(i=r=n.x,t._inverted?r=r+n.size||r:i=i-n.size||i,t._hasText&&(u=t._textHeight/2,n.text.indent>0&&(r+=n.text.indent+t._textWidth),n.text.indent<0&&(i+=n.text.indent-t._textWidth))):(i=r=n.y,t._inverted?r=r+n.size||r:i=i-n.size||i,t._hasText&&(u=t._textWidth/2,n.text.indent>0&&(r+=n.text.indent+t._textHeight),n.text.indent<0&&(i+=n.text.indent-t._textHeight))),{min:i,max:r,indent:u}}})}(DevExpress),function(n,t){var r=Math.min,u=t.extend;n.viz.gauges.__internals.CircularSpindle=n.Class.inherit({setup:function(n){return this._renderer=n.renderer,this._owner=n.owner,this},init:function(n){return this._options=u(!0,this._options||{},n),this},render:function(){var n=this,t=n._options;return t.visible!==!1&&t.size>0?(n._rootElement=n._rootElement||n._renderer.createGroup({"class":"spindle"}),n._rootElement.append(n._owner),n._element=n._element||n._renderer.createCircle().append(n._rootElement),n._element.applySettings({"class":"dx-spindle-border",cx:t.x,cy:t.y,r:t.size/2,fill:t.color||"none",stroke:"none",strokeWidth:0}),t.gapSize>0?(n._gapElement=n._gapElement||n._renderer.createCircle().append(n._rootElement),n._gapElement.applySettings({cx:t.x,cy:t.y,r:r(t.size,t.gapSize)/2,"class":"dx-spindle-hole",fill:t.containerBackgroundColor||"none",stroke:"none",strokeWidth:0})):(n._gapElement&&n._gapElement.remove(),delete n._gapElement)):(n._rootElement&&n._rootElement.remove(),delete n._rootElement,n._element&&n._element.remove(),delete n._element,n._gapElement&&n._gapElement.remove(),delete n._gapElement),n},measure:function(){var n=this._options.size/2||0;return{inverseHorizontalOffset:n,inverseVerticalOffset:n}}})}(DevExpress,jQuery),function(n,t){function v(n,t,i,r){var u;return i>n&&r<t?u=[{start:n,end:i},{start:r,end:t}]:i>=t||r<=n?u=[{start:n,end:t}]:i<=n&&r>=t?u=[]:i>n?u=[{start:n,end:i}]:r<t&&(u=[{start:r,end:t}]),u}function y(n,t,i,r){var u;return i<n&&r>t?u=[{start:n,end:i},{start:r,end:t}]:i<=t||r>=n?u=[{start:n,end:t}]:i>=n&&r<=t?u=[]:i<n?u=[{start:n,end:i}]:r>t&&(u=[{start:r,end:t}]),u}function p(n,t,i){return t-n>=i}function w(n,t,i){return n-t>=i}var h=n.utils.isDefined,e=n.utils.isString,o=n.utils.isArray,u=window.Number,s=window.isFinite,f=Math.max,c=Math.abs,r=t.each,l=t.map,a=t.extend;n.viz.gauges.__internals.BaseRangeContainer=n.Class.inherit({setup:function(n){var t=this;return t._renderer=n.renderer,t._owner=n.owner,t._incidentOccured=n.incidentOccured,t},init:function(n){var t=this;return t._options=a(!0,t._options||{},n),n&&h(n.ranges)&&(t._options.ranges=o(n.ranges)?n.ranges.slice(0):null),t},_getRanges:function(){var n=this._options,t=n.translator,k=t.getDomainStart(),tt=t.getDomainEnd(),a=tt-k,et=a>=0?p:w,it=a>=0?v:y,d=[],i=[],g=[{start:k,end:tt}],ot=c(a)/1e4,rt=o(n.palette)?n.palette:[],ut,st=e(n.backgroundColor)?n.backgroundColor:"none",h=n.width||{},b=u(h>0?h:h.start),nt=u(h>0?h:h.end),ft=nt-b;return n.ranges?b>=0&&nt>=0&&b+nt>0?(d=l(n.ranges,function(n){n=n||{};var i=t.adjust(n.startValue),r=t.adjust(n.endValue);return s(i)&&s(r)&&et(i,r,ot)?{start:i,end:r,color:n.color}:null}),ut=f(0,rt.length-d.length),r(d,function(n,t){var i=t.color;e(i)||(i=rt[n+ut]),e(i)||(i="none"),t.color=i}),r(d,function(n,t){for(var r,e,u,o=[],h=[],f=0,s=i.length;f<s;++f)u=i[f],e=it(u.start,u.end,t.start,t.end),(r=e[0])&&(r.color=u.color)&&o.push(r),(r=e[1])&&(r.color=u.color)&&o.push(r);for(o.push(t),i=o,f=0,s=g.length;f<s;++f)u=g[f],e=it(u.start,u.end,t.start,t.end),(r=e[0])&&h.push(r),(r=e[1])&&h.push(r);g=h}),r(g,function(n,t){t.color=st,t["class"]="dx-background-range",i.push(t)}),r(i,function(n,i){i.startPosition=t.translate(i.start),i.endPosition=t.translate(i.end),i.startWidth=(i.start-k)/a*ft+b,i.endWidth=(i.end-k)/a*ft+b}),i):(this._incidentOccured('The range container is not rendered because the value of the "width" option is not valid'),null):(this._incidentOccured('The range container is not rendered because the value of the "ranges" option is not valid'),null)},render:function(){var n=this,t;return n._rootElement=n._rootElement||n._renderer.createGroup({"class":"range-container"}),n._rootElement.append(n._owner).clear(),t=n._getRanges(),t&&n._renderRanges(t)||(n._rootElement.remove(),delete n._rootElement),n}}),n.viz.gauges.__internals.CircularRangeContainer=n.viz.gauges.__internals.BaseRangeContainer.inherit({_renderRanges:function(n){var e=this,t=e._options,h=t.x,c=t.y,o=t.radius,l=e._renderer,a=e._rootElement,i=0,u=0,s=t.width>0?t.width:f(t.width.start,t.width.end);switch(t.orientation){case"inside":i=1;break;case"outside":u=1;break;case"center":i=u=.5;break;default:e._incidentOccured('The range container is not rendered because the value of the "orientation" option is not valid')}return(i||u)&&o+u*s>0&&o-i*s>0?(r(n,function(n,t){var r=(t.startWidth+t.endWidth)/2,f=l.createArc(h,c,o+u*r,o-i*r,t.endPosition,t.startPosition,{stroke:"none",strokeWidth:0,fill:t.color}).append(a);"class"in t&&f.applySettings({"class":t["class"]})}),!0):!1},measure:function(){var r=this._options,t=r.radius,n=r.width||{},i=null;n=u(n)||f(n.start,n.end,0)||0;switch(r.orientation){case"inside":i={min:t-n,max:t};break;case"outside":i={min:t,max:t+n};break;case"center":i={min:t-n/2,max:t+n/2}}return i}}),n.viz.gauges.__internals.LinearRangeContainer=n.viz.gauges.__internals.BaseRangeContainer.inherit({_renderRanges:function(n){var f=this,e=f._options,o=f._renderer,s=f._rootElement,t=0,i=0,u;if(e.orientation==="vertical"){u=e.x;switch(e.horizontalOrientation){case"left":t=1;break;case"right":i=1;break;case"center":t=i=.5;break;default:f._incidentOccured('The range container is not rendered because the value of the "horizontalOrientation" option is not valid')}if(t||i)return r(n,function(n,r){var f=o.createArea([u-r.startWidth*t,r.startPosition,u-r.endWidth*t,r.endPosition,u+r.endWidth*i,r.endPosition,u+r.startWidth*i,r.startPosition],{stroke:"none",strokeWidth:0,fill:r.color}).append(s);"class"in r&&f.applySettings({"class":r["class"]})}),!0}else{u=e.y;switch(e.verticalOrientation){case"top":t=1;break;case"bottom":i=1;break;case"middle":t=i=.5;break;default:f._incidentOccured('The range container is not rendered because the value of the "verticalOrientation" option is not valid')}if(t||i)return r(n,function(n,r){var f=o.createArea([r.startPosition,u+r.startWidth*i,r.startPosition,u-r.startWidth*t,r.endPosition,u-r.endWidth*t,r.endPosition,u+r.endWidth*i],{stroke:"none",strokeWidth:0,fill:r.color}).append(s);"class"in r&&f.applySettings({"class":r["class"]})}),!0}return!1},measure:function(){var i=this._options,n=i.width||{},t=null;if(n=u(n)||f(n.start,n.end,0)||0,i.orientation==="vertical"){t={min:i.x,max:i.x};switch(i.horizontalOrientation){case"left":t.min-=n;break;case"right":t.max+=n;break;case"center":t.min-=n/2,t.max+=n/2}}else{t={min:i.y,max:i.y};switch(i.verticalOrientation){case"top":t.min-=n;break;case"bottom":t.max+=n;break;case"middle":t.min-=n/2,t.max+=n/2}}return t}})}(DevExpress,jQuery),function(n,t){var o=n.viz.core.Rectangle,u=n.utils.isString,s=n.utils.isDefined,h=Math.min,c=Math.max,f=Math.floor,r=Math.ceil,e=t.extend;n.viz.gauges.__internals.Title=n.Class.inherit({ctor:function(){this._options={title:{},subtitle:{}}},_measureTexts:function(){var t=this,n=t._mainText?t._mainText.getBBox():null,i=t._subText?t._subText.getBBox():null,u;t._location={x:0,y:0},n&&i?(t._subText.applySettings({y:r(-i.y)}),t._rect=new o({left:f(h(n.x,i.x)),right:r(c(n.x+n.width,i.x+i.width)),top:f(n.y),bottom:r(i.height)})):(n||i)&&(n=n||i,t._rect=new o({left:f(n.x),right:r(n.x+n.width),top:f(n.y),bottom:r(n.y+n.height)}))},render:function(n){var t=this;return e(!0,t._options,n),t._root=t._root||t._renderer.createGroup().applySettings({"class":"dx-gauge-title"}).append(t._owner),u(t._options.title.text)?(t._mainText=t._mainText||t._renderer.createText().append(t._root),t._mainText.applySettings({x:0,y:0,align:"center",font:t._options.title.font,text:t._options.title.text})):(t._mainText&&t._mainText.remove(),delete t._mainText),u(t._options.subtitle.text)?(t._subText=t._subText||t._renderer.createText().append(t._root),t._subText.applySettings({x:0,y:0,align:"center",font:t._options.subtitle.font,text:t._options.subtitle.text})):(t._subText&&t._subText.remove(),delete t._subText),t._mainText||t._subText?t._measureTexts():(t._root&&t._root.remove(),delete t._root),t},processTitleOptions:function(n){return u(n)?{text:n}:s(n)?(n=e({},n),n.layout=e({},n.layout,{position:n.position}),n):{text:null}},processSubtitleOptions:function(n){return u(n)?{text:n}:s(n)?e({},n):{text:null}},isVisible:function(){return!!(this._mainText||this._subText)},getBoundingRect:function(){return this._rect.clone()},getLayoutOptions:function(){return this._options.title.layout||{}},move:function(n,t){var i=this;return i._root.move(i._location.x+=n,i._location.y+=t),i._rect=i._rect.move(n,t),i}})}(DevExpress,jQuery),function(n){function r(n){n=n||{};var t=(i(n)?n:n.position||"").split("-");return{primary:i(t[0])?t[0].toLowerCase():"",secondary:i(t[1])?t[1].toLowerCase():"",overlay:n.overlay>0?Number(n.overlay):0}}var u=Math.min,f=Math.max,i=n.utils.isString,e=n.viz.core.Rectangle;n.viz.gauges.__internals.LayoutManager=n.Class.inherit({setRect:function(n){return this._rect=n.clone(),this},getRect:function(){return this._rect.clone()},applyLayout:function(n,t){var h=0,o=0,i=this._rect,e=n.clone(),c=r(t),s=e.height()-c.overlay;switch(c.primary){case"top":s>=0?(o=i.top-e.top,i.top=u(i.top+s,i.bottom)):o=i.top-e.top-s;break;case"bottom":s>=0?(o=i.bottom-e.bottom,i.bottom=f(i.bottom-s,i.top)):o=i.bottom-e.bottom+s}switch(c.secondary){case"":case"center":h=i.horizontalMiddle()-e.horizontalMiddle();break;case"left":h=i.left-e.left;break;case"right":h=i.right-e.right}return e=e.move(h,o),{rect:e,dx:h,dy:o}},dock:function(n,t){var e=0,u=0,o=this._rect,i=n.clone(),f=r(t);switch(f.primary){case"top":u=o.top-i.bottom+f.overlay;break;case"bottom":u=o.bottom-i.top-f.overlay}return i=i.move(e,u),{rect:i,dx:e,dy:u}},selectRectByAspectRatio:function(n,t){var i=this._rect.clone(),f,r=0,u=0;return t=t||{},n>0&&(i.left+=t.left||0,i.right-=t.right||0,i.top+=t.top||0,i.bottom-=t.bottom||0,i.width()>0&&i.height()>0?(f=i.height()/i.width(),f>1?n<f?r=i.width():u=i.height():n>f?u=i.height():r=i.width(),r>0||(r=u/n),u>0||(u=r*n),r=(i.width()-r)/2,u=(i.height()-u)/2,i.left+=r,i.right-=r,i.top+=u,i.bottom-=u):(i.left=i.right=i.horizontalMiddle(),i.top=i.bottom=i.verticalMiddle())),i},selectRectBySizes:function(n,t){var i=this._rect.clone(),r;return t=t||{},n&&(i.left+=t.left||0,i.right-=t.right||0,i.top+=t.top||0,i.bottom-=t.bottom||0,n.width>0&&(r=(i.width()-n.width)/2,r>0&&(i.left+=r,i.right-=r)),n.height>0&&(r=(i.height()-n.height)/2,r>0&&(i.top+=r,i.bottom-=r))),i}})}(DevExpress,jQuery),function(n,t){var r=function(n){return isString(n)?n:isNumber(n)?n.toString():"N/A"};t.viz.gauges.__internals.ThemeManager=t.viz.core.BaseThemeManager.inherit(function(){var n=function(n){this.callBase(n,"gauge"),this.theme.area.defaultFormatText=r},t=function(){return this.theme.range||{}},i=function(){return this.theme.scale||{}},u=function(){return this.theme.needle||{}},f=function(){return this.theme.marker||{}};return{ctor:n,getRangeTheme:t,getScaleTheme:i,getNeedleTheme:u,getMarkerTheme:f}}())}(jQuery,DevExpress),function(n,t){var f=n.viz.gauges.__internals,r={preset1:{commonNeedleSettings:{type:"rectangle"},commonMarkerSettings:{type:"textcloud"}},preset2:{commonNeedleSettings:{type:"twocolorrectangle"},commonMarkerSettings:{offset:6,type:"triangle"}},preset3:{commonMarkerSettings:{offset:6,type:"triangle"},commonRangeBarSettings:{text:{indent:70}}}},u={preset1:{commonNeedleSettings:{type:"rhombus"},commonMarkerSettings:{type:"textcloud"}},preset2:{commonNeedleSettings:{type:"circle"},commonMarkerSettings:{type:"triangle"}}};n.viz.gauges.__internals.PresetManager=n.Class.inherit({setup:function(n,t){var i=this;return i._activePreset={},i._setPresetsCollection(i._selectPresets(n),"preset1"),i._setActivePreset(t)},_selectPresets:function(n){var t={};switch(n){case"circular":t=r;break;case"linear":t=u}return t},_setActivePreset:function(n){var i={},t=!n||typeof n=="string";return this._presetName=t?n:n.name,this._presetName!=="none"?(t||this._updatePreset(n),this._activePreset=this._getCollectionElement(this._presetName)):this._activePreset=t?i:n,this._activePreset},getNeedlePreset:function(){return this._activePreset.commonNeedleSettings||{}},getMarkerPreset:function(){return this._activePreset.commonMarkerSettings||{}},getRangeBarPreset:function(){return this._activePreset.commonRangeBarSettings||{}},getScalePreset:function(){return this._activePreset.commonScaleSettings||{}},getRangePreset:function(){return this._activePreset.commonRangeSettings||{}},getTitlePreset:function(){return this._activePreset.title||{}},getSubtitlePreset:function(){return this._activePreset.subtitle||{}},getIndicatorPreset:function(){return this._activePreset.indicator||{}},getSpindlePreset:function(){return this._activePreset.spindle||{}},_updatePreset:function(n){this._presetsCollection.hasOwnProperty(n.name)?t.extend(!0,this._presetsCollection[n.name],n):t.extend(!0,this._presetsCollection.defaultPreset,n)},_getCollectionElement:function(n){var t={};return t=this._presetsCollection.hasOwnProperty(n)?this._presetsCollection[n]:this._presetsCollection.defaultPreset},_setPresetsCollection:function(n,i){this._presetsCollection=t.extend(!0,{},n||{}),this._presetsCollection.defaultPreset=i&&this._presetsCollection.hasOwnProperty(i)?t.extend({},this._presetsCollection[i]):{}}})}(DevExpress,jQuery),function(n,t,i){var u=n.viz.gauges.__factory,h=n.viz.core.Rectangle,o=n.utils.isNumber,c=n.utils.isString,l=n.utils.isFunction,s=window.isFinite,v=window.setTimeout,e=n.utils.windowResizeCallbacks,r=t.extend,f=t.each,y=500,a={size:{width:i,height:i},margin:{left:0,top:0,right:0,bottom:0},geometry:{},preset:"preset1",containerBackgroundColor:"#FFFFFF",animationEnabled:!0,animationDuration:1e3,redrawOnResize:!0,incidentOccured:t.noop,scale:{startValue:0,endValue:100,majorTick:{visible:!0,type:"rectangle",tickInterval:i,customTickValues:[],length:5,width:2,showCalculatedTicks:!0,useTicksAutoArrangement:!0,color:"#FFFFFF"},minorTick:{visible:!1,type:"rectangle",tickInterval:i,customTickValues:[],length:3,width:1,showCalculatedTicks:!0,color:"#FFFFFF"},label:{visible:!0,format:"",precision:2,customizeText:i,font:{color:"#7F7F7F",size:12,family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400}}},rangeContainer:{offset:0,width:5,backgroundColor:"#808080",palette:["#AD79CE","#639EC6","#A5C763","#FFB65A","#E78E94"],ranges:[]},commonNeedleSettings:{__info:"needle",color:"#C2C2C2"},commonMarkerSettings:{__info:"marker",color:"#679EC5",space:2,length:14,width:13,arrowLength:5,horizontalOffset:6,verticalOffset:3,text:{customizeText:i,font:{color:"#FFFFFF",size:18,family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400}}},commonRangeBarSettings:{baseValue:i,color:"#AD79CE",backgroundColor:"none",space:2,size:10,text:{indent:0,customizeText:i,font:{size:14,family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400}}},title:{layout:{position:"top-center",overlay:0},font:{size:18,color:"#232323",family:"'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:200}},subtitle:{font:{size:14,color:"#232323",family:"'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:200}},indicator:{hasPositiveMeaning:!0,text:{format:"fixedPoint",precision:0,customizeText:t.none,useDefaultColor:!1,font:{color:"#7F7F7F",size:18,family:"'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:400}},layout:{position:"bottom-center",overlay:0}},tooltip:{enabled:!1,format:i,precision:i,customizeText:i,font:{color:"#FFFFFF",size:26,family:"'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",weight:200},horizontalPadding:22,verticalPadding:6,arrowLength:10},tracker:{tooltipDelay:500}};n.viz.gauges.Gauge=n.ui.Component.inherit({_defaultOptions:function(){return r(!0,{},a)},_initOptions:function(n){var t=this,i;t._presetManager=u.createPresetManager(),i=t._presetManager.setup(t._gaugeType(),n?n.preset:{}),t.option(i),t.callBase(n)},_getPresetName:function(n){return n&&c(n.preset)?n.preset:this.option("preset")},_init:function(){var n=this;n._initRenderer(),n._tracker=u.createTracker(),n._tracker.setup(n),n._layoutManager=u.createLayoutManager(),n._defaultOpts=n._defaultOptions(),n._creationOptions=n._getCreationOptions(),n._mainElements=[],n._externalElements=[],n._needles=[],n._markers=[],n._rangeBars=[],n._initResizeHandler()},_dispose:function(){var n=this;n._disposeRenderer(),delete n._tracker,delete n._layoutManager,delete n._defaultOpts,delete n._creationOptions,delete n._mainElements,delete n._externalElements,delete n._needles,delete n._markers,delete n._rangeBars,n._disposeResizeHandler(),n.callBase()},_initRenderer:function(){var n=this;n._canvas={width:1,height:1,marginLeft:0,marginRight:0,marginTop:0,marginBottom:0},n._renderer=u.createRenderer({width:1,height:1}),n._rootElement=n._renderer.getRoot(),n._trackerGroup=n._renderer.createGroup({"class":"tracker"}).append(n._rootElement)},_disposeRenderer:function(){var n=this;delete n._canvas,delete n._renderer,delete n._rootElement,delete n._trackerGroup},_initResizeHandler:function(){var t=this;t._resizeHandler=n.utils.createResizeHandler(function(){t._renderCore()}),t._resizeHandler.dispose=function(){return t=null,this}},_disposeResizeHandler:function(){e.remove(this._resizeHandler.stop().dispose()),delete this._resizeHandler},_trackWindowResize:function(){var n=this;n.option("redrawOnResize")===!0?e.has(n._resizeHandler)||e.add(n._resizeHandler):e.remove(n._resizeHandler)},_getIncidentOccured:function(){var n=this.option("incidentOccured");return l(n)||(n=this._defaultOpts.incidentOccured),function(){n.apply(null,arguments)}},_getCreationOptions:function(){return{renderer:this._renderer,ownerElement:this._rootElement,owner:this._rootElement}},_getCommonOptions:function(){var n=this,t=n._getDefaultFormatOptions();return{translator:n._area.translator,animationEnabled:n.option("animationEnabled"),animationDuration:n.option("animationDuration"),containerBackgroundColor:n.option("containerBackgroundColor"),defaultTextFormat:t.format,defaultTextPrecision:t.precision}},_getDefaultFormatOptions:function(){var t=this._area;return n.utils.getAppropriateFormat(t.startValue,t.endValue,this._getApproximateScreenRange())},_getCommonNeedleSettings:function(){var n=this;return r(!0,{},n._defaultOpts.commonNeedleSettings,n._presetManager.getNeedlePreset(),n.option("commonNeedleSettings"))},_getCommonMarkerSettings:function(){var n=this;return r(!0,{},n._defaultOpts.commonMarkerSettings,n._presetManager.getMarkerPreset(),n.option("commonMarkerSettings"))},_getCommonRangeBarSettings:function(){var n=this;return r(!0,n._defaultOpts.commonRangeBarSettings,n._presetManager.getRangeBarPreset(),n.option("commonRangeBarSettings"))},_hide:function(){!this._isHidden&&(this._isHidden=!0)&&this._renderer.getRoot().hide()},_show:function(){this._isHidden&&delete this._isHidden&&this._renderer.getRoot().show()},_getCanvas:function(){var i=this,t=i.option("size")||{},n=i.option("margin")||{},f=i._element(),e=i._getDefaultContainerSize(),r=t.width>=0?Number(t.width):f.width(),u=t.height>=0?Number(t.height):f.height();return r||Number(t.width)===0||(r=e.width),u||Number(t.height)===0||(u=e.height),{width:r,height:u,marginLeft:n.left>0?Number(n.left):0,marginTop:n.top>0?Number(n.top):0,marginRight:n.right>0?Number(n.right):0,marginBottom:n.bottom>0?Number(n.bottom):0}},_updateVisibility:function(n){var t=this;return n.width-n.marginLeft-n.marginRight>=2&&n.height-n.marginTop-n.marginBottom>=2&&t._element().is(":visible")?(t._show(),!0):(t._hide(),t._incidentOccured("Gauge cannot be rendered since container is too small or not visible"),!1)},_getArea:function(){var i=this,t=i.option("scale")||{},n={};return n.startValue=o(t.startValue)?Number(t.startValue):0,n.endValue=o(t.endValue)?Number(t.endValue):100,n.baseValue=Math.min(n.startValue,n.endValue),i._setupArea(n),n.translator=u.createTranslator(n.startCoord,n.endCoord,n.startValue,n.endValue),n},_renderTitle:function(){var n=this,t=n.option("title"),i=n.option("subtitle");n._title||(n._title=u.createTitle(),n._title._renderer=n._renderer,n._title._owner=n._rootElement),t=r(!0,{},n._defaultOpts.title,n._presetManager.getTitlePreset(),n._title.processTitleOptions(t)),i=r(!0,{},n._defaultOpts.subtitle,n._presetManager.getSubtitlePreset(),n._title.processSubtitleOptions(i)),n._title.render({title:t,subtitle:i}),n._title.isVisible()&&n._externalElements.push(n._title)},_renderDeltaIndicator:function(){var n=this,t=n.option("indicator");n._indicator||(n._indicator=u.createIndicator(),n._indicator&&(n._indicator._renderer=n._renderer,n._indicator._owner=n._rootElement)),n._indicator&&(t=r(!0,{},n._defaultOpts.indicator,n._presetManager.getIndicatorPreset(),t),n._indicator.render(t),n._indicator.isVisible()&&n._externalElements.push(n._indicator))},_renderTooltip:function(){var n=this,t=r({},n._defaultOpts.tooltip,n.option("tooltip"));n._tooltip||(n._tooltip=u.createTooltip(),n._tooltip.setup(n)),n._tooltip.init(r(!0,{},n._defaultOpts.tooltip,n.option("tooltip"))),n._tooltip.render()},_renderCore:function(n){var t=this,r=t._canvas,i=t._getCanvas();t._updateVisibility(i)&&(i.width!==r.width||i.height!==r.height||n)&&(t._renderer.container||t._renderer.draw(t._element().get(0)),t._renderer.resize(i.width,i.height),t._canvas=i,t._rootRect=new h({left:i.marginLeft,top:i.marginTop,right:i.width-i.marginRight,bottom:i.height-i.marginBottom}),t._layoutManager.setRect(t._rootRect),t._mainRect=t._rootRect.clone(),t._area=t._getArea(),t._commonOptions=t._getCommonOptions(),t._mainElements.length=0,t._externalElements.length=0,t._renderTitle(),t._renderDeltaIndicator(),f(t._externalElements,function(n,i){var r=t._layoutManager.applyLayout(i.getBoundingRect(),i.getLayoutOptions());i.move(r.dx,r.dy)}),t._mainRect=t._layoutManager.getRect(),t._prepareMainElements(),t._applyMainLayout(t._measureMainElements()),t._renderMainElements(),f(t._externalElements,function(n,i){var r=t._layoutManager.dock(i.getBoundingRect(),i.getLayoutOptions());i.move(r.dx,r.dy)}),t._renderTooltip(),t._tracker.init(t.option("tracker")).activate())},_render:function(){var n=this;n._incidentOccured=n._getIncidentOccured(),n._renderCore(!0),n._updateActiveElements(),n._trackWindowResize()},_prepareMainElements:function(){var n=this;n._renderRangeContainer(),n._renderScale();var r=n.option("rangeBars"),t=n.option("needles"),u=n.option("markers");r===i&&t===i&&u===i&&(t=[{value:n._area.baseValue}]),n._renderIndicators("_rangeBars",r||[],n._getCommonRangeBarSettings(),n._createRangeBar),n._renderIndicators("_needles",t||[],n._getCommonNeedleSettings(),n._createNeedle),n._renderIndicators("_markers",u||[],n._getCommonMarkerSettings(),n._createMarker)},_updateActiveElements:function(){var n=this;f(n._mainElements,function(n,t){t.setCurrentValue&&t.setCurrentValue(t._options.value)})},_renderScale:function(){var n=this,i=n._scale,r=n.option("scale"),t;i||(i=n._scale=n._createScale(),i.setup({renderer:n._renderer,owner:n._rootElement,incidentOccured:n._incidentOccured})),t=n._combineOptions(n._commonOptions,n._defaultOpts.commonScaleSettings,n._presetManager.getScalePreset(),r,{offset:0}),t.majorTick.customTickValues=t.majorTick.customTickValues||[],t.minorTick.customTickValues=t.minorTick.customTickValues||[],i.init(t),n._mainElements.push(i)},_renderRangeContainer:function(){var n=this,t=n._rangeContainer,r=n.option("rangeContainer"),i;t||(t=n._rangeContainer=n._createRangeContainer(),t.setup({renderer:n._renderer,owner:n._rootElement,incidentOccured:n._incidentOccured})),i=n._combineOptions(n._commonOptions,n._defaultOpts.commonRangeSettings,n._presetManager.getRangePreset(),r),i.ranges=i.ranges||[],t.init(i),n._mainElements.push(t)},_renderIndicators:function(n,t,r,u){for(var c=this,a=c[n],l=[],o,s,e,f=0,h=a.length;f<h;++f)s=a[f],o=t[f],o?(e=c._renderIndicator(s,r,o,u),s!==e&&s.destroy(),e&&l.push(e)):s.destroy();for(f=h,h=t.length;f<h;++f)o=t[f],o&&(e=c._renderIndicator(i,r,o,u),e&&l.push(e));c[n]=l},_renderIndicator:function(n,t,r,u){var e=this,o=e._combineOptions(e._commonOptions,t,r),f=n;return e._updateIndicatorOptions(f,o),o.value!==i?(f&&f._options.type===o.type||(f=u.call(e,o.type),f?f.setup({renderer:e._renderer,owner:e._rootElement,tracker:e._trackerGroup}):e._incidentOccured("Cannot create "+o.__info+': type "'+o.type+'" is unknown')),f&&(f.init(o),e._mainElements.push(f))):f=i,f},_updateIndicatorOptions:function(n,t){t.baseValue=s(t.translator.translate(t.baseValue))?t.baseValue:this._area.baseValue,n&&(t.currentValue=n.getCurrentValue()),s(t.currentValue)||(t.currentValue=t.baseValue),t.value=t.translator.adjust(t.value),!t.text||t.text.format||t.text.precision||(t.text.format=this._commonOptions.defaultTextFormat,t.text.precision=this._commonOptions.defaultTextPrecision)},_getTrackedElements:function(){var n=[];return f(this._rangeBars,function(t,i){n.push({target:i,info:{type:"rangebar",index:t}})}),f(this._needles,function(t,i){n.push({target:i,info:{type:"needle",index:t}})}),f(this._markers,function(t,i){n.push({target:i,info:{type:"marker",index:t}})}),n},_accessIndicatorValue:function(n,t){return t===i?n?n.getCurrentValue():i:(n&&n.setCurrentValue(t),this)},needleValue:function(n,t){return this._accessIndicatorValue(this._needles[n],t)},markerValue:function(n,t){return this._accessIndicatorValue(this._markers[n],t)},rangeBarValue:function(n,t){return this._accessIndicatorValue(this._rangeBars[n],t)},indicatorValue:function(n){var t=this;n!==i&&t._indicator&&t._indicator.update(n)},_optionValuesEqual:function(n,t,i){return n==="rangeContainer"&&t&&i&&i.ranges&&(t.ranges=null),n==="scale"&&(t&&t.majorTick&&i.majorTick&&i.majorTick.customTickValues&&(t.majorTick.customTickValues=null),t&&t.minorTick&&i.minorTick&&i.minorTick.customTickValues&&(t.minorTick.customTickValues=null)),this.callBase.apply(this,arguments)}})}(DevExpress,jQuery),function(n,t,i){function w(n,t){var s=l(n),h=l(t),i=s.cos,u=s.sin,e=h.cos,o=h.sin;return{left:u<=0&&o>=0||u<=0&&o<=0&&i<=e||u>=0&&o>=0&&i>=e?-1:f(i,e,0),right:u>=0&&o<=0||u>=0&&o>=0&&i>=e||u<=0&&o<=0&&i<=e?1:r(i,e,0),up:i<=0&&e>=0||i<=0&&e<=0&&u>=o||i>=0&&e>=0&&u<=o?-1:-r(u,o,0),down:i>=0&&e<=0||i>=0&&e>=0&&u<=o||i<=0&&e<=0&&u>=o?1:-f(u,o,0)}}var u=n.viz.gauges.__factory,h=n.utils.isNumber,o=window.Number,c=n.utils.normalizeAngle,l=n.utils.getCosAndSin,r=Math.max,f=Math.min,e=Math.round,v=Array.prototype.slice,s=t.extend,a=t.each,y=Math.PI,p={geometry:{startAngle:225,endAngle:315,totalRadius:i},scale:{orientation:"outside",label:{indentFromTick:10}},rangeContainer:{orientation:"outside"},spindle:{visible:!0,size:14,gapSize:10,color:"#C2C2C2"},commonNeedleSettings:{offset:20,type:"rectangle",indentFromCenter:0,width:2,space:2,secondColor:"#E18E92",secondFraction:.4},commonMarkerSettings:{offset:-6,type:"textcloud"},commonRangeBarSettings:{offset:30}};n.viz.gauges.CircularGauge=n.viz.gauges.Gauge.inherit({_gaugeType:function(){return"circular"},_defaultOptions:function(){return s(!0,{},this.callBase(),p)},_setupArea:function(n){var r=this,u=r.option("geometry"),i=u.startAngle,t=u.endAngle;i=h(i)?c(i):r._defaultOpts.geometry.startAngle,t=h(t)?c(t):r._defaultOpts.geometry.endAngle,i<=t&&(t-=360),n.x=0,n.y=0,n.radius=100,n.startCoord=i,n.endCoord=t,n.totalRadius=u.totalRadius>0?o(u.totalRadius):r._defaultOpts.geometry.totalRadius,n.sides=w(i,t)},_getCreationOptions:function(){var n=this.callBase();return n.type="circular",n},_getCommonOptions:function(){var n=this._area;return s(!0,this.callBase(),{x:n.x,y:n.y,areaRadius:n.radius,type:"circular"})},_combineOptions:function(){var i=[!0,{}].concat(v.apply(arguments)),n=s.apply(t,i);return n.radius=e(n.areaRadius-o(n.offset)||n.areaRadius),n},_measureMainElements:function(){var s=this,n=0,u=Infinity,t=0,i=0,e=0,o=0;return a(s._mainElements,function(s,h){var c=h.measure();c.min>0&&(u=f(u,c.min)),c.max>0&&(n=r(n,c.max)),c.horizontalOffset>0&&(t=r(t,c.max+c.horizontalOffset)),c.verticalOffset>0&&(i=r(i,c.max+c.verticalOffset)),c.inverseHorizontalOffset>0&&(e=r(e,c.inverseHorizontalOffset)),c.inverseVerticalOffset>0&&(o=r(o,c.inverseVerticalOffset))}),t=r(t-n,0),i=r(i-n,0),{minRadius:u,maxRadius:n,horizontalMargin:t,verticalMargin:i,inverseHorizontalMargin:e,inverseVerticalMargin:o}},_applyMainLayout:function(n){var s=this,r=s._area,t=r.sides,o={left:(t.left<-.1?n.horizontalMargin:n.inverseHorizontalMargin)||0,right:(t.right>.1?n.horizontalMargin:n.inverseHorizontalMargin)||0,top:(t.up<-.1?n.verticalMargin:n.inverseVerticalMargin)||0,bottom:(t.down>.1?n.verticalMargin:n.inverseVerticalMargin)||0},i=s._layoutManager.selectRectByAspectRatio((t.down-t.up)/(t.right-t.left),o),u=f(i.width()/(t.right-t.left),i.height()/(t.down-t.up)),h,c;u>r.totalRadius&&(i=i.scale(r.totalRadius/u),u=r.totalRadius),u=u-n.maxRadius+r.radius,h=i.left-i.width()*t.left/(t.right-t.left),c=i.top-i.height()*t.up/(t.down-t.up),r.x=e(h),r.y=e(c),r.radius=u,i.left-=o.left,i.right+=o.right,i.top-=o.top,i.bottom+=o.bottom,s._layoutManager.setRect(i)},_renderMainElements:function(){var n=this,i=n._area.x,r=n._area.y,t=n._area.radius;a(n._mainElements,function(n,u){u.init({x:i,y:r,radius:e(t-o(u._options.offset)||t)}).render()})},_createScale:function(){return u.createCircularScale()},_createRangeContainer:function(){return u.createCircularRangeContainer()},_createNeedle:function(n){return u.createCircularNeedle(n)},_createMarker:function(n){return u.createCircularMarker(n)},_createRangeBar:function(){return u.createCircularRangeBar()},_createSpindle:function(){return u.createCircularSpindle()},_prepareMainElements:function(){this.callBase(),this._renderSpindle()},_renderSpindle:function(){var n=this;n._spindle||(n._spindle=n._createSpindle(),n._spindle.setup({renderer:n._renderer,owner:n._rootElement})),n._spindle.init(n._combineOptions(n._commonOptions,n._defaultOpts.spindle,n._presetManager.getSpindlePreset(),n.option("spindle"))),n._mainElements.push(n._spindle)},_getApproximateScreenRange:function(){var i=this,n=i._area,t=f(i._mainRect.width()/(n.sides.right-n.sides.left),i._mainRect.height()/(n.sides.down-n.sides.up));return t>n.totalRadius&&(t=n.totalRadius),t=.8*t,-n.translator.getCodomainRange()*t*y/180},_getDefaultContainerSize:function(){return{width:300,height:300}}})}(DevExpress,jQuery),function(n,t,i){var r=n.viz.gauges.__factory,e=Math.max,s=Math.min,u=Math.round,h=Array.prototype.slice,f=t.extend,o=t.each,c={geometry:{orientation:"horizontal",totalSize:i},scale:{horizontalOrientation:"right",verticalOrientation:"bottom",label:{indentFromTick:-10}},rangeContainer:{horizontalOrientation:"right",verticalOrientation:"bottom"},commonNeedleSettings:{offset:2.5,type:"rhombus",length:15,width:15},commonMarkerSettings:{offset:-1,type:"textcloud",horizontalOrientation:"left",verticalOrientation:"top"},commonRangeBarSettings:{offset:10,horizontalOrientation:"right",verticalOrientation:"bottom"}};n.viz.gauges.LinearGauge=n.viz.gauges.Gauge.inherit({_gaugeType:function(){return"linear"},_defaultOptions:function(){return f(!0,this.callBase(),c)},_setupArea:function(n){var t=this.option("geometry");n.vertical=t.orientation==="vertical",n.x=0,n.y=0,n.startCoord=-100,n.endCoord=100,n.totalSize=t.totalSize>0?Number(t.totalSize):i},_getCreationOptions:function(){var n=this.callBase();return n.type="linear",n},_getCommonOptions:function(){var n=this._area;return f(!0,this.callBase(),{baseX:n.x,baseY:n.y,orientation:n.vertical?"vertical":"horizontal"})},_combineOptions:function(){var i=[!0,{}].concat(h.apply(arguments)),n=f.apply(t,i);return n.x=u(n.baseX+Number(n.offset)||n.baseX),n.y=u(n.baseY+Number(n.offset)||n.baseY),n},_measureMainElements:function(){var r=this,n=1e3,t=0,i=0;return o(r._mainElements,function(r,u){var f=u.measure();t=e(t,f.max),n=s(n,f.min),f.indent>0&&(i=e(i,f.indent))}),{minBound:n,maxBound:t,indent:i}},_applyMainLayout:function(n){var f=this,t=f._area,i,e;t.vertical?(i=f._layoutManager.selectRectBySizes({width:n.maxBound-n.minBound,height:t.totalSize}),e=i.horizontalMiddle()-(n.minBound+n.maxBound)/2,t.startCoord=i.bottom-n.indent,t.endCoord=i.top+n.indent,t.x=u(t.x+e)):(i=f._layoutManager.selectRectBySizes({height:n.maxBound-n.minBound,width:t.totalSize}),e=i.verticalMiddle()-(n.minBound+n.maxBound)/2,t.startCoord=i.left+n.indent,t.endCoord=i.right-n.indent,t.y=u(t.y+e)),t.translator=r.createTranslator(t.startCoord,t.endCoord,t.startValue,t.endValue),f._layoutManager.setRect(i)},_renderMainElements:function(){var n=this,t=n._area.x,i=n._area.y,r=n._area.translator;o(n._mainElements,function(n,f){f.init({x:u(t+Number(f._options.offset)||t),y:u(i+Number(f._options.offset)||i),translator:r}).render()})},_createScale:function(){return r.createLinearScale()},_createRangeContainer:function(){return r.createLinearRangeContainer()},_createNeedle:function(n){return r.createLinearNeedle(n)},_createMarker:function(n){return r.createLinearMarker(n)},_createRangeBar:function(){return r.createLinearRangeBar()},_getApproximateScreenRange:function(){var t=this,i=t._area,n=i.vertical?t._mainRect.height():t._mainRect.width();return n>i.totalSize&&(n=i.totalSize),n=n*.8},_getDefaultContainerSize:function(){var n=this.option("geometry");return n.orientation==="vertical"?{width:100,height:300}:{width:300,height:100}}})}(DevExpress,jQuery),function(n,t){var s=n.formatHelper,f=window.Number,h=window.String,c=n.utils.isFunction,r=Math.round,e=t.extend,o=4,u={up:[-.5,-1,-1,0,0,-1,1,0,0,1,-1,0,0,1],down:[.5,1,1,0,0,1,-1,0,0,-1,1,0,0,-1],left:[-1,.5,0,1,-1,0,0,-1,1,0,0,1,1,0],right:[1,-.5,0,-1,1,0,0,1,-1,0,0,-1,-1,0]};n.viz.gauges.__internals.Tooltip=n.Class.inherit({setup:function(n){var t=this;return t._gauge=n,t._renderer=n._renderer,t._options={},t},init:function(n){var t=this;return e(!0,t._options,n),t},render:function(){var n=this;return n._options.enabled?(n._rootElement=n._rootElement||n._renderer.createGroup({"class":"tooltip"}),n._rootElement.append(n._gauge._rootElement),n._shadow=n._shadow||n._renderer.createArea().append(n._rootElement),n._cloud=n._cloud||n._renderer.createArea().append(n._rootElement),n._text=n._text||n._renderer.createText().append(n._rootElement),n._shadow.applySettings({stroke:"none",strokeWidth:0,fill:"#000000",opacity:.1}),n._cloud.applySettings({stroke:"none",strokeWidth:0}),n._text.applySettings({align:"center",font:n._options.font}),n._rootElement.applySettings({visibility:"hidden"}),n._visible=!1):n.clear(),n},clear:function(){var n=this;return n._rootElement&&(n._rootElement.remove(),delete n._rootElement,delete n._shadow,delete n._cloud,delete n._text),n},_formatValue:function(n,t){var i=this._options,u=s.format(n,i.format,i.precision),r;return c(i.customizeText)?(r=e(!0,t||{},{value:n,valueText:u}),h(i.customizeText.call(r,r))):u},_selectMask:function(n,t,i,r,f){var o=this._gauge._rootRect,e;return e=n+i/2>o.right?u.left:n-i/2<o.left?u.right:t-f-r<o.top?u.down:u.up},_getSettings:function(n,t,i,u,e){var w=this._options,a=i+2*f(w.horizontalPadding),v=u+2*f(w.verticalPadding),l=f(w.arrowLength),s=this._selectMask(n,t,a,v,l),y,b,p,h,c;for(b=[h=r(n-s[12]*e),c=r(t-s[13]*e),h+=r(s[0]*l),c+=r(s[1]*l),h+=r(s[2]*(a-l)/2),c+=r(s[3]*(v-l)/2),h+=r(s[4]*a),c+=r(s[5]*v),h+=r(s[6]*a),c+=r(s[7]*v),h+=r(s[8]*a),c+=r(s[9]*v),h+=r(s[10]*(a-l)/2),c+=r(s[11]*(v-l)/2)],p=b.slice(0),h=r(s[12]*o),c=r(s[13]*o),y=0;y<14;y+=2)p[y]+=h,p[y+1]+=c;return h=r(n-s[12]*(l+a/2+e)),c=r(t-s[13]*(l+v/2+e))-2,{x:h,y:c,cloudPoints:b,shadowPoints:p}},show:function(n){n=n||{};var t=this,f=t._formatValue(n.value,n.context),i,u;return t._text.applySettings({text:f,x:0,y:0}),i=t._text.getBBox(),u=t._getSettings(n.x,n.y,i.width,i.height,n.offset||0),t._shadow.applySettings({points:u.shadowPoints}),t._cloud.applySettings({points:u.cloudPoints,fill:n.color}),t._text.applySettings({x:u.x,y:r(u.y-i.y-i.height/2+2)}),!t._visible&&t._rootElement.applySettings({visibility:"visible"})&&(t._visible=!0),t},hide:function(){var n=this;return n._visible&&n._rootElement.applySettings({visibility:"hidden"})&&(n._visible=!1),n},enabled:function(){return!!this._rootElement}})}(DevExpress,jQuery),function(n,t){function a(n){var t=n.data.tracker;t._context!==null&&t._processLeave(),t._context=n.data,t._processEnter(n)}function v(n){var t=n.data.tracker;t._context!==null&&(t._processLeave(),t._context=null)}function y(n){n.data.tracker._processMove(n)}var u=window.setTimeout,f=window.clearTimeout,l=window.Number,e=t.extend,o=t.each,s=Math.abs,h=200,c=3,p={mouseover:a,mouseout:v},r={mousemove:y};n.viz.gauges.__internals.Tracker=n.Class.inherit({setup:function(n){var t=this;return t._gauge=n,t._listeners=[],t._context=null,t._options={},t._waitHoverCallback=function(){t._context.element.off(r),t._context.hover=!0,t._processHoverOn()},t},init:function(n){return e(!0,this._options,n),this},activate:function(){var n=this;return n._detachListeners(),n._gauge._tooltip.enabled()&&n._attachListeners(),n._gauge._trackerGroup.toForeground(),n._tooltipDelay=n._options.tooltipDelay>=0?l(n._options.tooltipDelay):0,n},_attachListeners:function(){var n=this;o(n._gauge._getTrackedElements(),function(t,i){var r;if(i.target.getTrackingElement&&(r=i.target.getTrackingElement(),r)){n._listeners.push(r);r.on(p,{tracker:n,element:r,target:i.target,info:i.info})}})},_detachListeners:function(){var n=this;o(n._listeners,function(n,t){t.off()}),n._listeners.length=0},_processEnter:function(n){var i=this,t=i._context;t.x=n.pageX,t.y=n.pageY;t.element.on(r,t);t.hoverTimeout=u(i._waitHoverCallback,h)},_processLeave:function(){var n=this;n._context.element.off(r),f(n._context.hoverTimeout),n._context.hover&&n._processHoverOff(),delete n._context.hover},_processMove:function(n){var i=this,t=i._context;(s(n.pageX-t.x)>c||s(n.pageY-t.y)>c)&&(t.x=n.pageX,t.y=n.pageY,f(t.hoverTimeout),t.hoverTimeout=u(i._waitHoverCallback,h))},_processHoverOn:function(){this._gauge._tooltip.show(e(!0,this._context.target.getTooltipParameters(),{context:this._context.info}))},_processHoverOff:function(){this._gauge._tooltip.hide()}})}(DevExpress,jQuery),function(n){n.viz.rangeSelector={utils:{}}}(DevExpress),function(n){DevExpress.viz.rangeSelector.BaseVisualElement=n.Class.inherit({ctor:function(n){this._renderer=n,this._isDrawn=!1},applyOptions:function(n){this._options=n||{},this._applyOptions(this._options)},_applyOptions:function(){},redraw:function(n){var t=this;t._isDrawn?t._update(n||t._group):(t._isDrawn=!(t._draw(n||t._group)===!1),n&&(t._group=n))},isDrawn:function(){return!!this._isDrawn},isInitialized:function(){return!!this._options},_draw:function(){},_update:function(n){n.clear(),this._draw(n)}})}(DevExpress),function(n,t,i){var u=t.viz.rangeSelector,h=t.viz.core,r=t.utils,o=t.data.utils,f=u.utils,s=t.viz.core.ParseUtils,e=t.formatHelper,c=100;u.consts={fontHeightRatio:.55,emptySliderMarkerText:". . ."},u.formatValue=function(n,t){var i={value:n,valueText:e.format(n,t.format,t.precision)};return String(t.customizeText?t.customizeText.call(i,i):i.valueText)},u.RangeSelector=t.ui.Component.inherit(function(){var y=5,p={size:i,margin:{left:0,top:0,right:0,bottom:0},scale:{showCustomBoundaryTicks:!0,showMinorTicks:!0,startValue:i,endValue:i,minorTickCount:i,minorTickInterval:i,majorTickInterval:i,useTicksAutoArrangement:!0,setTicksAtUnitBeginning:!0,minRange:i,maxRange:i,placeholderHeight:i,valueType:i,label:{visible:!0,format:i,precision:i,customizeText:i},marker:{visible:!0,label:{format:i,precision:i,customizeText:i}}},selectedRange:i,sliderMarker:{visible:!0,format:i,precision:i,customizeText:i,placeholderSize:i},behavior:{snapToTicks:!0,animationEnabled:!0,moveSelectedRangeByClick:!0,manualRangeSelectionEnabled:!0,allowSlidersSwap:!0,callSelectedRangeChanged:"onMovingComplete"},background:{color:"#C0BAE1",visible:!0,image:{url:i,location:"full"}},chart:{commonSeriesSettings:{type:"area",label:{visible:!1},hoverMode:"none"},equalBarWidth:!0,topIndent:.1,bottomIndent:0,valueAxis:{min:i,max:i,inverted:!1},series:i},dataSource:i,dataSourceField:"arg",redrawOnResize:!0,theme:i,selectedRangeChanged:null,incidentOccured:n.noop},h=function(n,t,r){var o=t===i?u.consts.emptySliderMarkerText:u.formatValue(t,r),e=f.getTextBBox(n,o,r.font);return{width:Math.ceil(e.width)+2*r.padding,height:Math.ceil(e.height*u.consts.fontHeightRatio)+2*r.padding+r.pointerSize}},c=function(n,t,i){var r=u.formatValue(t,i.label),e=f.getTextBBox(n,r,i.label.font);return Math.ceil(e.width/2)},w=function(n,t,i){var r={left:t.left+i.left,top:t.top+i.top,width:n.width-t.left-t.right-i.left-i.right,height:n.height-t.top-t.bottom-i.top-i.bottom};return r.width<=0&&(r.width=1),r},b=function(n){var t,i,u;return r.isNumber(n)?t=i=u=n:n&&(r.isNumber(n.height)&&(u=n.height),r.isNumber(n.width)?t=i=n.width:n.width&&(r.isNumber(n.width.left)&&(t=n.width.left),r.isNumber(n.width.right)&&(i=n.width.right))),{widthLeft:t,widthRight:i,height:u}},k=function(n,t,i,r){var s,a,v,l,y,u=0,f=0,e=0,o;return o=b(r.placeholderSize),u=o.widthLeft||0,f=o.widthRight||0,e=o.height||0,r.visible&&(s=h(n,i.startValue,r),u||(u=s.width),l=h(n,i.endValue,r),f||(f=l.width),e||(e=Math.max(s.height,l.height))),a=c(n,i.startValue,i),v=c(n,i.endValue,i),u=Math.max(u,a),f=Math.max(f,v),{left:u,right:f,top:e,bottom:0}},d=function(n){n&&n.empty()},g=function(n){return n._element()},nt=function(n){return u.rangeSelectorFactory.createRangeContainer(n)},tt=function(n,t){return u.rangeSelectorFactory.createTranslator(n,t)},it=function(n,t,i){return{left:t.left,top:t.top,right:n.width-t.width-t.left,bottom:n.height-t.height-t.top+i,width:n.width,height:n.height}},rt=function(n){var t=n.option("renderer");return t?t:t=u.rangeSelectorFactory.createRenderer()},ut=function(n){return u.rangeSelectorFactory.createThemeManager(n)},l=function(t,i){var r=[n.type(t),n.type(i)];return n.inArray(),n.inArray("date",r)!=-1?"datetime":n.inArray("number",r)!=-1?"numeric":""},ft=function(n){var r,f=n._dataSource&&n._dataSource.items(),t=n.option("scale"),i=t.valueType;return i||(i=l(t.startValue,t.endValue)),(f||n.option("chart").series)&&(r=new u.SeriesDataSource({renderer:n.renderer,dataSource:f,valueType:(i||"").toLowerCase(),chart:n.option("chart"),dataSourceField:n.option("dataSourceField"),backgroundColor:n._userBackgroundColor,incidentOccured:n.option("incidentOccured")})),r},et=function(n,i,u){var f,e,o,s=!1;return r.isDefined(u.startValue)&&r.isDefined(u.endValue)?(s=u.inverted=u.startValue>u.endValue,e=s?u.endValue:u.startValue,o=s?u.startValue:u.endValue):(r.isDefined(u.startValue)||r.isDefined(u.endValue))&&(e=u.startValue,o=u.endValue),f=i?i.getBoundRange():new t.viz.charts.Range,e!==o&&(f.invertX=s,f.getBoundRange({minX:e,maxX:o,minVisibleX:e,maxVisibleX:o})),f.isDefinedX()||f.setStubDataX(u.valueType),f},ot=function(n,t,i){var r,u=t.label.visible;return t.placeholderHeight?t.placeholderHeight:(r=f.getTextBBox(n,"0",t.label.font),(u?t.label.topIndent+r.height:0)+(i?t.marker.topIndent+t.marker.separatorHeight:0))},st=function(n,t,i,f){var e=t.isEmpty,a=u.rangeSelectorFactory.getTickProvider(),o,s,h,c,l=i.getBusinessRange();return o={tickInterval:e?0:n.option("scale").minorTickInterval,showCustomBoundaryTicks:t.showCustomBoundaryTicks,minorTickCount:t.minorTickCount},s={textOptions:{align:"center",font:t.label.font},renderer:n.renderer,getText:function(n){return u.formatValue(n,t.label)},translator:i,isStartTickGenerated:!r.isDefined(n.option("scale").majorTickInterval),tickInterval:t.majorTickInterval,textSpacing:y,setTicksAtUnitBeginning:t.setTicksAtUnitBeginning,useTicksAutoArrangement:t.useTicksAutoArrangement,hideLabels:e},h=e?l.minX:t.startValue,c=e?l.maxX:t.endValue,a.getFullTicks(h,c,f,s,o)},ht=function(n,t,i){var f=u.rangeSelectorFactory.getTickProvider(),r=f.getTickIntervals(n.startValue,n.endValue,t,{tickInterval:n.majorTickInterval,incidentOccured:i},{tickInterval:n.minorTickInterval,incidentOccured:i});n.minorTickInterval=r.minorTickInterval,n.majorTickInterval=r.majorTickInterval},ct=function(n,t,u,f,o){var s=r.isDefined(u.minVisibleX)?u.minVisibleX:u.minX,h=r.isDefined(u.maxVisibleX)?u.maxVisibleX:u.maxX;t&&!t.isEmpty()&&(o.startValue=o.inverted?h:s,o.endValue=o.inverted?s:h),o.isEmpty=!r.isDefined(o.startValue)||!r.isDefined(o.endValue)||o.startValue===o.endValue||o.valueType==="string",o.isEmpty?o.startValue=o.endValue=i:(ht(o,f,n.option("incidentOccured")),o.valueType!=="datetime"||r.isDefined(o.label.format)||(o.label.format=o.marker.visible?r.getDateUnitInterval(o.majorTickInterval):e.getDateFormatByTickInterval(o.startValue,o.endValue,o.majorTickInterval)))},lt=function(t,i,u){var f=n.extend(!0,{},t.option("sliderMarker")),o;return f.format||(!t.option("behavior").snapToTicks&&r.isNumber(i.startValue)&&(o=Math.abs(i.endValue-i.startValue),f.format="fixedPoint",f.precision=r.getSignificantDigitPosition(o/u)),i.valueType==="datetime"&&(f.format=i.marker.visible?r.getDateUnitInterval(r.isDefined(i.minorTickInterval)&&i.minorTickInterval!==0?i.minorTickInterval:i.majorTickInterval):e.getDateFormatByTickInterval(i.startValue,i.endValue,i.minorTickInterval!==0?i.minorTickInterval:i.majorTickInterval))),f},at=function(n){return n.valueType=="datetime"&&n.marker.visible},vt=function(n,t){var i=t.minorTickInterval||t.majorTickInterval;n=n.getBoundRange({intervalX:i})},yt=function(t,u){var f=n.extend(!0,{},t.option("scale")),h=t.option("incidentOccured"),e=0,a=new s({incidentOccured:h}),o=a.correctValueType((f.valueType||"").toLowerCase()),c;return(u&&(o=u.getCalculatedValueType()||o),o||(o=l(f.startValue,f.endValue)||"numeric"),f.valueType=o,f.valueType==="string")?(h("The type of the argument values specified in the data source is unsupported."),f):(c=a.getParser(o,"scale"),r.isDefined(f.startValue)&&(e=c(f.startValue),r.isDefined(e)?f.startValue=e:(f.startValue=i,h.call(null,"Cannot parse the value specified as the startValue property of the scale configuration object."))),r.isDefined(f.endValue)&&(e=c(f.endValue),r.isDefined(e)?f.endValue=e:(f.endValue=i,h.call(null,"Cannot parse the value specified as the endValue property of the scale configuration object."))),f.parser=c,f)},pt=function(n,t,i){var r=n.option("size")||{};t.height||r.height===0||(t.height=i.valueType==="datetime"&&i.marker.visible!==!1?160:120),t.width||r.width===0||(t.width=400)},wt=function(n){var r,i,u,f,t,e,o,s,h=n.container,c;if(n._isUpdating=!0,t=v(n),n._actualSize=t,i=ft(n),n._scaleOptions=yt(n,i),pt(n,t,n._scaleOptions),t.width&&t.height&&h.is(":visible"))n.stopRedraw=!1;else{n.stopRedraw=!0,n.option("incidentOccured")("RangeSelector can not be drawn as container is not visible");return}bt(n,t),u=et(n,i,n._scaleOptions),ct(n,i,u,t.width,n._scaleOptions),vt(u,n._scaleOptions),o=lt(n,n._scaleOptions,t.width),s=dt(n,n._scaleOptions),e=k(n.renderer,t,n._scaleOptions,o),r=w(t,n.option("margin"),e),f=ot(n.renderer,n._scaleOptions,at(n._scaleOptions)),n.translator=tt(u,it(t,r,f)),n._scaleOptions.ticksInfo=st(n,n._scaleOptions,n.translator,r.width),i&&i.adjustSeriesDimensions(n.translator),n.rangeContainer.applyOptions({canvas:r,scaleLabelsAreaHeight:f,sliderMarkerSpacing:e,translator:n.translator,selectedRange:s,scale:n._scaleOptions,behavior:n.option("behavior"),background:n.option("background"),chart:n.option("chart"),seriesDataSource:i,sliderMarker:o,sliderHandles:n.option("sliderHandles"),shutter:n.option("shutter"),selectedRangeChanged:a(n),setSelectedRange:function(t){n.setSelectedRange(t)}}),n._isUpdating=!1},a=function(n){return function(t,i){var r=n.option("selectedRangeChanged");n.option("selectedRange",t),r&&!i&&r(t)}},v=function(n){var i=n.container,r=n.option("size")||{},t={width:r.width,height:r.height};return i&&(t.width||(t.width=i.width()),t.height||(t.height=i.height())),t},bt=function(n,t){var i=n.renderer;i.isInitialized()?i.getRoot().applySettings({width:t.width,height:t.height}):(i.recreateCanvas(t.width,t.height),i.draw(n.container[0]))},kt=function(n,t){var i;!n.option("chart").theme&&t&&t.theme&&(i=t.theme,i&&(typeof i=="object"&&(i=i.chart||{},i.name=t.theme.name),n.option("chart").theme=i))},dt=function(n,t){var i=n.option("selectedRange"),f=t.parser||function(){return null},u=function(i,u){var e,o=t[u];return r.isDefined(i)&&(e=f(i)),r.isDefined(e)?o=e:n.option("incidentOccured").call(null,"Cannot parse the value specified as the "+u+" property of the selectedRange configuration object."),o};return i?{startValue:u(i.startValue,"startValue"),endValue:u(i.endValue,"endValue")}:{startValue:t.startValue,endValue:t.endValue}},gt=function(n){var t=n._actualSize,i=v(n);return t&&(t.width!==i.width||t.height!==i.height)},ni=function(n){return t.utils.createResizeHandler(function(){gt(n)&&n._render(!0)})};return{_defaultOptions:function(){return p},_dataSourceOptions:function(){return{paginate:!1,_preferSync:!0}},_init:function(){var t=this;t.container=g(t),d(t.container),t.renderer=rt(t),t.rangeContainer=nt(t.renderer),t.option("redrawOnResize")===!0&&r.windowResizeCallbacks.add(ni(t)),n.isFunction(t.option("incidentOccured"))||t.option("incidentOccured",n.noop),t._reinitDataSource()},_reinitDataSource:function(){this._initDataSource(),this._loadDataSource()},_initOptions:function(t){var i=this,r;this._optionsInitializing=!0,t=t||{},i._userOptions=n.extend(!0,{},t),r=ut(t.theme),r.setBackgroundColor(t.containerBackgroundColor),i.option(r.applyRangeSelectorTheme(t)),kt(i,t),t.background&&(i._userBackgroundColor=t.background.color)},_render:function(n){this._optionsInitializing=!1;var t=this,r,i;wt(t),t.stopRedraw||(n?(i=t.option("behavior"),r=i.animationEnabled,i.animationEnabled=!1,t.rangeContainer.redraw(),i.animationEnabled=r):t.rangeContainer.redraw())},_optionChanged:function(n,t){var r=this;this._optionsInitializing||o.compileSetter(n)(r._userOptions,t,{functionsAsIs:!0,merge:!0}),n==="dataSource"?(r._reinitDataSource(),r._invalidate()):n==="selectedRange"?r.setSelectedRange(r.option("selectedRange")):n==="selectedRangeChanged"?r.rangeContainer.slidersContainer.selectedRangeChanged=a(r):n==="containerBackgroundColor"||n==="theme"?(this._initOptions(r._userOptions),r._invalidate()):r._invalidate()},_handleDataSourceChanged:function(){var n=this;n.renderer.isInitialized()&&n._render()},getSelectedRange:function(){var t=this,n=t.rangeContainer.slidersContainer.getSelectedRange();return{startValue:n.startValue,endValue:n.endValue}},setSelectedRange:function(n){var i=this,t;!i._isUpdating&&n&&((t=i.rangeContainer.slidersContainer.getSelectedRange(),t&&t.startValue===n.startValue&&t.endValue===n.endValue)||i.rangeContainer.slidersContainer.setSelectedRange(n))},resetSelectedRange:function(n){var t=this;t.setSelectedRange({startValue:t._scaleOptions.startValue,endValue:t._scaleOptions.endValue,blockSelectedRangeChanged:n})}}}()).include(t.ui.DataHelperMixin)}(jQuery,DevExpress),function(n,t){var r=t.viz.rangeSelector;r.RangeContainer=r.BaseVisualElement.inherit(function(){var t=function(n){this.callBase(n),this.slidersContainer=u(n),this.rangeView=e(n),this.scale=f(n)},i=function(n){var t=this,i=n.scale.isEmpty,r={left:n.canvas.left,top:n.canvas.top,width:n.canvas.width,height:n.canvas.height>=n.scaleLabelsAreaHeight?n.canvas.height-n.scaleLabelsAreaHeight:0};t._viewCanvas=r,t.slidersContainer.applyOptions({canvas:r,translator:n.translator,scale:n.scale,selectedRange:n.selectedRange,sliderMarker:n.sliderMarker,sliderHandles:n.sliderHandles,shutter:n.shutter,behavior:n.behavior,selectedRangeChanged:n.selectedRangeChanged,isEmpty:i}),t.rangeView.applyOptions({canvas:r,translator:n.translator,background:n.background,chart:n.chart,seriesDataSource:n.seriesDataSource,behavior:n.behavior,isEmpty:i}),t.scale.applyOptions({canvas:n.canvas,translator:n.translator,scale:n.scale,hideLabels:i,scaleLabelsAreaHeight:n.scaleLabelsAreaHeight,setSelectedRange:n.setSelectedRange})},u=function(n){return r.rangeSelectorFactory.createSlidersContainer(n)},f=function(n){return r.rangeSelectorFactory.createScale(n)},e=function(n){return r.rangeSelectorFactory.createRangeView(n)},n=function(n,t){return{left:n.left-t.left,top:n.top-t.top,width:n.width+t.right+t.left,height:n.height+t.bottom+t.top}},o=function(){var t=this,i,e,o,s,r,h=t._options.size,u=n(t._options.canvas,t._options.sliderMarkerSpacing),f=t._viewCanvas;t._clipRect=t._renderer.createClipRect(u.left,u.top,u.width,u.height).append(),i=t._renderer.createGroup({"class":"rangeContainer",clipId:t._clipRect.id}).append(),t._viewClipRect=t._renderer.createClipRect(f.left,f.top,f.width,f.height).append(),e=t._renderer.createGroup({"class":"view",clipId:t._viewClipRect.id}),e.append(i),t.rangeView.redraw(e),o=t._renderer.createGroup({"class":"slidersContainer"}),o.append(i),t.slidersContainer.redraw(o),s=t._renderer.createGroup({"class":"scale"}),s.append(i),t.scale.redraw(s),r=t._renderer.createGroup({"class":"trackers"}),r.append(i),t._trackersGroup=r,t.slidersContainer.appendTrackers(r)},s=function(){var t=this,i=n(t._options.canvas,t._options.sliderMarkerSpacing),r=t._viewCanvas;t._clipRect.updateRectangle({x:i.left,y:i.top,width:i.width,height:i.height}),t._viewClipRect.updateRectangle({x:r.left,y:r.top,width:r.width,height:r.height}),t.rangeView.redraw(),t.slidersContainer.redraw(),t.slidersContainer.appendTrackers(t._trackersGroup),t.scale.redraw()};return{ctor:t,_applyOptions:i,_draw:o,_update:s}}())}(jQuery,DevExpress),function(n,t,i){var r=t.viz.rangeSelector,f=t.formatHelper,u=t.utils,e=5;r.Scale=r.BaseVisualElement.inherit({_setupDateTickInterval:function(n){this.dateUnitInterval=u.getDateUnitInterval(n),this._prepareTickIntervalObject(n,this.dateUnitInterval)},_prepareTickIntervalObject:function(n,t){if(u.isObject(n)&&u.isString(t))for(var i in n)i!==t+"s"&&delete n[i]},_prepareDatesDifferences:function(n,t){var i=t;i==="week"&&(i="day"),i==="quarter"&&(i="month"),n[i]&&(n[i]=!1,n.count--)},_getMarkerDate:function(n,t){var i=new Date(n.getTime()),r=0;switch(t){case"quarter":r=f.getFirstQuarterMonth(n.getMonth());case"month":i.setMonth(r);case"week":case"day":i.setDate(1);case"hour":i.setHours(0,0,0,0);break;case"millisecond":i.setMilliseconds(0);break;case"second":i.setSeconds(0,0);break;case"minute":i.setMinutes(0,0,0)}return i},_drawDateMarker:function(n,t){var r,u,f,i,e;if(t.x!==null)return i=this._options.scale,this.lineOptions["class"]="dx-range-selector-date-marker",this._renderer.createLine(t.x,t.y,t.x,t.y+i.marker.separatorHeight,this.lineOptions).append(t.group),f=this._getLabel(n,t.label),r=t.x+i.tick.width+i.marker.textLeftIndent,u=t.y+i.marker.textTopIndent+i.label.font.size,this.textOptions.align="left",e=this._renderer.createText(f,r,u,this.textOptions).append(t.group),r+e.getBBox().width},_drawDateMarkers:function(n,t){var c,i,e,o,r,h=-1,s;if(this._options.scale.valueType==="datetime"&&this.visibleMarkers&&(s=[],n.length>1)){for(i=1;i<n.length;i++)e=u.getDatesDifferences(n[i-1],n[i]),this._prepareDatesDifferences(e,this.dateUnitInterval),e.count>0&&(o=this._getMarkerDate(n[i],this.dateUnitInterval),r=this.translator.translateX(o),r>h&&(r!==null&&s.push({date:o,posX:r}),h=this._drawDateMarker(o,{group:t,y:this._options.canvas.top+this._options.canvas.height-this.markersAreaHeight+this._options.scale.marker.topIndent,x:r,label:this._getLabelFormatOptions(f.getDateFormatByDifferences(e))})));this._initializeMarkersEvents(s,t)}},_getLabelFormatOptions:function(t){return u.isDefined(this._options.scale.marker.label.format)?this._options.scale.marker.label:n.extend({},this._options.scale.marker.label,{format:t})},_calculateRangeByMarkerPosition:function(n,t,i){var r={},f,u;for(f in t)u=t[f],i.inverted?n<u.posX?r.endValue=u.date:r.startValue||(r.startValue=u.date):n>=u.posX?r.startValue=u.date:r.endValue||(r.endValue=u.date);return r.startValue=r.startValue||i.startValue,r.endValue=r.endValue||i.endValue,r},_initializeMarkersEvents:function(n,t){var i=this,s=this._options.canvas.top+this._options.canvas.height-this.markersAreaHeight+this._options.scale.marker.topIndent,u,f,h,e,o;if(n.length>0){u=i._renderer.createRect(i._options.canvas.left,s,i._options.canvas.width,i._options.scale.marker.separatorHeight,0,{fill:"grey",stroke:"grey",opacity:.0001}),u.append(t);u.on(r.events.start,function(t){f=r.utils.getRootOffsetLeft(i._renderer),e=r.utils.getEventPageX(t)-f,o=i._calculateRangeByMarkerPosition(e,n,i._options.scale),i._options.setSelectedRange(o)});i._markersTracker=u}},_getLabel:function(n,t){var i={value:n,valueText:f.format(n,t.format,t.precision)};return String(t.customizeText?t.customizeText.call(i,i):i.valueText)},_drawLabel:function(n,t){var i=this._options.canvas.top+this._options.canvas.height-this.markersAreaHeight,r=this._renderer.createText(this._getLabel(n,this._options.scale.label),this.translator.translateX(n),i,this.textOptions);r.append(t)},_drawTick:function(n,t){this.lineOptions["class"]="dx-range-selector-tick";var r=this._options.canvas.top+this._options.canvas.height-this.scaleLabelsAreaHeight,i=this.translator.translateX(n),u=this._renderer.createLine(i,this._options.canvas.top,i,r,this.lineOptions).append(t)},_redraw:function(n){for(var r=this,u=r._options.scale,e=r._renderer.createGroup(),o=r._renderer.createGroup().append(n),f=u.ticksInfo.majorTicks,s=u.ticksInfo.minorTicks,h=u.ticksInfo.customBoundaryTicks,c=r._options.hideLabels||f.hideLabels||!u.label.visible,i=0;i<f.length;i++)c||r._drawLabel(f[i],o),r._drawTick(f[i],e);if(u.showMinorTicks)for(i=0;i<s.length;i++)r._drawTick(s[i],e);for(i=0;i<h.length;i++)r._drawTick(h[i],e);e.append(n),r._drawDateMarkers(f,o)},_applyOptions:function(n){var t=n.scale,r;this.textOptions={align:"center","class":"dx-range-selector-scale",font:t.label.font,style:{"-webkit-user-select":"none"}},this.lineOptions={strokeWidth:t.tick.width,stroke:t.tick.color,strokeOpacity:t.tick.opacity},this._setupDateTickInterval(t.ticksInfo.majorTickInterval),this.visibleMarkers=t.marker.visible===i?!0:t.marker.visible,r=t.label.visible?t.label.topIndent+t.label.font.size:0,this.scaleLabelsAreaHeight=n.scaleLabelsAreaHeight,this.markersAreaHeight=this.scaleLabelsAreaHeight-r,this.translator=n.translator},_draw:function(n){this._redraw(n,!1)},_update:function(n){var t=this.callBase;this._markersTracker&&this._markersTracker.off(r.events.start,"**"),this.callBase=t,this.callBase(n)}})}(jQuery,DevExpress),function(n,t){var r=t.viz.rangeSelector,u=t.viz.renderers;r.rangeSelectorFactory=function(){return{createRenderer:function(n){return new u.Renderer(n)},createTranslator:function(n,i){return new t.viz.core.LinearTranslator(n,i)},getTickProvider:function(){return t.viz.core.tickProvider},createRangeContainer:function(n){return new r.RangeContainer(n)},createSlidersContainer:function(n){return new r.SlidersContainer(n)},createScale:function(n){return new r.Scale(n)},createSliderMarker:function(n){return new r.SliderMarker(n)},createRangeView:function(n){return new r.RangeView(n)},createThemeManager:function(n){return new r.ThemeManager(n)},createSlider:function(n,t){return new r.Slider(n,t)},createSlidersEventsManager:function(n,t,i){return new r.SlidersEventsManager(n,t,i)},createSlidersController:function(n){return new r.SlidersController(n)}}}()}(jQuery,DevExpress),function(n,t){var r=t.viz.rangeSelector,h=t.utils,e=window.navigator.msPointerEnabled,u=t.utils.isNumber,f=t.utils.isDate,o=0,s=1;r.SlidersContainer=r.BaseVisualElement.inherit(function(){return{_drawAreaTracker:function(n){var t=this,i,r;i=t._renderer.createRect(t._options.canvas.left,t._options.canvas.top,t._options.canvas.width,t._options.canvas.height,0,{fill:"grey",stroke:"grey",opacity:.0001}),i.append(n),r=t._renderer.createRect(t._options.canvas.left,t._options.canvas.top,t._options.canvas.width,t._options.canvas.height,0,{fill:"grey",stroke:"grey",opacity:.0001,style:{cursor:"pointer"}}),r.append(n),t._controller.setAreaTrackers(i,r)},_processSelectionChanged:function(n,t){var i=this,u=function(n){return n&&i._lastSelectedRange.startValue===n.startValue&&i._lastSelectedRange.endValue===n.endValue},r=i.getSelectedRange();n&&(i._options.behavior.callSelectedRangeChanged||"").toLowerCase()!=="onmoving"||!i._options.selectedRangeChanged||u(r)||(i._updateLastSelectedRange(r),typeof i._options.selectedRangeChanged=="function"&&i._options.selectedRangeChanged.call(null,r,t),n||u(r)||i.setSelectedRange(r))},_updateLastSelectedRange:function(n){n=n||this._options.selectedRange,this._lastSelectedRange={startValue:n.startValue,endValue:n.endValue}},_createSlider:function(n){return r.rangeSelectorFactory.createSlider(this._renderer,n)},_createSlidersController:function(n){return r.rangeSelectorFactory.createSlidersController(n)},_createSlidersEventsManager:function(n){var t=this;return r.rangeSelectorFactory.createSlidersEventsManager(t._renderer,n,function(n){t._processSelectionChanged(n)})},ctor:function(n){var t=this,i;t.callBase(n),i=[t._createSlider(o),t._createSlider(s)],t._controller=t._createSlidersController(i),t._eventsManager=t._createSlidersEventsManager(t._controller),t._lastSelectedRange={}},getSelectedRange:function(){return this._controller.getSelectedRange()},setSelectedRange:function(n){var t=this,i=t._options.scale,r,e,o=t._options.selectedRange;n&&(r=n.startValue,e=n.endValue),(u(i.startValue)&&u(r)||f(i.startValue)&&f(r))&&(o.startValue=r),(u(i.endValue)&&u(e)||f(i.endValue)&&f(e))&&(o.endValue=e),t._controller.applySelectedRange(o),t._controller.applyPosition(),t._processSelectionChanged(!1,n&&n.blockSelectedRangeChanged)},appendTrackers:function(n){this._controller.appendTrackers(n)},_applyOptions:function(n){var t=this;t._controller.applyOptions({translator:n.translator,canvas:n.canvas,sliderMarker:n.sliderMarker,sliderHandles:n.sliderHandles,shutter:n.shutter,scale:n.scale,behavior:n.behavior}),t._eventsManager.applyOptions({behavior:n.behavior})},_draw:function(n){var t=this,i;e&&(i=t._renderer.getRoot(),i&&(i.element.style.msTouchAction="none")),t._controller.redraw(n),t._drawAreaTracker(n),t._eventsManager.initialize(),t._update()},_update:function(){var n=this,t=n._options.isEmpty;n._eventsManager.setEnabled(!t),n._controller.applySelectedRange(t?{}:n._options.selectedRange),n._controller.applyPosition(n.isDrawn()),n._updateLastSelectedRange(),n._controller.redraw()}}}())}(jQuery,DevExpress),function(n,t,i){var f=t.viz.rangeSelector,e=t.utils,r=0,u=1;f.SlidersController=t.Class.inherit(function(){return{ctor:function(n){this._sliders=n,n[r].setAnotherSlider(n[u]),n[u].setAnotherSlider(n[r])},setAreaTrackers:function(n,t){this._areaTracker=n,this._selectedAreaTracker=t},applyOptions:function(n){var i=this,t=null;i._options=n,i.getSlider(r).applyOptions(n),i.getSlider(u).applyOptions(n),n.behavior.snapToTicks&&(t=n.scale.ticksInfo.fullTicks,t.length>1&&t[0]>t[t.length-1]&&(t=t.reverse())),i.getSlider(r).setAvailableValues(t),i.getSlider(u).setAvailableValues(t)},processDocking:function(n){var t=this;n!==i?t.getSlider(n).processDocking():(t.getSlider(r).processDocking(),t.getSlider(u).processDocking()),t.setTrackersCursorStyle("default"),t.applyAreaTrackersPosition()},getSelectedRangeInterval:function(){var n=this;return f.utils.getInterval(n.getSlider(r).getValue(),n.getSlider(u).getValue())},moveSliders:function(n,t){var i=this;i.getSlider(r).setPosition(i.getSlider(r).getPosition()+n,!1,t),i.applyPosition(!0)},moveSlider:function(n,t,i,u,f,e){var o=this,s=o.getSlider(n),h=s.getAnotherSlider(),l=h.getIndex(),c;s.canSwap()&&(n===r?i>h.getPosition():i<h.getPosition())&&(c=t,t||Math.abs(u)>=Math.abs(f)&&u*f<0&&(c=!0,i+=2*f,e(-f)),c&&(o.swapSliders(),h.applyPosition(!0))),s.setPosition(i,!0),s.applyPosition(!0),o.applyAreaTrackersPosition(),o.setTrackersCursorStyle("w-resize")},applySelectedAreaCenterPosition:function(n){var t=this,i=(t.getSlider(u).getPosition()-t.getSlider(r).getPosition())/2,f=t.getSelectedRangeInterval();t.getSlider(r).setPosition(n-i,!1,f),t.applyPosition(),t.processDocking()},processManualSelection:function(n,t,i){var e=this,o,f,s=[Math.min(n,t),Math.max(n,t)];o=n<t?r:u,f=n<t?u:r,e.getSlider(f).setPosition(s[f]),e.getSlider(o).setPosition(s[o]),e.getSlider(f).setPosition(s[f],!0),e.getSlider(f).startEventHandler(i),e.getSlider(o).processDocking(),e.getSlider(f).applyPosition(!0)},applySelectedRange:function(n){var t=this,i=t._options.scale.inverted;!i&&n.startValue>n.endValue||i&&n.startValue<n.endValue?(t.getSlider(r).setValue(n.endValue),t.getSlider(u).setValue(n.startValue)):(t.getSlider(r).setValue(n.startValue),t.getSlider(u).setValue(n.endValue))},getSelectedRange:function(){var n=this;return{startValue:n.getSlider(r).getValue(),endValue:n.getSlider(u).getValue()}},swapSliders:function(){var n=this;n._sliders.reverse(),n.getSlider(r).changeLocation(),n.getSlider(u).changeLocation()},applyAreaTrackersPosition:function(){var n=this,t=n.getSelectedRange(),i=n._options.scale,f=n.getSlider(u).getPosition()-n.getSlider(r).getPosition(),e={x:n.getSlider(r).getPosition(),width:f<0?0:f,y:n._options.canvas.top,height:n._options.canvas.height,style:{cursor:i.endValue-i.startValue==t.endValue-t.startValue?"default":"pointer"}};n._selectedAreaTracker.applySettings(e),n._areaTracker.applySettings({x:n._options.canvas.left,width:n._options.canvas.width,y:n._options.canvas.top,height:n._options.canvas.height})},applyPosition:function(n){var t=this;t.getSlider(r).applyPosition(n),t.getSlider(u).applyPosition(n),t.applyAreaTrackersPosition()},redraw:function(n){var t=this;t.getSlider(r).redraw(n),t.getSlider(u).redraw(n)},appendTrackers:function(n){var t=this;t._areaTracker&&t._selectedAreaTracker&&(t._areaTracker.append(n),t._selectedAreaTracker.append(n)),t.getSlider(r).appendTrackers(n),t.getSlider(u).appendTrackers(n)},getSlider:function(n){return this._sliders[n]},getAreaTracker:function(){return this._areaTracker},getSelectedAreaTracker:function(){return this._selectedAreaTracker},setTrackersCursorStyle:function(n){var t=this;t._selectedAreaTracker.applySettings({style:{cursor:n}}),t._areaTracker.applySettings({style:{cursor:n}})}}}())}(jQuery,DevExpress),function(n,t,i){var r=t.viz.rangeSelector,u=t.utils,f="ontouchstart"in window,e=window.navigator.msPointerEnabled;r.events={start:e?"MSPointerDown":f?"touchstart mousedown":"mousedown",move:e?"MSPointerMove":f?"touchmove mousemove":"mousemove",end:e?"MSPointerUp MSPointerCancel":f?"touchend mouseup":"mouseup"};var s=10,o=0,h=1;r.SlidersEventsManager=t.Class.inherit(function(){var e=function(n){return r.utils.getRootOffsetLeft(n._renderer)},n=function(n){return r.utils.getEventPageX(n)},t=function(n){var r=n||window.event,t=r.originalEvent,f=r.touches,u=t?t.pointerType:!1,e=t?t.touches:!1,o=r.which===i&&r.button===1,s=t&&u!==i&&(u===(t.MSPOINTER_TYPE_TOUCH||"touch")||u===(t.MSPOINTER_TYPE_MOUSE||"mouse")&&t.buttons===1),h=o||r.which===1,c=f&&f.length>0||e&&e.length>0;return h||s||c},f=function(n){return n&&n.type&&n.type.indexOf("touch")===0},c=function(i,o){var p=i._renderer,v,c=i._slidersController,a=i._processSelectionChanged,s=c.getSlider(o),w=s.getAnotherSlider(),y,l,h;s.startEventHandler=function(r){i._enabled&&t(r)&&!h&&(y=this===s.getSliderTracker().element,h=!0,v=f(r),l=n(r)-s.getPosition()-e(i),r.stopPropagation(),r.preventDefault())};s.on(r.events.start,s.startEventHandler);u.subscribeEventToDocument(r.events.end,function(){h&&(h=!1,c.processDocking(),a(!1))}),u.subscribeEventToDocument(r.events.move,function(r){var k,u,o,p=e(i),w,b=s.getIndex();v===f(r)&&(!t(r,!0)&&h?(h=!1,c.processDocking(),a(!1)):h&&(r.preventDefault(),u=n(r),w=u-l-p,o=u-s.getPosition()-p,c.moveSlider(b,y,w,o,l,function(n){l=n}),a(!0)))})},l=function(i){var y=i._renderer,c,e=i._slidersController,h=i._processSelectionChanged,v=e.getSelectedAreaTracker(),s=!1,l,a;v.on(r.events.start,function(r){i._enabled&&t(r)&&!s&&(s=!0,c=f(r),l=n(r)-e.getSlider(o).getPosition(),a=e.getSelectedRangeInterval(),r.stopPropagation(),r.preventDefault())});u.subscribeEventToDocument(r.events.end,function(){s&&(s=!1,e.processDocking(),h(!1))}),u.subscribeEventToDocument(r.events.move,function(i){var r,u;c===f(i)&&(s&&!t(i)&&(s=!1,e.processDocking(),h(!1)),s&&(i.preventDefault(),u=n(i),r=u-e.getSlider(o).getPosition()-l,e.moveSliders(r,a),h(!0)))})},a=function(i){var y=i._renderer,a,c=i._slidersController,l=i._processSelectionChanged,v=c.getAreaTracker(),o=!1,p=!1,h;v.on(r.events.start,function(r){i._enabled&&t(r)&&!o&&(o=!0,a=f(r),h=n(r))});u.subscribeEventToDocument(r.events.end,function(t){var r;o&&(r=n(t),i._options.behavior.moveSelectedRangeByClick&&Math.abs(h-r)<s&&c.applySelectedAreaCenterPosition(r-e(i)),o=!1,l(!1))}),u.subscribeEventToDocument(r.events.move,function(r){var u,v,y,p=e(i);a===f(r)&&(o&&!t(r)&&(o=!1,l(!1)),o&&(u=n(r),i._options.behavior.manualRangeSelectionEnabled&&Math.abs(h-u)>=s&&(v=h-p,y=u-p,c.processManualSelection(v,y,r),o=!1,l(!0))))})};return{ctor:function(n,t,i){this._renderer=n,this._slidersController=t,this._processSelectionChanged=i,this._enabled=!0},applyOptions:function(n){this._options=n},initialize:function(){var n=this;n._renderer.isInitialized()&&(l(n),a(n),c(n,o),c(n,h))},setEnabled:function(n){this._enabled=n}}}())}(jQuery,DevExpress),function(n,t,i){var f=t.viz.rangeSelector,r=t.utils,s="ontouchstart"in window,h=window.navigator.msPointerEnabled,o={duration:250},c=8,l=20,u=0,e=1;f.Slider=f.BaseVisualElement.inherit(function(){return{_createSlider:function(){var n=this,i,t;return t=n._renderer.createGroup({"class":"slider"}),t.applySettings({translateX:n._options.canvas.left,translateY:n._options.canvas.top}),i=n._renderer.createLine(0,0,0,n._options.canvas.height,{"class":"dx-range-selector-slider",strokeWidth:n._options.sliderHandles.width,stroke:n._options.sliderHandles.color,strokeOpacity:n._options.sliderHandles.opacity}),i.append(t),t.setValid=function(t){i.applySettings({stroke:t?n._options.sliderHandles.color:n._options.sliderMarker.invalidRangeColor})},t.updateHeight=function(){i.applySettings({points:[0,0,0,n._options.canvas.height]})},t.applyOptions=function(n){i.applySettings(n)},t},_createSliderTracker:function(){var n=this,r=s||h?l:c,i,t;return i=n._renderer.createRect(-r/2,0,r,n._options.canvas.height,0,{fill:"grey",stroke:"grey",opacity:.0001,style:{cursor:"w-resize"}}),t=n._renderer.createGroup({"class":"sliderTracker"}),t.applySettings({translateX:0,translateY:n._options.canvas.top}),i.append(t),t.updateHeight=function(){i.applySettings({height:n._options.canvas.height})},t},_drawSliderTracker:function(n){var i=this,t=i._createSliderTracker();t&&(t.append(n),i._sliderTracker=t)},_createSliderMarker:function(n){return f.rangeSelectorFactory.createSliderMarker(n)},_setPosition:function(n,t){var i=this,r=i._correctPosition(n),u=i._options.translator.untranslateX(r);i.setValue(u,t),i._position=r},_setPositionForBothSliders:function(n,t){var i=this,e,u,f,o,s=i._options.scale.inverted;e=i.getAnotherSlider(),n=i._correctBounds(n),u=i._options.translator.untranslateX(n),f=r.addInterval(u,t),!s&&f>i._options.scale.endValue||s&&f<i._options.scale.endValue?(f=i._options.scale.endValue,o=i._options.canvas.left+i._options.canvas.width,u=r.addInterval(f,t,!0),n=i._options.translator.translateX(u)):o=i._options.translator.translateX(f),i._values&&((s?u>i._values[i._values.length-1]:u<i._values[0])?(u=i._correctBusinessValueByAvailableValues(u),f=r.addInterval(u,t)):(f=i._correctBusinessValueByAvailableValues(f),u=r.addInterval(f,t,!0))),e.setValue(f),i.setValue(u),i._position=n,e._position=o},_correctPosition:function(n){var i=this,t=i._correctInversion(n);return t=i._correctBounds(t)},_correctInversion:function(n){var i=this,r=n,t=i.getAnotherSlider().getPosition(),f=i.getIndex()===u?n>t:n<t;return f&&(r=t),r},_correctBounds:function(n){var r=this,i=n,t=r._options.canvas;return n<t.left&&(i=t.left),n>t.left+t.width&&(i=t.left+t.width),i},_correctBusinessValue:function(n,t){var r=this,i=r._correctBusinessValueByAvailableValues(n);return t&&(i=r._correctBusinessValueByMinMaxRangeFromAnotherSlider(i)),i=r._correctBusinessValueByMinRangeFromStartEndValues(i)},_correctBusinessValueByAvailableValues:function(n){var t=this._values;return t?f.utils.findNearValue(t,n):n},_correctBusinessValueByMinMaxRangeFromAnotherSlider:function(n){var h=this,c=n,t=h._options.scale,l=h._values,y=h.getIndex(),a=h.getAnotherSlider().getValue(),v=!0,o,s;return!t.inverted&&y===u||t.inverted&&y===e?(t.maxRange&&(o=r.addInterval(a,t.maxRange,!0)),t.minRange&&(s=r.addInterval(a,t.minRange,!0))):(t.maxRange&&(s=r.addInterval(a,t.maxRange)),t.minRange&&(o=r.addInterval(a,t.minRange))),s!==i&&c>s?(c=l?f.utils.findLessOrEqualValue(l,s):s,v=!1):o!==i&&c<o&&(c=l?f.utils.findGreaterOrEqualValue(l,o):o,v=!1),h._setValid(v),c},_correctBusinessValueByMinRangeFromStartEndValues:function(n){var f=this,h=f._values,o,s,c=!0,t=f._options.scale,i=n;return t.minRange&&(f.getIndex()===e?(o=r.addInterval(t.startValue,t.minRange,t.inverted),(!t.inverted&&i<o||t.inverted&&i>o)&&(i=o)):f.getIndex()===u&&(s=r.addInterval(t.endValue,t.minRange,!t.inverted),(!t.inverted&&i>s||t.inverted&&i<s)&&(i=s))),i},_applySliderPosition:function(n,t){var i=this,f=i._options.behavior.animationEnabled&&!t,r=i._options.canvas.top,u=i._slider;f||u.inAnimation?(u.inAnimation=!0,u.animate({translate:{x:n,y:r}},f?o:{duration:0},function(){u.inAnimation=!1}),i._sliderTracker.animate({translate:{x:n,y:r}},f?o:{duration:0})):(i._slider.applySettings({translateX:n,translateY:r}),i._sliderTracker.applySettings({translateX:n,translateY:r})),i._sliderTracker.updateHeight(),i._slider.updateHeight()},_applyShutterPosition:function(n,t){var i=this,r,f=i._shutter,s=i._options.behavior.animationEnabled&&!t,h=i.getIndex();h==u?r={x:i._options.canvas.left,y:i._options.canvas.top,width:n-i._options.canvas.left,height:i._options.canvas.height}:h==e&&(r={x:n+1,y:i._options.canvas.top,width:i._options.canvas.left+i._options.canvas.width-n,height:i._options.canvas.height}),r&&(s||f.inAnimation?(f.inAnimation=!0,f.animate(r,s?o:{duration:0},function(){f.inAnimation=!1})):f.applySettings(r))},_setValid:function(n){var t=this;t._marker&&t._marker.setValid(n),t._slider.setValid(n)},_setText:function(n){var t=this;t._marker&&t._marker.setText(n)},ctor:function(n,t){var i=this;i.callBase(n),i._index=t},getIndex:function(){return this._index},setAvailableValues:function(n){this._values=n},setAnotherSlider:function(n){this._anotherSlider=n},getAnotherSlider:function(){return this._anotherSlider},appendTrackers:function(n){var t=this;t._sliderTracker&&t._sliderTracker.append(n)},getSliderTracker:function(){return this._sliderTracker},changeLocation:function(){var n=this;n._marker&&n._marker.changeLocation(),n._index=this._index===u?e:u,n._lastPosition=null},setPosition:function(n,t,r){var f=this,e;r!==i?(e=f.getIndex()===u?f:f.getAnotherSlider(),e._setPositionForBothSliders(n,r)):f._setPosition(n,t)},getPosition:function(){return this._position},_applyOptions:function(){this._lastPosition=null},setValue:function(n,t){var r=this;n===i?(r._value=i,r._valuePosition=r._position=r.getIndex()===u?r._options.canvas.left:r._options.canvas.left+r._options.canvas.width,r._setText(f.consts.emptySliderMarkerText)):(r._value=r._correctBusinessValue(n,t),r._valuePosition=r._position=r._options.translator.translateX(r._value),r._setText(f.formatValue(r._value,r._options.sliderMarker)))},getValue:function(){return this._value},canSwap:function(){var i=this,n=i._options.scale,f,e,t;if(i._options.behavior.allowSlidersSwap){if(n.minRange)if(t=i.getAnotherSlider().getValue(),i.getIndex()===u){if(e=r.addInterval(n.endValue,n.minRange,!n.inverted),!n.inverted&&t>e||n.inverted&&t<e)return!1}else if(f=r.addInterval(n.startValue,n.minRange,n.inverted),!n.inverted&&t<f||n.inverted&&t>f)return!1;return!0}return!1},processDocking:function(){var n=this;n._position=n._valuePosition,n.applyPosition(!1),n._setValid(!0)},applyPosition:function(n){var t=this,i=t.getPosition();t._lastPosition!==i&&(t._applySliderPosition(i,n),t._applyShutterPosition(i,n),t._lastPosition=i)},on:function(n,t){var i=this;i._sliderTracker.on(n,t);if(i._marker)i._marker.getTracker().on(n,t)},_update:function(){var n=this;n._marker&&n._marker.applyOptions(n._options.sliderMarker),n._shutter&&n._shutter.applySettings({fill:n._options.shutter.color,fillOpacity:n._options.shutter.opacity}),n._slider&&n._slider.applyOptions({strokeWidth:n._options.sliderHandles.width,stroke:n._options.sliderHandles.color,strokeOpacity:n._options.sliderHandles.opacity})},_draw:function(n){var t=this,i,o,f,r,h,c,s=t.getIndex();f=t._renderer.createGroup({"class":"sliderArea"}),f.append(n),s===u?r=t._renderer.createRect(t._options.canvas.left,t._options.canvas.top,0,t._options.canvas.height,0):s===e&&(r=t._renderer.createRect(t._options.canvas.left,t._options.canvas.top,t._options.canvas.width,t._options.canvas.height,0)),r&&(r.append(f),i=t._createSlider(),i&&i.append(f),t._options.sliderMarker.visible&&(o=t._createSliderMarker({renderer:t._renderer,isLeftPointer:s===e,sliderMarkerOptions:t._options.sliderMarker}),o.draw(i)),t._shutter=r,t._slider=i,t._marker=o),t._drawSliderTracker(n)}}}())}(jQuery,DevExpress),function(n,t){var r=t.viz.rangeSelector;r.SliderMarker=t.Class.inherit(function(){var u=function(n){this._renderer=n.renderer,this._text=n.text,this._isLeftPointer=n.isLeftPointer,this._options=n.sliderMarkerOptions,this._isValid=!0,t(this,{width:10,height:10})},f=function(n){this._options=n,this.update()},n=function(n,t){return{width:Math.round(2*n._options.padding+t.width),height:Math.round(2*n._options.padding+t.height*r.consts.fontHeightRatio)}},t=function(t,i){var r=n(t,i);t._points=[],t._isLeftPointer?(t._points.push({x:0,y:0}),t._points.push({x:r.width,y:0}),t._points.push({x:r.width,y:r.height}),t._points.push({x:t._options.pointerSize,y:r.height}),t._points.push({x:0,y:r.height+t._options.pointerSize})):(t._points.push({x:0,y:0}),t._points.push({x:r.width,y:0}),t._points.push({x:r.width,y:r.height+t._options.pointerSize}),t._points.push({x:r.width-t._options.pointerSize,y:r.height}),t._points.push({x:0,y:r.height}))},e=function(t,i){var r=n(t,i);return t._isLeftPointer?{x:0,y:r.height+t._options.pointerSize}:{x:r.width-1,y:r.height+t._options.pointerSize}},o=function(n){var t=this,i=t._options.padding;t._sliderMarkerGroup=t._renderer.createGroup({"class":"sliderMarker"}),t._sliderMarkerGroup.append(n),t._area=t._renderer.createArea(t.points,{fill:t._options.color}),t._area.append(t._sliderMarkerGroup),t._label=t._renderer.createText(t._text,i,i,{font:t._options.font,style:{"-webkit-user-select":"none"}}),t._label.append(t._sliderMarkerGroup),t._tracker=t._renderer.createRect(0,0,2*i,2*i+t._options.pointerSize,0,{fill:"grey",stroke:"grey",opacity:.0001,style:{cursor:"pointer"}}),t._tracker.append(t._sliderMarkerGroup),t._drawn=!0,t.update()},s=function(n){var t=n._label.getBBox();return!n._textHeight&&isFinite(t.height)&&(n._textHeight=t.height),{width:t.width,height:n._textHeight}},i=function(r){var u=this,f,o,h;(u._interval&&clearInterval(u._interval),delete u._interval,u._drawn)&&(u._label.updateText(u._text),f=s(u),r?delete u._textSize:(u._textSize=u._textSize||f,u._textSize=f.width>u._textSize.width||f.height>u._textSize.height?f:u._textSize,f=u._textSize,u._interval=setInterval(function(){i.call(u,[!0])},75)),o=n(u,f),h=e(u,f),u._sliderMarkerGroup.applySettings({translateX:-h.x,translateY:-h.y}),t(u,f),u._area.applySettings({points:u._points,fill:u._isValid?u._options.color:u._options.invalidRangeColor}),u._tracker.applySettings({width:o.width,height:o.height+u._options.pointerSize}),u._label.applySettings({x:u._options.padding,y:o.height-u._options.padding}))},h=function(){var n=this;return n._text},c=function(n){var t=this;t._text!==n&&(t._text=n,t.update())},l=function(n){var t=this;t._isValid=n,t.update()},a=function(){var n=this;n._isLeftPointer=!n._isLeftPointer,n.update()},v=function(){var n=this;return n._tracker};return{ctor:u,draw:o,update:i,getText:h,setText:c,changeLocation:a,applyOptions:f,getTracker:v,setValid:l}}())}(jQuery,DevExpress),function(n,t){var r=t.viz.rangeSelector;r.RangeView=r.BaseVisualElement.inherit(function(){var n=function(n){return t.viz.charts.factory.createThemeManager(n.chart.theme)};return{_draw:function(n){var t=this,o,s,f,u,r,e,i,h=t._options.isEmpty;if(e=t._options.seriesDataSource&&t._options.seriesDataSource.isShowChart()&&!h,i=t._options.canvas,e?f=t._options.seriesDataSource.getBackgroundColor():!h&&t._options.background.visible&&(f=t._options.background.color),t._options.background.visible&&f&&(o=t._renderer.createRect(i.left,i.top,i.width+1,i.height,0,{fill:f,"class":"dx-range-selector-background"}),o.append(n)),t._options.background.visible&&t._options.background.image&&t._options.background.image.url&&(s=t._renderer.createImage(i.left,i.top,i.width+1,i.height,t._options.background.image.url,{location:t._options.background.image.location}),s.append(n)),e)for(u=t._options.seriesDataSource.getSeries(),r=0;r<u.length;r++)u[r].options.seriesGroup=n,u[r].options.seriesLabelsGroup=n,u[r].options.trackerGroup=n,u[r].draw(t._options.translator),t._options.behavior&&t._options.behavior.animationEnabled&&u[r].animate()}}}())}(jQuery,DevExpress),function(n,t,i){var u=t.viz.rangeSelector,r=t.viz.charts;u.SeriesDataSource=t.Class.inherit(function(){var u=function(n){return r.factory.createThemeManager(n,"rangeSelector.chart")},f=function(i){return n.isArray(i)&&i.length>0&&(t.utils.isNumber(i[0])||t.utils.isDate(i[0]))},e=function(t){return n.map(t,function(n,t){return{arg:n,val:t}})},o=function(t,o){var w=[],h,b,l,y=u(o.chart),s=o.chart.series,k=o.chart.valueAxis&&o.chart.valueAxis.valueType,a,c,v,p;for(o.dataSource&&!s&&(f(o.dataSource)&&(o.dataSource=e(o.dataSource)),a=o.dataSourceField||"arg",s={argumentField:a,valueField:a},t._hideChart=!0),s=n.isArray(s)?s:s?[s]:[],c=y.applyTheme(y.getTheme(),o.chart),n.extend(c.commonSeriesSettings,{argumentType:o.valueType,valueType:a?o.valueType:k,incidentOccured:o.incidentOccured}),t._backgroundColor=o.backgroundColor!==i?o.backgroundColor:c.backgroundColor,v=0;v<s.length;v++)h=s[v],h.rotated=!1,l=h.data||o.dataSource,b=y.applyNextSeriesTheme(h,c.commonSeriesSettings),l&&l.length>0&&(p=r.factory.createSeries(h.type||c.commonSeriesSettings.type,o.renderer,l,b),p._suppressTrackers=!0,w.push(p));return w},s=function(t,i){var f=[],u=[];return n.each(t,function(t,i){n.inArray(i.type,u)===-1&&u.push(i.type)}),n.each(u,function(n,u){var e=new r.factory.createSeriesFamily({type:u,equalBarWidth:i});e.add(t),e.adjustSeriesValues(),f.push(e)}),f};return{ctor:function(n){var t=this;t._indent={top:n.chart.topIndent>=0&&n.chart.topIndent<1?n.chart.topIndent:0,bottom:n.chart.bottomIndent>=0&&n.chart.bottomIndent<1?n.chart.bottomIndent:0},t._valueAxis=n.chart.valueAxis||{},t._hideChart=!1,t._series=o(t,n),t._seriesFamilies=s(t._series,n.chart.equalBarWidth)},adjustSeriesDimensions:function(t){var i=this;n.each(i._seriesFamilies,function(){this.adjustSeriesDimensions(t)})},getBoundRange:function(){for(var u=this,l,c,r=new t.viz.charts.Range({minY:u._valueAxis.min,minVisibleY:u._valueAxis.min,maxY:u._valueAxis.max,maxVisibleY:u._valueAxis.max}),o,f,s,h,e=0;e<u._series.length;e++)c=u._series[e].getRangeData(),r=r.getBoundRange(c);return r.isDefined()&&(s=u._valueAxis.inverted?u._indent.top:u._indent.bottom,h=u._valueAxis.inverted?u._indent.bottom:u._indent.top,o=r.maxY-r.minY,f=(n.isNumeric(r.maxVisibleY)?r.maxVisibleY:r.maxY)-(n.isNumeric(r.minVisibleY)?r.minVisibleY:r.minY),r.minY-=o*s,r.maxY+=o*h,n.isNumeric(f)&&(r.maxVisibleY=r.maxVisibleY?r.maxVisibleY+f*h:i,r.minVisibleY=r.minVisibleY?r.minVisibleY-f*s:i),r.invertY=u._valueAxis.inverted),r},getSeries:function(){var n=this;return n._series},getBackgroundColor:function(){var n=this;return n._backgroundColor},isEmpty:function(){var n=this;return n.getSeries().length===0},isShowChart:function(){var n=this;return!n.isEmpty()&&!n._hideChart},getCalculatedValueType:function(){var n=this,t;return n._series.length&&(t=n._series[0].options.argumentType),t}}}())}(jQuery,DevExpress),function(n,t){var o=t.viz.rangeSelector,r=o.utils,f=t.utils,e=-1e3,u=function(n,t){var u;if(!n||n.length===0)return-1;for(var r=0,i=n.length-1,u=0;i-r>1;)u=r+i>>1,n[u]>t?i=u:r=u;return n[i]<=t?i:r},s=function(n,t){var i=u(n,t);return n&&i>=0&&i<n.length?n[i]:t},h=function(n,t){var i=u(n,t);return n&&i>=0&&i<n.length?(i+1<n.length&&(f.isDate(t)?n[i+1].getTime()-t.getTime()<t.getTime()-n[i].getTime()&&i++:n[i+1]-t<t-n[i]&&i++),n[i]):t},c=function(n,t){var i=u(n,t);return n&&i>=0&&i<n.length?(n[i]<t&&i+1<n.length&&i++,n[i]):t},l=function(n,t,i){var r,u,e,o,s;return f.isDate(n)?i==="year"||i==="quarter"||i==="month"?{months:t.getFullYear()*12+t.getMonth()-n.getFullYear()*12-n.getMonth()}:{milliseconds:t.valueOf()-n.valueOf()}:t-n},a=function(n){var t,i=0,r=n.getRoot();if(r)if(t=r.element,t.getScreenCTM)i=t.createSVGPoint().matrixTransform(t.getScreenCTM()).x;else while(t)i+=t.offsetLeft||0,t=t.offsetParent;return i},v=function(n){var t=0;return n.pageX?t=n.pageX:n.originalEvent&&n.originalEvent.pageX&&(t=n.originalEvent.pageX),n.originalEvent&&n.originalEvent.touches&&(n.originalEvent.touches.length>0?t=n.originalEvent.touches[0].pageX:n.originalEvent.changedTouches.length>0&&(t=n.originalEvent.changedTouches[0].pageX)),t},y=function(n,t,i){var r=n.createText(t,e,e,{font:i}).append(),u=r.getBBox();return r.remove(),u};r.findLessOrEqualValue=s,r.findNearValue=h,r.findGreaterOrEqualValue=c,r.getInterval=l,r.getRootOffsetLeft=a,r.getEventPageX=v,r.getTextBBox=y}(jQuery,DevExpress),function(n,t){t.viz.rangeSelector=t.viz.rangeSelector,t.viz.rangeSelector.ThemeManager=t.viz.core.BaseThemeManager.inherit({ctor:function(n){var t=this;t.callBase(n,"rangeSelector"),t.initializeFont(t.theme.scale.label.font),t.initializeFont(t.theme.sliderMarker.font)},applyRangeSelectorTheme:function(n){var i=this,r={dataSource:n.dataSource},t;return delete n.dataSource,t=i.applyTheme(i.theme,n),t.dataSource=r.dataSource,t},setBackgroundColor:function(n){var t=this.theme;n&&(t.containerBackgroundColor=n),t.shutter.color=t.shutter.color||t.containerBackgroundColor}})}(jQuery,DevExpress),function(n){var t=n.viz;t.Chart=t.charts.Chart,t.PieChart=t.charts.PieChart,t.RangeSelector=t.rangeSelector.RangeSelector,t.CircularGauge=t.gauges.CircularGauge,t.LinearGauge=t.gauges.LinearGauge}(DevExpress),function(n,t){var r=t.ui,u=t.viz;r.registerComponent("dxChart",u.Chart)}(jQuery,DevExpress),function(n,t){var r=t.ui,u=t.viz;r.registerComponent("dxPieChart",u.PieChart)}(jQuery,DevExpress),function(n){n.ui.registerComponent("dxCircularGauge",n.viz.CircularGauge)}(DevExpress),function(n){n.ui.registerComponent("dxLinearGauge",n.viz.LinearGauge)}(DevExpress),function(n,t){var r=t.ui,u=t.viz;r.registerComponent("dxRangeSelector",u.RangeSelector)}(jQuery,DevExpress),DevExpress.MOD_VIZ=!0);
/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
Contains fixes to run in WinJS environment
*/
(function(n,t){function dt(n){var t=n.length,r=i.type(n);return i.isWindow(n)?!1:n.nodeType===1&&t?!0:r==="array"||r!=="function"&&(t===0||typeof t=="number"&&t>0&&t-1 in n)}function kf(n){var t=gt[n]={};return i.each(n.match(s)||[],function(n,i){t[i]=!0}),t}function ir(n,r,u,f){if(i.acceptData(n)){var s,h,c=i.expando,a=typeof r=="string",l=n.nodeType,o=l?i.cache:n,e=l?n[c]:n[c]&&c;if(e&&o[e]&&(f||o[e].data)||!a||u!==t)return e||(l?n[c]=e=b.pop()||i.guid++:e=c),o[e]||(o[e]={},l||(o[e].toJSON=i.noop)),(typeof r=="object"||typeof r=="function")&&(f?o[e]=i.extend(o[e],r):o[e].data=i.extend(o[e].data,r)),s=o[e],f||(s.data||(s.data={}),s=s.data),u!==t&&(s[i.camelCase(r)]=u),a?(h=s[r],h==null&&(h=s[i.camelCase(r)])):h=s,h}}function rr(n,t,r){if(i.acceptData(n)){var o,h,e,s=n.nodeType,u=s?i.cache:n,f=s?n[i.expando]:i.expando;if(u[f]){if(t&&(e=r?u[f]:u[f].data,e)){for(i.isArray(t)?t=t.concat(i.map(t,i.camelCase)):(t in e)?t=[t]:(t=i.camelCase(t),t=t in e?[t]:t.split(" ")),o=0,h=t.length;o<h;o++)delete e[t[o]];if(!(r?ni:i.isEmptyObject)(e))return}(r||(delete u[f].data,ni(u[f])))&&(s?i.cleanData([n],!0):i.support.deleteExpando||u!=u.window?delete u[f]:u[f]=null)}}}function ur(n,r,u){if(u===t&&n.nodeType===1){var f="data-"+r.replace(tr,"-$1").toLowerCase();if(u=n.getAttribute(f),typeof u=="string"){try{u=u==="true"?!0:u==="false"?!1:u==="null"?null:+u+""===u?+u:nr.test(u)?i.parseJSON(u):u}catch(e){}i.data(n,r,u)}else u=t}return u}function ni(n){var t;for(t in n)if((t!=="data"||!i.isEmptyObject(n[t]))&&t!=="toJSON")return!1;return!0}function ht(){return!0}function d(){return!1}function cr(n,t){do n=n[t];while(n&&n.nodeType!==1);return n}function lr(n,t,r){if(t=t||0,i.isFunction(t))return i.grep(n,function(n,i){var u=!!t.call(n,i,n);return u===r});if(t.nodeType)return i.grep(n,function(n){return n===t===r});if(typeof t=="string"){var u=i.grep(n,function(n){return n.nodeType===1});if(fe.test(t))return i.filter(t,u,!r);t=i.filter(t,u)}return i.grep(n,function(n){return i.inArray(n,t)>=0===r})}function ar(n){var i=vr.split("|"),t=n.createDocumentFragment();if(t.createElement)while(i.length)t.createElement(i.pop());return t}function ye(n,t){return n.getElementsByTagName(t)[0]||n.appendChild(n.ownerDocument.createElement(t))}function dr(n){var t=n.getAttributeNode("type");return n.type=(t&&t.specified)+"/"+n.type,n}function gr(n){var t=le.exec(n.type);return t?n.type=t[1]:n.removeAttribute("type"),n}function si(n,t){for(var u,r=0;(u=n[r])!=null;r++)i._data(u,"globalEval",!t||i._data(t[r],"globalEval"))}function nu(n,t){if(t.nodeType===1&&i.hasData(n)){var u,f,o,s=i._data(n),r=i._data(t,s),e=s.events;if(e){delete r.handle,r.events={};for(u in e)for(f=0,o=e[u].length;f<o;f++)i.event.add(t,u,e[u][f])}r.data&&(r.data=i.extend({},r.data))}}function pe(n,t){var r,f,u;if(t.nodeType===1){if(r=t.nodeName.toLowerCase(),!i.support.noCloneEvent&&t[i.expando]){u=i._data(t);for(f in u.events)i.removeEvent(t,f,u.handle);t.removeAttribute(i.expando)}r==="script"&&t.text!==n.text?(dr(t).text=n.text,gr(t)):r==="object"?(t.parentNode&&(t.outerHTML=n.outerHTML),i.support.html5Clone&&n.innerHTML&&!i.trim(t.innerHTML)&&(t.innerHTML=n.innerHTML)):r==="input"&&ei.test(n.type)?(t.defaultChecked=t.checked=n.checked,t.value!==n.value&&(t.value=n.value)):r==="option"?t.defaultSelected=t.selected=n.defaultSelected:(r==="input"||r==="textarea")&&(t.defaultValue=n.defaultValue)}}function u(n,r){var s,e,h=0,f=typeof n.getElementsByTagName!==o?n.getElementsByTagName(r||"*"):typeof n.querySelectorAll!==o?n.querySelectorAll(r||"*"):t;if(!f)for(f=[],s=n.childNodes||n;(e=s[h])!=null;h++)!r||i.nodeName(e,r)?f.push(e):i.merge(f,u(e,r));return r===t||r&&i.nodeName(n,r)?i.merge([n],f):f}function we(n){ei.test(n.type)&&(n.defaultChecked=n.checked)}function fu(n,t){if(t in n)return t;for(var r=t.charAt(0).toUpperCase()+t.slice(1),u=t,i=uu.length;i--;)if(t=uu[i]+r,t in n)return t;return u}function ut(n,t){return n=t||n,i.css(n,"display")==="none"||!i.contains(n.ownerDocument,n)}function eu(n,t){for(var f,r,o,e=[],u=0,s=n.length;u<s;u++)(r=n[u],r.style)&&(e[u]=i._data(r,"olddisplay"),f=r.style.display,t?(e[u]||f!=="none"||(r.style.display=""),r.style.display===""&&ut(r)&&(e[u]=i._data(r,"olddisplay",cu(r.nodeName)))):e[u]||(o=ut(r),(f&&f!=="none"||!o)&&i._data(r,"olddisplay",o?f:i.css(r,"display"))));for(u=0;u<s;u++)(r=n[u],r.style)&&(t&&r.style.display!=="none"&&r.style.display!==""||(r.style.display=t?e[u]||"":"none"));return n}function ou(n,t,i){var r=ge.exec(t);return r?Math.max(0,r[1]-(i||0))+(r[2]||"px"):t}function su(n,t,r,u,f){for(var e=r===(u?"border":"content")?4:t==="width"?1:0,o=0;e<4;e+=2)r==="margin"&&(o+=i.css(n,r+p[e],!0,f)),u?(r==="content"&&(o-=i.css(n,"padding"+p[e],!0,f)),r!=="margin"&&(o-=i.css(n,"border"+p[e]+"Width",!0,f))):(o+=i.css(n,"padding"+p[e],!0,f),r!=="padding"&&(o+=i.css(n,"border"+p[e]+"Width",!0,f)));return o}function hu(n,t,r){var e=!0,u=t==="width"?n.offsetWidth:n.offsetHeight,f=v(n),o=i.support.boxSizing&&i.css(n,"boxSizing",!1,f)==="border-box";if(u<=0||u==null){if(u=y(n,t,f),(u<0||u==null)&&(u=n.style[t]),ct.test(u))return u;e=o&&(i.support.boxSizingReliable||u===n.style[t]),u=parseFloat(u)||0}return u+su(n,t,r||(o?"border":"content"),e,f)+"px"}function cu(n){var u=r,t=iu[n];return t||(t=lu(n,u),t!=="none"&&t||(rt=(rt||i("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(u.documentElement),u=(rt[0].contentWindow||rt[0].contentDocument).document,u.write("<!doctype html><html><body>"),u.close(),t=lu(n,u),rt.detach()),iu[n]=t),t}function lu(n,t){var r=i(t.createElement(n)).appendTo(t.body),u=i.css(r[0],"display");return r.remove(),u}function ci(n,t,r,u){var f;if(i.isArray(t))i.each(t,function(t,i){r||ro.test(n)?u(n,i):ci(n+"["+(typeof i=="object"?t:"")+"]",i,r,u)});else if(r||i.type(t)!=="object")u(n,t);else for(f in t)ci(n+"["+f+"]",t[f],r,u)}function ku(n){return function(t,r){typeof t!="string"&&(r=t,t="*");var u,f=0,e=t.toLowerCase().match(s)||[];if(i.isFunction(r))while(u=e[f++])u[0]==="+"?(u=u.slice(1)||"*",(n[u]=n[u]||[]).unshift(r)):(n[u]=n[u]||[]).push(r)}}function du(n,t,r,u){function e(s){var h;return f[s]=!0,i.each(n[s]||[],function(n,i){var s=i(t,r,u);if(typeof s!="string"||o||f[s]){if(o)return!(h=s)}else return t.dataTypes.unshift(s),e(s),!1}),h}var f={},o=n===vi;return e(t.dataTypes[0])||!f["*"]&&e("*")}function yi(n,r){var f,u,e=i.ajaxSettings.flatOptions||{};for(u in r)r[u]!==t&&((e[u]?n:f||(f={}))[u]=r[u]);return f&&i.extend(!0,n,f),n}function co(n,i,r){var s,o,e,u,h=n.contents,f=n.dataTypes,c=n.responseFields;for(u in c)u in r&&(i[c[u]]=r[u]);while(f[0]==="*")f.shift(),o===t&&(o=n.mimeType||i.getResponseHeader("Content-Type"));if(o)for(u in h)if(h[u]&&h[u].test(o)){f.unshift(u);break}if(f[0]in r)e=f[0];else{for(u in r){if(!f[0]||n.converters[u+" "+f[0]]){e=u;break}s||(s=u)}e=e||s}if(e)return e!==f[0]&&f.unshift(e),r[e]}function lo(n,t){var o,r,i,e,u={},h=0,s=n.dataTypes.slice(),f=s[0];if(n.dataFilter&&(t=n.dataFilter(t,n.dataType)),s[1])for(i in n.converters)u[i.toLowerCase()]=n.converters[i];for(;r=s[++h];)if(r!=="*"){if(f!=="*"&&f!==r){if(i=u[f+" "+r]||u["* "+r],!i)for(o in u)if(e=o.split(" "),e[1]===r&&(i=u[f+" "+e[0]]||u["* "+e[0]],i)){i===!0?i=u[o]:u[o]!==!0&&(r=e[0],s.splice(h--,0,r));break}if(i!==!0)if(i&&n.throws)t=i(t);else try{t=i(t)}catch(c){return{state:"parsererror",error:i?c:"No conversion from "+f+" to "+r}}}f=r}return{state:"success",data:t}}function nf(){try{return new n.XMLHttpRequest}catch(t){}}function ao(){try{return new n.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function tf(){return setTimeout(function(){tt=t}),tt=i.now()}function wo(n,t){i.each(t,function(t,i){for(var u=(ft[t]||[]).concat(ft["*"]),r=0,f=u.length;r<f;r++)if(u[r].call(n,t,i))return})}function rf(n,t,r){var e,o,s=0,l=yt.length,f=i.Deferred().always(function(){delete c.elem}),c=function(){if(o)return!1;for(var s=tt||tf(),t=Math.max(0,u.startTime+u.duration-s),h=t/u.duration||0,i=1-h,r=0,e=u.tweens.length;r<e;r++)u.tweens[r].run(i);return f.notifyWith(n,[u,i,t]),i<1&&e?t:(f.resolveWith(n,[u]),!1)},u=f.promise({elem:n,props:i.extend({},t),opts:i.extend(!0,{specialEasing:{}},r),originalProperties:t,originalOptions:r,startTime:tt||tf(),duration:r.duration,tweens:[],createTween:function(t,r){var f=i.Tween(n,u.opts,t,r,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(f),f},stop:function(t){var i=0,r=t?u.tweens.length:0;if(o)return this;for(o=!0;i<r;i++)u.tweens[i].run(1);return t?f.resolveWith(n,[u,t]):f.rejectWith(n,[u,t]),this}}),h=u.props;for(bo(h,u.opts.specialEasing);s<l;s++)if(e=yt[s].call(u,n,h,u.opts),e)return e;return wo(u,h),i.isFunction(u.opts.start)&&u.opts.start.call(n,u),i.fx.timer(i.extend(c,{elem:n,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function bo(n,t){var u,f,r,e,o;for(r in n)if(f=i.camelCase(r),e=t[f],u=n[r],i.isArray(u)&&(e=u[1],u=n[r]=u[0]),r!==f&&(n[f]=u,delete n[r]),o=i.cssHooks[f],o&&"expand"in o){u=o.expand(u),delete n[f];for(r in u)r in n||(n[r]=u[r],t[r]=e)}else t[f]=e}function ko(n,t,r){var u,o,v,a,s,y,l,f,b,h=this,e=n.style,p={},w=[],c=n.nodeType&&ut(n);r.queue||(f=i._queueHooks(n,"fx"),f.unqueued==null&&(f.unqueued=0,b=f.empty.fire,f.empty.fire=function(){f.unqueued||b()}),f.unqueued++,h.always(function(){h.always(function(){f.unqueued--,i.queue(n,"fx").length||f.empty.fire()})})),n.nodeType===1&&("height"in t||"width"in t)&&(r.overflow=[e.overflow,e.overflowX,e.overflowY],i.css(n,"display")==="inline"&&i.css(n,"float")==="none"&&(i.support.inlineBlockNeedsLayout&&cu(n.nodeName)!=="inline"?e.zoom=1:e.display="inline-block")),r.overflow&&(e.overflow="hidden",i.support.shrinkWrapBlocks||h.always(function(){e.overflow=r.overflow[0],e.overflowX=r.overflow[1],e.overflowY=r.overflow[2]}));for(o in t)if(a=t[o],vo.exec(a)){if(delete t[o],y=y||a==="toggle",a===(c?"hide":"show"))continue;w.push(o)}if(v=w.length,v)for(s=i._data(n,"fxshow")||i._data(n,"fxshow",{}),("hidden"in s)&&(c=s.hidden),y&&(s.hidden=!c),c?i(n).show():h.done(function(){i(n).hide()}),h.done(function(){var t;i._removeData(n,"fxshow");for(t in p)i.style(n,t,p[t])}),o=0;o<v;o++)u=w[o],l=h.createTween(u,c?s[u]:0),p[u]=s[u]||i.style(n,u),u in s||(s[u]=l.start,c&&(l.end=l.start,l.start=u==="width"||u==="height"?1:0))}function f(n,t,i,r,u){return new f.prototype.init(n,t,i,r,u)}function pt(n,t){var r,i={height:n},u=0;for(t=t?1:0;u<4;u+=2-t)r=p[u],i["margin"+r]=i["padding"+r]=n;return t&&(i.opacity=i.width=n),i}function uf(n){return i.isWindow(n)?n:n.nodeType===9?n.defaultView||n.parentWindow:!1}var et,wi,o=typeof t,r=n.document,ff=n.location,ef=n.jQuery,of=n.$,ot={},b=[],wt="1.9.1",bi=b.concat,bt=b.push,l=b.slice,ki=b.indexOf,sf=ot.toString,it=ot.hasOwnProperty,kt=wt.trim,i=function(n,t){return new i.fn.init(n,t,wi)},st=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,s=/\S+/g,hf=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,cf=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,di=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,lf=/^[\],:{}\s]*$/,af=/(?:^|:|,)(?:\s*\[)+/g,vf=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,yf=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,pf=/^-ms-/,wf=/-([\da-z])/gi,bf=function(n,t){return t.toUpperCase()},h=function(n){(r.addEventListener||n.type==="load"||r.readyState==="complete")&&(gi(),i.ready())},gi=function(){r.addEventListener?(r.removeEventListener("DOMContentLoaded",h,!1),n.removeEventListener("load",h,!1)):(r.detachEvent("onreadystatechange",h),n.detachEvent("onload",h))},gt,nr,tr,pi,lt,g,nt,gu,at;i.fn=i.prototype={jquery:wt,constructor:i,init:function(n,u,f){var e,o;if(!n)return this;if(typeof n=="string"){if(e=n.charAt(0)==="<"&&n.charAt(n.length-1)===">"&&n.length>=3?[null,n,null]:cf.exec(n),e&&(e[1]||!u)){if(e[1]){if(u=u instanceof i?u[0]:u,i.merge(this,i.parseHTML(e[1],u&&u.nodeType?u.ownerDocument||u:r,!0)),di.test(e[1])&&i.isPlainObject(u))for(e in u)i.isFunction(this[e])?this[e](u[e]):this.attr(e,u[e]);return this}if(o=r.getElementById(e[2]),o&&o.parentNode){if(o.id!==e[2])return f.find(n);this.length=1,this[0]=o}return this.context=r,this.selector=n,this}return!u||u.jquery?(u||f).find(n):this.constructor(u).find(n)}return n.nodeType?(this.context=this[0]=n,this.length=1,this):i.isFunction(n)?f.ready(n):(n.selector!==t&&(this.selector=n.selector,this.context=n.context),i.makeArray(n,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return l.call(this)},get:function(n){return n==null?this.toArray():n<0?this[this.length+n]:this[n]},pushStack:function(n){var t=i.merge(this.constructor(),n);return t.prevObject=this,t.context=this.context,t},each:function(n,t){return i.each(this,n,t)},ready:function(n){return i.ready.promise().done(n),this},slice:function(){return this.pushStack(l.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(n){var i=this.length,t=+n+(n<0?i:0);return this.pushStack(t>=0&&t<i?[this[t]]:[])},map:function(n){return this.pushStack(i.map(this,function(t,i){return n.call(t,i,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:bt,sort:[].sort,splice:[].splice},i.fn.init.prototype=i.fn,i.extend=i.fn.extend=function(){var u,o,r,e,s,h,n=arguments[0]||{},f=1,l=arguments.length,c=!1;for(typeof n=="boolean"&&(c=n,n=arguments[1]||{},f=2),typeof n=="object"||i.isFunction(n)||(n={}),l===f&&(n=this,--f);f<l;f++)if((s=arguments[f])!=null)for(e in s)(u=n[e],r=s[e],n!==r)&&(c&&r&&(i.isPlainObject(r)||(o=i.isArray(r)))?(o?(o=!1,h=u&&i.isArray(u)?u:[]):h=u&&i.isPlainObject(u)?u:{},n[e]=i.extend(c,h,r)):r!==t&&(n[e]=r));return n},i.extend({noConflict:function(t){return n.$===i&&(n.$=of),t&&n.jQuery===i&&(n.jQuery=ef),i},isReady:!1,readyWait:1,holdReady:function(n){n?i.readyWait++:i.ready(!0)},ready:function(n){if(n===!0?!--i.readyWait:!i.isReady){if(!r.body)return setTimeout(i.ready);(i.isReady=!0,n!==!0&&--i.readyWait>0)||(et.resolveWith(r,[i]),i.fn.trigger&&i(r).trigger("ready").off("ready"))}},isFunction:function(n){return i.type(n)==="function"},isArray:Array.isArray||function(n){return i.type(n)==="array"},isWindow:function(n){return n!=null&&n==n.window},isNumeric:function(n){return!isNaN(parseFloat(n))&&isFinite(n)},type:function(n){return n==null?String(n):typeof n=="object"||typeof n=="function"?ot[sf.call(n)]||"object":typeof n},isPlainObject:function(n){if(!n||i.type(n)!=="object"||n.nodeType||i.isWindow(n))return!1;try{if(n.constructor&&!it.call(n,"constructor")&&!it.call(n.constructor.prototype,"isPrototypeOf"))return!1}catch(u){return!1}var r;for(r in n);return r===t||it.call(n,r)},isEmptyObject:function(n){var t;for(t in n)return!1;return!0},error:function(n){throw new Error(n);},parseHTML:function(n,t,u){if(!n||typeof n!="string")return null;typeof t=="boolean"&&(u=t,t=!1),t=t||r;var f=di.exec(n),e=!u&&[];return f?[t.createElement(f[1])]:(f=i.buildFragment([n],t,e),e&&i(e).remove(),i.merge([],f.childNodes))},parseJSON:function(t){if(n.JSON&&n.JSON.parse)return n.JSON.parse(t);if(t===null)return t;if(typeof t=="string"&&(t=i.trim(t),t&&lf.test(t.replace(vf,"@").replace(yf,"]").replace(af,""))))return new Function("return "+t)();i.error("Invalid JSON: "+t)},parseXML:function(r){var u,f;if(!r||typeof r!="string")return null;try{n.DOMParser?(f=new DOMParser,u=f.parseFromString(r,"text/xml")):(u=new ActiveXObject("Microsoft.XMLDOM"),u.async="false",u.loadXML(r))}catch(e){u=t}return u&&u.documentElement&&!u.getElementsByTagName("parsererror").length||i.error("Invalid XML: "+r),u},noop:function(){},globalEval:function(t){t&&i.trim(t)&&(n.execScript||function(t){n.eval.call(n,t)})(t)},camelCase:function(n){return n.replace(pf,"ms-").replace(wf,bf)},nodeName:function(n,t){return n.nodeName&&n.nodeName.toLowerCase()===t.toLowerCase()},each:function(n,t,i){var u,r=0,f=n.length,e=dt(n);if(i){if(e){for(;r<f;r++)if(u=t.apply(n[r],i),u===!1)break}else for(r in n)if(u=t.apply(n[r],i),u===!1)break}else if(e){for(;r<f;r++)if(u=t.call(n[r],r,n[r]),u===!1)break}else for(r in n)if(u=t.call(n[r],r,n[r]),u===!1)break;return n},trim:kt&&!kt.call("\ufeff\u00a0")?function(n){return n==null?"":kt.call(n)}:function(n){return n==null?"":(n+"").replace(hf,"")},makeArray:function(n,t){var r=t||[];return n!=null&&(dt(Object(n))?i.merge(r,typeof n=="string"?[n]:n):bt.call(r,n)),r},inArray:function(n,t,i){var r;if(t){if(ki)return ki.call(t,n,i);for(r=t.length,i=i?i<0?Math.max(0,r+i):i:0;i<r;i++)if(i in t&&t[i]===n)return i}return-1},merge:function(n,i){var f=i.length,u=n.length,r=0;if(typeof f=="number")for(;r<f;r++)n[u++]=i[r];else while(i[r]!==t)n[u++]=i[r++];return n.length=u,n},grep:function(n,t,i){var u,f=[],r=0,e=n.length;for(i=!!i;r<e;r++)u=!!t(n[r],r),i!==u&&f.push(n[r]);return f},map:function(n,t,i){var u,r=0,e=n.length,o=dt(n),f=[];if(o)for(;r<e;r++)u=t(n[r],r,i),u!=null&&(f[f.length]=u);else for(r in n)u=t(n[r],r,i),u!=null&&(f[f.length]=u);return bi.apply([],f)},guid:1,proxy:function(n,r){var f,u,e;return(typeof r=="string"&&(e=n[r],r=n,n=e),!i.isFunction(n))?t:(f=l.call(arguments,2),u=function(){return n.apply(r||this,f.concat(l.call(arguments)))},u.guid=n.guid=n.guid||i.guid++,u)},access:function(n,r,u,f,e,o,s){var h=0,l=n.length,c=u==null;if(i.type(u)==="object"){e=!0;for(h in u)i.access(n,r,h,u[h],!0,o,s)}else if(f!==t&&(e=!0,i.isFunction(f)||(s=!0),c&&(s?(r.call(n,f),r=null):(c=r,r=function(n,t,r){return c.call(i(n),r)})),r))for(;h<l;h++)r(n[h],u,s?f:f.call(n[h],h,r(n[h],u)));return e?n:c?r.call(n):l?r(n[0],u):o},now:function(){return(new Date).getTime()}}),i.ready.promise=function(t){if(!et)if(et=i.Deferred(),r.readyState==="complete")setTimeout(i.ready);else if(r.addEventListener)r.addEventListener("DOMContentLoaded",h,!1),n.addEventListener("load",h,!1);else{r.attachEvent("onreadystatechange",h),n.attachEvent("onload",h);var u=!1;try{u=n.frameElement==null&&r.documentElement}catch(e){}u&&u.doScroll&&function f(){if(!i.isReady){try{u.doScroll("left")}catch(n){return setTimeout(f,50)}gi(),i.ready()}}()}return et.promise(t)},i.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(n,t){ot["[object "+t+"]"]=t.toLowerCase()}),wi=i(r),gt={},i.Callbacks=function(n){n=typeof n=="string"?gt[n]||kf(n):i.extend({},n);var o,f,c,s,e,l,r=[],u=!n.once&&[],a=function(t){for(f=n.memory&&t,c=!0,e=l||0,l=0,s=r.length,o=!0;r&&e<s;e++)if(r[e].apply(t[0],t[1])===!1&&n.stopOnFalse){f=!1;break}o=!1,r&&(u?u.length&&a(u.shift()):f?r=[]:h.disable())},h={add:function(){if(r){var t=r.length;(function u(t){i.each(t,function(t,f){var e=i.type(f);e==="function"?n.unique&&h.has(f)||r.push(f):f&&f.length&&e!=="string"&&u(f)})})(arguments),o?s=r.length:f&&(l=t,a(f))}return this},remove:function(){return r&&i.each(arguments,function(n,t){for(var u;(u=i.inArray(t,r,u))>-1;)r.splice(u,1),o&&(u<=s&&s--,u<=e&&e--)}),this},has:function(n){return n?i.inArray(n,r)>-1:!!(r&&r.length)},empty:function(){return r=[],this},disable:function(){return r=u=f=t,this},disabled:function(){return!r},lock:function(){return u=t,f||h.disable(),this},locked:function(){return!u},fireWith:function(n,t){return t=t||[],t=[n,t.slice?t.slice():t],r&&(!c||u)&&(o?u.push(t):a(t)),this},fire:function(){return h.fireWith(this,arguments),this},fired:function(){return!!c}};return h},i.extend({Deferred:function(n){var u=[["resolve","done",i.Callbacks("once memory"),"resolved"],["reject","fail",i.Callbacks("once memory"),"rejected"],["notify","progress",i.Callbacks("memory")]],f="pending",r={state:function(){return f},always:function(){return t.done(arguments).fail(arguments),this},then:function(){var n=arguments;return i.Deferred(function(f){i.each(u,function(u,e){var s=e[0],o=i.isFunction(n[u])&&n[u];t[e[1]](function(){var n=o&&o.apply(this,arguments);n&&i.isFunction(n.promise)?n.promise().done(f.resolve).fail(f.reject).progress(f.notify):f[s+"With"](this===r?f.promise():this,o?[n]:arguments)})}),n=null}).promise()},promise:function(n){return n!=null?i.extend(n,r):r}},t={};return r.pipe=r.then,i.each(u,function(n,i){var e=i[2],o=i[3];r[i[1]]=e.add,o&&e.add(function(){f=o},u[n^1][2].disable,u[2][2].lock),t[i[0]]=function(){return t[i[0]+"With"](this===t?r:this,arguments),this},t[i[0]+"With"]=e.fireWith}),r.promise(t),n&&n.call(t,t),t},when:function(n){var t=0,u=l.call(arguments),r=u.length,e=r!==1||n&&i.isFunction(n.promise)?r:0,f=e===1?n:i.Deferred(),h=function(n,t,i){return function(r){t[n]=this,i[n]=arguments.length>1?l.call(arguments):r,i===o?f.notifyWith(t,i):--e||f.resolveWith(t,i)}},o,c,s;if(r>1)for(o=new Array(r),c=new Array(r),s=new Array(r);t<r;t++)u[t]&&i.isFunction(u[t].promise)?u[t].promise().done(h(t,s,u)).fail(f.reject).progress(h(t,c,o)):--e;return e||f.resolveWith(s,u),f.promise()}}),i.support=function(){var u,s,e,f,h,c,l,a,p,v,t=r.createElement("div"),y="  <link/><table><\/table><a href='/a'>a<\/a><input type='checkbox'/>";if(n.WinJS&&n.toStaticHTML&&(y=toStaticHTML(y)),t.setAttribute("className","t"),t.innerHTML=y,s=t.getElementsByTagName("*"),e=t.getElementsByTagName("a")[0],!s||!e||!s.length)return{};h=r.createElement("select"),l=h.appendChild(r.createElement("option")),f=t.getElementsByTagName("input")[0],e.style.cssText="top:1px;float:left;opacity:.5",u={getSetAttribute:t.className!=="t",leadingWhitespace:t.firstChild.nodeType===3,tbody:!t.getElementsByTagName("tbody").length,htmlSerialize:!!t.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.5/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:!!f.value,optSelected:l.selected,enctype:!!r.createElement("form").enctype,html5Clone:r.createElement("nav").cloneNode(!0).outerHTML!=="<:nav><\/:nav>",boxModel:r.compatMode==="CSS1Compat",deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},f.checked=!0,u.noCloneChecked=f.cloneNode(!0).checked,h.disabled=!0,u.optDisabled=!l.disabled;try{delete t.test}catch(w){u.deleteExpando=!1}f=r.createElement("input"),f.setAttribute("value",""),u.input=f.getAttribute("value")==="",f.value="t",f.setAttribute("type","radio"),u.radioValue=f.value==="t",f.setAttribute("checked","t"),f.setAttribute("name","t"),c=r.createDocumentFragment(),c.appendChild(f),u.appendChecked=f.checked,u.checkClone=c.cloneNode(!0).cloneNode(!0).lastChild.checked,t.attachEvent&&(t.attachEvent("onclick",function(){u.noCloneEvent=!1}),t.cloneNode(!0).click());for(v in{submit:!0,change:!0,focusin:!0})t.setAttribute(a="on"+v,"t"),u[v+"Bubbles"]=a in n||t.attributes[a].expando===!1;return t.style.backgroundClip="content-box",t.cloneNode(!0).style.backgroundClip="",u.clearCloneStyle=t.style.backgroundClip==="content-box",i(function(){var e,f,i,h="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",s=r.getElementsByTagName("body")[0];s&&(e=r.createElement("div"),e.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",s.appendChild(e).appendChild(t),t.innerHTML="<table><tr><td><\/td><td>t<\/td><\/tr><\/table>",i=t.getElementsByTagName("td"),i[0].style.cssText="padding:0;margin:0;border:0;display:none",p=i[0].offsetHeight===0,i[0].style.display="",i[1].style.display="none",u.reliableHiddenOffsets=p&&i[0].offsetHeight===0,t.innerHTML="",t.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",u.boxSizing=t.offsetWidth===4,u.doesNotIncludeMarginInBodyOffset=s.offsetTop!==1,n.getComputedStyle&&(u.pixelPosition=(n.getComputedStyle(t,null)||{}).top!=="1%",u.boxSizingReliable=(n.getComputedStyle(t,null)||{width:"4px"}).width==="4px",f=t.appendChild(r.createElement("div")),f.style.cssText=t.style.cssText=h,f.style.marginRight=f.style.width="0",t.style.width="1px",u.reliableMarginRight=!parseFloat((n.getComputedStyle(f,null)||{}).marginRight)),typeof t.style.zoom!==o&&(t.innerHTML="",t.style.cssText=h+"width:1px;padding:1px;display:inline;zoom:1",u.inlineBlockNeedsLayout=t.offsetWidth===3,t.style.display="block",t.innerHTML="<div><\/div>",t.firstChild.style.width="5px",u.shrinkWrapBlocks=t.offsetWidth!==3,u.inlineBlockNeedsLayout&&(s.style.zoom=1)),s.removeChild(e),e=t=i=f=null)}),s=h=c=l=e=f=null,u}(),nr=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,tr=/([A-Z])/g,i.extend({cache:{},expando:"jQuery"+(wt+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(n){return n=n.nodeType?i.cache[n[i.expando]]:n[i.expando],!!n&&!ni(n)},data:function(n,t,i){return ir(n,t,i)},removeData:function(n,t){return rr(n,t)},_data:function(n,t,i){return ir(n,t,i,!0)},_removeData:function(n,t){return rr(n,t,!0)},acceptData:function(n){if(n.nodeType&&n.nodeType!==1&&n.nodeType!==9)return!1;var t=n.nodeName&&i.noData[n.nodeName.toLowerCase()];return!t||t!==!0&&n.getAttribute("classid")===t}}),i.fn.extend({data:function(n,r){var e,f,u=this[0],o=0,s=null;if(n===t){if(this.length&&(s=i.data(u),u.nodeType===1&&!i._data(u,"parsedAttrs"))){for(e=u.attributes;o<e.length;o++)f=e[o].name,f.indexOf("data-")||(f=i.camelCase(f.slice(5)),ur(u,f,s[f]));i._data(u,"parsedAttrs",!0)}return s}return typeof n=="object"?this.each(function(){i.data(this,n)}):i.access(this,function(r){if(r===t)return u?ur(u,n,i.data(u,n)):null;this.each(function(){i.data(this,n,r)})},null,r,arguments.length>1,null,!0)},removeData:function(n){return this.each(function(){i.removeData(this,n)})}}),i.extend({queue:function(n,t,r){var u;if(n)return t=(t||"fx")+"queue",u=i._data(n,t),r&&(!u||i.isArray(r)?u=i._data(n,t,i.makeArray(r)):u.push(r)),u||[]},dequeue:function(n,t){t=t||"fx";var f=i.queue(n,t),e=f.length,r=f.shift(),u=i._queueHooks(n,t),o=function(){i.dequeue(n,t)};r==="inprogress"&&(r=f.shift(),e--),u.cur=r,r&&(t==="fx"&&f.unshift("inprogress"),delete u.stop,r.call(n,o,u)),!e&&u&&u.empty.fire()},_queueHooks:function(n,t){var r=t+"queueHooks";return i._data(n,r)||i._data(n,r,{empty:i.Callbacks("once memory").add(function(){i._removeData(n,t+"queue"),i._removeData(n,r)})})}}),i.fn.extend({queue:function(n,r){var u=2;return(typeof n!="string"&&(r=n,n="fx",u--),arguments.length<u)?i.queue(this[0],n):r===t?this:this.each(function(){var t=i.queue(this,n,r);i._queueHooks(this,n),n==="fx"&&t[0]!=="inprogress"&&i.dequeue(this,n)})},dequeue:function(n){return this.each(function(){i.dequeue(this,n)})},delay:function(n,t){return n=i.fx?i.fx.speeds[n]||n:n,t=t||"fx",this.queue(t,function(t,i){var r=setTimeout(t,n);i.stop=function(){clearTimeout(r)}})},clearQueue:function(n){return this.queue(n||"fx",[])},promise:function(n,r){var u,e=1,o=i.Deferred(),f=this,s=this.length,h=function(){--e||o.resolveWith(f,[f])};for(typeof n!="string"&&(r=n,n=t),n=n||"fx";s--;)u=i._data(f[s],n+"queueHooks"),u&&u.empty&&(e++,u.empty.add(h));return h(),o.promise(r)}});var k,fr,ti=/[\t\r\n]/g,df=/\r/g,gf=/^(?:input|select|textarea|button|object)$/i,ne=/^(?:a|area)$/i,er=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,ii=/^(?:checked|selected)$/i,a=i.support.getSetAttribute,ri=i.support.input;i.fn.extend({attr:function(n,t){return i.access(this,i.attr,n,t,arguments.length>1)},removeAttr:function(n){return this.each(function(){i.removeAttr(this,n)})},prop:function(n,t){return i.access(this,i.prop,n,t,arguments.length>1)},removeProp:function(n){return n=i.propFix[n]||n,this.each(function(){try{this[n]=t,delete this[n]}catch(i){}})},addClass:function(n){var e,t,r,u,o,f=0,h=this.length,c=typeof n=="string"&&n;if(i.isFunction(n))return this.each(function(t){i(this).addClass(n.call(this,t,this.className))});if(c)for(e=(n||"").match(s)||[];f<h;f++)if(t=this[f],r=t.nodeType===1&&(t.className?(" "+t.className+" ").replace(ti," "):" "),r){for(o=0;u=e[o++];)r.indexOf(" "+u+" ")<0&&(r+=u+" ");t.className=i.trim(r)}return this},removeClass:function(n){var e,r,t,u,o,f=0,h=this.length,c=arguments.length===0||typeof n=="string"&&n;if(i.isFunction(n))return this.each(function(t){i(this).removeClass(n.call(this,t,this.className))});if(c)for(e=(n||"").match(s)||[];f<h;f++)if(r=this[f],t=r.nodeType===1&&(r.className?(" "+r.className+" ").replace(ti," "):""),t){for(o=0;u=e[o++];)while(t.indexOf(" "+u+" ")>=0)t=t.replace(" "+u+" "," ");r.className=n?i.trim(t):""}return this},toggleClass:function(n,t){var r=typeof n,u=typeof t=="boolean";return i.isFunction(n)?this.each(function(r){i(this).toggleClass(n.call(this,r,this.className,t),t)}):this.each(function(){if(r==="string")for(var f,c=0,h=i(this),e=t,l=n.match(s)||[];f=l[c++];)e=u?e:!h.hasClass(f),h[e?"addClass":"removeClass"](f);else(r===o||r==="boolean")&&(this.className&&i._data(this,"__className__",this.className),this.className=this.className||n===!1?"":i._data(this,"__className__")||"")})},hasClass:function(n){for(var i=" "+n+" ",t=0,r=this.length;t<r;t++)if(this[t].nodeType===1&&(" "+this[t].className+" ").replace(ti," ").indexOf(i)>=0)return!0;return!1},val:function(n){var u,r,e,f=this[0];return arguments.length?(e=i.isFunction(n),this.each(function(u){var f,o=i(this);this.nodeType===1&&(f=e?n.call(this,u,o.val()):n,f==null?f="":typeof f=="number"?f+="":i.isArray(f)&&(f=i.map(f,function(n){return n==null?"":n+""})),r=i.valHooks[this.type]||i.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,f,"value")!==t||(this.value=f))})):f?(r=i.valHooks[f.type]||i.valHooks[f.nodeName.toLowerCase()],r&&"get"in r&&(u=r.get(f,"value"))!==t)?u:(u=f.value,typeof u=="string"?u.replace(df,""):u==null?"":u):void 0}}),i.extend({valHooks:{option:{get:function(n){var t=n.attributes.value;return!t||t.specified?n.value:n.text}},select:{get:function(n){for(var e,t,o=n.options,r=n.selectedIndex,u=n.type==="select-one"||r<0,s=u?null:[],h=u?r+1:o.length,f=r<0?h:u?r:0;f<h;f++)if(t=o[f],(t.selected||f===r)&&(i.support.optDisabled?!t.disabled:t.getAttribute("disabled")===null)&&(!t.parentNode.disabled||!i.nodeName(t.parentNode,"optgroup"))){if(e=i(t).val(),u)return e;s.push(e)}return s},set:function(n,t){var r=i.makeArray(t);return i(n).find("option").each(function(){this.selected=i.inArray(i(this).val(),r)>=0}),r.length||(n.selectedIndex=-1),r}}},attr:function(n,r,u){var f,s,e,h=n.nodeType;if(n&&h!==3&&h!==8&&h!==2){if(typeof n.getAttribute===o)return i.prop(n,r,u);if(s=h!==1||!i.isXMLDoc(n),s&&(r=r.toLowerCase(),f=i.attrHooks[r]||(er.test(r)?fr:k)),u!==t)if(u===null)i.removeAttr(n,r);else return f&&s&&"set"in f&&(e=f.set(n,u,r))!==t?e:(n.setAttribute(r,u+""),u);else return f&&s&&"get"in f&&(e=f.get(n,r))!==null?e:(typeof n.getAttribute!==o&&(e=n.getAttribute(r)),e==null?t:e)}},removeAttr:function(n,t){var r,u,e=0,f=t&&t.match(s);if(f&&n.nodeType===1)while(r=f[e++])u=i.propFix[r]||r,er.test(r)?!a&&ii.test(r)?n[i.camelCase("default-"+r)]=n[u]=!1:n[u]=!1:i.attr(n,r,""),n.removeAttribute(a?r:u)},attrHooks:{type:{set:function(n,t){if(!i.support.radioValue&&t==="radio"&&i.nodeName(n,"input")){var r=n.value;return n.setAttribute("type",t),r&&(n.value=r),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(n,r,u){var e,f,s,o=n.nodeType;if(n&&o!==3&&o!==8&&o!==2)return s=o!==1||!i.isXMLDoc(n),s&&(r=i.propFix[r]||r,f=i.propHooks[r]),u!==t?f&&"set"in f&&(e=f.set(n,u,r))!==t?e:n[r]=u:f&&"get"in f&&(e=f.get(n,r))!==null?e:n[r]},propHooks:{tabIndex:{get:function(n){var i=n.getAttributeNode("tabindex");return i&&i.specified?parseInt(i.value,10):gf.test(n.nodeName)||ne.test(n.nodeName)&&n.href?0:t}}}}),fr={get:function(n,r){var u=i.prop(n,r),f=typeof u=="boolean"&&n.getAttribute(r),e=typeof u=="boolean"?ri&&a?f!=null:ii.test(r)?n[i.camelCase("default-"+r)]:!!f:n.getAttributeNode(r);return e&&e.value!==!1?r.toLowerCase():t},set:function(n,t,r){return t===!1?i.removeAttr(n,r):ri&&a||!ii.test(r)?n.setAttribute(!a&&i.propFix[r]||r,r):n[i.camelCase("default-"+r)]=n[r]=!0,r}},ri&&a||(i.attrHooks.value={get:function(n,r){var u=n.getAttributeNode(r);return i.nodeName(n,"input")?n.defaultValue:u&&u.specified?u.value:t},set:function(n,t,r){if(i.nodeName(n,"input"))n.defaultValue=t;else return k&&k.set(n,t,r)}}),a||(k=i.valHooks.button={get:function(n,i){var r=n.getAttributeNode(i);return r&&(i==="id"||i==="name"||i==="coords"?r.value!=="":r.specified)?r.value:t},set:function(n,i,r){var u=n.getAttributeNode(r);return u||n.setAttributeNode(u=n.ownerDocument.createAttribute(r)),u.value=i+="",r==="value"||i===n.getAttribute(r)?i:t}},i.attrHooks.contenteditable={get:k.get,set:function(n,t,i){k.set(n,t===""?!1:t,i)}},i.each(["width","height"],function(n,t){i.attrHooks[t]=i.extend(i.attrHooks[t],{set:function(n,i){if(i==="")return n.setAttribute(t,"auto"),i}})})),i.support.hrefNormalized||(i.each(["href","src","width","height"],function(n,r){i.attrHooks[r]=i.extend(i.attrHooks[r],{get:function(n){var i=n.getAttribute(r,2);return i==null?t:i}})}),i.each(["href","src"],function(n,t){i.propHooks[t]={get:function(n){return n.getAttribute(t,4)}}})),i.support.style||(i.attrHooks.style={get:function(n){return n.style.cssText||t},set:function(n,t){return n.style.cssText=t+""}}),i.support.optSelected||(i.propHooks.selected=i.extend(i.propHooks.selected,{get:function(n){var t=n.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),i.support.enctype||(i.propFix.enctype="encoding"),i.support.checkOn||i.each(["radio","checkbox"],function(){i.valHooks[this]={get:function(n){return n.getAttribute("value")===null?"on":n.value}}}),i.each(["radio","checkbox"],function(){i.valHooks[this]=i.extend(i.valHooks[this],{set:function(n,t){if(i.isArray(t))return n.checked=i.inArray(i(n).val(),t)>=0}})});var ui=/^(?:input|select|textarea)$/i,te=/^key/,ie=/^(?:mouse|contextmenu)|click/,or=/^(?:focusinfocus|focusoutblur)$/,sr=/^([^.]*)(?:\.(.+)|)$/;i.event={global:{},add:function(n,r,u,f,e){var b,p,k,w,c,l,a,v,h,d,g,y=i._data(n);if(y){for(u.handler&&(w=u,u=w.handler,e=w.selector),u.guid||(u.guid=i.guid++),(p=y.events)||(p=y.events={}),(l=y.handle)||(l=y.handle=function(n){return typeof i!==o&&(!n||i.event.triggered!==n.type)?i.event.dispatch.apply(l.elem,arguments):t},l.elem=n),r=(r||"").match(s)||[""],k=r.length;k--;)b=sr.exec(r[k])||[],h=g=b[1],d=(b[2]||"").split(".").sort(),c=i.event.special[h]||{},h=(e?c.delegateType:c.bindType)||h,c=i.event.special[h]||{},a=i.extend({type:h,origType:g,data:f,handler:u,guid:u.guid,selector:e,needsContext:e&&i.expr.match.needsContext.test(e),namespace:d.join(".")},w),(v=p[h])||(v=p[h]=[],v.delegateCount=0,c.setup&&c.setup.call(n,f,d,l)!==!1||(n.addEventListener?n.addEventListener(h,l,!1):n.attachEvent&&n.attachEvent("on"+h,l))),c.add&&(c.add.call(n,a),a.handler.guid||(a.handler.guid=u.guid)),e?v.splice(v.delegateCount++,0,a):v.push(a),i.event.global[h]=!0;n=null}},remove:function(n,t,r,u,f){var y,o,h,b,p,a,c,l,e,w,k,v=i.hasData(n)&&i._data(n);if(v&&(a=v.events)){for(t=(t||"").match(s)||[""],p=t.length;p--;){if(h=sr.exec(t[p])||[],e=k=h[1],w=(h[2]||"").split(".").sort(),!e){for(e in a)i.event.remove(n,e+t[p],r,u,!0);continue}for(c=i.event.special[e]||{},e=(u?c.delegateType:c.bindType)||e,l=a[e]||[],h=h[2]&&new RegExp("(^|\\.)"+w.join("\\.(?:.*\\.|)")+"(\\.|$)"),b=y=l.length;y--;)o=l[y],(f||k===o.origType)&&(!r||r.guid===o.guid)&&(!h||h.test(o.namespace))&&(!u||u===o.selector||u==="**"&&o.selector)&&(l.splice(y,1),o.selector&&l.delegateCount--,c.remove&&c.remove.call(n,o));b&&!l.length&&(c.teardown&&c.teardown.call(n,w,v.handle)!==!1||i.removeEvent(n,e,v.handle),delete a[e])}i.isEmptyObject(a)&&(delete v.handle,i._removeData(n,"events"))}},trigger:function(u,f,e,o){var a,v,h,p,l,c,w,b=[e||r],s=it.call(u,"type")?u.type:u,y=it.call(u,"namespace")?u.namespace.split("."):[];if((h=c=e=e||r,e.nodeType!==3&&e.nodeType!==8)&&!or.test(s+i.event.triggered)&&(s.indexOf(".")>=0&&(y=s.split("."),s=y.shift(),y.sort()),v=s.indexOf(":")<0&&"on"+s,u=u[i.expando]?u:new i.Event(s,typeof u=="object"&&u),u.isTrigger=!0,u.namespace=y.join("."),u.namespace_re=u.namespace?new RegExp("(^|\\.)"+y.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,u.result=t,u.target||(u.target=e),f=f==null?[u]:i.makeArray(f,[u]),l=i.event.special[s]||{},o||!l.trigger||l.trigger.apply(e,f)!==!1)){if(!o&&!l.noBubble&&!i.isWindow(e)){for(p=l.delegateType||s,or.test(p+s)||(h=h.parentNode);h;h=h.parentNode)b.push(h),c=h;c===(e.ownerDocument||r)&&b.push(c.defaultView||c.parentWindow||n)}for(w=0;(h=b[w++])&&!u.isPropagationStopped();)u.type=w>1?p:l.bindType||s,a=(i._data(h,"events")||{})[u.type]&&i._data(h,"handle"),a&&a.apply(h,f),a=v&&h[v],a&&i.acceptData(h)&&a.apply&&a.apply(h,f)===!1&&u.preventDefault();if(u.type=s,!o&&!u.isDefaultPrevented()&&(!l._default||l._default.apply(e.ownerDocument,f)===!1)&&!(s==="click"&&i.nodeName(e,"a"))&&i.acceptData(e)&&v&&e[s]&&!i.isWindow(e)){c=e[v],c&&(e[v]=null),i.event.triggered=s;try{e[s]()}catch(k){}i.event.triggered=t,c&&(e[v]=c)}return u.result}},dispatch:function(n){n=i.event.fix(n);var o,e,r,u,s,h=[],c=l.call(arguments),a=(i._data(this,"events")||{})[n.type]||[],f=i.event.special[n.type]||{};if(c[0]=n,n.delegateTarget=this,!f.preDispatch||f.preDispatch.call(this,n)!==!1){for(h=i.event.handlers.call(this,n,a),o=0;(u=h[o++])&&!n.isPropagationStopped();)for(n.currentTarget=u.elem,s=0;(r=u.handlers[s++])&&!n.isImmediatePropagationStopped();)(!n.namespace_re||n.namespace_re.test(r.namespace))&&(n.handleObj=r,n.data=r.data,e=((i.event.special[r.origType]||{}).handle||r.handler).apply(u.elem,c),e!==t&&(n.result=e)===!1&&(n.preventDefault(),n.stopPropagation()));return f.postDispatch&&f.postDispatch.call(this,n),n.result}},handlers:function(n,r){var e,o,f,s,c=[],h=r.delegateCount,u=n.target;if(h&&u.nodeType&&(!n.button||n.type!=="click"))for(;u!=this;u=u.parentNode||this)if(u.nodeType===1&&(u.disabled!==!0||n.type!=="click")){for(f=[],s=0;s<h;s++)o=r[s],e=o.selector+" ",f[e]===t&&(f[e]=o.needsContext?i(e,this).index(u)>=0:i.find(e,this,null,[u]).length),f[e]&&f.push(o);f.length&&c.push({elem:u,handlers:f})}return h<r.length&&c.push({elem:this,handlers:r.slice(h)}),c},fix:function(n){if(n[i.expando])return n;var e,o,s,u=n.type,f=n,t=this.fixHooks[u];for(t||(this.fixHooks[u]=t=ie.test(u)?this.mouseHooks:te.test(u)?this.keyHooks:{}),s=t.props?this.props.concat(t.props):this.props,n=new i.Event(f),e=s.length;e--;)o=s[e],n[o]=f[o];return n.target||(n.target=f.srcElement||r),n.target.nodeType===3&&(n.target=n.target.parentNode),n.metaKey=!!n.metaKey,t.filter?t.filter(n,f):n},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(n,t){return n.which==null&&(n.which=t.charCode!=null?t.charCode:t.keyCode),n}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(n,i){var u,o,f,e=i.button,s=i.fromElement;return n.pageX==null&&i.clientX!=null&&(o=n.target.ownerDocument||r,f=o.documentElement,u=o.body,n.pageX=i.clientX+(f&&f.scrollLeft||u&&u.scrollLeft||0)-(f&&f.clientLeft||u&&u.clientLeft||0),n.pageY=i.clientY+(f&&f.scrollTop||u&&u.scrollTop||0)-(f&&f.clientTop||u&&u.clientTop||0)),!n.relatedTarget&&s&&(n.relatedTarget=s===n.target?i.toElement:s),n.which||e===t||(n.which=e&1?1:e&2?3:e&4?2:0),n}},special:{load:{noBubble:!0},click:{trigger:function(){if(i.nodeName(this,"input")&&this.type==="checkbox"&&this.click)return this.click(),!1}},focus:{trigger:function(){if(this!==r.activeElement&&this.focus)try{return this.focus(),!1}catch(n){}},delegateType:"focusin"},blur:{trigger:function(){if(this===r.activeElement&&this.blur)return this.blur(),!1},delegateType:"focusout"},beforeunload:{postDispatch:function(n){n.result!==t&&(n.originalEvent.returnValue=n.result)}}},simulate:function(n,t,r,u){var f=i.extend(new i.Event,r,{type:n,isSimulated:!0,originalEvent:{}});u?i.event.trigger(f,null,t):i.event.dispatch.call(t,f),f.isDefaultPrevented()&&r.preventDefault()}},i.removeEvent=r.removeEventListener?function(n,t,i){n.removeEventListener&&n.removeEventListener(t,i,!1)}:function(n,t,i){var r="on"+t;n.detachEvent&&(typeof n[r]===o&&(n[r]=null),n.detachEvent(r,i))},i.Event=function(n,t){if(!(this instanceof i.Event))return new i.Event(n,t);n&&n.type?(this.originalEvent=n,this.type=n.type,this.isDefaultPrevented=n.defaultPrevented||n.returnValue===!1||n.getPreventDefault&&n.getPreventDefault()?ht:d):this.type=n,t&&i.extend(this,t),this.timeStamp=n&&n.timeStamp||i.now(),this[i.expando]=!0},i.Event.prototype={isDefaultPrevented:d,isPropagationStopped:d,isImmediatePropagationStopped:d,preventDefault:function(){var n=this.originalEvent;(this.isDefaultPrevented=ht,n)&&(n.preventDefault?n.preventDefault():n.returnValue=!1)},stopPropagation:function(){var n=this.originalEvent;(this.isPropagationStopped=ht,n)&&(n.stopPropagation&&n.stopPropagation(),n.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ht,this.stopPropagation()}},i.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(n,t){i.event.special[n]={delegateType:t,bindType:t,handle:function(n){var u,f=this,r=n.relatedTarget,e=n.handleObj;return r&&(r===f||i.contains(f,r))||(n.type=e.origType,u=e.handler.apply(this,arguments),n.type=t),u}}}),i.support.submitBubbles||(i.event.special.submit={setup:function(){if(i.nodeName(this,"form"))return!1;i.event.add(this,"click._submit keypress._submit",function(n){var u=n.target,r=i.nodeName(u,"input")||i.nodeName(u,"button")?u.form:t;r&&!i._data(r,"submitBubbles")&&(i.event.add(r,"submit._submit",function(n){n._submit_bubble=!0}),i._data(r,"submitBubbles",!0))})},postDispatch:function(n){n._submit_bubble&&(delete n._submit_bubble,this.parentNode&&!n.isTrigger&&i.event.simulate("submit",this.parentNode,n,!0))},teardown:function(){if(i.nodeName(this,"form"))return!1;i.event.remove(this,"._submit")}}),i.support.changeBubbles||(i.event.special.change={setup:function(){if(ui.test(this.nodeName))return(this.type==="checkbox"||this.type==="radio")&&(i.event.add(this,"propertychange._change",function(n){n.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),i.event.add(this,"click._change",function(n){this._just_changed&&!n.isTrigger&&(this._just_changed=!1),i.event.simulate("change",this,n,!0)})),!1;i.event.add(this,"beforeactivate._change",function(n){var t=n.target;ui.test(t.nodeName)&&!i._data(t,"changeBubbles")&&(i.event.add(t,"change._change",function(n){!this.parentNode||n.isSimulated||n.isTrigger||i.event.simulate("change",this.parentNode,n,!0)}),i._data(t,"changeBubbles",!0))})},handle:function(n){var t=n.target;if(this!==t||n.isSimulated||n.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return n.handleObj.handler.apply(this,arguments)},teardown:function(){return i.event.remove(this,"._change"),!ui.test(this.nodeName)}}),i.support.focusinBubbles||i.each({focus:"focusin",blur:"focusout"},function(n,t){var u=0,f=function(n){i.event.simulate(t,n.target,i.event.fix(n),!0)};i.event.special[t]={setup:function(){u++==0&&r.addEventListener(n,f,!0)},teardown:function(){--u==0&&r.removeEventListener(n,f,!0)}}}),i.fn.extend({on:function(n,r,u,f,e){var s,o;if(typeof n=="object"){typeof r!="string"&&(u=u||r,r=t);for(s in n)this.on(s,r,u,n[s],e);return this}if(u==null&&f==null?(f=r,u=r=t):f==null&&(typeof r=="string"?(f=u,u=t):(f=u,u=r,r=t)),f===!1)f=d;else if(!f)return this;return e===1&&(o=f,f=function(n){return i().off(n),o.apply(this,arguments)},f.guid=o.guid||(o.guid=i.guid++)),this.each(function(){i.event.add(this,n,f,u,r)})},one:function(n,t,i,r){return this.on(n,t,i,r,1)},off:function(n,r,u){var f,e;if(n&&n.preventDefault&&n.handleObj)return f=n.handleObj,i(n.delegateTarget).off(f.namespace?f.origType+"."+f.namespace:f.origType,f.selector,f.handler),this;if(typeof n=="object"){for(e in n)this.off(e,r,n[e]);return this}return(r===!1||typeof r=="function")&&(u=r,r=t),u===!1&&(u=d),this.each(function(){i.event.remove(this,n,u,r)})},bind:function(n,t,i){return this.on(n,null,t,i)},unbind:function(n,t){return this.off(n,null,t)},delegate:function(n,t,i,r){return this.on(t,n,i,r)},undelegate:function(n,t,i){return arguments.length===1?this.off(n,"**"):this.off(t,n||"**",i)},trigger:function(n,t){return this.each(function(){i.event.trigger(n,t,this)})},triggerHandler:function(n,t){var r=this[0];if(r)return i.event.trigger(n,t,r,!0)}});(function(n,t){function ti(n){return tr.test(n+"")}function ii(){var n,t=[];return n=function(i,u){return t.push(i+=" ")>r.cacheLength&&delete n[t.shift()],n[i]=u}}function l(n){return n[f]=!0,n}function b(n){var t=s.createElement("div");try{return n(t)}catch(i){return!1}finally{t=null}}function u(n,t,i,r){var y,u,e,l,p,v,w,h,d,b;if((t?t.ownerDocument||t:k)!==s&&it(t),t=t||s,i=i||[],!n||typeof n!="string")return i;if((l=t.nodeType)!==1&&l!==9)return[];if(!c&&!r){if(y=ir.exec(n))if(e=y[1]){if(l===9)if(u=t.getElementById(e),u&&u.parentNode){if(u.id===e)return i.push(u),i}else return i;else if(t.ownerDocument&&(u=t.ownerDocument.getElementById(e))&&et(t,u)&&u.id===e)return i.push(u),i}else{if(y[2])return ut.apply(i,ft.call(t.getElementsByTagName(n),0)),i;if((e=y[3])&&o.getByClassName&&t.getElementsByClassName)return ut.apply(i,ft.call(t.getElementsByClassName(e),0)),i}if(o.qsa&&!a.test(n)){if(w=!0,h=f,d=t,b=l===9&&n,l===1&&t.nodeName.toLowerCase()!=="object"){for(v=yt(n),(w=t.getAttribute("id"))?h=w.replace(fr,"\\$&"):t.setAttribute("id",h),h="[id='"+h+"'] ",p=v.length;p--;)v[p]=h+pt(v[p]);d=ni.test(n)&&t.parentNode||t,b=v.join(",")}if(b)try{return ut.apply(i,ft.call(d.querySelectorAll(b),0)),i}catch(g){}finally{w||t.removeAttribute("id")}}}return lr(n.replace(at,"$1"),t,i,r)}function yi(n,t){var i=t&&n,r=i&&(~t.sourceIndex||li)-(~n.sourceIndex||li);if(r)return r;if(i)while(i=i.nextSibling)if(i===t)return-1;return n?1:-1}function or(n){return function(t){var i=t.nodeName.toLowerCase();return i==="input"&&t.type===n}}function sr(n){return function(t){var i=t.nodeName.toLowerCase();return(i==="input"||i==="button")&&t.type===n}}function g(n){return l(function(t){return t=+t,l(function(i,r){for(var u,f=n([],i.length,t),e=f.length;e--;)i[u=f[e]]&&(i[u]=!(r[u]=i[u]))})})}function yt(n,t){var e,f,s,o,i,h,c,l=hi[n+" "];if(l)return t?0:l.slice(0);for(i=n,h=[],c=r.preFilter;i;){(!e||(f=ki.exec(i)))&&(f&&(i=i.slice(f[0].length)||i),h.push(s=[])),e=!1,(f=di.exec(i))&&(e=f.shift(),s.push({value:e,type:f[0].replace(at," ")}),i=i.slice(e.length));for(o in r.filter)(f=vt[o].exec(i))&&(!c[o]||(f=c[o](f)))&&(e=f.shift(),s.push({value:e,type:o,matches:f}),i=i.slice(e.length));if(!e)break}return t?i.length:i?u.error(n):hi(n,h).slice(0)}function pt(n){for(var t=0,r=n.length,i="";t<r;t++)i+=n[t].value;return i}function ri(n,t,i){var r=t.dir,u=i&&r==="parentNode",e=wi++;return t.first?function(t,i,f){while(t=t[r])if(t.nodeType===1||u)return n(t,i,f)}:function(t,i,o){var h,s,c,l=v+" "+e;if(o){while(t=t[r])if((t.nodeType===1||u)&&n(t,i,o))return!0}else while(t=t[r])if(t.nodeType===1||u)if(c=t[f]||(t[f]={}),(s=c[r])&&s[0]===l){if((h=s[1])===!0||h===ot)return h===!0}else if(s=c[r]=[l],s[1]=n(t,i,o)||ot,s[1]===!0)return!0}}function ui(n){return n.length>1?function(t,i,r){for(var u=n.length;u--;)if(!n[u](t,i,r))return!1;return!0}:n[0]}function wt(n,t,i,r,u){for(var e,o=[],f=0,s=n.length,h=t!=null;f<s;f++)(e=n[f])&&(!i||i(e,r,u))&&(o.push(e),h&&t.push(f));return o}function fi(n,t,i,r,u,e){return r&&!r[f]&&(r=fi(r)),u&&!u[f]&&(u=fi(u,e)),l(function(f,e,o,s){var l,c,a,p=[],y=[],w=e.length,b=f||cr(t||"*",o.nodeType?[o]:o,[]),v=n&&(f||!t)?wt(b,p,n,o,s):b,h=i?u||(f?n:w||r)?[]:e:v;if(i&&i(v,h,o,s),r)for(l=wt(h,y),r(l,[],o,s),c=l.length;c--;)(a=l[c])&&(h[y[c]]=!(v[y[c]]=a));if(f){if(u||n){if(u){for(l=[],c=h.length;c--;)(a=h[c])&&l.push(v[c]=a);u(null,h=[],l,s)}for(c=h.length;c--;)(a=h[c])&&(l=u?dt.call(f,a):p[c])>-1&&(f[l]=!(e[l]=a))}}else h=wt(h===e?h.splice(w,h.length):h),u?u(null,e,h,s):ut.apply(e,h)})}function ei(n){for(var s,u,i,o=n.length,h=r.relative[n[0].type],c=h||r.relative[" "],t=h?1:0,l=ri(function(n){return n===s},c,!0),a=ri(function(n){return dt.call(s,n)>-1},c,!0),e=[function(n,t,i){return!h&&(i||t!==ht)||((s=t).nodeType?l(n,t,i):a(n,t,i))}];t<o;t++)if(u=r.relative[n[t].type])e=[ri(ui(e),u)];else{if(u=r.filter[n[t].type].apply(null,n[t].matches),u[f]){for(i=++t;i<o;i++)if(r.relative[n[i].type])break;return fi(t>1&&ui(e),t>1&&pt(n.slice(0,t-1)).replace(at,"$1"),u,t<i&&ei(n.slice(t,i)),i<o&&ei(n=n.slice(i)),i<o&&pt(n))}e.push(u)}return ui(e)}function hr(n,t){var f=0,i=t.length>0,e=n.length>0,o=function(o,h,c,l,a){var p,d,b,w=[],k=0,y="0",g=o&&[],nt=a!=null,tt=ht,rt=o||e&&r.find.TAG("*",a&&h.parentNode||h),it=v+=tt==null?1:Math.random()||.1;for(nt&&(ht=h!==s&&h,ot=f);(p=rt[y])!=null;y++){if(e&&p){for(d=0;b=n[d++];)if(b(p,h,c)){l.push(p);break}nt&&(v=it,ot=++f)}i&&((p=!b&&p)&&k--,o&&g.push(p))}if(k+=y,i&&y!==k){for(d=0;b=t[d++];)b(g,w,h,c);if(o){if(k>0)while(y--)g[y]||w[y]||(w[y]=bi.call(l));w=wt(w)}ut.apply(l,w),nt&&!o&&w.length>0&&k+t.length>1&&u.uniqueSort(l)}return nt&&(v=it,ht=tt),g};return i?l(o):o}function cr(n,t,i){for(var r=0,f=t.length;r<f;r++)u(n,t[r],i);return i}function lr(n,t,i,u){var o,f,e,h,l,s=yt(n);if(!u&&s.length===1){if(f=s[0]=s[0].slice(0),f.length>2&&(e=f[0]).type==="ID"&&t.nodeType===9&&!c&&r.relative[f[1].type]){if(t=r.find.ID(e.matches[0].replace(p,w),t)[0],!t)return i;n=n.slice(f.shift().value.length)}for(o=vt.needsContext.test(n)?0:f.length;o--;){if(e=f[o],r.relative[h=e.type])break;if((l=r.find[h])&&(u=l(e.matches[0].replace(p,w),ni.test(f[0].type)&&t.parentNode||t))){if(f.splice(o,1),n=u.length&&pt(f),!n)return ut.apply(i,ft.call(u,0)),i;break}}}return bt(n,s)(u,t,c,i,ni.test(n)),i}function pi(){}var nt,ot,r,st,oi,bt,tt,ht,it,s,h,c,a,rt,ct,et,kt,f="sizzle"+-new Date,k=n.document,o={},v=0,wi=0,si=ii(),hi=ii(),ci=ii(),y=typeof t,li=-2147483648,lt=[],bi=lt.pop,ut=lt.push,ft=lt.slice,dt=lt.indexOf||function(n){for(var t=0,i=this.length;t<i;t++)if(this[t]===n)return t;return-1},e="[\\x20\\t\\r\\n\\f]",d="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",ai=d.replace("w","w#"),vi="\\["+e+"*("+d+")"+e+"*(?:([*^$|!~]?=)"+e+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+ai+")|)|)"+e+"*\\]",gt=":("+d+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+vi.replace(3,8)+")*)|.*)\\)|)",at=new RegExp("^"+e+"+|((?:^|[^\\\\])(?:\\\\.)*)"+e+"+$","g"),ki=new RegExp("^"+e+"*,"+e+"*"),di=new RegExp("^"+e+"*([\\x20\\t\\r\\n\\f>+~])"+e+"*"),gi=new RegExp(gt),nr=new RegExp("^"+ai+"$"),vt={ID:new RegExp("^#("+d+")"),CLASS:new RegExp("^\\.("+d+")"),NAME:new RegExp("^\\[name=['\"]?("+d+")['\"]?\\]"),TAG:new RegExp("^("+d.replace("w","w*")+")"),ATTR:new RegExp("^"+vi),PSEUDO:new RegExp("^"+gt),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+e+"*(even|odd|(([+-]|)(\\d*)n|)"+e+"*(?:([+-]|)"+e+"*(\\d+)|))"+e+"*\\)|)","i"),needsContext:new RegExp("^"+e+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+e+"*((?:-\\d)?\\d*)"+e+"*\\)|)(?=[^-]|$)","i")},ni=/[\x20\t\r\n\f]*[+~]/,tr=/^[^{]+\{\s*\[native code/,ir=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rr=/^(?:input|select|textarea|button)$/i,ur=/^h\d$/i,fr=/'|\\/g,er=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,p=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,w=function(n,t){var i="0x"+t-65536;return i!==i?t:i<0?String.fromCharCode(i+65536):String.fromCharCode(i>>10|55296,i&1023|56320)};try{ft.call(k.documentElement.childNodes,0)[0].nodeType}catch(ar){ft=function(n){for(var t,i=[];t=this[n++];)i.push(t);return i}}oi=u.isXML=function(n){var t=n&&(n.ownerDocument||n).documentElement;return t?t.nodeName!=="HTML":!1},it=u.setDocument=function(n){var i=n?n.ownerDocument||n:k;return i===s||i.nodeType!==9||!i.documentElement?s:(s=i,h=i.documentElement,c=oi(i),o.tagNameNoComments=b(function(n){return n.appendChild(i.createComment("")),!n.getElementsByTagName("*").length}),o.attributes=b(function(n){n.innerHTML="<select><\/select>";var t=typeof n.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),o.getByClassName=b(function(n){return(n.innerHTML="<div class='hidden e'><\/div><div class='hidden'><\/div>",!n.getElementsByClassName||!n.getElementsByClassName("e").length)?!1:(n.lastChild.className="e",n.getElementsByClassName("e").length===2)}),o.getByName=b(function(n){n.id=f+0,n.innerHTML="<a name='"+f+"'><\/a><div name='"+f+"'><\/div>",h.insertBefore(n,h.firstChild);var t=i.getElementsByName&&i.getElementsByName(f).length===2+i.getElementsByName(f+0).length;return o.getIdNotName=!i.getElementById(f),h.removeChild(n),t}),r.attrHandle=b(function(n){return n.innerHTML="<a href='#'><\/a>",n.firstChild&&typeof n.firstChild.getAttribute!==y&&n.firstChild.getAttribute("href")==="#"})?{}:{href:function(n){return n.getAttribute("href",2)},type:function(n){return n.getAttribute("type")}},o.getIdNotName?(r.find.ID=function(n,t){if(typeof t.getElementById!==y&&!c){var i=t.getElementById(n);return i&&i.parentNode?[i]:[]}},r.filter.ID=function(n){var t=n.replace(p,w);return function(n){return n.getAttribute("id")===t}}):(r.find.ID=function(n,i){if(typeof i.getElementById!==y&&!c){var r=i.getElementById(n);return r?r.id===n||typeof r.getAttributeNode!==y&&r.getAttributeNode("id").value===n?[r]:t:[]}},r.filter.ID=function(n){var t=n.replace(p,w);return function(n){var i=typeof n.getAttributeNode!==y&&n.getAttributeNode("id");return i&&i.value===t}}),r.find.TAG=o.tagNameNoComments?function(n,t){if(typeof t.getElementsByTagName!==y)return t.getElementsByTagName(n)}:function(n,t){var i,r=[],f=0,u=t.getElementsByTagName(n);if(n==="*"){while(i=u[f++])i.nodeType===1&&r.push(i);return r}return u},r.find.NAME=o.getByName&&function(n,t){if(typeof t.getElementsByName!==y)return t.getElementsByName(name)},r.find.CLASS=o.getByClassName&&function(n,t){if(typeof t.getElementsByClassName!==y&&!c)return t.getElementsByClassName(n)},rt=[],a=[":focus"],(o.qsa=ti(i.querySelectorAll))&&(b(function(n){n.innerHTML="<select><option selected=''><\/option><\/select>",n.querySelectorAll("[selected]").length||a.push("\\["+e+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),n.querySelectorAll(":checked").length||a.push(":checked")}),b(function(n){n.innerHTML="<input type='hidden' i=''/>",n.querySelectorAll("[i^='']").length&&a.push("[*^$]="+e+"*(?:\"\"|'')"),n.querySelectorAll(":enabled").length||a.push(":enabled",":disabled"),n.querySelectorAll("*,:x"),a.push(",.*:")})),(o.matchesSelector=ti(ct=h.matchesSelector||h.mozMatchesSelector||h.webkitMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&b(function(n){o.disconnectedMatch=ct.call(n,"div"),ct.call(n,"[s!='']:x"),rt.push("!=",gt)}),a=new RegExp(a.join("|")),rt=new RegExp(rt.join("|")),et=ti(h.contains)||h.compareDocumentPosition?function(n,t){var r=n.nodeType===9?n.documentElement:n,i=t&&t.parentNode;return n===i||!!(i&&i.nodeType===1&&(r.contains?r.contains(i):n.compareDocumentPosition&&n.compareDocumentPosition(i)&16))}:function(n,t){if(t)while(t=t.parentNode)if(t===n)return!0;return!1},kt=h.compareDocumentPosition?function(n,t){var r;return n===t?(tt=!0,0):(r=t.compareDocumentPosition&&n.compareDocumentPosition&&n.compareDocumentPosition(t))?r&1||n.parentNode&&n.parentNode.nodeType===11?n===i||et(k,n)?-1:t===i||et(k,t)?1:0:r&4?-1:1:n.compareDocumentPosition?-1:1}:function(n,t){var r,u=0,o=n.parentNode,s=t.parentNode,f=[n],e=[t];if(n===t)return tt=!0,0;if(o&&s){if(o===s)return yi(n,t)}else return n===i?-1:t===i?1:o?-1:s?1:0;for(r=n;r=r.parentNode;)f.unshift(r);for(r=t;r=r.parentNode;)e.unshift(r);while(f[u]===e[u])u++;return u?yi(f[u],e[u]):f[u]===k?-1:e[u]===k?1:0},tt=!1,[0,0].sort(kt),o.detectDuplicates=tt,s)},u.matches=function(n,t){return u(n,null,null,t)},u.matchesSelector=function(n,t){if((n.ownerDocument||n)!==s&&it(n),t=t.replace(er,"='$1']"),o.matchesSelector&&!c&&(!rt||!rt.test(t))&&!a.test(t))try{var i=ct.call(n,t);if(i||o.disconnectedMatch||n.document&&n.document.nodeType!==11)return i}catch(r){}return u(t,s,null,[n]).length>0},u.contains=function(n,t){return(n.ownerDocument||n)!==s&&it(n),et(n,t)},u.attr=function(n,t){var i;return((n.ownerDocument||n)!==s&&it(n),c||(t=t.toLowerCase()),i=r.attrHandle[t])?i(n):c||o.attributes?n.getAttribute(t):((i=n.getAttributeNode(t))||n.getAttribute(t))&&n[t]===!0?t:i&&i.specified?i.value:null},u.error=function(n){throw new Error("Syntax error, unrecognized expression: "+n);},u.uniqueSort=function(n){var r,u=[],t=1,i=0;if(tt=!o.detectDuplicates,n.sort(kt),tt){for(;r=n[t];t++)r===n[t-1]&&(i=u.push(t));while(i--)n.splice(u[i],1)}return n},st=u.getText=function(n){var r,i="",u=0,t=n.nodeType;if(t){if(t===1||t===9||t===11){if(typeof n.textContent=="string")return n.textContent;for(n=n.firstChild;n;n=n.nextSibling)i+=st(n)}else if(t===3||t===4)return n.nodeValue}else for(;r=n[u];u++)i+=st(r);return i},r=u.selectors={cacheLength:50,createPseudo:l,match:vt,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(n){return n[1]=n[1].replace(p,w),n[3]=(n[4]||n[5]||"").replace(p,w),n[2]==="~="&&(n[3]=" "+n[3]+" "),n.slice(0,4)},CHILD:function(n){return n[1]=n[1].toLowerCase(),n[1].slice(0,3)==="nth"?(n[3]||u.error(n[0]),n[4]=+(n[4]?n[5]+(n[6]||1):2*(n[3]==="even"||n[3]==="odd")),n[5]=+(n[7]+n[8]||n[3]==="odd")):n[3]&&u.error(n[0]),n},PSEUDO:function(n){var i,t=!n[5]&&n[2];return vt.CHILD.test(n[0])?null:(n[4]?n[2]=n[4]:t&&gi.test(t)&&(i=yt(t,!0))&&(i=t.indexOf(")",t.length-i)-t.length)&&(n[0]=n[0].slice(0,i),n[2]=t.slice(0,i)),n.slice(0,3))}},filter:{TAG:function(n){return n==="*"?function(){return!0}:(n=n.replace(p,w).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===n})},CLASS:function(n){var t=si[n+" "];return t||(t=new RegExp("(^|"+e+")"+n+"("+e+"|$)"))&&si(n,function(n){return t.test(n.className||typeof n.getAttribute!==y&&n.getAttribute("class")||"")})},ATTR:function(n,t,i){return function(r){var f=u.attr(r,n);return f==null?t==="!=":t?(f+="",t==="="?f===i:t==="!="?f!==i:t==="^="?i&&f.indexOf(i)===0:t==="*="?i&&f.indexOf(i)>-1:t==="$="?i&&f.slice(-i.length)===i:t==="~="?(" "+f+" ").indexOf(i)>-1:t==="|="?f===i||f.slice(0,i.length+1)===i+"-":!1):!0}},CHILD:function(n,t,i,r,u){var s=n.slice(0,3)!=="nth",o=n.slice(-4)!=="last",e=t==="of-type";return r===1&&u===0?function(n){return!!n.parentNode}:function(t,i,h){var a,k,c,l,y,w,b=s!==o?"nextSibling":"previousSibling",p=t.parentNode,g=e&&t.nodeName.toLowerCase(),d=!h&&!e;if(p){if(s){while(b){for(c=t;c=c[b];)if(e?c.nodeName.toLowerCase()===g:c.nodeType===1)return!1;w=b=n==="only"&&!w&&"nextSibling"}return!0}if(w=[o?p.firstChild:p.lastChild],o&&d){for(k=p[f]||(p[f]={}),a=k[n]||[],y=a[0]===v&&a[1],l=a[0]===v&&a[2],c=y&&p.childNodes[y];c=++y&&c&&c[b]||(l=y=0)||w.pop();)if(c.nodeType===1&&++l&&c===t){k[n]=[v,y,l];break}}else if(d&&(a=(t[f]||(t[f]={}))[n])&&a[0]===v)l=a[1];else while(c=++y&&c&&c[b]||(l=y=0)||w.pop())if((e?c.nodeName.toLowerCase()===g:c.nodeType===1)&&++l&&(d&&((c[f]||(c[f]={}))[n]=[v,l]),c===t))break;return l-=u,l===r||l%r==0&&l/r>=0}}},PSEUDO:function(n,t){var e,i=r.pseudos[n]||r.setFilters[n.toLowerCase()]||u.error("unsupported pseudo: "+n);return i[f]?i(t):i.length>1?(e=[n,n,"",t],r.setFilters.hasOwnProperty(n.toLowerCase())?l(function(n,r){for(var u,f=i(n,t),e=f.length;e--;)u=dt.call(n,f[e]),n[u]=!(r[u]=f[e])}):function(n){return i(n,0,e)}):i}},pseudos:{not:l(function(n){var i=[],r=[],t=bt(n.replace(at,"$1"));return t[f]?l(function(n,i,r,u){for(var e,o=t(n,null,u,[]),f=n.length;f--;)(e=o[f])&&(n[f]=!(i[f]=e))}):function(n,u,f){return i[0]=n,t(i,null,f,r),!r.pop()}}),has:l(function(n){return function(t){return u(n,t).length>0}}),contains:l(function(n){return function(t){return(t.textContent||t.innerText||st(t)).indexOf(n)>-1}}),lang:l(function(n){return nr.test(n||"")||u.error("unsupported lang: "+n),n=n.replace(p,w).toLowerCase(),function(t){var i;do if(i=c?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return i=i.toLowerCase(),i===n||i.indexOf(n+"-")===0;while((t=t.parentNode)&&t.nodeType===1);return!1}}),target:function(t){var i=n.location&&n.location.hash;return i&&i.slice(1)===t.id},root:function(n){return n===h},focus:function(n){return n===s.activeElement&&(!s.hasFocus||s.hasFocus())&&!!(n.type||n.href||~n.tabIndex)},enabled:function(n){return n.disabled===!1},disabled:function(n){return n.disabled===!0},checked:function(n){var t=n.nodeName.toLowerCase();return t==="input"&&!!n.checked||t==="option"&&!!n.selected},selected:function(n){return n.parentNode&&n.parentNode.selectedIndex,n.selected===!0},empty:function(n){for(n=n.firstChild;n;n=n.nextSibling)if(n.nodeName>"@"||n.nodeType===3||n.nodeType===4)return!1;return!0},parent:function(n){return!r.pseudos.empty(n)},header:function(n){return ur.test(n.nodeName)},input:function(n){return rr.test(n.nodeName)},button:function(n){var t=n.nodeName.toLowerCase();return t==="input"&&n.type==="button"||t==="button"},text:function(n){var t;return n.nodeName.toLowerCase()==="input"&&n.type==="text"&&((t=n.getAttribute("type"))==null||t.toLowerCase()===n.type)},first:g(function(){return[0]}),last:g(function(n,t){return[t-1]}),eq:g(function(n,t,i){return[i<0?i+t:i]}),even:g(function(n,t){for(var i=0;i<t;i+=2)n.push(i);return n}),odd:g(function(n,t){for(var i=1;i<t;i+=2)n.push(i);return n}),lt:g(function(n,t,i){for(var r=i<0?i+t:i;--r>=0;)n.push(r);return n}),gt:g(function(n,t,i){for(var r=i<0?i+t:i;++r<t;)n.push(r);return n})}};for(nt in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[nt]=or(nt);for(nt in{submit:!0,reset:!0})r.pseudos[nt]=sr(nt);bt=u.compile=function(n,t){var r,u=[],e=[],i=ci[n+" "];if(!i){for(t||(t=yt(n)),r=t.length;r--;)i=ei(t[r]),i[f]?u.push(i):e.push(i);i=ci(n,hr(e,u))}return i},r.pseudos.nth=r.pseudos.eq,r.filters=pi.prototype=r.pseudos,r.setFilters=new pi,it(),u.attr=i.attr,i.find=u,i.expr=u.selectors,i.expr[":"]=i.expr.pseudos,i.unique=u.uniqueSort,i.text=u.getText,i.isXMLDoc=u.isXML,i.contains=u.contains})(n);var re=/Until$/,ue=/^(?:parents|prev(?:Until|All))/,fe=/^.[^:#\[\.,]*$/,hr=i.expr.match.needsContext,ee={children:!0,contents:!0,next:!0,prev:!0};i.fn.extend({find:function(n){var t,r,f,u=this.length;if(typeof n!="string")return f=this,this.pushStack(i(n).filter(function(){for(t=0;t<u;t++)if(i.contains(f[t],this))return!0}));for(r=[],t=0;t<u;t++)i.find(n,this[t],r);return r=this.pushStack(u>1?i.unique(r):r),r.selector=(this.selector?this.selector+" ":"")+n,r},has:function(n){var t,r=i(n,this),u=r.length;return this.filter(function(){for(t=0;t<u;t++)if(i.contains(this,r[t]))return!0})},not:function(n){return this.pushStack(lr(this,n,!1))},filter:function(n){return this.pushStack(lr(this,n,!0))},is:function(n){return!!n&&(typeof n=="string"?hr.test(n)?i(n,this.context).index(this[0])>=0:i.filter(n,this).length>0:this.filter(n).length>0)},closest:function(n,t){for(var r,f=0,o=this.length,u=[],e=hr.test(n)||typeof n!="string"?i(n,t||this.context):0;f<o;f++)for(r=this[f];r&&r.ownerDocument&&r!==t&&r.nodeType!==11;){if(e?e.index(r)>-1:i.find.matchesSelector(r,n)){u.push(r);break}r=r.parentNode}return this.pushStack(u.length>1?i.unique(u):u)},index:function(n){return n?typeof n=="string"?i.inArray(this[0],i(n)):i.inArray(n.jquery?n[0]:n,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(n,t){var r=typeof n=="string"?i(n,t):i.makeArray(n&&n.nodeType?[n]:n),u=i.merge(this.get(),r);return this.pushStack(i.unique(u))},addBack:function(n){return this.add(n==null?this.prevObject:this.prevObject.filter(n))}}),i.fn.andSelf=i.fn.addBack,i.each({parent:function(n){var t=n.parentNode;return t&&t.nodeType!==11?t:null},parents:function(n){return i.dir(n,"parentNode")},parentsUntil:function(n,t,r){return i.dir(n,"parentNode",r)},next:function(n){return cr(n,"nextSibling")},prev:function(n){return cr(n,"previousSibling")},nextAll:function(n){return i.dir(n,"nextSibling")},prevAll:function(n){return i.dir(n,"previousSibling")},nextUntil:function(n,t,r){return i.dir(n,"nextSibling",r)},prevUntil:function(n,t,r){return i.dir(n,"previousSibling",r)},siblings:function(n){return i.sibling((n.parentNode||{}).firstChild,n)},children:function(n){return i.sibling(n.firstChild)},contents:function(n){return i.nodeName(n,"iframe")?n.contentDocument||n.contentWindow.document:i.merge([],n.childNodes)}},function(n,t){i.fn[n]=function(r,u){var f=i.map(this,t,r);return re.test(n)||(u=r),u&&typeof u=="string"&&(f=i.filter(u,f)),f=this.length>1&&!ee[n]?i.unique(f):f,this.length>1&&ue.test(n)&&(f=f.reverse()),this.pushStack(f)}}),i.extend({filter:function(n,t,r){return r&&(n=":not("+n+")"),t.length===1?i.find.matchesSelector(t[0],n)?[t[0]]:[]:i.find.matches(n,t)},dir:function(n,r,u){for(var e=[],f=n[r];f&&f.nodeType!==9&&(u===t||f.nodeType!==1||!i(f).is(u));)f.nodeType===1&&e.push(f),f=f[r];return e},sibling:function(n,t){for(var i=[];n;n=n.nextSibling)n.nodeType===1&&n!==t&&i.push(n);return i}});var vr="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",oe=/ jQuery\d+="(?:null|\d+)"/g,yr=new RegExp("<(?:"+vr+")[\\s/>]","i"),fi=/^\s+/,pr=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,wr=/<([\w:]+)/,br=/<tbody/i,se=/<|&#?\w+;/,he=/<(?:script|style|link)/i,ei=/^(?:checkbox|radio)$/i,ce=/checked\s*(?:[^=]|=\s*.checked.)/i,kr=/^$|\/(?:java|ecma)script/i,le=/^true\/(.*)/,ae=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,e={option:[1,"<select multiple='multiple'>","<\/select>"],legend:[1,"<fieldset>","<\/fieldset>"],area:[1,"<map>","<\/map>"],param:[1,"<object>","<\/object>"],thead:[1,"<table>","<\/table>"],tr:[2,"<table><tbody>","<\/tbody><\/table>"],col:[2,"<table><tbody><\/tbody><colgroup>","<\/colgroup><\/table>"],td:[3,"<table><tbody><tr>","<\/tr><\/tbody><\/table>"],_default:i.support.htmlSerialize?[0,"",""]:[1,"X<div>","<\/div>"]},ve=ar(r),oi=ve.appendChild(r.createElement("div"));e.optgroup=e.option,e.tbody=e.tfoot=e.colgroup=e.caption=e.thead,e.th=e.td,i.fn.extend({text:function(n){return i.access(this,function(n){return n===t?i.text(this):this.empty().append((this[0]&&this[0].ownerDocument||r).createTextNode(n))},null,n,arguments.length)},wrapAll:function(n){if(i.isFunction(n))return this.each(function(t){i(this).wrapAll(n.call(this,t))});if(this[0]){var t=i(n,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var n=this;n.firstChild&&n.firstChild.nodeType===1;)n=n.firstChild;return n}).append(this)}return this},wrapInner:function(n){return i.isFunction(n)?this.each(function(t){i(this).wrapInner(n.call(this,t))}):this.each(function(){var t=i(this),r=t.contents();r.length?r.wrapAll(n):t.append(n)})},wrap:function(n){var t=i.isFunction(n);return this.each(function(r){i(this).wrapAll(t?n.call(this,r):n)})},unwrap:function(){return this.parent().each(function(){i.nodeName(this,"body")||i(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(n){(this.nodeType===1||this.nodeType===11||this.nodeType===9)&&this.appendChild(n)})},prepend:function(){return this.domManip(arguments,!0,function(n){(this.nodeType===1||this.nodeType===11||this.nodeType===9)&&this.insertBefore(n,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(n){this.parentNode&&this.parentNode.insertBefore(n,this)})},after:function(){return this.domManip(arguments,!1,function(n){this.parentNode&&this.parentNode.insertBefore(n,this.nextSibling)})},remove:function(n,t){for(var r,f=0;(r=this[f])!=null;f++)(!n||i.filter(n,[r]).length>0)&&(t||r.nodeType!==1||i.cleanData(u(r)),r.parentNode&&(t&&i.contains(r.ownerDocument,r)&&si(u(r,"script")),r.parentNode.removeChild(r)));return this},empty:function(){for(var n,t=0;(n=this[t])!=null;t++){for(n.nodeType===1&&i.cleanData(u(n,!1));n.firstChild;)n.removeChild(n.firstChild);n.options&&i.nodeName(n,"select")&&(n.options.length=0)}return this},clone:function(n,t){return n=n==null?!1:n,t=t==null?n:t,this.map(function(){return i.clone(this,n,t)})},html:function(n){return i.access(this,function(n){var r=this[0]||{},f=0,o=this.length;if(n===t)return r.nodeType===1?r.innerHTML.replace(oe,""):t;if(typeof n=="string"&&!he.test(n)&&(i.support.htmlSerialize||!yr.test(n))&&(i.support.leadingWhitespace||!fi.test(n))&&!e[(wr.exec(n)||["",""])[1].toLowerCase()]){n=n.replace(pr,"<$1><\/$2>");try{for(;f<o;f++)r=this[f]||{},r.nodeType===1&&(i.cleanData(u(r,!1)),r.innerHTML=n);r=0}catch(s){}}r&&this.empty().append(n)},null,n,arguments.length)},replaceWith:function(n){var t=i.isFunction(n);return t||typeof n=="string"||(n=i(n).not(this).detach()),this.domManip([n],!0,function(n){var r=this.nextSibling,t=this.parentNode;t&&(i(this).remove(),t.insertBefore(n,r))})},detach:function(n){return this.remove(n,!0)},domManip:function(n,r,f){n=bi.apply([],n);var c,e,l,s,y,h,o=0,a=this.length,w=this,b=a-1,v=n[0],p=i.isFunction(v);if(p||!(a<=1||typeof v!="string"||i.support.checkClone||!ce.test(v)))return this.each(function(i){var u=w.eq(i);p&&(n[0]=v.call(this,i,r?u.html():t)),u.domManip(n,r,f)});if(a&&(h=i.buildFragment(n,this[0].ownerDocument,!1,this),c=h.firstChild,h.childNodes.length===1&&(h=c),c)){for(r=r&&i.nodeName(c,"tr"),s=i.map(u(h,"script"),dr),l=s.length;o<a;o++)e=h,o!==b&&(e=i.clone(e,!0,!0),l&&i.merge(s,u(e,"script"))),f.call(r&&i.nodeName(this[o],"table")?ye(this[o],"tbody"):this[o],e,o);if(l)for(y=s[s.length-1].ownerDocument,i.map(s,gr),o=0;o<l;o++)e=s[o],kr.test(e.type||"")&&!i._data(e,"globalEval")&&i.contains(y,e)&&(e.src?i.ajax({url:e.src,type:"GET",dataType:"script",async:!1,global:!1,throws:!0}):i.globalEval((e.text||e.textContent||e.innerHTML||"").replace(ae,"")));h=c=null}return this}}),i.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(n,t){i.fn[n]=function(n){for(var u,r=0,f=[],e=i(n),o=e.length-1;r<=o;r++)u=r===o?this:this.clone(!0),i(e[r])[t](u),bt.apply(f,u.get());return this.pushStack(f)}}),i.extend({clone:function(n,t,r){var f,h,o,e,s,c=i.contains(n.ownerDocument,n);if(i.support.html5Clone||i.isXMLDoc(n)||!yr.test("<"+n.nodeName+">")?o=n.cloneNode(!0):(oi.innerHTML=n.outerHTML,oi.removeChild(o=oi.firstChild)),(!i.support.noCloneEvent||!i.support.noCloneChecked)&&(n.nodeType===1||n.nodeType===11)&&!i.isXMLDoc(n))for(f=u(o),s=u(n),e=0;(h=s[e])!=null;++e)f[e]&&pe(h,f[e]);if(t)if(r)for(s=s||u(n),f=f||u(o),e=0;(h=s[e])!=null;e++)nu(h,f[e]);else nu(n,o);return f=u(o,"script"),f.length>0&&si(f,!c&&u(n,"script")),f=s=h=null,o},buildFragment:function(n,t,r,f){for(var h,o,w,s,y,p,l,b=n.length,a=ar(t),c=[],v=0;v<b;v++)if(o=n[v],o||o===0)if(i.type(o)==="object")i.merge(c,o.nodeType?[o]:o);else if(se.test(o)){for(s=s||a.appendChild(t.createElement("div")),y=(wr.exec(o)||["",""])[1].toLowerCase(),l=e[y]||e._default,s.innerHTML=l[1]+o.replace(pr,"<$1><\/$2>")+l[2],h=l[0];h--;)s=s.lastChild;if(!i.support.leadingWhitespace&&fi.test(o)&&c.push(t.createTextNode(fi.exec(o)[0])),!i.support.tbody)for(o=y==="table"&&!br.test(o)?s.firstChild:l[1]==="<table>"&&!br.test(o)?s:0,h=o&&o.childNodes.length;h--;)i.nodeName(p=o.childNodes[h],"tbody")&&!p.childNodes.length&&o.removeChild(p);for(i.merge(c,s.childNodes),s.textContent="";s.firstChild;)s.removeChild(s.firstChild);s=a.lastChild}else c.push(t.createTextNode(o));for(s&&a.removeChild(s),i.support.appendChecked||i.grep(u(c,"input"),we),v=0;o=c[v++];)if((!f||i.inArray(o,f)===-1)&&(w=i.contains(o.ownerDocument,o),s=u(a.appendChild(o),"script"),w&&si(s),r))for(h=0;o=s[h++];)kr.test(o.type||"")&&r.push(o);return s=null,a},cleanData:function(n,t){for(var r,e,u,f,c=0,s=i.expando,h=i.cache,l=i.support.deleteExpando,a=i.event.special;(r=n[c])!=null;c++)if((t||i.acceptData(r))&&(u=r[s],f=u&&h[u],f)){if(f.events)for(e in f.events)a[e]?i.event.remove(r,e):i.removeEvent(r,e,f.handle);h[u]&&(delete h[u],l?delete r[s]:typeof r.removeAttribute!==o?r.removeAttribute(s):r[s]=null,b.push(u))}}});var rt,v,y,hi=/alpha\([^)]*\)/i,be=/opacity\s*=\s*([^)]*)/,ke=/^(top|right|bottom|left)$/,de=/^(none|table(?!-c[ea]).+)/,tu=/^margin/,ge=new RegExp("^("+st+")(.*)$","i"),ct=new RegExp("^("+st+")(?!px)[a-z%]+$","i"),no=new RegExp("^([+-])=("+st+")","i"),iu={BODY:"block"},to={position:"absolute",visibility:"hidden",display:"block"},ru={letterSpacing:0,fontWeight:400},p=["Top","Right","Bottom","Left"],uu=["Webkit","O","Moz","ms"];i.fn.extend({css:function(n,r){return i.access(this,function(n,r,u){var e,o,s={},f=0;if(i.isArray(r)){for(o=v(n),e=r.length;f<e;f++)s[r[f]]=i.css(n,r[f],!1,o);return s}return u!==t?i.style(n,r,u):i.css(n,r)},n,r,arguments.length>1)},show:function(){return eu(this,!0)},hide:function(){return eu(this)},toggle:function(n){var t=typeof n=="boolean";return this.each(function(){(t?n:ut(this))?i(this).show():i(this).hide()})}}),i.extend({cssHooks:{opacity:{get:function(n,t){if(t){var i=y(n,"opacity");return i===""?"1":i}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{float:i.support.cssFloat?"cssFloat":"styleFloat"},style:function(n,r,u,f){if(n&&n.nodeType!==3&&n.nodeType!==8&&n.style){var o,s,e,h=i.camelCase(r),c=n.style;if(r=i.cssProps[h]||(i.cssProps[h]=fu(c,h)),e=i.cssHooks[r]||i.cssHooks[h],u!==t){if(s=typeof u,s==="string"&&(o=no.exec(u))&&(u=(o[1]+1)*o[2]+parseFloat(i.css(n,r)),s="number"),u==null||s==="number"&&isNaN(u))return;if(s!=="number"||i.cssNumber[h]||(u+="px"),i.support.clearCloneStyle||u!==""||r.indexOf("background")!==0||(c[r]="inherit"),!e||!("set"in e)||(u=e.set(n,u,f))!==t)try{c[r]=u}catch(l){}}else return e&&"get"in e&&(o=e.get(n,!1,f))!==t?o:c[r]}},css:function(n,r,u,f){var h,e,o,s=i.camelCase(r);return(r=i.cssProps[s]||(i.cssProps[s]=fu(n.style,s)),o=i.cssHooks[r]||i.cssHooks[s],o&&"get"in o&&(e=o.get(n,!0,u)),e===t&&(e=y(n,r,f)),e==="normal"&&r in ru&&(e=ru[r]),u===""||u)?(h=parseFloat(e),u===!0||i.isNumeric(h)?h||0:e):e},swap:function(n,t,i,r){var f,u,e={};for(u in t)e[u]=n.style[u],n.style[u]=t[u];f=i.apply(n,r||[]);for(u in t)n.style[u]=e[u];return f}}),n.getComputedStyle?(v=function(t){return n.getComputedStyle(t,null)},y=function(n,r,u){var s,h,c,o=u||v(n),e=o?o.getPropertyValue(r)||o[r]:t,f=n.style;return o&&(e!==""||i.contains(n.ownerDocument,n)||(e=i.style(n,r)),ct.test(e)&&tu.test(r)&&(s=f.width,h=f.minWidth,c=f.maxWidth,f.minWidth=f.maxWidth=f.width=e,e=o.width,f.width=s,f.minWidth=h,f.maxWidth=c)),e}):r.documentElement.currentStyle&&(v=function(n){return n.currentStyle},y=function(n,i,r){var s,e,o,h=r||v(n),u=h?h[i]:t,f=n.style;return u==null&&f&&f[i]&&(u=f[i]),ct.test(u)&&!ke.test(i)&&(s=f.left,e=n.runtimeStyle,o=e&&e.left,o&&(e.left=n.currentStyle.left),f.left=i==="fontSize"?"1em":u,u=f.pixelLeft+"px",f.left=s,o&&(e.left=o)),u===""?"auto":u}),i.each(["height","width"],function(n,t){i.cssHooks[t]={get:function(n,r,u){if(r)return n.offsetWidth===0&&de.test(i.css(n,"display"))?i.swap(n,to,function(){return hu(n,t,u)}):hu(n,t,u)},set:function(n,r,u){var f=u&&v(n);return ou(n,r,u?su(n,t,u,i.support.boxSizing&&i.css(n,"boxSizing",!1,f)==="border-box",f):0)}}}),i.support.opacity||(i.cssHooks.opacity={get:function(n,t){return be.test((t&&n.currentStyle?n.currentStyle.filter:n.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(n,t){var r=n.style,u=n.currentStyle,e=i.isNumeric(t)?"alpha(opacity="+t*100+")":"",f=u&&u.filter||r.filter||"";(r.zoom=1,(t>=1||t==="")&&i.trim(f.replace(hi,""))===""&&r.removeAttribute&&(r.removeAttribute("filter"),t===""||u&&!u.filter))||(r.filter=hi.test(f)?f.replace(hi,e):f+" "+e)}}),i(function(){i.support.reliableMarginRight||(i.cssHooks.marginRight={get:function(n,t){if(t)return i.swap(n,{display:"inline-block"},y,[n,"marginRight"])}}),!i.support.pixelPosition&&i.fn.position&&i.each(["top","left"],function(n,t){i.cssHooks[t]={get:function(n,r){if(r)return r=y(n,t),ct.test(r)?i(n).position()[t]+"px":r}}})}),i.expr&&i.expr.filters&&(i.expr.filters.hidden=function(n){return n.offsetWidth<=0&&n.offsetHeight<=0||!i.support.reliableHiddenOffsets&&(n.style&&n.style.display||i.css(n,"display"))==="none"},i.expr.filters.visible=function(n){return!i.expr.filters.hidden(n)}),i.each({margin:"",padding:"",border:"Width"},function(n,t){i.cssHooks[n+t]={expand:function(i){for(var r=0,f={},u=typeof i=="string"?i.split(" "):[i];r<4;r++)f[n+p[r]+t]=u[r]||u[r-2]||u[0];return f}},tu.test(n)||(i.cssHooks[n+t].set=ou)});var io=/%20/g,ro=/\[\]$/,au=/\r?\n/g,uo=/^(?:submit|button|image|reset|file)$/i,fo=/^(?:input|select|textarea|keygen)/i;i.fn.extend({serialize:function(){return i.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var n=i.prop(this,"elements");return n?i.makeArray(n):this}).filter(function(){var n=this.type;return this.name&&!i(this).is(":disabled")&&fo.test(this.nodeName)&&!uo.test(n)&&(this.checked||!ei.test(n))}).map(function(n,t){var r=i(this).val();return r==null?null:i.isArray(r)?i.map(r,function(n){return{name:t.name,value:n.replace(au,"\r\n")}}):{name:t.name,value:r.replace(au,"\r\n")}}).get()}}),i.param=function(n,r){var u,f=[],e=function(n,t){t=i.isFunction(t)?t():t==null?"":t,f[f.length]=encodeURIComponent(n)+"="+encodeURIComponent(t)};if(r===t&&(r=i.ajaxSettings&&i.ajaxSettings.traditional),i.isArray(n)||n.jquery&&!i.isPlainObject(n))i.each(n,function(){e(this.name,this.value)});else for(u in n)ci(u,n[u],r,e);return f.join("&").replace(io,"+")},i.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(n,t){i.fn[t]=function(n,i){return arguments.length>0?this.on(t,null,n,i):this.trigger(t)}}),i.fn.hover=function(n,t){return this.mouseenter(n).mouseleave(t||n)};var w,c,li=i.now(),ai=/\?/,eo=/#.*$/,vu=/([?&])_=[^&]*/,oo=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,so=/^(?:GET|HEAD)$/,ho=/^\/\//,yu=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,pu=i.fn.load,wu={},vi={},bu="*/".concat("*");try{c=ff.href}catch(go){c=r.createElement("a"),c.href="",c=c.href}w=yu.exec(c.toLowerCase())||[],i.fn.load=function(n,r,u){if(typeof n!="string"&&pu)return pu.apply(this,arguments);var f,s,h,e=this,o=n.indexOf(" ");return o>=0&&(f=n.slice(o,n.length),n=n.slice(0,o)),i.isFunction(r)?(u=r,r=t):r&&typeof r=="object"&&(h="POST"),e.length>0&&i.ajax({url:n,type:h,dataType:"html",data:r}).done(function(n){s=arguments,e.html(f?i("<div>").append(i.parseHTML(n)).find(f):n)}).complete(u&&function(n,t){e.each(u,s||[n.responseText,t,n])}),this},i.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(n,t){i.fn[t]=function(n){return this.on(t,n)}}),i.each(["get","post"],function(n,r){i[r]=function(n,u,f,e){return i.isFunction(u)&&(e=e||f,f=u,u=t),i.ajax({url:n,type:r,dataType:e,data:u,success:f})}}),i.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:c,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(w[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":bu,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":n.String,"text html":!0,"text json":i.parseJSON,"text xml":i.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(n,t){return t?yi(yi(n,i.ajaxSettings),t):yi(i.ajaxSettings,n)},ajaxPrefilter:ku(wu),ajaxTransport:ku(vi),ajax:function(n,r){function k(n,r,s,c){var l,k,w,rt,p,a=r;o!==2&&(o=2,g&&clearTimeout(g),v=t,d=c||"",f.readyState=n>0?4:0,s&&(rt=co(u,f,s)),n>=200&&n<300||n===304?(u.ifModified&&(p=f.getResponseHeader("Last-Modified"),p&&(i.lastModified[e]=p),p=f.getResponseHeader("etag"),p&&(i.etag[e]=p)),n===204?(l=!0,a="nocontent"):n===304?(l=!0,a="notmodified"):(l=lo(u,rt),a=l.state,k=l.data,w=l.error,l=!w)):(w=a,(n||!a)&&(a="error",n<0&&(n=0))),f.status=n,f.statusText=(r||a)+"",l?tt.resolveWith(h,[k,a,f]):tt.rejectWith(h,[f,a,w]),f.statusCode(b),b=t,y&&nt.trigger(l?"ajaxSuccess":"ajaxError",[f,u,l?k:w]),it.fireWith(h,[f,a]),y&&(nt.trigger("ajaxComplete",[f,u]),--i.active||i.event.trigger("ajaxStop")))}typeof n=="object"&&(r=n,n=t),r=r||{};var l,a,e,d,g,y,v,p,u=i.ajaxSetup({},r),h=u.context||u,nt=u.context&&(h.nodeType||h.jquery)?i(h):i.event,tt=i.Deferred(),it=i.Callbacks("once memory"),b=u.statusCode||{},rt={},ut={},o=0,ft="canceled",f={readyState:0,getResponseHeader:function(n){var t;if(o===2){if(!p)for(p={};t=oo.exec(d);)p[t[1].toLowerCase()]=t[2];t=p[n.toLowerCase()]}return t==null?null:t},getAllResponseHeaders:function(){return o===2?d:null},setRequestHeader:function(n,t){var i=n.toLowerCase();return o||(n=ut[i]=ut[i]||n,rt[n]=t),this},overrideMimeType:function(n){return o||(u.mimeType=n),this},statusCode:function(n){var t;if(n)if(o<2)for(t in n)b[t]=[b[t],n[t]];else f.always(n[f.status]);return this},abort:function(n){var t=n||ft;return v&&v.abort(t),k(0,t),this}};if(tt.promise(f).complete=it.add,f.success=f.done,f.error=f.fail,u.url=((n||u.url||c)+"").replace(eo,"").replace(ho,w[1]+"//"),u.type=r.method||r.type||u.method||u.type,u.dataTypes=i.trim(u.dataType||"*").toLowerCase().match(s)||[""],u.crossDomain==null&&(l=yu.exec(u.url.toLowerCase()),u.crossDomain=!!(l&&(l[1]!==w[1]||l[2]!==w[2]||(l[3]||(l[1]==="http:"?80:443))!=(w[3]||(w[1]==="http:"?80:443))))),u.data&&u.processData&&typeof u.data!="string"&&(u.data=i.param(u.data,u.traditional)),du(wu,u,r,f),o===2)return f;y=u.global,y&&i.active++==0&&i.event.trigger("ajaxStart"),u.type=u.type.toUpperCase(),u.hasContent=!so.test(u.type),e=u.url,u.hasContent||(u.data&&(e=u.url+=(ai.test(e)?"&":"?")+u.data,delete u.data),u.cache===!1&&(u.url=vu.test(e)?e.replace(vu,"$1_="+li++):e+(ai.test(e)?"&":"?")+"_="+li++)),u.ifModified&&(i.lastModified[e]&&f.setRequestHeader("If-Modified-Since",i.lastModified[e]),i.etag[e]&&f.setRequestHeader("If-None-Match",i.etag[e])),(u.data&&u.hasContent&&u.contentType!==!1||r.contentType)&&f.setRequestHeader("Content-Type",u.contentType),f.setRequestHeader("Accept",u.dataTypes[0]&&u.accepts[u.dataTypes[0]]?u.accepts[u.dataTypes[0]]+(u.dataTypes[0]!=="*"?", "+bu+"; q=0.01":""):u.accepts["*"]);for(a in u.headers)f.setRequestHeader(a,u.headers[a]);if(u.beforeSend&&(u.beforeSend.call(h,f,u)===!1||o===2))return f.abort();ft="abort";for(a in{success:1,error:1,complete:1})f[a](u[a]);if(v=du(vi,u,r,f),v){f.readyState=1,y&&nt.trigger("ajaxSend",[f,u]),u.async&&u.timeout>0&&(g=setTimeout(function(){f.abort("timeout")},u.timeout));try{o=1,v.send(rt,k)}catch(et){if(o<2)k(-1,et);else throw et;}}else k(-1,"No Transport");return f},getScript:function(n,r){return i.get(n,t,r,"script")},getJSON:function(n,t,r){return i.get(n,t,r,"json")}}),i.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(n){return i.globalEval(n),n}}}),i.ajaxPrefilter("script",function(n){n.cache===t&&(n.cache=!1),n.crossDomain&&(n.type="GET",n.global=!1)}),i.ajaxTransport("script",function(n){if(n.crossDomain){var u,f=r.head||i("head")[0]||r.documentElement;return{send:function(t,i){u=r.createElement("script"),u.async=!0,n.scriptCharset&&(u.charset=n.scriptCharset),u.src=n.url,u.onload=u.onreadystatechange=function(n,t){(t||!u.readyState||/loaded|complete/.test(u.readyState))&&(u.onload=u.onreadystatechange=null,u.parentNode&&u.parentNode.removeChild(u),u=null,t||i(200,"success"))},f.insertBefore(u,f.firstChild)},abort:function(){if(u)u.onload(t,!0)}}}}),pi=[],lt=/(=)\?(?=&|$)|\?\?/,i.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var n=pi.pop()||i.expando+"_"+li++;return this[n]=!0,n}}),i.ajaxPrefilter("json jsonp",function(r,u,f){var e,s,o,h=r.jsonp!==!1&&(lt.test(r.url)?"url":typeof r.data=="string"&&!(r.contentType||"").indexOf("application/x-www-form-urlencoded")&&lt.test(r.data)&&"data");if(h||r.dataTypes[0]==="jsonp")return e=r.jsonpCallback=i.isFunction(r.jsonpCallback)?r.jsonpCallback():r.jsonpCallback,h?r[h]=r[h].replace(lt,"$1"+e):r.jsonp!==!1&&(r.url+=(ai.test(r.url)?"&":"?")+r.jsonp+"="+e),r.converters["script json"]=function(){return o||i.error(e+" was not called"),o[0]},r.dataTypes[0]="json",s=n[e],n[e]=function(){o=arguments},f.always(function(){n[e]=s,r[e]&&(r.jsonpCallback=u.jsonpCallback,pi.push(e)),o&&i.isFunction(s)&&s(o[0]),o=s=t}),"script"}),gu=0,at=n.ActiveXObject&&function(){var n;for(n in g)g[n](t,!0)},i.ajaxSettings.xhr=n.ActiveXObject?function(){return!this.isLocal&&nf()||ao()}:nf,nt=i.ajaxSettings.xhr(),i.support.cors=!!nt&&"withCredentials"in nt,nt=i.support.ajax=!!nt,nt&&i.ajaxTransport(function(r){if(!r.crossDomain||i.support.cors){var u;return{send:function(f,e){var h,s,o=r.xhr();if(r.username?o.open(r.type,r.url,r.async,r.username,r.password):o.open(r.type,r.url,r.async),r.xhrFields)for(s in r.xhrFields)o[s]=r.xhrFields[s];r.mimeType&&o.overrideMimeType&&o.overrideMimeType(r.mimeType),r.crossDomain||f["X-Requested-With"]||(f["X-Requested-With"]="XMLHttpRequest");try{for(s in f)o.setRequestHeader(s,f[s])}catch(c){}o.send(r.hasContent&&r.data||null),u=function(n,f){var s,a,l,c;try{if(u&&(f||o.readyState===4))if(u=t,h&&(o.onreadystatechange=i.noop,at&&delete g[h]),f)o.readyState!==4&&o.abort();else{c={},s=o.status,a=o.getAllResponseHeaders(),typeof o.responseText=="string"&&(c.text=o.responseText);try{l=o.statusText}catch(y){l=""}s||!r.isLocal||r.crossDomain?s===1223&&(s=204):s=c.text?200:404}}catch(v){f||e(-1,v)}c&&e(s,l,c,a)},r.async?o.readyState===4?setTimeout(u):(h=++gu,at&&(g||(g={},i(n).unload(at)),g[h]=u),o.onreadystatechange=u):u()},abort:function(){u&&u(t,!0)}}}});var tt,vt,vo=/^(?:toggle|show|hide)$/,yo=new RegExp("^(?:([+-])=|)("+st+")([a-z%]*)$","i"),po=/queueHooks$/,yt=[ko],ft={"*":[function(n,t){var o,s,r=this.createTween(n,t),e=yo.exec(t),h=r.cur(),u=+h||0,f=1,c=20;if(e){if(o=+e[2],s=e[3]||(i.cssNumber[n]?"":"px"),s!=="px"&&u){u=i.css(r.elem,n,!0)||o||1;do f=f||".5",u=u/f,i.style(r.elem,n,u+s);while(f!==(f=r.cur()/h)&&f!==1&&--c)}r.unit=s,r.start=u,r.end=e[1]?u+(e[1]+1)*o:o}return r}]};i.Animation=i.extend(rf,{tweener:function(n,t){i.isFunction(n)?(t=n,n=["*"]):n=n.split(" ");for(var r,u=0,f=n.length;u<f;u++)r=n[u],ft[r]=ft[r]||[],ft[r].unshift(t)},prefilter:function(n,t){t?yt.unshift(n):yt.push(n)}}),i.Tween=f,f.prototype={constructor:f,init:function(n,t,r,u,f,e){this.elem=n,this.prop=r,this.easing=f||"swing",this.options=t,this.start=this.now=this.cur(),this.end=u,this.unit=e||(i.cssNumber[r]?"":"px")},cur:function(){var n=f.propHooks[this.prop];return n&&n.get?n.get(this):f.propHooks._default.get(this)},run:function(n){var t,r=f.propHooks[this.prop];return this.pos=this.options.duration?t=i.easing[this.easing](n,this.options.duration*n,0,1,this.options.duration):t=n,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),r&&r.set?r.set(this):f.propHooks._default.set(this),this}},f.prototype.init.prototype=f.prototype,f.propHooks={_default:{get:function(n){var t;return n.elem[n.prop]!=null&&(!n.elem.style||n.elem.style[n.prop]==null)?n.elem[n.prop]:(t=i.css(n.elem,n.prop,""),!t||t==="auto"?0:t)},set:function(n){i.fx.step[n.prop]?i.fx.step[n.prop](n):n.elem.style&&(n.elem.style[i.cssProps[n.prop]]!=null||i.cssHooks[n.prop])?i.style(n.elem,n.prop,n.now+n.unit):n.elem[n.prop]=n.now}}},f.propHooks.scrollTop=f.propHooks.scrollLeft={set:function(n){n.elem.nodeType&&n.elem.parentNode&&(n.elem[n.prop]=n.now)}},i.each(["toggle","show","hide"],function(n,t){var r=i.fn[t];i.fn[t]=function(n,i,u){return n==null||typeof n=="boolean"?r.apply(this,arguments):this.animate(pt(t,!0),n,i,u)}}),i.fn.extend({fadeTo:function(n,t,i,r){return this.filter(ut).css("opacity",0).show().end().animate({opacity:t},n,i,r)},animate:function(n,t,r,u){var o=i.isEmptyObject(n),e=i.speed(t,r,u),f=function(){var t=rf(this,i.extend({},n),e);f.finish=function(){t.stop(!0)},(o||i._data(this,"finish"))&&t.stop(!0)};return f.finish=f,o||e.queue===!1?this.each(f):this.queue(e.queue,f)},stop:function(n,r,u){var f=function(n){var t=n.stop;delete n.stop,t(u)};return typeof n!="string"&&(u=r,r=n,n=t),r&&n!==!1&&this.queue(n||"fx",[]),this.each(function(){var o=!0,t=n!=null&&n+"queueHooks",e=i.timers,r=i._data(this);if(t)r[t]&&r[t].stop&&f(r[t]);else for(t in r)r[t]&&r[t].stop&&po.test(t)&&f(r[t]);for(t=e.length;t--;)e[t].elem===this&&(n==null||e[t].queue===n)&&(e[t].anim.stop(u),o=!1,e.splice(t,1));(o||!u)&&i.dequeue(this,n)})},finish:function(n){return n!==!1&&(n=n||"fx"),this.each(function(){var t,f=i._data(this),r=f[n+"queue"],e=f[n+"queueHooks"],u=i.timers,o=r?r.length:0;for(f.finish=!0,i.queue(this,n,[]),e&&e.cur&&e.cur.finish&&e.cur.finish.call(this),t=u.length;t--;)u[t].elem===this&&u[t].queue===n&&(u[t].anim.stop(!0),u.splice(t,1));for(t=0;t<o;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete f.finish})}}),i.each({slideDown:pt("show"),slideUp:pt("hide"),slideToggle:pt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(n,t){i.fn[n]=function(n,i,r){return this.animate(t,n,i,r)}}),i.speed=function(n,t,r){var u=n&&typeof n=="object"?i.extend({},n):{complete:r||!r&&t||i.isFunction(n)&&n,duration:n,easing:r&&t||t&&!i.isFunction(t)&&t};return u.duration=i.fx.off?0:typeof u.duration=="number"?u.duration:u.duration in i.fx.speeds?i.fx.speeds[u.duration]:i.fx.speeds._default,(u.queue==null||u.queue===!0)&&(u.queue="fx"),u.old=u.complete,u.complete=function(){i.isFunction(u.old)&&u.old.call(this),u.queue&&i.dequeue(this,u.queue)},u},i.easing={linear:function(n){return n},swing:function(n){return.5-Math.cos(n*Math.PI)/2}},i.timers=[],i.fx=f.prototype.init,i.fx.tick=function(){var u,n=i.timers,r=0;for(tt=i.now();r<n.length;r++)u=n[r],u()||n[r]!==u||n.splice(r--,1);n.length||i.fx.stop(),tt=t},i.fx.timer=function(n){n()&&i.timers.push(n)&&i.fx.start()},i.fx.interval=13,i.fx.start=function(){vt||(vt=setInterval(i.fx.tick,i.fx.interval))},i.fx.stop=function(){clearInterval(vt),vt=null},i.fx.speeds={slow:600,fast:200,_default:400},i.fx.step={},i.expr&&i.expr.filters&&(i.expr.filters.animated=function(n){return i.grep(i.timers,function(t){return n===t.elem}).length}),i.fn.offset=function(n){if(arguments.length)return n===t?this:this.each(function(t){i.offset.setOffset(this,n,t)});var r,e,f={top:0,left:0},u=this[0],s=u&&u.ownerDocument;if(s)return(r=s.documentElement,!i.contains(r,u))?f:(typeof u.getBoundingClientRect!==o&&(f=u.getBoundingClientRect()),e=uf(s),{top:f.top+(e.pageYOffset||r.scrollTop)-(r.clientTop||0),left:f.left+(e.pageXOffset||r.scrollLeft)-(r.clientLeft||0)})},i.offset={setOffset:function(n,t,r){var f=i.css(n,"position");f==="static"&&(n.style.position="relative");var e=i(n),o=e.offset(),l=i.css(n,"top"),a=i.css(n,"left"),v=(f==="absolute"||f==="fixed")&&i.inArray("auto",[l,a])>-1,u={},s={},h,c;v?(s=e.position(),h=s.top,c=s.left):(h=parseFloat(l)||0,c=parseFloat(a)||0),i.isFunction(t)&&(t=t.call(n,r,o)),t.top!=null&&(u.top=t.top-o.top+h),t.left!=null&&(u.left=t.left-o.left+c),"using"in t?t.using.call(n,u):e.css(u)}},i.fn.extend({position:function(){if(this[0]){var n,r,t={top:0,left:0},u=this[0];return i.css(u,"position")==="fixed"?r=u.getBoundingClientRect():(n=this.offsetParent(),r=this.offset(),i.nodeName(n[0],"html")||(t=n.offset()),t.top+=i.css(n[0],"borderTopWidth",!0),t.left+=i.css(n[0],"borderLeftWidth",!0)),{top:r.top-t.top-i.css(u,"marginTop",!0),left:r.left-t.left-i.css(u,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var n=this.offsetParent||r.documentElement;n&&!i.nodeName(n,"html")&&i.css(n,"position")==="static";)n=n.offsetParent;return n||r.documentElement})}}),i.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(n,r){var u=/Y/.test(r);i.fn[n]=function(f){return i.access(this,function(n,f,e){var o=uf(n);if(e===t)return o?r in o?o[r]:o.document.documentElement[f]:n[f];o?o.scrollTo(u?i(o).scrollLeft():e,u?e:i(o).scrollTop()):n[f]=e},n,f,arguments.length,null)}}),i.each({Height:"height",Width:"width"},function(n,r){i.each({padding:"inner"+n,content:r,"":"outer"+n},function(u,f){i.fn[f]=function(f,e){var o=arguments.length&&(u||typeof f!="boolean"),s=u||(f===!0||e===!0?"margin":"border");return i.access(this,function(r,u,f){var e;return i.isWindow(r)?r.document.documentElement["client"+n]:r.nodeType===9?(e=r.documentElement,Math.max(r.body["scroll"+n],e["scroll"+n],r.body["offset"+n],e["offset"+n],e["client"+n])):f===t?i.css(r,u,s):i.style(r,u,f,s)},r,o?f:t,o,null)}})}),n.jQuery=n.$=i,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return i})})(window)
;
// Knockout JavaScript library v2.2.1
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function() {function j(w){throw w;}var m=!0,p=null,r=!1;function u(w){return function(){return w}};var x=window,y=document,ga=navigator,F=window.jQuery,I=void 0;
function L(w){function ha(a,d,c,e,f){var g=[];a=b.j(function(){var a=d(c,f)||[];0<g.length&&(b.a.Ya(M(g),a),e&&b.r.K(e,p,[c,a,f]));g.splice(0,g.length);b.a.P(g,a)},p,{W:a,Ka:function(){return 0==g.length||!b.a.X(g[0])}});return{M:g,j:a.pa()?a:I}}function M(a){for(;a.length&&!b.a.X(a[0]);)a.splice(0,1);if(1<a.length){for(var d=a[0],c=a[a.length-1],e=[d];d!==c;){d=d.nextSibling;if(!d)return;e.push(d)}Array.prototype.splice.apply(a,[0,a.length].concat(e))}return a}function S(a,b,c,e,f){var g=Math.min,
h=Math.max,k=[],l,n=a.length,q,s=b.length,v=s-n||1,G=n+s+1,J,A,z;for(l=0;l<=n;l++){A=J;k.push(J=[]);z=g(s,l+v);for(q=h(0,l-1);q<=z;q++)J[q]=q?l?a[l-1]===b[q-1]?A[q-1]:g(A[q]||G,J[q-1]||G)+1:q+1:l+1}g=[];h=[];v=[];l=n;for(q=s;l||q;)s=k[l][q]-1,q&&s===k[l][q-1]?h.push(g[g.length]={status:c,value:b[--q],index:q}):l&&s===k[l-1][q]?v.push(g[g.length]={status:e,value:a[--l],index:l}):(g.push({status:"retained",value:b[--q]}),--l);if(h.length&&v.length){a=10*n;var t;for(b=c=0;(f||b<a)&&(t=h[c]);c++){for(e=
0;k=v[e];e++)if(t.value===k.value){t.moved=k.index;k.moved=t.index;v.splice(e,1);b=e=0;break}b+=e}}return g.reverse()}function T(a,d,c,e,f){f=f||{};var g=a&&N(a),g=g&&g.ownerDocument,h=f.templateEngine||O;b.za.vb(c,h,g);c=h.renderTemplate(c,e,f,g);("number"!=typeof c.length||0<c.length&&"number"!=typeof c[0].nodeType)&&j(Error("Template engine must return an array of DOM nodes"));g=r;switch(d){case "replaceChildren":b.e.N(a,c);g=m;break;case "replaceNode":b.a.Ya(a,c);g=m;break;case "ignoreTargetNode":break;
default:j(Error("Unknown renderMode: "+d))}g&&(U(c,e),f.afterRender&&b.r.K(f.afterRender,p,[c,e.$data]));return c}function N(a){return a.nodeType?a:0<a.length?a[0]:p}function U(a,d){if(a.length){var c=a[0],e=a[a.length-1];V(c,e,function(a){b.Da(d,a)});V(c,e,function(a){b.s.ib(a,[d])})}}function V(a,d,c){var e;for(d=b.e.nextSibling(d);a&&(e=a)!==d;)a=b.e.nextSibling(e),(1===e.nodeType||8===e.nodeType)&&c(e)}function W(a,d,c){a=b.g.aa(a);for(var e=b.g.Q,f=0;f<a.length;f++){var g=a[f].key;if(e.hasOwnProperty(g)){var h=
e[g];"function"===typeof h?(g=h(a[f].value))&&j(Error(g)):h||j(Error("This template engine does not support the '"+g+"' binding within its templates"))}}a="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+b.g.ba(a)+" } })()})";return c.createJavaScriptEvaluatorBlock(a)+d}function X(a,d,c,e){function f(a){return function(){return k[a]}}function g(){return k}var h=0,k,l;b.j(function(){var n=c&&c instanceof b.z?c:new b.z(b.a.d(c)),q=n.$data;e&&b.eb(a,n);if(k=("function"==typeof d?
d(n,a):d)||b.J.instance.getBindings(a,n)){if(0===h){h=1;for(var s in k){var v=b.c[s];v&&8===a.nodeType&&!b.e.I[s]&&j(Error("The binding '"+s+"' cannot be used with virtual elements"));if(v&&"function"==typeof v.init&&(v=(0,v.init)(a,f(s),g,q,n))&&v.controlsDescendantBindings)l!==I&&j(Error("Multiple bindings ("+l+" and "+s+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.")),l=s}h=2}if(2===h)for(s in k)(v=b.c[s])&&"function"==
typeof v.update&&(0,v.update)(a,f(s),g,q,n)}},p,{W:a});return{Nb:l===I}}function Y(a,d,c){var e=m,f=1===d.nodeType;f&&b.e.Ta(d);if(f&&c||b.J.instance.nodeHasBindings(d))e=X(d,p,a,c).Nb;e&&Z(a,d,!f)}function Z(a,d,c){for(var e=b.e.firstChild(d);d=e;)e=b.e.nextSibling(d),Y(a,d,c)}function $(a,b){var c=aa(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:p}function aa(a,b){for(var c=a,e=1,f=[];c=c.nextSibling;){if(H(c)&&(e--,0===e))return f;f.push(c);B(c)&&e++}b||j(Error("Cannot find closing comment tag to match: "+
a.nodeValue));return p}function H(a){return 8==a.nodeType&&(K?a.text:a.nodeValue).match(ia)}function B(a){return 8==a.nodeType&&(K?a.text:a.nodeValue).match(ja)}function P(a,b){for(var c=p;a!=c;)c=a,a=a.replace(ka,function(a,c){return b[c]});return a}function la(){var a=[],d=[];this.save=function(c,e){var f=b.a.i(a,c);0<=f?d[f]=e:(a.push(c),d.push(e))};this.get=function(c){c=b.a.i(a,c);return 0<=c?d[c]:I}}function ba(a,b,c){function e(e){var g=b(a[e]);switch(typeof g){case "boolean":case "number":case "string":case "function":f[e]=
g;break;case "object":case "undefined":var h=c.get(g);f[e]=h!==I?h:ba(g,b,c)}}c=c||new la;a=b(a);if(!("object"==typeof a&&a!==p&&a!==I&&!(a instanceof Date)))return a;var f=a instanceof Array?[]:{};c.save(a,f);var g=a;if(g instanceof Array){for(var h=0;h<g.length;h++)e(h);"function"==typeof g.toJSON&&e("toJSON")}else for(h in g)e(h);return f}function ca(a,d){if(a)if(8==a.nodeType){var c=b.s.Ua(a.nodeValue);c!=p&&d.push({sb:a,Fb:c})}else if(1==a.nodeType)for(var c=0,e=a.childNodes,f=e.length;c<f;c++)ca(e[c],
d)}function Q(a,d,c,e){b.c[a]={init:function(a){b.a.f.set(a,da,{});return{controlsDescendantBindings:m}},update:function(a,g,h,k,l){h=b.a.f.get(a,da);g=b.a.d(g());k=!c!==!g;var n=!h.Za;if(n||d||k!==h.qb)n&&(h.Za=b.a.Ia(b.e.childNodes(a),m)),k?(n||b.e.N(a,b.a.Ia(h.Za)),b.Ea(e?e(l,g):l,a)):b.e.Y(a),h.qb=k}};b.g.Q[a]=r;b.e.I[a]=m}function ea(a,d,c){c&&d!==b.k.q(a)&&b.k.T(a,d);d!==b.k.q(a)&&b.r.K(b.a.Ba,p,[a,"change"])}var b="undefined"!==typeof w?w:{};b.b=function(a,d){for(var c=a.split("."),e=b,f=0;f<
c.length-1;f++)e=e[c[f]];e[c[c.length-1]]=d};b.p=function(a,b,c){a[b]=c};b.version="2.2.1";b.b("version",b.version);b.a=new function(){function a(a,d){if("input"!==b.a.u(a)||!a.type||"click"!=d.toLowerCase())return r;var c=a.type;return"checkbox"==c||"radio"==c}var d=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,c={},e={};c[/Firefox\/2/i.test(ga.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];c.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");
for(var f in c){var g=c[f];if(g.length)for(var h=0,k=g.length;h<k;h++)e[g[h]]=f}var l={propertychange:m},n,c=3;f=y.createElement("div");for(g=f.getElementsByTagName("i");f.innerHTML="\x3c!--[if gt IE "+ ++c+"]><i></i><![endif]--\x3e",g[0];);n=4<c?c:I;return{Na:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],o:function(a,b){for(var d=0,c=a.length;d<c;d++)b(a[d])},i:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var d=0,c=a.length;d<
c;d++)if(a[d]===b)return d;return-1},lb:function(a,b,d){for(var c=0,e=a.length;c<e;c++)if(b.call(d,a[c]))return a[c];return p},ga:function(a,d){var c=b.a.i(a,d);0<=c&&a.splice(c,1)},Ga:function(a){a=a||[];for(var d=[],c=0,e=a.length;c<e;c++)0>b.a.i(d,a[c])&&d.push(a[c]);return d},V:function(a,b){a=a||[];for(var d=[],c=0,e=a.length;c<e;c++)d.push(b(a[c]));return d},fa:function(a,b){a=a||[];for(var d=[],c=0,e=a.length;c<e;c++)b(a[c])&&d.push(a[c]);return d},P:function(a,b){if(b instanceof Array)a.push.apply(a,
b);else for(var d=0,c=b.length;d<c;d++)a.push(b[d]);return a},extend:function(a,b){if(b)for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);return a},ka:function(a){for(;a.firstChild;)b.removeNode(a.firstChild)},Hb:function(a){a=b.a.L(a);for(var d=y.createElement("div"),c=0,e=a.length;c<e;c++)d.appendChild(b.A(a[c]));return d},Ia:function(a,d){for(var c=0,e=a.length,g=[];c<e;c++){var f=a[c].cloneNode(m);g.push(d?b.A(f):f)}return g},N:function(a,d){b.a.ka(a);if(d)for(var c=0,e=d.length;c<e;c++)a.appendChild(d[c])},
Ya:function(a,d){var c=a.nodeType?[a]:a;if(0<c.length){for(var e=c[0],g=e.parentNode,f=0,h=d.length;f<h;f++)g.insertBefore(d[f],e);f=0;for(h=c.length;f<h;f++)b.removeNode(c[f])}},bb:function(a,b){7>n?a.setAttribute("selected",b):a.selected=b},D:function(a){return(a||"").replace(d,"")},Rb:function(a,d){for(var c=[],e=(a||"").split(d),f=0,g=e.length;f<g;f++){var h=b.a.D(e[f]);""!==h&&c.push(h)}return c},Ob:function(a,b){a=a||"";return b.length>a.length?r:a.substring(0,b.length)===b},tb:function(a,b){if(b.compareDocumentPosition)return 16==
(b.compareDocumentPosition(a)&16);for(;a!=p;){if(a==b)return m;a=a.parentNode}return r},X:function(a){return b.a.tb(a,a.ownerDocument)},u:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},n:function(b,d,c){var e=n&&l[d];if(!e&&"undefined"!=typeof F){if(a(b,d)){var f=c;c=function(a,b){var d=this.checked;b&&(this.checked=b.nb!==m);f.call(this,a);this.checked=d}}F(b).bind(d,c)}else!e&&"function"==typeof b.addEventListener?b.addEventListener(d,c,r):"undefined"!=typeof b.attachEvent?b.attachEvent("on"+
d,function(a){c.call(b,a)}):j(Error("Browser doesn't support addEventListener or attachEvent"))},Ba:function(b,d){(!b||!b.nodeType)&&j(Error("element must be a DOM node when calling triggerEvent"));if("undefined"!=typeof F){var c=[];a(b,d)&&c.push({nb:b.checked});F(b).trigger(d,c)}else"function"==typeof y.createEvent?"function"==typeof b.dispatchEvent?(c=y.createEvent(e[d]||"HTMLEvents"),c.initEvent(d,m,m,x,0,0,0,0,0,r,r,r,r,0,b),b.dispatchEvent(c)):j(Error("The supplied element doesn't support dispatchEvent")):
"undefined"!=typeof b.fireEvent?(a(b,d)&&(b.checked=b.checked!==m),b.fireEvent("on"+d)):j(Error("Browser doesn't support triggering events"))},d:function(a){return b.$(a)?a():a},ua:function(a){return b.$(a)?a.t():a},da:function(a,d,c){if(d){var e=/[\w-]+/g,f=a.className.match(e)||[];b.a.o(d.match(e),function(a){var d=b.a.i(f,a);0<=d?c||f.splice(d,1):c&&f.push(a)});a.className=f.join(" ")}},cb:function(a,d){var c=b.a.d(d);if(c===p||c===I)c="";if(3===a.nodeType)a.data=c;else{var e=b.e.firstChild(a);
!e||3!=e.nodeType||b.e.nextSibling(e)?b.e.N(a,[y.createTextNode(c)]):e.data=c;b.a.wb(a)}},ab:function(a,b){a.name=b;if(7>=n)try{a.mergeAttributes(y.createElement("<input name='"+a.name+"'/>"),r)}catch(d){}},wb:function(a){9<=n&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},ub:function(a){if(9<=n){var b=a.style.width;a.style.width=0;a.style.width=b}},Lb:function(a,d){a=b.a.d(a);d=b.a.d(d);for(var c=[],e=a;e<=d;e++)c.push(e);return c},L:function(a){for(var b=[],d=0,c=a.length;d<
c;d++)b.push(a[d]);return b},Pb:6===n,Qb:7===n,Z:n,Oa:function(a,d){for(var c=b.a.L(a.getElementsByTagName("input")).concat(b.a.L(a.getElementsByTagName("textarea"))),e="string"==typeof d?function(a){return a.name===d}:function(a){return d.test(a.name)},f=[],g=c.length-1;0<=g;g--)e(c[g])&&f.push(c[g]);return f},Ib:function(a){return"string"==typeof a&&(a=b.a.D(a))?x.JSON&&x.JSON.parse?x.JSON.parse(a):(new Function("return "+a))():p},xa:function(a,d,c){("undefined"==typeof JSON||"undefined"==typeof JSON.stringify)&&
j(Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js"));return JSON.stringify(b.a.d(a),d,c)},Jb:function(a,d,c){c=c||{};var e=c.params||{},f=c.includeFields||this.Na,g=a;if("object"==typeof a&&"form"===b.a.u(a))for(var g=a.action,h=f.length-1;0<=h;h--)for(var k=b.a.Oa(a,f[h]),l=k.length-1;0<=l;l--)e[k[l].name]=k[l].value;d=b.a.d(d);var n=y.createElement("form");
n.style.display="none";n.action=g;n.method="post";for(var w in d)a=y.createElement("input"),a.name=w,a.value=b.a.xa(b.a.d(d[w])),n.appendChild(a);for(w in e)a=y.createElement("input"),a.name=w,a.value=e[w],n.appendChild(a);y.body.appendChild(n);c.submitter?c.submitter(n):n.submit();setTimeout(function(){n.parentNode.removeChild(n)},0)}}};b.b("utils",b.a);b.b("utils.arrayForEach",b.a.o);b.b("utils.arrayFirst",b.a.lb);b.b("utils.arrayFilter",b.a.fa);b.b("utils.arrayGetDistinctValues",b.a.Ga);b.b("utils.arrayIndexOf",
b.a.i);b.b("utils.arrayMap",b.a.V);b.b("utils.arrayPushAll",b.a.P);b.b("utils.arrayRemoveItem",b.a.ga);b.b("utils.extend",b.a.extend);b.b("utils.fieldsIncludedWithJsonPost",b.a.Na);b.b("utils.getFormFields",b.a.Oa);b.b("utils.peekObservable",b.a.ua);b.b("utils.postJson",b.a.Jb);b.b("utils.parseJson",b.a.Ib);b.b("utils.registerEventHandler",b.a.n);b.b("utils.stringifyJson",b.a.xa);b.b("utils.range",b.a.Lb);b.b("utils.toggleDomNodeCssClass",b.a.da);b.b("utils.triggerEvent",b.a.Ba);b.b("utils.unwrapObservable",
b.a.d);Function.prototype.bind||(Function.prototype.bind=function(a){var b=this,c=Array.prototype.slice.call(arguments);a=c.shift();return function(){return b.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});b.a.f=new function(){var a=0,d="__ko__"+(new Date).getTime(),c={};return{get:function(a,d){var c=b.a.f.la(a,r);return c===I?I:c[d]},set:function(a,d,c){c===I&&b.a.f.la(a,r)===I||(b.a.f.la(a,m)[d]=c)},la:function(b,f){var g=b[d];if(!g||!("null"!==g&&c[g])){if(!f)return I;g=b[d]="ko"+
a++;c[g]={}}return c[g]},clear:function(a){var b=a[d];return b?(delete c[b],a[d]=p,m):r}}};b.b("utils.domData",b.a.f);b.b("utils.domData.clear",b.a.f.clear);b.a.F=new function(){function a(a,d){var e=b.a.f.get(a,c);e===I&&d&&(e=[],b.a.f.set(a,c,e));return e}function d(c){var e=a(c,r);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);b.a.f.clear(c);"function"==typeof F&&"function"==typeof F.cleanData&&F.cleanData([c]);if(f[c.nodeType])for(e=c.firstChild;c=e;)e=c.nextSibling,8===c.nodeType&&d(c)}
var c="__ko_domNodeDisposal__"+(new Date).getTime(),e={1:m,8:m,9:m},f={1:m,9:m};return{Ca:function(b,d){"function"!=typeof d&&j(Error("Callback must be a function"));a(b,m).push(d)},Xa:function(d,e){var f=a(d,r);f&&(b.a.ga(f,e),0==f.length&&b.a.f.set(d,c,I))},A:function(a){if(e[a.nodeType]&&(d(a),f[a.nodeType])){var c=[];b.a.P(c,a.getElementsByTagName("*"));for(var k=0,l=c.length;k<l;k++)d(c[k])}return a},removeNode:function(a){b.A(a);a.parentNode&&a.parentNode.removeChild(a)}}};b.A=b.a.F.A;b.removeNode=
b.a.F.removeNode;b.b("cleanNode",b.A);b.b("removeNode",b.removeNode);b.b("utils.domNodeDisposal",b.a.F);b.b("utils.domNodeDisposal.addDisposeCallback",b.a.F.Ca);b.b("utils.domNodeDisposal.removeDisposeCallback",b.a.F.Xa);b.a.ta=function(a){var d;if("undefined"!=typeof F)if(F.parseHTML)d=F.parseHTML(a);else{if((d=F.clean([a]))&&d[0]){for(a=d[0];a.parentNode&&11!==a.parentNode.nodeType;)a=a.parentNode;a.parentNode&&a.parentNode.removeChild(a)}}else{var c=b.a.D(a).toLowerCase();d=y.createElement("div");
c=c.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!c.indexOf("<tr")&&[2,"<table><tbody>","</tbody></table>"]||(!c.indexOf("<td")||!c.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];a="ignored<div>"+c[1]+a+c[2]+"</div>";for("function"==typeof x.innerShiv?d.appendChild(x.innerShiv(a)):d.innerHTML=a;c[0]--;)d=d.lastChild;d=b.a.L(d.lastChild.childNodes)}return d};b.a.ca=function(a,d){b.a.ka(a);d=b.a.d(d);if(d!==p&&d!==I)if("string"!=typeof d&&(d=d.toString()),
"undefined"!=typeof F)F(a).html(d);else for(var c=b.a.ta(d),e=0;e<c.length;e++)a.appendChild(c[e])};b.b("utils.parseHtmlFragment",b.a.ta);b.b("utils.setHtml",b.a.ca);var R={};b.s={ra:function(a){"function"!=typeof a&&j(Error("You can only pass a function to ko.memoization.memoize()"));var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);R[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},hb:function(a,b){var c=R[a];c===I&&j(Error("Couldn't find any memo with ID "+
a+". Perhaps it's already been unmemoized."));try{return c.apply(p,b||[]),m}finally{delete R[a]}},ib:function(a,d){var c=[];ca(a,c);for(var e=0,f=c.length;e<f;e++){var g=c[e].sb,h=[g];d&&b.a.P(h,d);b.s.hb(c[e].Fb,h);g.nodeValue="";g.parentNode&&g.parentNode.removeChild(g)}},Ua:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:p}};b.b("memoization",b.s);b.b("memoization.memoize",b.s.ra);b.b("memoization.unmemoize",b.s.hb);b.b("memoization.parseMemoText",b.s.Ua);b.b("memoization.unmemoizeDomNodeAndDescendants",
b.s.ib);b.Ma={throttle:function(a,d){a.throttleEvaluation=d;var c=p;return b.j({read:a,write:function(b){clearTimeout(c);c=setTimeout(function(){a(b)},d)}})},notify:function(a,d){a.equalityComparer="always"==d?u(r):b.m.fn.equalityComparer;return a}};b.b("extenders",b.Ma);b.fb=function(a,d,c){this.target=a;this.ha=d;this.rb=c;b.p(this,"dispose",this.B)};b.fb.prototype.B=function(){this.Cb=m;this.rb()};b.S=function(){this.w={};b.a.extend(this,b.S.fn);b.p(this,"subscribe",this.ya);b.p(this,"extend",
this.extend);b.p(this,"getSubscriptionsCount",this.yb)};b.S.fn={ya:function(a,d,c){c=c||"change";var e=new b.fb(this,d?a.bind(d):a,function(){b.a.ga(this.w[c],e)}.bind(this));this.w[c]||(this.w[c]=[]);this.w[c].push(e);return e},notifySubscribers:function(a,d){d=d||"change";this.w[d]&&b.r.K(function(){b.a.o(this.w[d].slice(0),function(b){b&&b.Cb!==m&&b.ha(a)})},this)},yb:function(){var a=0,b;for(b in this.w)this.w.hasOwnProperty(b)&&(a+=this.w[b].length);return a},extend:function(a){var d=this;if(a)for(var c in a){var e=
b.Ma[c];"function"==typeof e&&(d=e(d,a[c]))}return d}};b.Qa=function(a){return"function"==typeof a.ya&&"function"==typeof a.notifySubscribers};b.b("subscribable",b.S);b.b("isSubscribable",b.Qa);var C=[];b.r={mb:function(a){C.push({ha:a,La:[]})},end:function(){C.pop()},Wa:function(a){b.Qa(a)||j(Error("Only subscribable things can act as dependencies"));if(0<C.length){var d=C[C.length-1];d&&!(0<=b.a.i(d.La,a))&&(d.La.push(a),d.ha(a))}},K:function(a,b,c){try{return C.push(p),a.apply(b,c||[])}finally{C.pop()}}};
var ma={undefined:m,"boolean":m,number:m,string:m};b.m=function(a){function d(){if(0<arguments.length){if(!d.equalityComparer||!d.equalityComparer(c,arguments[0]))d.H(),c=arguments[0],d.G();return this}b.r.Wa(d);return c}var c=a;b.S.call(d);d.t=function(){return c};d.G=function(){d.notifySubscribers(c)};d.H=function(){d.notifySubscribers(c,"beforeChange")};b.a.extend(d,b.m.fn);b.p(d,"peek",d.t);b.p(d,"valueHasMutated",d.G);b.p(d,"valueWillMutate",d.H);return d};b.m.fn={equalityComparer:function(a,
b){return a===p||typeof a in ma?a===b:r}};var E=b.m.Kb="__ko_proto__";b.m.fn[E]=b.m;b.ma=function(a,d){return a===p||a===I||a[E]===I?r:a[E]===d?m:b.ma(a[E],d)};b.$=function(a){return b.ma(a,b.m)};b.Ra=function(a){return"function"==typeof a&&a[E]===b.m||"function"==typeof a&&a[E]===b.j&&a.zb?m:r};b.b("observable",b.m);b.b("isObservable",b.$);b.b("isWriteableObservable",b.Ra);b.R=function(a){0==arguments.length&&(a=[]);a!==p&&(a!==I&&!("length"in a))&&j(Error("The argument passed when initializing an observable array must be an array, or null, or undefined."));
var d=b.m(a);b.a.extend(d,b.R.fn);return d};b.R.fn={remove:function(a){for(var b=this.t(),c=[],e="function"==typeof a?a:function(b){return b===a},f=0;f<b.length;f++){var g=b[f];e(g)&&(0===c.length&&this.H(),c.push(g),b.splice(f,1),f--)}c.length&&this.G();return c},removeAll:function(a){if(a===I){var d=this.t(),c=d.slice(0);this.H();d.splice(0,d.length);this.G();return c}return!a?[]:this.remove(function(d){return 0<=b.a.i(a,d)})},destroy:function(a){var b=this.t(),c="function"==typeof a?a:function(b){return b===
a};this.H();for(var e=b.length-1;0<=e;e--)c(b[e])&&(b[e]._destroy=m);this.G()},destroyAll:function(a){return a===I?this.destroy(u(m)):!a?[]:this.destroy(function(d){return 0<=b.a.i(a,d)})},indexOf:function(a){var d=this();return b.a.i(d,a)},replace:function(a,b){var c=this.indexOf(a);0<=c&&(this.H(),this.t()[c]=b,this.G())}};b.a.o("pop push reverse shift sort splice unshift".split(" "),function(a){b.R.fn[a]=function(){var b=this.t();this.H();b=b[a].apply(b,arguments);this.G();return b}});b.a.o(["slice"],
function(a){b.R.fn[a]=function(){var b=this();return b[a].apply(b,arguments)}});b.b("observableArray",b.R);b.j=function(a,d,c){function e(){b.a.o(z,function(a){a.B()});z=[]}function f(){var a=h.throttleEvaluation;a&&0<=a?(clearTimeout(t),t=setTimeout(g,a)):g()}function g(){if(!q)if(n&&w())A();else{q=m;try{var a=b.a.V(z,function(a){return a.target});b.r.mb(function(c){var d;0<=(d=b.a.i(a,c))?a[d]=I:z.push(c.ya(f))});for(var c=s.call(d),e=a.length-1;0<=e;e--)a[e]&&z.splice(e,1)[0].B();n=m;h.notifySubscribers(l,
"beforeChange");l=c}finally{b.r.end()}h.notifySubscribers(l);q=r;z.length||A()}}function h(){if(0<arguments.length)return"function"===typeof v?v.apply(d,arguments):j(Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.")),this;n||g();b.r.Wa(h);return l}function k(){return!n||0<z.length}var l,n=r,q=r,s=a;s&&"object"==typeof s?(c=s,s=c.read):(c=c||{},s||(s=c.read));"function"!=typeof s&&j(Error("Pass a function that returns the value of the ko.computed"));
var v=c.write,G=c.disposeWhenNodeIsRemoved||c.W||p,w=c.disposeWhen||c.Ka||u(r),A=e,z=[],t=p;d||(d=c.owner);h.t=function(){n||g();return l};h.xb=function(){return z.length};h.zb="function"===typeof c.write;h.B=function(){A()};h.pa=k;b.S.call(h);b.a.extend(h,b.j.fn);b.p(h,"peek",h.t);b.p(h,"dispose",h.B);b.p(h,"isActive",h.pa);b.p(h,"getDependenciesCount",h.xb);c.deferEvaluation!==m&&g();if(G&&k()){A=function(){b.a.F.Xa(G,arguments.callee);e()};b.a.F.Ca(G,A);var D=w,w=function(){return!b.a.X(G)||D()}}return h};
b.Bb=function(a){return b.ma(a,b.j)};w=b.m.Kb;b.j[w]=b.m;b.j.fn={};b.j.fn[w]=b.j;b.b("dependentObservable",b.j);b.b("computed",b.j);b.b("isComputed",b.Bb);b.gb=function(a){0==arguments.length&&j(Error("When calling ko.toJS, pass the object you want to convert."));return ba(a,function(a){for(var c=0;b.$(a)&&10>c;c++)a=a();return a})};b.toJSON=function(a,d,c){a=b.gb(a);return b.a.xa(a,d,c)};b.b("toJS",b.gb);b.b("toJSON",b.toJSON);b.k={q:function(a){switch(b.a.u(a)){case "option":return a.__ko__hasDomDataOptionValue__===
m?b.a.f.get(a,b.c.options.sa):7>=b.a.Z?a.getAttributeNode("value").specified?a.value:a.text:a.value;case "select":return 0<=a.selectedIndex?b.k.q(a.options[a.selectedIndex]):I;default:return a.value}},T:function(a,d){switch(b.a.u(a)){case "option":switch(typeof d){case "string":b.a.f.set(a,b.c.options.sa,I);"__ko__hasDomDataOptionValue__"in a&&delete a.__ko__hasDomDataOptionValue__;a.value=d;break;default:b.a.f.set(a,b.c.options.sa,d),a.__ko__hasDomDataOptionValue__=m,a.value="number"===typeof d?
d:""}break;case "select":for(var c=a.options.length-1;0<=c;c--)if(b.k.q(a.options[c])==d){a.selectedIndex=c;break}break;default:if(d===p||d===I)d="";a.value=d}}};b.b("selectExtensions",b.k);b.b("selectExtensions.readValue",b.k.q);b.b("selectExtensions.writeValue",b.k.T);var ka=/\@ko_token_(\d+)\@/g,na=["true","false"],oa=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;b.g={Q:[],aa:function(a){var d=b.a.D(a);if(3>d.length)return[];"{"===d.charAt(0)&&(d=d.substring(1,d.length-1));a=[];for(var c=
p,e,f=0;f<d.length;f++){var g=d.charAt(f);if(c===p)switch(g){case '"':case "'":case "/":c=f,e=g}else if(g==e&&"\\"!==d.charAt(f-1)){g=d.substring(c,f+1);a.push(g);var h="@ko_token_"+(a.length-1)+"@",d=d.substring(0,c)+h+d.substring(f+1),f=f-(g.length-h.length),c=p}}e=c=p;for(var k=0,l=p,f=0;f<d.length;f++){g=d.charAt(f);if(c===p)switch(g){case "{":c=f;l=g;e="}";break;case "(":c=f;l=g;e=")";break;case "[":c=f,l=g,e="]"}g===l?k++:g===e&&(k--,0===k&&(g=d.substring(c,f+1),a.push(g),h="@ko_token_"+(a.length-
1)+"@",d=d.substring(0,c)+h+d.substring(f+1),f-=g.length-h.length,c=p))}e=[];d=d.split(",");c=0;for(f=d.length;c<f;c++)k=d[c],l=k.indexOf(":"),0<l&&l<k.length-1?(g=k.substring(l+1),e.push({key:P(k.substring(0,l),a),value:P(g,a)})):e.push({unknown:P(k,a)});return e},ba:function(a){var d="string"===typeof a?b.g.aa(a):a,c=[];a=[];for(var e,f=0;e=d[f];f++)if(0<c.length&&c.push(","),e.key){var g;a:{g=e.key;var h=b.a.D(g);switch(h.length&&h.charAt(0)){case "'":case '"':break a;default:g="'"+h+"'"}}e=e.value;
c.push(g);c.push(":");c.push(e);e=b.a.D(e);0<=b.a.i(na,b.a.D(e).toLowerCase())?e=r:(h=e.match(oa),e=h===p?r:h[1]?"Object("+h[1]+")"+h[2]:e);e&&(0<a.length&&a.push(", "),a.push(g+" : function(__ko_value) { "+e+" = __ko_value; }"))}else e.unknown&&c.push(e.unknown);d=c.join("");0<a.length&&(d=d+", '_ko_property_writers' : { "+a.join("")+" } ");return d},Eb:function(a,d){for(var c=0;c<a.length;c++)if(b.a.D(a[c].key)==d)return m;return r},ea:function(a,d,c,e,f){if(!a||!b.Ra(a)){if((a=d()._ko_property_writers)&&
a[c])a[c](e)}else(!f||a.t()!==e)&&a(e)}};b.b("expressionRewriting",b.g);b.b("expressionRewriting.bindingRewriteValidators",b.g.Q);b.b("expressionRewriting.parseObjectLiteral",b.g.aa);b.b("expressionRewriting.preProcessBindings",b.g.ba);b.b("jsonExpressionRewriting",b.g);b.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",b.g.ba);var K="\x3c!--test--\x3e"===y.createComment("test").text,ja=K?/^\x3c!--\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*--\x3e$/:/^\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*$/,ia=K?/^\x3c!--\s*\/ko\s*--\x3e$/:
/^\s*\/ko\s*$/,pa={ul:m,ol:m};b.e={I:{},childNodes:function(a){return B(a)?aa(a):a.childNodes},Y:function(a){if(B(a)){a=b.e.childNodes(a);for(var d=0,c=a.length;d<c;d++)b.removeNode(a[d])}else b.a.ka(a)},N:function(a,d){if(B(a)){b.e.Y(a);for(var c=a.nextSibling,e=0,f=d.length;e<f;e++)c.parentNode.insertBefore(d[e],c)}else b.a.N(a,d)},Va:function(a,b){B(a)?a.parentNode.insertBefore(b,a.nextSibling):a.firstChild?a.insertBefore(b,a.firstChild):a.appendChild(b)},Pa:function(a,d,c){c?B(a)?a.parentNode.insertBefore(d,
c.nextSibling):c.nextSibling?a.insertBefore(d,c.nextSibling):a.appendChild(d):b.e.Va(a,d)},firstChild:function(a){return!B(a)?a.firstChild:!a.nextSibling||H(a.nextSibling)?p:a.nextSibling},nextSibling:function(a){B(a)&&(a=$(a));return a.nextSibling&&H(a.nextSibling)?p:a.nextSibling},jb:function(a){return(a=B(a))?a[1]:p},Ta:function(a){if(pa[b.a.u(a)]){var d=a.firstChild;if(d){do if(1===d.nodeType){var c;c=d.firstChild;var e=p;if(c){do if(e)e.push(c);else if(B(c)){var f=$(c,m);f?c=f:e=[c]}else H(c)&&
(e=[c]);while(c=c.nextSibling)}if(c=e){e=d.nextSibling;for(f=0;f<c.length;f++)e?a.insertBefore(c[f],e):a.appendChild(c[f])}}while(d=d.nextSibling)}}}};b.b("virtualElements",b.e);b.b("virtualElements.allowedBindings",b.e.I);b.b("virtualElements.emptyNode",b.e.Y);b.b("virtualElements.insertAfter",b.e.Pa);b.b("virtualElements.prepend",b.e.Va);b.b("virtualElements.setDomNodeChildren",b.e.N);b.J=function(){this.Ha={}};b.a.extend(b.J.prototype,{nodeHasBindings:function(a){switch(a.nodeType){case 1:return a.getAttribute("data-bind")!=
p;case 8:return b.e.jb(a)!=p;default:return r}},getBindings:function(a,b){var c=this.getBindingsString(a,b);return c?this.parseBindingsString(c,b,a):p},getBindingsString:function(a){switch(a.nodeType){case 1:return a.getAttribute("data-bind");case 8:return b.e.jb(a);default:return p}},parseBindingsString:function(a,d,c){try{var e;if(!(e=this.Ha[a])){var f=this.Ha,g,h="with($context){with($data||{}){return{"+b.g.ba(a)+"}}}";g=new Function("$context","$element",h);e=f[a]=g}return e(d,c)}catch(k){j(Error("Unable to parse bindings.\nMessage: "+
k+";\nBindings value: "+a))}}});b.J.instance=new b.J;b.b("bindingProvider",b.J);b.c={};b.z=function(a,d,c){d?(b.a.extend(this,d),this.$parentContext=d,this.$parent=d.$data,this.$parents=(d.$parents||[]).slice(0),this.$parents.unshift(this.$parent)):(this.$parents=[],this.$root=a,this.ko=b);this.$data=a;c&&(this[c]=a)};b.z.prototype.createChildContext=function(a,d){return new b.z(a,this,d)};b.z.prototype.extend=function(a){var d=b.a.extend(new b.z,this);return b.a.extend(d,a)};b.eb=function(a,d){if(2==
arguments.length)b.a.f.set(a,"__ko_bindingContext__",d);else return b.a.f.get(a,"__ko_bindingContext__")};b.Fa=function(a,d,c){1===a.nodeType&&b.e.Ta(a);return X(a,d,c,m)};b.Ea=function(a,b){(1===b.nodeType||8===b.nodeType)&&Z(a,b,m)};b.Da=function(a,b){b&&(1!==b.nodeType&&8!==b.nodeType)&&j(Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"));b=b||x.document.body;Y(a,b,m)};b.ja=function(a){switch(a.nodeType){case 1:case 8:var d=b.eb(a);if(d)return d;
if(a.parentNode)return b.ja(a.parentNode)}return I};b.pb=function(a){return(a=b.ja(a))?a.$data:I};b.b("bindingHandlers",b.c);b.b("applyBindings",b.Da);b.b("applyBindingsToDescendants",b.Ea);b.b("applyBindingsToNode",b.Fa);b.b("contextFor",b.ja);b.b("dataFor",b.pb);var fa={"class":"className","for":"htmlFor"};b.c.attr={update:function(a,d){var c=b.a.d(d())||{},e;for(e in c)if("string"==typeof e){var f=b.a.d(c[e]),g=f===r||f===p||f===I;g&&a.removeAttribute(e);8>=b.a.Z&&e in fa?(e=fa[e],g?a.removeAttribute(e):
a[e]=f):g||a.setAttribute(e,f.toString());"name"===e&&b.a.ab(a,g?"":f.toString())}}};b.c.checked={init:function(a,d,c){b.a.n(a,"click",function(){var e;if("checkbox"==a.type)e=a.checked;else if("radio"==a.type&&a.checked)e=a.value;else return;var f=d(),g=b.a.d(f);"checkbox"==a.type&&g instanceof Array?(e=b.a.i(g,a.value),a.checked&&0>e?f.push(a.value):!a.checked&&0<=e&&f.splice(e,1)):b.g.ea(f,c,"checked",e,m)});"radio"==a.type&&!a.name&&b.c.uniqueName.init(a,u(m))},update:function(a,d){var c=b.a.d(d());
"checkbox"==a.type?a.checked=c instanceof Array?0<=b.a.i(c,a.value):c:"radio"==a.type&&(a.checked=a.value==c)}};b.c.css={update:function(a,d){var c=b.a.d(d());if("object"==typeof c)for(var e in c){var f=b.a.d(c[e]);b.a.da(a,e,f)}else c=String(c||""),b.a.da(a,a.__ko__cssValue,r),a.__ko__cssValue=c,b.a.da(a,c,m)}};b.c.enable={update:function(a,d){var c=b.a.d(d());c&&a.disabled?a.removeAttribute("disabled"):!c&&!a.disabled&&(a.disabled=m)}};b.c.disable={update:function(a,d){b.c.enable.update(a,function(){return!b.a.d(d())})}};
b.c.event={init:function(a,d,c,e){var f=d()||{},g;for(g in f)(function(){var f=g;"string"==typeof f&&b.a.n(a,f,function(a){var g,n=d()[f];if(n){var q=c();try{var s=b.a.L(arguments);s.unshift(e);g=n.apply(e,s)}finally{g!==m&&(a.preventDefault?a.preventDefault():a.returnValue=r)}q[f+"Bubble"]===r&&(a.cancelBubble=m,a.stopPropagation&&a.stopPropagation())}})})()}};b.c.foreach={Sa:function(a){return function(){var d=a(),c=b.a.ua(d);if(!c||"number"==typeof c.length)return{foreach:d,templateEngine:b.C.oa};
b.a.d(d);return{foreach:c.data,as:c.as,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,beforeMove:c.beforeMove,afterMove:c.afterMove,templateEngine:b.C.oa}}},init:function(a,d){return b.c.template.init(a,b.c.foreach.Sa(d))},update:function(a,d,c,e,f){return b.c.template.update(a,b.c.foreach.Sa(d),c,e,f)}};b.g.Q.foreach=r;b.e.I.foreach=m;b.c.hasfocus={init:function(a,d,c){function e(e){a.__ko_hasfocusUpdating=m;var f=a.ownerDocument;"activeElement"in
f&&(e=f.activeElement===a);f=d();b.g.ea(f,c,"hasfocus",e,m);a.__ko_hasfocusUpdating=r}var f=e.bind(p,m),g=e.bind(p,r);b.a.n(a,"focus",f);b.a.n(a,"focusin",f);b.a.n(a,"blur",g);b.a.n(a,"focusout",g)},update:function(a,d){var c=b.a.d(d());a.__ko_hasfocusUpdating||(c?a.focus():a.blur(),b.r.K(b.a.Ba,p,[a,c?"focusin":"focusout"]))}};b.c.html={init:function(){return{controlsDescendantBindings:m}},update:function(a,d){b.a.ca(a,d())}};var da="__ko_withIfBindingData";Q("if");Q("ifnot",r,m);Q("with",m,r,function(a,
b){return a.createChildContext(b)});b.c.options={update:function(a,d,c){"select"!==b.a.u(a)&&j(Error("options binding applies only to SELECT elements"));for(var e=0==a.length,f=b.a.V(b.a.fa(a.childNodes,function(a){return a.tagName&&"option"===b.a.u(a)&&a.selected}),function(a){return b.k.q(a)||a.innerText||a.textContent}),g=a.scrollTop,h=b.a.d(d());0<a.length;)b.A(a.options[0]),a.remove(0);if(h){c=c();var k=c.optionsIncludeDestroyed;"number"!=typeof h.length&&(h=[h]);if(c.optionsCaption){var l=y.createElement("option");
b.a.ca(l,c.optionsCaption);b.k.T(l,I);a.appendChild(l)}d=0;for(var n=h.length;d<n;d++){var q=h[d];if(!q||!q._destroy||k){var l=y.createElement("option"),s=function(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c},v=s(q,c.optionsValue,q);b.k.T(l,b.a.d(v));q=s(q,c.optionsText,v);b.a.cb(l,q);a.appendChild(l)}}h=a.getElementsByTagName("option");d=k=0;for(n=h.length;d<n;d++)0<=b.a.i(f,b.k.q(h[d]))&&(b.a.bb(h[d],m),k++);a.scrollTop=g;e&&"value"in c&&ea(a,b.a.ua(c.value),m);b.a.ub(a)}}};
b.c.options.sa="__ko.optionValueDomData__";b.c.selectedOptions={init:function(a,d,c){b.a.n(a,"change",function(){var e=d(),f=[];b.a.o(a.getElementsByTagName("option"),function(a){a.selected&&f.push(b.k.q(a))});b.g.ea(e,c,"value",f)})},update:function(a,d){"select"!=b.a.u(a)&&j(Error("values binding applies only to SELECT elements"));var c=b.a.d(d());c&&"number"==typeof c.length&&b.a.o(a.getElementsByTagName("option"),function(a){var d=0<=b.a.i(c,b.k.q(a));b.a.bb(a,d)})}};b.c.style={update:function(a,
d){var c=b.a.d(d()||{}),e;for(e in c)if("string"==typeof e){var f=b.a.d(c[e]);a.style[e]=f||""}}};b.c.submit={init:function(a,d,c,e){"function"!=typeof d()&&j(Error("The value for a submit binding must be a function"));b.a.n(a,"submit",function(b){var c,h=d();try{c=h.call(e,a)}finally{c!==m&&(b.preventDefault?b.preventDefault():b.returnValue=r)}})}};b.c.text={update:function(a,d){b.a.cb(a,d())}};b.e.I.text=m;b.c.uniqueName={init:function(a,d){if(d()){var c="ko_unique_"+ ++b.c.uniqueName.ob;b.a.ab(a,
c)}}};b.c.uniqueName.ob=0;b.c.value={init:function(a,d,c){function e(){h=r;var e=d(),f=b.k.q(a);b.g.ea(e,c,"value",f)}var f=["change"],g=c().valueUpdate,h=r;g&&("string"==typeof g&&(g=[g]),b.a.P(f,g),f=b.a.Ga(f));if(b.a.Z&&("input"==a.tagName.toLowerCase()&&"text"==a.type&&"off"!=a.autocomplete&&(!a.form||"off"!=a.form.autocomplete))&&-1==b.a.i(f,"propertychange"))b.a.n(a,"propertychange",function(){h=m}),b.a.n(a,"blur",function(){h&&e()});b.a.o(f,function(c){var d=e;b.a.Ob(c,"after")&&(d=function(){setTimeout(e,
0)},c=c.substring(5));b.a.n(a,c,d)})},update:function(a,d){var c="select"===b.a.u(a),e=b.a.d(d()),f=b.k.q(a),g=e!=f;0===e&&(0!==f&&"0"!==f)&&(g=m);g&&(f=function(){b.k.T(a,e)},f(),c&&setTimeout(f,0));c&&0<a.length&&ea(a,e,r)}};b.c.visible={update:function(a,d){var c=b.a.d(d()),e="none"!=a.style.display;c&&!e?a.style.display="":!c&&e&&(a.style.display="none")}};b.c.click={init:function(a,d,c,e){return b.c.event.init.call(this,a,function(){var a={};a.click=d();return a},c,e)}};b.v=function(){};b.v.prototype.renderTemplateSource=
function(){j(Error("Override renderTemplateSource"))};b.v.prototype.createJavaScriptEvaluatorBlock=function(){j(Error("Override createJavaScriptEvaluatorBlock"))};b.v.prototype.makeTemplateSource=function(a,d){if("string"==typeof a){d=d||y;var c=d.getElementById(a);c||j(Error("Cannot find template with ID "+a));return new b.l.h(c)}if(1==a.nodeType||8==a.nodeType)return new b.l.O(a);j(Error("Unknown template type: "+a))};b.v.prototype.renderTemplate=function(a,b,c,e){a=this.makeTemplateSource(a,e);
return this.renderTemplateSource(a,b,c)};b.v.prototype.isTemplateRewritten=function(a,b){return this.allowTemplateRewriting===r?m:this.makeTemplateSource(a,b).data("isRewritten")};b.v.prototype.rewriteTemplate=function(a,b,c){a=this.makeTemplateSource(a,c);b=b(a.text());a.text(b);a.data("isRewritten",m)};b.b("templateEngine",b.v);var qa=/(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi,ra=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;b.za={vb:function(a,
d,c){d.isTemplateRewritten(a,c)||d.rewriteTemplate(a,function(a){return b.za.Gb(a,d)},c)},Gb:function(a,b){return a.replace(qa,function(a,e,f,g,h,k,l){return W(l,e,b)}).replace(ra,function(a,e){return W(e,"\x3c!-- ko --\x3e",b)})},kb:function(a){return b.s.ra(function(d,c){d.nextSibling&&b.Fa(d.nextSibling,a,c)})}};b.b("__tr_ambtns",b.za.kb);b.l={};b.l.h=function(a){this.h=a};b.l.h.prototype.text=function(){var a=b.a.u(this.h),a="script"===a?"text":"textarea"===a?"value":"innerHTML";if(0==arguments.length)return this.h[a];
var d=arguments[0];"innerHTML"===a?b.a.ca(this.h,d):this.h[a]=d};b.l.h.prototype.data=function(a){if(1===arguments.length)return b.a.f.get(this.h,"templateSourceData_"+a);b.a.f.set(this.h,"templateSourceData_"+a,arguments[1])};b.l.O=function(a){this.h=a};b.l.O.prototype=new b.l.h;b.l.O.prototype.text=function(){if(0==arguments.length){var a=b.a.f.get(this.h,"__ko_anon_template__")||{};a.Aa===I&&a.ia&&(a.Aa=a.ia.innerHTML);return a.Aa}b.a.f.set(this.h,"__ko_anon_template__",{Aa:arguments[0]})};b.l.h.prototype.nodes=
function(){if(0==arguments.length)return(b.a.f.get(this.h,"__ko_anon_template__")||{}).ia;b.a.f.set(this.h,"__ko_anon_template__",{ia:arguments[0]})};b.b("templateSources",b.l);b.b("templateSources.domElement",b.l.h);b.b("templateSources.anonymousTemplate",b.l.O);var O;b.wa=function(a){a!=I&&!(a instanceof b.v)&&j(Error("templateEngine must inherit from ko.templateEngine"));O=a};b.va=function(a,d,c,e,f){c=c||{};(c.templateEngine||O)==I&&j(Error("Set a template engine before calling renderTemplate"));
f=f||"replaceChildren";if(e){var g=N(e);return b.j(function(){var h=d&&d instanceof b.z?d:new b.z(b.a.d(d)),k="function"==typeof a?a(h.$data,h):a,h=T(e,f,k,h,c);"replaceNode"==f&&(e=h,g=N(e))},p,{Ka:function(){return!g||!b.a.X(g)},W:g&&"replaceNode"==f?g.parentNode:g})}return b.s.ra(function(e){b.va(a,d,c,e,"replaceNode")})};b.Mb=function(a,d,c,e,f){function g(a,b){U(b,k);c.afterRender&&c.afterRender(b,a)}function h(d,e){k=f.createChildContext(b.a.d(d),c.as);k.$index=e;var g="function"==typeof a?
a(d,k):a;return T(p,"ignoreTargetNode",g,k,c)}var k;return b.j(function(){var a=b.a.d(d)||[];"undefined"==typeof a.length&&(a=[a]);a=b.a.fa(a,function(a){return c.includeDestroyed||a===I||a===p||!b.a.d(a._destroy)});b.r.K(b.a.$a,p,[e,a,h,c,g])},p,{W:e})};b.c.template={init:function(a,d){var c=b.a.d(d());if("string"!=typeof c&&!c.name&&(1==a.nodeType||8==a.nodeType))c=1==a.nodeType?a.childNodes:b.e.childNodes(a),c=b.a.Hb(c),(new b.l.O(a)).nodes(c);return{controlsDescendantBindings:m}},update:function(a,
d,c,e,f){d=b.a.d(d());c={};e=m;var g,h=p;"string"!=typeof d&&(c=d,d=c.name,"if"in c&&(e=b.a.d(c["if"])),e&&"ifnot"in c&&(e=!b.a.d(c.ifnot)),g=b.a.d(c.data));"foreach"in c?h=b.Mb(d||a,e&&c.foreach||[],c,a,f):e?(f="data"in c?f.createChildContext(g,c.as):f,h=b.va(d||a,f,c,a)):b.e.Y(a);f=h;(g=b.a.f.get(a,"__ko__templateComputedDomDataKey__"))&&"function"==typeof g.B&&g.B();b.a.f.set(a,"__ko__templateComputedDomDataKey__",f&&f.pa()?f:I)}};b.g.Q.template=function(a){a=b.g.aa(a);return 1==a.length&&a[0].unknown||
b.g.Eb(a,"name")?p:"This template engine does not support anonymous templates nested within its templates"};b.e.I.template=m;b.b("setTemplateEngine",b.wa);b.b("renderTemplate",b.va);b.a.Ja=function(a,b,c){a=a||[];b=b||[];return a.length<=b.length?S(a,b,"added","deleted",c):S(b,a,"deleted","added",c)};b.b("utils.compareArrays",b.a.Ja);b.a.$a=function(a,d,c,e,f){function g(a,b){t=l[b];w!==b&&(z[a]=t);t.na(w++);M(t.M);s.push(t);A.push(t)}function h(a,c){if(a)for(var d=0,e=c.length;d<e;d++)c[d]&&b.a.o(c[d].M,
function(b){a(b,d,c[d].U)})}d=d||[];e=e||{};var k=b.a.f.get(a,"setDomNodeChildrenFromArrayMapping_lastMappingResult")===I,l=b.a.f.get(a,"setDomNodeChildrenFromArrayMapping_lastMappingResult")||[],n=b.a.V(l,function(a){return a.U}),q=b.a.Ja(n,d),s=[],v=0,w=0,B=[],A=[];d=[];for(var z=[],n=[],t,D=0,C,E;C=q[D];D++)switch(E=C.moved,C.status){case "deleted":E===I&&(t=l[v],t.j&&t.j.B(),B.push.apply(B,M(t.M)),e.beforeRemove&&(d[D]=t,A.push(t)));v++;break;case "retained":g(D,v++);break;case "added":E!==I?
g(D,E):(t={U:C.value,na:b.m(w++)},s.push(t),A.push(t),k||(n[D]=t))}h(e.beforeMove,z);b.a.o(B,e.beforeRemove?b.A:b.removeNode);for(var D=0,k=b.e.firstChild(a),H;t=A[D];D++){t.M||b.a.extend(t,ha(a,c,t.U,f,t.na));for(v=0;q=t.M[v];k=q.nextSibling,H=q,v++)q!==k&&b.e.Pa(a,q,H);!t.Ab&&f&&(f(t.U,t.M,t.na),t.Ab=m)}h(e.beforeRemove,d);h(e.afterMove,z);h(e.afterAdd,n);b.a.f.set(a,"setDomNodeChildrenFromArrayMapping_lastMappingResult",s)};b.b("utils.setDomNodeChildrenFromArrayMapping",b.a.$a);b.C=function(){this.allowTemplateRewriting=
r};b.C.prototype=new b.v;b.C.prototype.renderTemplateSource=function(a){var d=!(9>b.a.Z)&&a.nodes?a.nodes():p;if(d)return b.a.L(d.cloneNode(m).childNodes);a=a.text();return b.a.ta(a)};b.C.oa=new b.C;b.wa(b.C.oa);b.b("nativeTemplateEngine",b.C);b.qa=function(){var a=this.Db=function(){if("undefined"==typeof F||!F.tmpl)return 0;try{if(0<=F.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,c,e){e=e||{};2>a&&j(Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later."));
var f=b.data("precompiled");f||(f=b.text()||"",f=F.template(p,"{{ko_with $item.koBindingContext}}"+f+"{{/ko_with}}"),b.data("precompiled",f));b=[c.$data];c=F.extend({koBindingContext:c},e.templateOptions);c=F.tmpl(f,b,c);c.appendTo(y.createElement("div"));F.fragments={};return c};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){y.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(F.tmpl.tag.ko_code=
{open:"__.push($1 || '');"},F.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};b.qa.prototype=new b.v;w=new b.qa;0<w.Db&&b.wa(w);b.b("jqueryTmplTemplateEngine",b.qa)}"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?L(module.exports||exports):"function"===typeof define&&define.amd?define(["exports"],L):L(x.ko={});m;
})();

// Avoid `console` errors in browsers that lack a console.
(function() {
    var method;
    var noop = function () {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var length = methods.length;
    var console = (window.console = window.console || {});

    while (length--) {
        method = methods[length];

        // Only stub undefined methods.
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());

// Place any jQuery/helper plugins in here.
;
(function() {


}).call(this);
/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery-1.10.2.min.map
*/

(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
/* Modernizr 2.6.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-websockets-websqldatabase-webworkers-geolocation-inlinesvg-smil-svg-svgclippaths-touch-webgl-shiv-mq-cssclasses-addtest-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-load
 */

;window.Modernizr=function(a,b,c){function D(a){j.cssText=a}function E(a,b){return D(n.join(a+";")+(b||""))}function F(a,b){return typeof a===b}function G(a,b){return!!~(""+a).indexOf(b)}function H(a,b){for(var d in a){var e=a[d];if(!G(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function I(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:F(f,"function")?f.bind(d||b):f}return!1}function J(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+p.join(d+" ")+d).split(" ");return F(b,"string")||F(b,"undefined")?H(e,b):(e=(a+" "+q.join(d+" ")+d).split(" "),I(e,b,c))}function K(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)u[c[d]]=c[d]in k;return u.list&&(u.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),u}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:e=k.value!=l)),t[a[d]]=!!e;return t}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.6.2",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n=" -webkit- -moz- -o- -ms- ".split(" "),o="Webkit Moz O ms",p=o.split(" "),q=o.toLowerCase().split(" "),r={svg:"http://www.w3.org/2000/svg"},s={},t={},u={},v=[],w=v.slice,x,y=function(a,c,d,e){var f,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),l.appendChild(j);return f=["&#173;",'<style id="s',h,'">',a,"</style>"].join(""),l.id=h,(m?l:n).innerHTML+=f,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=g.style.overflow,g.style.overflow="hidden",g.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),g.style.overflow=k),!!i},z=function(b){var c=a.matchMedia||a.msMatchMedia;if(c)return c(b).matches;var d;return y("@media "+b+" { #"+h+" { position: absolute; } }",function(b){d=(a.getComputedStyle?getComputedStyle(b,null):b.currentStyle)["position"]=="absolute"}),d},A=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=F(e[d],"function"),F(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),B={}.hasOwnProperty,C;!F(B,"undefined")&&!F(B.call,"undefined")?C=function(a,b){return B.call(a,b)}:C=function(a,b){return b in a&&F(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=w.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(w.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(w.call(arguments)))};return e}),s.flexbox=function(){return J("flexWrap")},s.canvas=function(){var a=b.createElement("canvas");return!!a.getContext&&!!a.getContext("2d")},s.canvastext=function(){return!!e.canvas&&!!F(b.createElement("canvas").getContext("2d").fillText,"function")},s.webgl=function(){return!!a.WebGLRenderingContext},s.touch=function(){var c;return"ontouchstart"in a||a.DocumentTouch&&b instanceof DocumentTouch?c=!0:y(["@media (",n.join("touch-enabled),("),h,")","{#modernizr{top:9px;position:absolute}}"].join(""),function(a){c=a.offsetTop===9}),c},s.geolocation=function(){return"geolocation"in navigator},s.postmessage=function(){return!!a.postMessage},s.websqldatabase=function(){return!!a.openDatabase},s.indexedDB=function(){return!!J("indexedDB",a)},s.hashchange=function(){return A("hashchange",a)&&(b.documentMode===c||b.documentMode>7)},s.history=function(){return!!a.history&&!!history.pushState},s.draganddrop=function(){var a=b.createElement("div");return"draggable"in a||"ondragstart"in a&&"ondrop"in a},s.websockets=function(){return"WebSocket"in a||"MozWebSocket"in a},s.rgba=function(){return D("background-color:rgba(150,255,150,.5)"),G(j.backgroundColor,"rgba")},s.hsla=function(){return D("background-color:hsla(120,40%,100%,.5)"),G(j.backgroundColor,"rgba")||G(j.backgroundColor,"hsla")},s.multiplebgs=function(){return D("background:url(https://),url(https://),red url(https://)"),/(url\s*\(.*?){3}/.test(j.background)},s.backgroundsize=function(){return J("backgroundSize")},s.borderimage=function(){return J("borderImage")},s.borderradius=function(){return J("borderRadius")},s.boxshadow=function(){return J("boxShadow")},s.textshadow=function(){return b.createElement("div").style.textShadow===""},s.opacity=function(){return E("opacity:.55"),/^0.55$/.test(j.opacity)},s.cssanimations=function(){return J("animationName")},s.csscolumns=function(){return J("columnCount")},s.cssgradients=function(){var a="background-image:",b="gradient(linear,left top,right bottom,from(#9f9),to(white));",c="linear-gradient(left top,#9f9, white);";return D((a+"-webkit- ".split(" ").join(b+a)+n.join(c+a)).slice(0,-a.length)),G(j.backgroundImage,"gradient")},s.cssreflections=function(){return J("boxReflect")},s.csstransforms=function(){return!!J("transform")},s.csstransforms3d=function(){var a=!!J("perspective");return a&&"webkitPerspective"in g.style&&y("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b,c){a=b.offsetLeft===9&&b.offsetHeight===3}),a},s.csstransitions=function(){return J("transition")},s.fontface=function(){var a;return y('@font-face {font-family:"font";src:url("https://")}',function(c,d){var e=b.getElementById("smodernizr"),f=e.sheet||e.styleSheet,g=f?f.cssRules&&f.cssRules[0]?f.cssRules[0].cssText:f.cssText||"":"";a=/src/i.test(g)&&g.indexOf(d.split(" ")[0])===0}),a},s.generatedcontent=function(){var a;return y(["#",h,"{font:0/0 a}#",h,':after{content:"',l,'";visibility:hidden;font:3px/1 a}'].join(""),function(b){a=b.offsetHeight>=3}),a},s.video=function(){var a=b.createElement("video"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,""),c.h264=a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,""),c.webm=a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,"")}catch(d){}return c},s.audio=function(){var a=b.createElement("audio"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),c.mp3=a.canPlayType("audio/mpeg;").replace(/^no$/,""),c.wav=a.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),c.m4a=(a.canPlayType("audio/x-m4a;")||a.canPlayType("audio/aac;")).replace(/^no$/,"")}catch(d){}return c},s.localstorage=function(){try{return localStorage.setItem(h,h),localStorage.removeItem(h),!0}catch(a){return!1}},s.sessionstorage=function(){try{return sessionStorage.setItem(h,h),sessionStorage.removeItem(h),!0}catch(a){return!1}},s.webworkers=function(){return!!a.Worker},s.applicationcache=function(){return!!a.applicationCache},s.svg=function(){return!!b.createElementNS&&!!b.createElementNS(r.svg,"svg").createSVGRect},s.inlinesvg=function(){var a=b.createElement("div");return a.innerHTML="<svg/>",(a.firstChild&&a.firstChild.namespaceURI)==r.svg},s.smil=function(){return!!b.createElementNS&&/SVGAnimate/.test(m.call(b.createElementNS(r.svg,"animate")))},s.svgclippaths=function(){return!!b.createElementNS&&/SVGClipPath/.test(m.call(b.createElementNS(r.svg,"clipPath")))};for(var L in s)C(s,L)&&(x=L.toLowerCase(),e[x]=s[L](),v.push((e[x]?"":"no-")+x));return e.input||K(),e.addTest=function(a,b){if(typeof a=="object")for(var d in a)C(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},D(""),i=k=null,function(a,b){function k(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function l(){var a=r.elements;return typeof a=="string"?a.split(" "):a}function m(a){var b=i[a[g]];return b||(b={},h++,a[g]=h,i[h]=b),b}function n(a,c,f){c||(c=b);if(j)return c.createElement(a);f||(f=m(c));var g;return f.cache[a]?g=f.cache[a].cloneNode():e.test(a)?g=(f.cache[a]=f.createElem(a)).cloneNode():g=f.createElem(a),g.canHaveChildren&&!d.test(a)?f.frag.appendChild(g):g}function o(a,c){a||(a=b);if(j)return a.createDocumentFragment();c=c||m(a);var d=c.frag.cloneNode(),e=0,f=l(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function p(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return r.shivMethods?n(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+l().join().replace(/\w+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(r,b.frag)}function q(a){a||(a=b);var c=m(a);return r.shivCSS&&!f&&!c.hasCSS&&(c.hasCSS=!!k(a,"article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}")),j||p(a,c),a}var c=a.html5||{},d=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,e=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,f,g="_html5shiv",h=0,i={},j;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",f="hidden"in a,j=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){f=!0,j=!0}})();var r={elements:c.elements||"abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",shivCSS:c.shivCSS!==!1,supportsUnknownElements:j,shivMethods:c.shivMethods!==!1,type:"default",shivDocument:q,createElement:n,createDocumentFragment:o};a.html5=r,q(b)}(this,b),e._version=d,e._prefixes=n,e._domPrefixes=q,e._cssomPrefixes=p,e.mq=z,e.hasEvent=A,e.testProp=function(a){return H([a])},e.testAllProps=J,e.testStyles=y,e.prefixed=function(a,b,c){return b?J(a,b,c):J(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+v.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};
// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or vendor/assets/javascripts of plugins, if any, can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file.
//
// Read Sprockets README (https://github.com/sstephenson/sprockets#sprockets-directives) for details
// about supported directives.
//




;
